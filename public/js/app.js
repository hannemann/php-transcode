/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0hBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzP2EzNGEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n");

/***/ }),

/***/ "./node_modules/@iconify/iconify/dist/iconify.min.js":
/*!***********************************************************!*\
  !*** ./node_modules/@iconify/iconify/dist/iconify.min.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n* (c) Iconify\n*\n* For the full copyright and license information, please view the license.txt or license.gpl.txt\n* files at https://github.com/iconify/iconify\n*\n* Licensed under Apache 2.0 or GPL 2.0 at your option.\n* If derivative product is not compatible with one of licenses, you can pick one of licenses.\n*\n* @license Apache 2.0\n* @license GPL 2.0\n*/\nvar Iconify=function(){\"use strict\";function e(e,n,t){return e(t={path:n,exports:{},require:function(e,n){return function(){throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\")}(null==n&&t.path)}},t.exports),t.exports}var n=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.fullIcon=n.iconDefaults=n.minifyProps=n.matchName=void 0,n.matchName=/^[a-z0-9]+(-[a-z0-9]+)*$/,n.minifyProps=[\"width\",\"height\",\"top\",\"left\"],n.iconDefaults=Object.freeze({left:0,top:0,width:16,height:16,rotate:0,vFlip:!1,hFlip:!1}),n.fullIcon=function(e){return Object.assign({},n.iconDefaults,e)}})),t=e((function(e,t){Object.defineProperty(t,\"__esModule\",{value:!0}),t.mergeIconData=void 0,t.mergeIconData=function(e,t){var r=Object.assign({},e);for(var o in n.iconDefaults){var i=o;if(void 0!==t[i]){var a=t[i];if(void 0===r[i]){r[i]=a;continue}switch(i){case\"rotate\":r[i]=(r[i]+a)%4;break;case\"hFlip\":case\"vFlip\":r[i]=a!==r[i];break;default:r[i]=a}}}return r}})),r=e((function(e,r){Object.defineProperty(r,\"__esModule\",{value:!0}),r.parseIconSet=void 0;var o=Object.keys(n.iconDefaults);function i(e,n,r,o){void 0===o&&(o=0);var a=e.parent;if(void 0!==n[a])return t.mergeIconData(n[a],e);if(void 0!==r[a]){if(o>2)return null;var c=i(r[a],n,r,o+1);if(c)return t.mergeIconData(c,e)}return null}r.parseIconSet=function(e,t,r){void 0===r&&(r=\"none\");var a=[];if(\"object\"!=typeof e)return\"none\"!==r&&a;if(e.not_found instanceof Array&&e.not_found.forEach((function(e){t(e,null),\"all\"===r&&a.push(e)})),\"object\"!=typeof e.icons)return\"none\"!==r&&a;var c=Object.create(null);o.forEach((function(n){void 0!==e[n]&&\"object\"!=typeof e[n]&&(c[n]=e[n])}));var u=e.icons;if(Object.keys(u).forEach((function(e){var r=u[e];\"string\"==typeof r.body&&(t(e,Object.freeze(Object.assign({},n.iconDefaults,c,r))),a.push(e))})),\"object\"==typeof e.aliases){var f=e.aliases;Object.keys(f).forEach((function(e){var r=i(f[e],u,f,1);r&&(t(e,Object.freeze(Object.assign({},n.iconDefaults,c,r))),a.push(e))}))}return\"none\"===r?a.length>0:a}})),o=e((function(e,t){Object.defineProperty(t,\"__esModule\",{value:!0}),t.validateIcon=t.stringToIcon=void 0;t.stringToIcon=function(e,n,r,o){void 0===o&&(o=\"\");var i=e.split(\":\");if(\"@\"===e.slice(0,1)){if(i.length<2||i.length>3)return null;o=i.shift().slice(1)}if(i.length>3||!i.length)return null;if(i.length>1){var a=i.pop(),c=i.pop(),u={provider:i.length>0?i[0]:o,prefix:c,name:a};return n&&!t.validateIcon(u)?null:u}var f=i[0],l=f.split(\"-\");if(l.length>1){var s={provider:o,prefix:l.shift(),name:l.join(\"-\")};return n&&!t.validateIcon(s)?null:s}if(r&&\"\"===o){var d={provider:o,prefix:\"\",name:f};return n&&!t.validateIcon(d,r)?null:d}return null};t.validateIcon=function(e,t){return!!e&&!(\"\"!==e.provider&&!e.provider.match(n.matchName)||!(t&&\"\"===e.prefix||e.prefix.match(n.matchName))||!e.name.match(n.matchName))}})),i=e((function(e,t){Object.defineProperty(t,\"__esModule\",{value:!0}),t.listIcons=t.getIcon=t.iconExists=t.addIcon=t.addIconSet=t.getStorage=t.newStorage=void 0;var o=Object.create(null);function i(e,n){return{provider:e,prefix:n,icons:Object.create(null),missing:Object.create(null)}}function a(e,n){void 0===o[e]&&(o[e]=Object.create(null));var t=o[e];return void 0===t[n]&&(t[n]=i(e,n)),t[n]}t.newStorage=i,t.getStorage=a,t.addIconSet=function(e,n,t){void 0===t&&(t=\"none\");var o=Date.now();return r.parseIconSet(n,(function(n,t){null===t?e.missing[n]=o:e.icons[n]=t}),t)},t.addIcon=function(e,t,r){try{if(\"string\"==typeof r.body)return e.icons[t]=Object.freeze(n.fullIcon(r)),!0}catch(e){}return!1},t.iconExists=function(e,n){return void 0!==e.icons[n]},t.getIcon=function(e,n){var t=e.icons[n];return void 0===t?null:t},t.listIcons=function(e,n){var t=[];return(\"string\"==typeof e?[e]:Object.keys(o)).forEach((function(e){(\"string\"==typeof e&&\"string\"==typeof n?[n]:void 0===o[e]?[]:Object.keys(o[e])).forEach((function(n){var r=a(e,n),o=Object.keys(r.icons).map((function(t){return(\"\"!==e?\"@\"+e+\":\":\"\")+n+\":\"+t}));t=t.concat(o)}))})),t}})),a=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.storageFunctions=n.addCollection=n.addIcon=n.getIconData=n.allowSimpleNames=void 0;var t=!1;function a(e){var n=\"string\"==typeof e?o.stringToIcon(e,!0,t):e;return n?i.getIcon(i.getStorage(n.provider,n.prefix),n.name):null}function c(e,n){var r=o.stringToIcon(e,!0,t);if(!r)return!1;var a=i.getStorage(r.provider,r.prefix);return i.addIcon(a,r.name,n)}function u(e,n){if(\"object\"!=typeof e)return!1;if(\"string\"!=typeof n&&(n=\"string\"==typeof e.provider?e.provider:\"\"),t&&\"\"===n&&(\"string\"!=typeof e.prefix||\"\"===e.prefix)){var a=!1;return r.parseIconSet(e,(function(e,n){null!==n&&c(e,n)&&(a=!0)})),a}if(\"string\"!=typeof e.prefix||!o.validateIcon({provider:n,prefix:e.prefix,name:\"a\"}))return!1;var u=i.getStorage(n,e.prefix);return!!i.addIconSet(u,e)}n.allowSimpleNames=function(e){return\"boolean\"==typeof e&&(t=e),t},n.getIconData=a,n.addIcon=c,n.addCollection=u,n.storageFunctions={iconExists:function(e){return null!==a(e)},getIcon:function(e){var n=a(e);return n?Object.assign({},n):null},listIcons:i.listIcons,addIcon:c,addCollection:u}})),c=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.replaceIDs=void 0;var t=/\\sid=\"(\\S+)\"/g,r=\"([^A-Za-z0-9_-])\";var o=\"IconifyId-\"+Date.now().toString(16)+\"-\"+(16777216*Math.random()|0).toString(16)+\"-\",i=0;n.replaceIDs=function(e,n){void 0===n&&(n=o);for(var a,c=[];a=t.exec(e);)c.push(a[1]);return c.length?(c.forEach((function(t){var o=\"function\"==typeof n?n():n+i++;e=e.replace(new RegExp(r+\"(\"+(t.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\")+\")\")+r,\"g\"),\"$1\"+o+\"$3\")})),e):e}})),u=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.calculateSize=void 0;var t=/(-?[0-9.]*[0-9]+[0-9.]*)/g,r=/^-?[0-9.]*[0-9]+[0-9.]*$/g;n.calculateSize=function(e,n,o){if(1===n)return e;if(o=void 0===o?100:o,\"number\"==typeof e)return Math.ceil(e*n*o)/o;if(\"string\"!=typeof e)return e;var i=e.split(t);if(null===i||!i.length)return e;for(var a=[],c=i.shift(),u=r.test(c);;){if(u){var f=parseFloat(c);isNaN(f)?a.push(c):a.push(Math.ceil(f*n*o)/o)}else a.push(c);if(void 0===(c=i.shift()))return a.join(\"\");u=!u}}})),f=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.mergeCustomisations=n.defaults=void 0,n.defaults=Object.freeze({inline:!1,width:null,height:null,hAlign:\"center\",vAlign:\"middle\",slice:!1,hFlip:!1,vFlip:!1,rotate:0}),n.mergeCustomisations=function(e,n){var t={};for(var r in e){var o=r;if(t[o]=e[o],void 0!==n[o]){var i=n[o];switch(o){case\"inline\":case\"slice\":\"boolean\"==typeof i&&(t[o]=i);break;case\"hFlip\":case\"vFlip\":!0===i&&(t[o]=!t[o]);break;case\"hAlign\":case\"vAlign\":\"string\"==typeof i&&\"\"!==i&&(t[o]=i);break;case\"width\":case\"height\":(\"string\"==typeof i&&\"\"!==i||\"number\"==typeof i&&i||null===i)&&(t[o]=i);break;case\"rotate\":\"number\"==typeof i&&(t[o]+=i)}}}return t}})),l=e((function(e,n){function t(e){var n=\"\";switch(e.hAlign){case\"left\":n+=\"xMin\";break;case\"right\":n+=\"xMax\";break;default:n+=\"xMid\"}switch(e.vAlign){case\"top\":n+=\"YMin\";break;case\"bottom\":n+=\"YMax\";break;default:n+=\"YMid\"}return n+=e.slice?\" slice\":\" meet\"}Object.defineProperty(n,\"__esModule\",{value:!0}),n.iconToSVG=void 0,n.iconToSVG=function(e,n){var r,o,i={left:e.left,top:e.top,width:e.width,height:e.height},a=e.body;[e,n].forEach((function(e){var n,t=[],r=e.hFlip,o=e.vFlip,c=e.rotate;switch(r?o?c+=2:(t.push(\"translate(\"+(i.width+i.left)+\" \"+(0-i.top)+\")\"),t.push(\"scale(-1 1)\"),i.top=i.left=0):o&&(t.push(\"translate(\"+(0-i.left)+\" \"+(i.height+i.top)+\")\"),t.push(\"scale(1 -1)\"),i.top=i.left=0),c<0&&(c-=4*Math.floor(c/4)),c%=4){case 1:n=i.height/2+i.top,t.unshift(\"rotate(90 \"+n+\" \"+n+\")\");break;case 2:t.unshift(\"rotate(180 \"+(i.width/2+i.left)+\" \"+(i.height/2+i.top)+\")\");break;case 3:n=i.width/2+i.left,t.unshift(\"rotate(-90 \"+n+\" \"+n+\")\")}c%2==1&&(0===i.left&&0===i.top||(n=i.left,i.left=i.top,i.top=n),i.width!==i.height&&(n=i.width,i.width=i.height,i.height=n)),t.length&&(a='<g transform=\"'+t.join(\" \")+'\">'+a+\"</g>\")})),null===n.width&&null===n.height?(o=\"1em\",r=u.calculateSize(o,i.width/i.height)):null!==n.width&&null!==n.height?(r=n.width,o=n.height):null!==n.height?(o=n.height,r=u.calculateSize(o,i.width/i.height)):(r=n.width,o=u.calculateSize(r,i.height/i.width)),\"auto\"===r&&(r=i.width),\"auto\"===o&&(o=i.height);var c={attributes:{width:r=\"string\"==typeof r?r:r+\"\",height:o=\"string\"==typeof o?o:o+\"\",preserveAspectRatio:t(n),viewBox:i.left+\" \"+i.top+\" \"+i.width+\" \"+i.height},body:a};return n.inline&&(c.inline=!0),c}})),s=e((function(e,t){Object.defineProperty(t,\"__esModule\",{value:!0}),t.builderFunctions=void 0,t.builderFunctions={replaceIDs:c.replaceIDs,calculateSize:u.calculateSize,buildIcon:function(e,t){return l.iconToSVG(n.fullIcon(e),f.mergeCustomisations(f.defaults,t))}}})),d=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.coreModules=void 0,n.coreModules={}})),v=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.storeCache=n.loadCache=n.mock=n.emptyList=n.count=n.config=void 0;var t=\"iconify2\",r=\"iconify\",o=\"iconify-count\",a=\"iconify-version\",c=36e5;n.config={local:!0,session:!0};var u=!1;n.count={local:0,session:0},n.emptyList={local:[],session:[]};var f=\"undefined\"==typeof window?{}:window;function l(e){var t=e+\"Storage\";try{if(f&&f[t]&&\"number\"==typeof f[t].length)return f[t]}catch(e){}return n.config[e]=!1,null}function s(e,t,r){try{return e.setItem(o,r+\"\"),n.count[t]=r,!0}catch(e){return!1}}function d(e){var n=e.getItem(o);if(n){var t=parseInt(n);return t||0}return 0}n.mock=function(e){u=!1,f=e};n.loadCache=function(){if(!u){u=!0;var e=Math.floor(Date.now()/c)-168;for(var o in n.config)f(o)}function f(o){var c=l(o);if(c){var u=function(n){var t=r+n,o=c.getItem(t);if(\"string\"!=typeof o)return!1;var a=!0;try{var u=JSON.parse(o);if(\"object\"!=typeof u||\"number\"!=typeof u.cached||u.cached<e||\"string\"!=typeof u.provider||\"object\"!=typeof u.data||\"string\"!=typeof u.data.prefix)a=!1;else{var f=u.provider,l=u.data.prefix,s=i.getStorage(f,l);a=i.addIconSet(s,u.data)}}catch(e){a=!1}return a||c.removeItem(t),a};try{var f=c.getItem(a);if(f!==t)return f&&function(e){try{for(var n=d(e),t=0;t<n;t++)e.removeItem(r+t)}catch(e){}}(c),void function(e,n){try{e.setItem(a,t)}catch(e){}s(e,n,0)}(c,o);for(var v=d(c),p=v-1;p>=0;p--)u(p)||(p===v-1?v--:n.emptyList[o].push(p));s(c,o,v)}catch(e){}}}};n.storeCache=function(e,t){function o(o){if(!n.config[o])return!1;var i=l(o);if(!i)return!1;var a=n.emptyList[o].shift();if(void 0===a&&!s(i,o,(a=n.count[o])+1))return!1;try{var u={cached:Math.floor(Date.now()/c),provider:e,data:t};i.setItem(r+a,JSON.stringify(u))}catch(e){return!1}return!0}u||n.loadCache(),o(\"local\")||o(\"session\")}})),p=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.toggleBrowserCache=void 0,n.toggleBrowserCache=function(e,n){switch(e){case\"local\":case\"session\":v.config[e]=n;break;case\"all\":for(var t in v.config)v.config[t]=n}}})),h=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.defaultConfig=void 0,n.defaultConfig={resources:[],index:0,timeout:2e3,rotate:750,random:!1,dataAfterTimeout:!1}})),g=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.sendQuery=void 0,n.sendQuery=function(e,n,t,r,o){var i,a=e.resources.length,c=e.random?Math.floor(Math.random()*a):e.index;if(e.random){var u=e.resources.slice(0);for(i=[];u.length>1;){var f=Math.floor(Math.random()*u.length);i.push(u[f]),u=u.slice(0,f).concat(u.slice(f+1))}i=i.concat(u)}else i=e.resources.slice(c).concat(e.resources.slice(0,c));var l=Date.now(),s=\"pending\",d=0,v=void 0,p=null,h=[],g=[];function m(){p&&(clearTimeout(p),p=null)}function b(){\"pending\"===s&&(s=\"aborted\"),m(),h.forEach((function(e){e.abort&&e.abort(),\"pending\"===e.status&&(e.status=\"aborted\")})),h=[]}function y(e,n){n&&(g=[]),\"function\"==typeof e&&g.push(e)}function I(){return{startTime:l,payload:n,status:s,queriesSent:d,queriesPending:h.length,subscribe:y,abort:b}}function j(){s=\"failed\",g.forEach((function(e){e(void 0,v)}))}function x(){h=h.filter((function(e){return\"pending\"===e.status&&(e.status=\"aborted\"),e.abort&&e.abort(),!1}))}function O(){if(\"pending\"===s){m();var r=i.shift();if(void 0!==r){var a={getQueryStatus:I,status:\"pending\",resource:r,done:function(n,t){!function(n,t,r){var a=void 0===t;switch(h=h.filter((function(e){return e!==n})),s){case\"pending\":break;case\"failed\":if(a||!e.dataAfterTimeout)return;break;default:return}if(a)return void 0!==r&&(v=r),void(h.length||(i.length?O():j()));if(m(),x(),o&&!e.random){var c=e.resources.indexOf(n.resource);-1!==c&&c!==e.index&&o(c)}s=\"completed\",g.forEach((function(e){e(t)}))}(a,n,t)}};h.push(a),d++;var c=\"function\"==typeof e.rotate?e.rotate(d,l):e.rotate;p=setTimeout(O,c),t(r,n,a)}else{if(h.length){var u=\"function\"==typeof e.timeout?e.timeout(l):e.timeout;if(u)return void(p=setTimeout((function(){m(),\"pending\"===s&&(x(),j())}),u))}j()}}}return\"function\"==typeof r&&g.push(r),setTimeout(O),I}})),m=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.initRedundancy=void 0,n.initRedundancy=function(e){var n=function(e){if(!(\"object\"==typeof e&&\"object\"==typeof e.resources&&e.resources instanceof Array&&e.resources.length))throw new Error(\"Invalid Reduncancy configuration\");var n,t=Object.create(null);for(n in h.defaultConfig)void 0!==e[n]?t[n]=e[n]:t[n]=h.defaultConfig[n];return t}(e),t=[];function r(){t=t.filter((function(e){return\"pending\"===e().status}))}return{query:function(e,o,i){var a=g.sendQuery(n,e,o,(function(e,n){r(),i&&i(e,n)}),(function(e){n.index=e}));return t.push(a),a},find:function(e){var n=t.find((function(n){return e(n)}));return void 0!==n?n:null},setIndex:function(e){n.index=e},getIndex:function(){return n.index},cleanup:r}}})),b=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.sortIcons=void 0,n.sortIcons=function(e){var n={loaded:[],missing:[],pending:[]},t=Object.create(null);e.sort((function(e,n){return e.provider!==n.provider?e.provider.localeCompare(n.provider):e.prefix!==n.prefix?e.prefix.localeCompare(n.prefix):e.name.localeCompare(n.name)}));var r={provider:\"\",prefix:\"\",name:\"\"};return e.forEach((function(e){if(r.name!==e.name||r.prefix!==e.prefix||r.provider!==e.provider){r=e;var o=e.provider,a=e.prefix,c=e.name;void 0===t[o]&&(t[o]=Object.create(null));var u=t[o];void 0===u[a]&&(u[a]=i.getStorage(o,a));var f=u[a],l={provider:o,prefix:a,name:c};(void 0!==f.icons[c]?n.loaded:\"\"===a||void 0!==f.missing[c]?n.missing:n.pending).push(l)}})),n}})),y=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.storeCallback=n.updateCallbacks=n.callbacks=void 0,n.callbacks=Object.create(null);var t=Object.create(null);function r(e,t){e.forEach((function(e){var r=e.provider;if(void 0!==n.callbacks[r]){var o=n.callbacks[r],i=e.prefix,a=o[i];a&&(o[i]=a.filter((function(e){return e.id!==t})))}}))}n.updateCallbacks=function(e,o){void 0===t[e]&&(t[e]=Object.create(null));var a=t[e];a[o]||(a[o]=!0,setTimeout((function(){if(a[o]=!1,void 0!==n.callbacks[e]&&void 0!==n.callbacks[e][o]){var t=n.callbacks[e][o].slice(0);if(t.length){var c=i.getStorage(e,o),u=!1;t.forEach((function(n){var t=n.icons,i=t.pending.length;t.pending=t.pending.filter((function(n){if(n.prefix!==o)return!0;var r=n.name;if(void 0!==c.icons[r])t.loaded.push({provider:e,prefix:o,name:r});else{if(void 0===c.missing[r])return u=!0,!0;t.missing.push({provider:e,prefix:o,name:r})}return!1})),t.pending.length!==i&&(u||r([{provider:e,prefix:o}],n.id),n.callback(t.loaded.slice(0),t.missing.slice(0),t.pending.slice(0),n.abort))}))}}})))};var o=0;n.storeCallback=function(e,t,i){var a=o++,c=r.bind(null,i,a);if(!t.pending.length)return c;var u={id:a,icons:t,callback:e,abort:c};return i.forEach((function(e){var t=e.provider,r=e.prefix;void 0===n.callbacks[t]&&(n.callbacks[t]=Object.create(null));var o=n.callbacks[t];void 0===o[r]&&(o[r]=[]),o[r].push(u)})),c}})),I=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.getAPIModule=n.setAPIModule=void 0;var t=Object.create(null);n.setAPIModule=function(e,n){t[e]=n},n.getAPIModule=function(e){return void 0===t[e]?t[\"\"]:t[e]}})),j=e((function(e,n){function t(e){var n;if(\"string\"==typeof e.resources)n=[e.resources];else if(!((n=e.resources)instanceof Array&&n.length))return null;return{resources:n,path:void 0===e.path?\"/\":e.path,maxURL:e.maxURL?e.maxURL:500,rotate:e.rotate?e.rotate:750,timeout:e.timeout?e.timeout:5e3,random:!0===e.random,index:e.index?e.index:0,dataAfterTimeout:!1!==e.dataAfterTimeout}}Object.defineProperty(n,\"__esModule\",{value:!0}),n.getAPIConfig=n.setAPIConfig=void 0;for(var r=Object.create(null),o=[\"https://api.simplesvg.com\",\"https://api.unisvg.com\"],i=[];o.length>0;)1===o.length||Math.random()>.5?i.push(o.shift()):i.push(o.pop());r[\"\"]=t({resources:[\"https://api.iconify.design\"].concat(i)}),n.setAPIConfig=function(e,n){var o=t(n);return null!==o&&(r[e]=o,!0)};n.getAPIConfig=function(e){return r[e]}})),x=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.getProviders=n.listToIcons=void 0,n.listToIcons=function(e,n,t){void 0===n&&(n=!0),void 0===t&&(t=!1);var r=[];return e.forEach((function(e){var i=\"string\"==typeof e?o.stringToIcon(e,!1,t):e;n&&!o.validateIcon(i,t)||r.push({provider:i.provider,prefix:i.prefix,name:i.name})})),r},n.getProviders=function(e){var n=Object.create(null);return e.forEach((function(e){n[e.provider]=!0})),Object.keys(n)}})),O=e((function(e,n){function t(){}Object.defineProperty(n,\"__esModule\",{value:!0}),n.API=n.getRedundancyCache=void 0;var r=Object.create(null),o=Object.create(null),c=Object.create(null),u=Object.create(null),f=Object.create(null);function l(e){if(void 0===f[e]){var n=j.getAPIConfig(e);if(!n)return;var t={config:n,redundancy:m.initRedundancy(n)};f[e]=t}return f[e]}n.getRedundancyCache=l;var s=Object.create(null);function v(e,n,t){function a(){var t=(\"\"===e?\"\":\"@\"+e+\":\")+n,r=Math.floor(Date.now()/6e4);s[t]<r&&(s[t]=r,console.error('Unable to retrieve icons for \"'+t+'\" because API is not configured properly.'))}void 0===o[e]&&(o[e]=Object.create(null));var f=o[e];void 0===u[e]&&(u[e]=Object.create(null));var v=u[e];void 0===r[e]&&(r[e]=Object.create(null));var p,h=r[e];void 0===f[n]?f[n]=t:f[n]=f[n].concat(t).sort(),v[n]||(v[n]=!0,setTimeout((function(){v[n]=!1;var t=f[n];delete f[n];var r=I.getAPIModule(e);if(r){if(void 0===p){var o=l(e);if(void 0===o)return void a();p=o}r.prepare(e,n,t).forEach((function(t){p.redundancy.query(t,r.send,(function(r,o){var a=i.getStorage(e,n);if(\"object\"!=typeof r){if(404!==o)return;var u=Date.now();t.icons.forEach((function(e){a.missing[e]=u}))}else try{var f=i.addIconSet(a,r,\"all\");if(\"boolean\"==typeof f)return;var l=h[n];f.forEach((function(e){delete l[e]})),d.coreModules.cache&&d.coreModules.cache(e,r)}catch(e){console.error(e)}!function(e,n){void 0===c[e]&&(c[e]=Object.create(null));var t=c[e];t[n]||(t[n]=!0,setTimeout((function(){t[n]=!1,y.updateCallbacks(e,n)})))}(e,n)}))}))}else a()})))}n.API={isPending:function(e){return void 0!==r[e.provider]&&void 0!==r[e.provider][e.prefix]&&void 0!==r[e.provider][e.prefix][e.name]},loadIcons:function(e,n){var o=x.listToIcons(e,!0,a.allowSimpleNames()),i=b.sortIcons(o);if(!i.pending.length){var c=!0;return n&&setTimeout((function(){c&&n(i.loaded,i.missing,i.pending,t)})),function(){c=!1}}var u,f,l=Object.create(null),s=[];i.pending.forEach((function(e){var n=e.provider,t=e.prefix;if(t!==f||n!==u){u=n,f=t,s.push({provider:n,prefix:t}),void 0===r[n]&&(r[n]=Object.create(null));var o=r[n];void 0===o[t]&&(o[t]=Object.create(null)),void 0===l[n]&&(l[n]=Object.create(null));var i=l[n];void 0===i[t]&&(i[t]=[])}}));var d=Date.now();return i.pending.forEach((function(e){var n=e.provider,t=e.prefix,o=e.name,i=r[n][t];void 0===i[o]&&(i[o]=d,l[n][t].push(o))})),s.forEach((function(e){var n=e.provider,t=e.prefix;l[n][t].length&&v(n,t,l[n][t])})),n?y.storeCallback(n,i,s):t}}})),P=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.APIInternalFunctions=n.APIFunctions=void 0,n.APIFunctions={loadIcons:O.API.loadIcons,addAPIProvider:j.setAPIConfig},n.APIInternalFunctions={getAPI:O.getRedundancyCache,getAPIConfig:j.getAPIConfig,setAPIModule:I.setAPIModule}})),w=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.getAPIModule=void 0;var t=null,r=\"{prefix}.js?icons={icons}&callback={callback}\",o=Object.create(null),i=Object.create(null);function a(){if(null===t){var e=self,n=\"Iconify\",o=\".cb\";if(void 0===e[n])o=\"\",void 0===e[n=\"IconifyJSONP\"]&&(e[n]=Object.create(null)),t=e[n];else{var i=e[n];void 0===i.cb&&(i.cb=Object.create(null)),t=i.cb}r=r.replace(\"{callback}\",n+o+\".{cb}\")}return t}n.getAPIModule=function(e){return{prepare:function(n,t,c){var u=[],f=o[n+\":\"+t];void 0===f&&(f=function(n,t){var c,u=e(n);if(!u)return 0;if(u.maxURL){var f=0;u.resources.forEach((function(e){var n=e;f=Math.max(f,n.length)})),a(),c=u.maxURL-f-u.path.length-r.replace(\"{provider}\",n).replace(\"{prefix}\",t).replace(\"{icons}\",\"\").length-3}else c=0;var l=n+\":\"+t;return i[l]=u.path,o[l]=c,c}(n,t));var l={provider:n,prefix:t,icons:[]},s=0;return c.forEach((function(e,r){(s+=e.length+1)>=f&&r>0&&(u.push(l),l={provider:n,prefix:t,icons:[]},s=e.length),l.icons.push(e)})),u.push(l),u},send:function(e,n,t){for(var o=n.provider,c=n.prefix,u=n.icons.join(\",\"),f=o+\":\"+c,l=c.split(\"-\").shift().slice(0,3),s=a(),d=function(e){var n,t=0;for(n=e.length-1;n>=0;n--)t+=e.charCodeAt(n);return t%999}(o+\":\"+e+\":\"+c+\":\"+u);void 0!==s[l+d];)d++;var v=l+d,p=i[f]+r.replace(\"{provider}\",o).replace(\"{prefix}\",c).replace(\"{icons}\",u).replace(\"{cb}\",v);s[v]=function(e){delete s[v],t.done(e)};var h=e+p,g=document.createElement(\"script\");g.type=\"text/javascript\",g.async=!0,g.src=h,document.head.appendChild(g)}}}})),M=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.getAPIModule=n.setFetch=void 0;var t=\"{prefix}.json?icons={icons}\",r=Object.create(null),o=Object.create(null),i=null;try{i=fetch}catch(e){}n.setFetch=function(e){i=e};n.getAPIModule=function(e){return{prepare:function(n,i,a){var c=[],u=r[i];void 0===u&&(u=function(n,i){var a,c=e(n);if(!c)return 0;if(c.maxURL){var u=0;c.resources.forEach((function(e){var n=e;u=Math.max(u,n.length)})),a=c.maxURL-u-c.path.length-t.replace(\"{provider}\",n).replace(\"{prefix}\",i).replace(\"{icons}\",\"\").length}else a=0;var f=n+\":\"+i;return o[f]=c.path,r[f]=a,a}(n,i));var f={provider:n,prefix:i,icons:[]},l=0;return a.forEach((function(e,t){(l+=e.length+1)>=u&&t>0&&(c.push(f),f={provider:n,prefix:i,icons:[]},l=e.length),f.icons.push(e)})),c.push(f),c},send:function(e,n,r){var a=n.provider,c=n.prefix,u=n.icons.join(\",\"),f=o[a+\":\"+c]+t.replace(\"{provider}\",a).replace(\"{prefix}\",c).replace(\"{icons}\",u);i?i(e+f).then((function(e){if(200===e.status)return e.json();r.done(void 0,e.status)})).then((function(e){\"object\"==typeof e&&null!==e&&r.done(e)})).catch((function(e){r.done(void 0,e.errno)})):r.done(void 0,424)}}}})),A=\"iconifyFinder\"+Date.now(),S=\"iconifyData\"+Date.now();function _(e,n,t,r){var o;try{o=document.createElement(\"span\")}catch(e){return r?\"\":null}var i=l.iconToSVG(t,f.mergeCustomisations(f.defaults,n)),a=e.element,u=e.finder,s=e.name,d=a?a.getAttribute(\"class\"):\"\",v=u?u.classFilter(d?d.split(/\\s+/):[]):[],p='<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" aria-hidden=\"true\" role=\"img\" class=\"'+(\"iconify iconify--\"+s.prefix+(\"\"===s.provider?\"\":\" iconify--\"+s.provider)+(v.length?\" \"+v.join(\" \"):\"\"))+'\">'+c.replaceIDs(i.body)+\"</svg>\";o.innerHTML=p;var h=o.childNodes[0],g=h.style,m=i.attributes;if(Object.keys(m).forEach((function(e){h.setAttribute(e,m[e])})),i.inline&&(g.verticalAlign=\"-0.125em\"),a){for(var b=a.attributes,y=0;y<b.length;y++){var I=b.item(y);if(I){var j=I.name;if(\"class\"!==j&&\"style\"!==j&&void 0===m[j])try{h.setAttribute(j,I.value)}catch(e){}}}for(var x=a.style,O=0;O<x.length;O++){var P=x[O];g[P]=x[P]}}if(u){var w={name:s,status:\"loaded\",customisations:n};h[S]=w,h[A]=u}var M=r?o.innerHTML:h;return a&&a.parentNode?a.parentNode.replaceChild(h,a):o.removeChild(h),M}var E=[];function k(e){for(var n=0;n<E.length;n++){var t=E[n];if((\"function\"==typeof t.node?t.node():t.node)===e)return t}}function C(e,n){void 0===n&&(n=!1);var t=k(e);return t?(t.temporary&&(t.temporary=n),t):(t={node:e,temporary:n},E.push(t),t)}function F(){return E}var T=null,D={childList:!0,subtree:!0,attributes:!0};function N(e){if(e.observer){var n=e.observer;n.pendingScan||(n.pendingScan=setTimeout((function(){delete n.pendingScan,T&&T(e)})))}}function L(e,n){if(e.observer){var t=e.observer;if(!t.pendingScan)for(var r=0;r<n.length;r++){var o=n[r];if(o.addedNodes&&o.addedNodes.length>0||\"attributes\"===o.type&&void 0!==o.target[A])return void(t.paused||N(e))}}}function z(e,n){e.observer.instance.observe(n,D)}function R(e){var n=e.observer;if(!n||!n.instance){var t=\"function\"==typeof e.node?e.node():e.node;t&&(n||(n={paused:0},e.observer=n),n.instance=new MutationObserver(L.bind(null,e)),z(e,t),n.paused||N(e))}}function q(){F().forEach(R)}function U(e){if(e.observer){var n=e.observer;n.pendingScan&&(clearTimeout(n.pendingScan),delete n.pendingScan),n.instance&&(n.instance.disconnect(),delete n.instance)}}function V(e){var n=null!==T;T!==e&&(T=e,n&&F().forEach(U)),n?q():function(e){var n=document;\"complete\"===n.readyState||\"loading\"!==n.readyState&&!n.documentElement.doScroll?e():(n.addEventListener(\"DOMContentLoaded\",e),window.addEventListener(\"load\",e))}(q)}function G(e){(e?[e]:F()).forEach((function(e){if(e.observer){var n=e.observer;if(n.paused++,!(n.paused>1)&&n.instance)n.instance.disconnect()}else e.observer={paused:1}}))}function $(e){(e?[e]:F()).forEach((function(e){if(e.observer){var n=e.observer;if(n.paused&&(n.paused--,!n.paused)){var t=\"function\"==typeof e.node?e.node():e.node;if(!t)return;n.instance?z(e,t):R(e)}}else R(e)}))}function B(e,n){void 0===n&&(n=!1);var t=C(e,n);return R(t),t}function Q(e){var n=k(e);n&&(U(n),function(e){E=E.filter((function(n){var t=\"function\"==typeof n.node?n.node():n.node;return e!==t}))}(e))}var H=[];function J(e){return\"string\"==typeof e&&(e=o.stringToIcon(e)),null!==e&&o.validateIcon(e)?e:null}function Y(e){var n=[];H.forEach((function(t){var r=t.find(e);Array.prototype.forEach.call(r,(function(e){var r=e;if(void 0===r[A]||r[A]===t){var o=J(t.name(r));if(null!==o){r[A]=t;var i={element:r,finder:t,name:o};n.push(i)}}}))}));var t=e.querySelectorAll(\"svg.iconify\");return Array.prototype.forEach.call(t,(function(e){var t=e,r=t[A],o=t[S];if(r&&o){var i=J(r.name(t));if(null!==i){var a,c=!1;if(i.prefix!==o.name.prefix||i.name!==o.name.name?c=!0:(a=r.customisations(t),function(e,n){var t=Object.keys(e),r=Object.keys(n);if(t.length!==r.length)return!1;for(var o=0;o<t.length;o++){var i=t[o];if(n[i]!==e[i])return!1}return!0}(o.customisations,a)||(c=!0)),c){var u={element:t,finder:r,name:i,customisations:a};n.push(u)}}}})),n}var Z=!1;function K(){Z||(Z=!0,setTimeout((function(){Z&&(Z=!1,W())})))}function W(e,n){void 0===n&&(n=!1),Z=!1;var t=Object.create(null);if((e?[e]:F()).forEach((function(e){var r=\"function\"==typeof e.node?e.node():e.node;if(r&&r.querySelectorAll){var o=!1,a=!1;Y(r).forEach((function(n){var r,c,u=n.element,f=n.name,l=f.provider,s=f.prefix,v=f.name,p=u[S];if(void 0!==p&&(r=p.name,c=f,null!==r&&null!==c&&r.name===c.name&&r.prefix===c.prefix))switch(p.status){case\"missing\":return;case\"loading\":if(d.coreModules.api&&d.coreModules.api.isPending({provider:l,prefix:s,name:v}))return void(o=!0)}var h=i.getStorage(l,s);if(void 0===h.icons[v]){if(h.missing[v])return p={name:f,status:\"missing\",customisations:{}},void(u[S]=p);if(d.coreModules.api&&!d.coreModules.api.isPending({provider:l,prefix:s,name:v})){void 0===t[l]&&(t[l]=Object.create(null));var g=t[l];void 0===g[s]&&(g[s]=Object.create(null)),g[s][v]=!0}p={name:f,status:\"loading\",customisations:{}},u[S]=p,o=!0}else{!a&&e.observer&&(G(e),a=!0);var m=void 0!==n.customisations?n.customisations:n.finder.customisations(u);_(n,m,i.getIcon(h,v))}})),e.temporary&&!o?Q(r):n&&o?B(r,!0):a&&e.observer&&$(e)}})),d.coreModules.api){var r=d.coreModules.api;Object.keys(t).forEach((function(e){var n=t[e];Object.keys(n).forEach((function(t){r.loadIcons(Object.keys(n[t]).map((function(n){return{provider:e,prefix:t,name:n}})),K)}))}))}}var X=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.rotateFromString=void 0,n.rotateFromString=function(e){var n=e.replace(/^-?[0-9.]*/,\"\");function t(e){for(;e<0;)e+=4;return e%4}if(\"\"===n){var r=parseInt(e);return isNaN(r)?0:t(r)}if(n!==e){var o=0;switch(n){case\"%\":o=25;break;case\"deg\":o=90}if(o){var i=parseFloat(e.slice(0,e.length-n.length));return isNaN(i)?0:(i/=o)%1==0?t(i):0}}return 0}})),ee=e((function(e,n){Object.defineProperty(n,\"__esModule\",{value:!0}),n.alignmentFromString=n.flipFromString=void 0;var t=/[\\s,]+/;n.flipFromString=function(e,n){n.split(t).forEach((function(n){switch(n.trim()){case\"horizontal\":e.hFlip=!0;break;case\"vertical\":e.vFlip=!0}}))},n.alignmentFromString=function(e,n){n.split(t).forEach((function(n){var t=n.trim();switch(t){case\"left\":case\"center\":case\"right\":e.hAlign=t;break;case\"top\":case\"middle\":case\"bottom\":e.vAlign=t;break;case\"slice\":case\"crop\":e.slice=!0;break;case\"meet\":e.slice=!1}}))}}));function ne(e,n){return e.hasAttribute(n)}function te(e,n){return e.getAttribute(n)}var re=[\"inline\",\"hFlip\",\"vFlip\"],oe=[\"width\",\"height\"],ie=\"iconify-inline\",ae={find:function(e){return e.querySelectorAll(\"i.iconify, span.iconify, i.iconify-inline, span.iconify-inline\")},name:function(e){return ne(e,\"data-icon\")?te(e,\"data-icon\"):null},customisations:function(e,n){void 0===n&&(n={inline:!1});var t=n,r=e.getAttribute(\"class\");if(-1!==(r?r.split(/\\s+/):[]).indexOf(ie)&&(t.inline=!0),ne(e,\"data-rotate\")){var o=X.rotateFromString(te(e,\"data-rotate\"));o&&(t.rotate=o)}return ne(e,\"data-flip\")&&ee.flipFromString(t,te(e,\"data-flip\")),ne(e,\"data-align\")&&ee.alignmentFromString(t,te(e,\"data-align\")),re.forEach((function(n){if(ne(e,\"data-\"+n)){var r=function(e,n){var t=e.getAttribute(n);return t===n||\"true\"===t||\"\"!==t&&\"false\"!==t&&null}(e,\"data-\"+n);\"boolean\"==typeof r&&(t[n]=r)}})),oe.forEach((function(n){if(ne(e,\"data-\"+n)){var r=te(e,\"data-\"+n);\"\"!==r&&(t[n]=r)}})),t},classFilter:function(e){var n=[];return e.forEach((function(e){\"iconify\"!==e&&\"\"!==e&&\"iconify--\"!==e.slice(0,9)&&n.push(e)})),n}};function ce(e,n,t){var r=a.getIconData(e);return r?_({name:o.stringToIcon(e)},f.mergeCustomisations(f.defaults,\"object\"==typeof n?n:{}),r,t):null}var ue={getVersion:function(){return\"2.0.4\"},renderSVG:function(e,n){return ce(e,n,!1)},renderHTML:function(e,n){return ce(e,n,!0)},renderIcon:function(e,n){var t=a.getIconData(e);if(!t)return null;var r=f.mergeCustomisations(f.defaults,\"object\"==typeof n?n:{});return l.iconToSVG(t,r)},scan:function(e){e?function(e){var n=k(e);n?W(n):W({node:e,temporary:!0},!0)}(e):W()},observe:function(e){B(e)},stopObserving:function(e){Q(e)},pauseObserver:function(e){if(e){var n=k(e);n&&G(n)}else G()},resumeObserver:function(e){if(e){var n=k(e);n&&$(n)}else $()}};if(\"undefined\"!=typeof document&&\"undefined\"!=typeof window){!function(){if(document.documentElement)return C(document.documentElement);E.push({node:function(){return document.documentElement}})}(),function(e){-1===H.indexOf(e)&&H.push(e)}(ae);var fe=window;if(void 0!==fe.IconifyPreload){var le=fe.IconifyPreload,se=\"Invalid IconifyPreload syntax.\";\"object\"==typeof le&&null!==le&&(le instanceof Array?le:[le]).forEach((function(e){try{(\"object\"!=typeof e||null===e||e instanceof Array||\"object\"!=typeof e.icons||\"string\"!=typeof e.prefix||!a.storageFunctions.addCollection(e))&&console.error(se)}catch(e){console.error(se)}}))}setTimeout((function(){V(W),W()}))}var de={enableCache:function(e,n){return p.toggleBrowserCache(e,!1!==n)},disableCache:function(e){return p.toggleBrowserCache(e,!0)}},ve={_api:P.APIInternalFunctions};[a.storageFunctions,s.builderFunctions,ue,de,P.APIFunctions].forEach((function(e){for(var n in e)ve[n]=e[n]})),d.coreModules.api=O.API;var pe=M.getAPIModule;try{\"undefined\"!=typeof document&&\"undefined\"!=typeof window&&(pe=\"function\"==typeof fetch&&\"function\"==typeof Promise?M.getAPIModule:w.getAPIModule)}catch(se){}if(I.setAPIModule(\"\",pe(j.getAPIConfig)),ve._api.setFetch=function(e){M.setFetch(e),pe!==M.getAPIModule&&(pe=M.getAPIModule,I.setAPIModule(\"\",pe(j.getAPIConfig)))},\"undefined\"!=typeof document&&\"undefined\"!=typeof window){d.coreModules.cache=v.storeCache,v.loadCache();var he=window;if(void 0!==he.IconifyProviders){var ge=he.IconifyProviders;if(\"object\"==typeof ge&&null!==ge)for(var me in ge){var be=\"IconifyProviders[\"+me+\"] is invalid.\";try{var ye=ge[me];if(\"object\"!=typeof ye||!ye||void 0===ye.resources)continue;j.setAPIConfig(me,ye)||console.error(be)}catch(e){console.error(be)}}}}return ve}();try{void 0===self.Iconify&&(self.Iconify=Iconify)}catch(e){}if(true)try{exports.__esModule=!0,exports.default=Iconify}catch(e){}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGljb25pZnkvaWNvbmlmeS9kaXN0L2ljb25pZnkubWluLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhLGtCQUFrQixZQUFZLGlCQUFpQix1QkFBdUIsa0JBQWtCLDJGQUEyRixtQkFBbUIsc0JBQXNCLHVCQUF1QixzQ0FBc0MsU0FBUyxnTEFBZ0wsMkRBQTJELHlCQUF5Qix1QkFBdUIsb0JBQW9CLHNCQUFzQixzQ0FBc0MsU0FBUyx1REFBdUQsc0JBQXNCLElBQUksNkJBQTZCLFFBQVEsa0JBQWtCLFdBQVcsa0JBQWtCLE9BQU8sU0FBUyxVQUFVLDZCQUE2QixNQUFNLHNDQUFzQyxNQUFNLGlCQUFpQixVQUFVLHNCQUFzQixzQ0FBc0MsU0FBUyx3QkFBd0Isa0NBQWtDLG9CQUFvQixrQkFBa0IsZUFBZSxnREFBZ0Qsa0JBQWtCLG1CQUFtQixzQkFBc0IsaUNBQWlDLFlBQVksK0JBQStCLHVCQUF1QixTQUFTLDBDQUEwQyxrRUFBa0UsK0JBQStCLGdEQUFnRCwwQkFBMEIsdUJBQXVCLGtEQUFrRCxHQUFHLGNBQWMsdUNBQXVDLFdBQVcsNERBQTRELGtDQUFrQywrQkFBK0IsZ0JBQWdCLG9DQUFvQyxvQkFBb0Isc0NBQXNDLGtDQUFrQyxHQUFHLCtCQUErQixzQkFBc0Isc0NBQXNDLFNBQVMsdUNBQXVDLGlDQUFpQyxtQkFBbUIsbUJBQW1CLHVCQUF1QixzQ0FBc0MscUJBQXFCLHFDQUFxQyxlQUFlLDJCQUEyQiw0Q0FBNEMsb0NBQW9DLDBCQUEwQixlQUFlLE9BQU8sOENBQThDLG9DQUFvQyxjQUFjLE9BQU8sNkJBQTZCLHNDQUFzQyxhQUFhLDZCQUE2Qiw2SUFBNkksc0JBQXNCLHNDQUFzQyxTQUFTLDZGQUE2RiwwQkFBMEIsZ0JBQWdCLE9BQU8sMkVBQTJFLGdCQUFnQiwwQ0FBMEMsV0FBVyx5Q0FBeUMsMkRB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QUEwQixrQkFBa0IsMEJBQTBCLHVCQUF1QixrQkFBa0IsOERBQThELEVBQUUsd0JBQXdCLGtCQUFrQixjQUFjLFdBQVcsVUFBVSxvQkFBb0IsS0FBSyxRQUFRLHFCQUFxQixLQUFLLDJCQUEyQixLQUFLLDJCQUEyQixNQUFNLFdBQVcsUUFBUSxTQUFTLDRCQUE0QixNQUFNLFdBQVcsUUFBUSxXQUFXLDZEQUE2RCxZQUFZLCtEQUErRCxRQUFRLGdCQUFnQixpQ0FBaUMsRUFBRSxlQUFlLDZCQUE2QixLQUFLLGNBQWMsK0JBQStCLDZEQUE2RCxtRkFBbUYsSUFBSSxpS0FBaUssU0FBUyxtQkFBbUIsR0FBRyx1QkFBdUIsU0FBUyxHQUFHLFFBQVEsMEJBQTBCLHNDQUFzQywwQkFBMEIsbUNBQW1DLEtBQUssNkJBQTZCLGtGQUFrRiwwQkFBMEIsMkJBQTJCLHNCQUFzQixJQUFJLGtKQUFrSixXQUFXLHNFQUFzRSw2RkFBNkYsMkRBQTJELCtDQUErQyxjQUFjLGlDQUFpQywyQkFBMkIsb0RBQW9ELDhDQUE4QyxJQUFJLGNBQWMsNERBQTRELHlDQUF5QyxTQUFTLHFCQUFxQixVQUFVLEdBQUcsSUFBSSw4Q0FBOEMsVUFBVSxHQUFHLElBQXdCLEtBQUssa0JBQWtCLElBQUksZUFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BpY29uaWZ5L2ljb25pZnkvZGlzdC9pY29uaWZ5Lm1pbi5qcz8yYTJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiAoYykgSWNvbmlmeVxuKlxuKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgbGljZW5zZS50eHQgb3IgbGljZW5zZS5ncGwudHh0XG4qIGZpbGVzIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9pY29uaWZ5L2ljb25pZnlcbipcbiogTGljZW5zZWQgdW5kZXIgQXBhY2hlIDIuMCBvciBHUEwgMi4wIGF0IHlvdXIgb3B0aW9uLlxuKiBJZiBkZXJpdmF0aXZlIHByb2R1Y3QgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBvbmUgb2YgbGljZW5zZXMsIHlvdSBjYW4gcGljayBvbmUgb2YgbGljZW5zZXMuXG4qXG4qIEBsaWNlbnNlIEFwYWNoZSAyLjBcbiogQGxpY2Vuc2UgR1BMIDIuMFxuKi9cbnZhciBJY29uaWZ5PWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZShlLG4sdCl7cmV0dXJuIGUodD17cGF0aDpuLGV4cG9ydHM6e30scmVxdWlyZTpmdW5jdGlvbihlLG4pe3JldHVybiBmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzXCIpfShudWxsPT1uJiZ0LnBhdGgpfX0sdC5leHBvcnRzKSx0LmV4cG9ydHN9dmFyIG49ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmZ1bGxJY29uPW4uaWNvbkRlZmF1bHRzPW4ubWluaWZ5UHJvcHM9bi5tYXRjaE5hbWU9dm9pZCAwLG4ubWF0Y2hOYW1lPS9eW2EtejAtOV0rKC1bYS16MC05XSspKiQvLG4ubWluaWZ5UHJvcHM9W1wid2lkdGhcIixcImhlaWdodFwiLFwidG9wXCIsXCJsZWZ0XCJdLG4uaWNvbkRlZmF1bHRzPU9iamVjdC5mcmVlemUoe2xlZnQ6MCx0b3A6MCx3aWR0aDoxNixoZWlnaHQ6MTYscm90YXRlOjAsdkZsaXA6ITEsaEZsaXA6ITF9KSxuLmZ1bGxJY29uPWZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LG4uaWNvbkRlZmF1bHRzLGUpfX0pKSx0PWUoKGZ1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5tZXJnZUljb25EYXRhPXZvaWQgMCx0Lm1lcmdlSWNvbkRhdGE9ZnVuY3Rpb24oZSx0KXt2YXIgcj1PYmplY3QuYXNzaWduKHt9LGUpO2Zvcih2YXIgbyBpbiBuLmljb25EZWZhdWx0cyl7dmFyIGk9bztpZih2b2lkIDAhPT10W2ldKXt2YXIgYT10W2ldO2lmKHZvaWQgMD09PXJbaV0pe3JbaV09YTtjb250aW51ZX1zd2l0Y2goaSl7Y2FzZVwicm90YXRlXCI6cltpXT0ocltpXSthKSU0O2JyZWFrO2Nhc2VcImhGbGlwXCI6Y2FzZVwidkZsaXBcIjpyW2ldPWEhPT1yW2ldO2JyZWFrO2RlZmF1bHQ6cltpXT1hfX19cmV0dXJuIHJ9fSkpLHI9ZSgoZnVuY3Rpb24oZSxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLnBhcnNlSWNvblNldD12b2lkIDA7dmFyIG89T2JqZWN0LmtleXMobi5pY29uRGVmYXVsdHMpO2Z1bmN0aW9uIGkoZSxuLHIsbyl7dm9pZCAwPT09byYmKG89MCk7dmFyIGE9ZS5wYXJlbnQ7aWYodm9pZCAwIT09blthXSlyZXR1cm4gdC5tZXJnZUljb25EYXRhKG5bYV0sZSk7aWYodm9pZCAwIT09clthXSl7aWYobz4yKXJldHVybiBudWxsO3ZhciBjPWkoclthXSxuLHIsbysxKTtpZihjKXJldHVybiB0Lm1lcmdlSWNvbkRhdGEoYyxlKX1yZXR1cm4gbnVsbH1yLnBhcnNlSWNvblNldD1mdW5jdGlvbihlLHQscil7dm9pZCAwPT09ciYmKHI9XCJub25lXCIpO3ZhciBhPVtdO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXJldHVyblwibm9uZVwiIT09ciYmYTtpZihlLm5vdF9mb3VuZCBpbnN0YW5jZW9mIEFycmF5JiZlLm5vdF9mb3VuZC5mb3JFYWNoKChmdW5jdGlvbihlKXt0KGUsbnVsbCksXCJhbGxcIj09PXImJmEucHVzaChlKX0pKSxcIm9iamVjdFwiIT10eXBlb2YgZS5pY29ucylyZXR1cm5cIm5vbmVcIiE9PXImJmE7dmFyIGM9T2JqZWN0LmNyZWF0ZShudWxsKTtvLmZvckVhY2goKGZ1bmN0aW9uKG4pe3ZvaWQgMCE9PWVbbl0mJlwib2JqZWN0XCIhPXR5cGVvZiBlW25dJiYoY1tuXT1lW25dKX0pKTt2YXIgdT1lLmljb25zO2lmKE9iamVjdC5rZXlzKHUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPXVbZV07XCJzdHJpbmdcIj09dHlwZW9mIHIuYm9keSYmKHQoZSxPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sbi5pY29uRGVmYXVsdHMsYyxyKSkpLGEucHVzaChlKSl9KSksXCJvYmplY3RcIj09dHlwZW9mIGUuYWxpYXNlcyl7dmFyIGY9ZS5hbGlhc2VzO09iamVjdC5rZXlzKGYpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPWkoZltlXSx1LGYsMSk7ciYmKHQoZSxPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sbi5pY29uRGVmYXVsdHMsYyxyKSkpLGEucHVzaChlKSl9KSl9cmV0dXJuXCJub25lXCI9PT1yP2EubGVuZ3RoPjA6YX19KSksbz1lKChmdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQudmFsaWRhdGVJY29uPXQuc3RyaW5nVG9JY29uPXZvaWQgMDt0LnN0cmluZ1RvSWNvbj1mdW5jdGlvbihlLG4scixvKXt2b2lkIDA9PT1vJiYobz1cIlwiKTt2YXIgaT1lLnNwbGl0KFwiOlwiKTtpZihcIkBcIj09PWUuc2xpY2UoMCwxKSl7aWYoaS5sZW5ndGg8Mnx8aS5sZW5ndGg+MylyZXR1cm4gbnVsbDtvPWkuc2hpZnQoKS5zbGljZSgxKX1pZihpLmxlbmd0aD4zfHwhaS5sZW5ndGgpcmV0dXJuIG51bGw7aWYoaS5sZW5ndGg+MSl7dmFyIGE9aS5wb3AoKSxjPWkucG9wKCksdT17cHJvdmlkZXI6aS5sZW5ndGg+MD9pWzBdOm8scHJlZml4OmMsbmFtZTphfTtyZXR1cm4gbiYmIXQudmFsaWRhdGVJY29uKHUpP251bGw6dX12YXIgZj1pWzBdLGw9Zi5zcGxpdChcIi1cIik7aWYobC5sZW5ndGg+MSl7dmFyIHM9e3Byb3ZpZGVyOm8scHJlZml4Omwuc2hpZnQoKSxuYW1lOmwuam9pbihcIi1cIil9O3JldHVybiBuJiYhdC52YWxpZGF0ZUljb24ocyk/bnVsbDpzfWlmKHImJlwiXCI9PT1vKXt2YXIgZD17cHJvdmlkZXI6byxwcmVmaXg6XCJcIixuYW1lOmZ9O3JldHVybiBuJiYhdC52YWxpZGF0ZUljb24oZCxyKT9udWxsOmR9cmV0dXJuIG51bGx9O3QudmFsaWRhdGVJY29uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuISFlJiYhKFwiXCIhPT1lLnByb3ZpZGVyJiYhZS5wcm92aWRlci5tYXRjaChuLm1hdGNoTmFtZSl8fCEodCYmXCJcIj09PWUucHJlZml4fHxlLnByZWZpeC5tYXRjaChuLm1hdGNoTmFtZSkpfHwhZS5uYW1lLm1hdGNoKG4ubWF0Y2hOYW1lKSl9fSkpLGk9ZSgoZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lmxpc3RJY29ucz10LmdldEljb249dC5pY29uRXhpc3RzPXQuYWRkSWNvbj10LmFkZEljb25TZXQ9dC5nZXRTdG9yYWdlPXQubmV3U3RvcmFnZT12b2lkIDA7dmFyIG89T2JqZWN0LmNyZWF0ZShudWxsKTtmdW5jdGlvbiBpKGUsbil7cmV0dXJue3Byb3ZpZGVyOmUscHJlZml4Om4saWNvbnM6T2JqZWN0LmNyZWF0ZShudWxsKSxtaXNzaW5nOk9iamVjdC5jcmVhdGUobnVsbCl9fWZ1bmN0aW9uIGEoZSxuKXt2b2lkIDA9PT1vW2VdJiYob1tlXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgdD1vW2VdO3JldHVybiB2b2lkIDA9PT10W25dJiYodFtuXT1pKGUsbikpLHRbbl19dC5uZXdTdG9yYWdlPWksdC5nZXRTdG9yYWdlPWEsdC5hZGRJY29uU2V0PWZ1bmN0aW9uKGUsbix0KXt2b2lkIDA9PT10JiYodD1cIm5vbmVcIik7dmFyIG89RGF0ZS5ub3coKTtyZXR1cm4gci5wYXJzZUljb25TZXQobiwoZnVuY3Rpb24obix0KXtudWxsPT09dD9lLm1pc3Npbmdbbl09bzplLmljb25zW25dPXR9KSx0KX0sdC5hZGRJY29uPWZ1bmN0aW9uKGUsdCxyKXt0cnl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHIuYm9keSlyZXR1cm4gZS5pY29uc1t0XT1PYmplY3QuZnJlZXplKG4uZnVsbEljb24ocikpLCEwfWNhdGNoKGUpe31yZXR1cm4hMX0sdC5pY29uRXhpc3RzPWZ1bmN0aW9uKGUsbil7cmV0dXJuIHZvaWQgMCE9PWUuaWNvbnNbbl19LHQuZ2V0SWNvbj1mdW5jdGlvbihlLG4pe3ZhciB0PWUuaWNvbnNbbl07cmV0dXJuIHZvaWQgMD09PXQ/bnVsbDp0fSx0Lmxpc3RJY29ucz1mdW5jdGlvbihlLG4pe3ZhciB0PVtdO3JldHVybihcInN0cmluZ1wiPT10eXBlb2YgZT9bZV06T2JqZWN0LmtleXMobykpLmZvckVhY2goKGZ1bmN0aW9uKGUpeyhcInN0cmluZ1wiPT10eXBlb2YgZSYmXCJzdHJpbmdcIj09dHlwZW9mIG4/W25dOnZvaWQgMD09PW9bZV0/W106T2JqZWN0LmtleXMob1tlXSkpLmZvckVhY2goKGZ1bmN0aW9uKG4pe3ZhciByPWEoZSxuKSxvPU9iamVjdC5rZXlzKHIuaWNvbnMpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuKFwiXCIhPT1lP1wiQFwiK2UrXCI6XCI6XCJcIikrbitcIjpcIit0fSkpO3Q9dC5jb25jYXQobyl9KSl9KSksdH19KSksYT1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uc3RvcmFnZUZ1bmN0aW9ucz1uLmFkZENvbGxlY3Rpb249bi5hZGRJY29uPW4uZ2V0SWNvbkRhdGE9bi5hbGxvd1NpbXBsZU5hbWVzPXZvaWQgMDt2YXIgdD0hMTtmdW5jdGlvbiBhKGUpe3ZhciBuPVwic3RyaW5nXCI9PXR5cGVvZiBlP28uc3RyaW5nVG9JY29uKGUsITAsdCk6ZTtyZXR1cm4gbj9pLmdldEljb24oaS5nZXRTdG9yYWdlKG4ucHJvdmlkZXIsbi5wcmVmaXgpLG4ubmFtZSk6bnVsbH1mdW5jdGlvbiBjKGUsbil7dmFyIHI9by5zdHJpbmdUb0ljb24oZSwhMCx0KTtpZighcilyZXR1cm4hMTt2YXIgYT1pLmdldFN0b3JhZ2Uoci5wcm92aWRlcixyLnByZWZpeCk7cmV0dXJuIGkuYWRkSWNvbihhLHIubmFtZSxuKX1mdW5jdGlvbiB1KGUsbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpcmV0dXJuITE7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIG4mJihuPVwic3RyaW5nXCI9PXR5cGVvZiBlLnByb3ZpZGVyP2UucHJvdmlkZXI6XCJcIiksdCYmXCJcIj09PW4mJihcInN0cmluZ1wiIT10eXBlb2YgZS5wcmVmaXh8fFwiXCI9PT1lLnByZWZpeCkpe3ZhciBhPSExO3JldHVybiByLnBhcnNlSWNvblNldChlLChmdW5jdGlvbihlLG4pe251bGwhPT1uJiZjKGUsbikmJihhPSEwKX0pKSxhfWlmKFwic3RyaW5nXCIhPXR5cGVvZiBlLnByZWZpeHx8IW8udmFsaWRhdGVJY29uKHtwcm92aWRlcjpuLHByZWZpeDplLnByZWZpeCxuYW1lOlwiYVwifSkpcmV0dXJuITE7dmFyIHU9aS5nZXRTdG9yYWdlKG4sZS5wcmVmaXgpO3JldHVybiEhaS5hZGRJY29uU2V0KHUsZSl9bi5hbGxvd1NpbXBsZU5hbWVzPWZ1bmN0aW9uKGUpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgZSYmKHQ9ZSksdH0sbi5nZXRJY29uRGF0YT1hLG4uYWRkSWNvbj1jLG4uYWRkQ29sbGVjdGlvbj11LG4uc3RvcmFnZUZ1bmN0aW9ucz17aWNvbkV4aXN0czpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWEoZSl9LGdldEljb246ZnVuY3Rpb24oZSl7dmFyIG49YShlKTtyZXR1cm4gbj9PYmplY3QuYXNzaWduKHt9LG4pOm51bGx9LGxpc3RJY29uczppLmxpc3RJY29ucyxhZGRJY29uOmMsYWRkQ29sbGVjdGlvbjp1fX0pKSxjPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5yZXBsYWNlSURzPXZvaWQgMDt2YXIgdD0vXFxzaWQ9XCIoXFxTKylcIi9nLHI9XCIoW15BLVphLXowLTlfLV0pXCI7dmFyIG89XCJJY29uaWZ5SWQtXCIrRGF0ZS5ub3coKS50b1N0cmluZygxNikrXCItXCIrKDE2Nzc3MjE2Kk1hdGgucmFuZG9tKCl8MCkudG9TdHJpbmcoMTYpK1wiLVwiLGk9MDtuLnJlcGxhY2VJRHM9ZnVuY3Rpb24oZSxuKXt2b2lkIDA9PT1uJiYobj1vKTtmb3IodmFyIGEsYz1bXTthPXQuZXhlYyhlKTspYy5wdXNoKGFbMV0pO3JldHVybiBjLmxlbmd0aD8oYy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP24oKTpuK2krKztlPWUucmVwbGFjZShuZXcgUmVnRXhwKHIrXCIoXCIrKHQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csXCJcXFxcJCZcIikrXCIpXCIpK3IsXCJnXCIpLFwiJDFcIitvK1wiJDNcIil9KSksZSk6ZX19KSksdT1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uY2FsY3VsYXRlU2l6ZT12b2lkIDA7dmFyIHQ9LygtP1swLTkuXSpbMC05XStbMC05Ll0qKS9nLHI9L14tP1swLTkuXSpbMC05XStbMC05Ll0qJC9nO24uY2FsY3VsYXRlU2l6ZT1mdW5jdGlvbihlLG4sbyl7aWYoMT09PW4pcmV0dXJuIGU7aWYobz12b2lkIDA9PT1vPzEwMDpvLFwibnVtYmVyXCI9PXR5cGVvZiBlKXJldHVybiBNYXRoLmNlaWwoZSpuKm8pL287aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuIGU7dmFyIGk9ZS5zcGxpdCh0KTtpZihudWxsPT09aXx8IWkubGVuZ3RoKXJldHVybiBlO2Zvcih2YXIgYT1bXSxjPWkuc2hpZnQoKSx1PXIudGVzdChjKTs7KXtpZih1KXt2YXIgZj1wYXJzZUZsb2F0KGMpO2lzTmFOKGYpP2EucHVzaChjKTphLnB1c2goTWF0aC5jZWlsKGYqbipvKS9vKX1lbHNlIGEucHVzaChjKTtpZih2b2lkIDA9PT0oYz1pLnNoaWZ0KCkpKXJldHVybiBhLmpvaW4oXCJcIik7dT0hdX19fSkpLGY9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLm1lcmdlQ3VzdG9taXNhdGlvbnM9bi5kZWZhdWx0cz12b2lkIDAsbi5kZWZhdWx0cz1PYmplY3QuZnJlZXplKHtpbmxpbmU6ITEsd2lkdGg6bnVsbCxoZWlnaHQ6bnVsbCxoQWxpZ246XCJjZW50ZXJcIix2QWxpZ246XCJtaWRkbGVcIixzbGljZTohMSxoRmxpcDohMSx2RmxpcDohMSxyb3RhdGU6MH0pLG4ubWVyZ2VDdXN0b21pc2F0aW9ucz1mdW5jdGlvbihlLG4pe3ZhciB0PXt9O2Zvcih2YXIgciBpbiBlKXt2YXIgbz1yO2lmKHRbb109ZVtvXSx2b2lkIDAhPT1uW29dKXt2YXIgaT1uW29dO3N3aXRjaChvKXtjYXNlXCJpbmxpbmVcIjpjYXNlXCJzbGljZVwiOlwiYm9vbGVhblwiPT10eXBlb2YgaSYmKHRbb109aSk7YnJlYWs7Y2FzZVwiaEZsaXBcIjpjYXNlXCJ2RmxpcFwiOiEwPT09aSYmKHRbb109IXRbb10pO2JyZWFrO2Nhc2VcImhBbGlnblwiOmNhc2VcInZBbGlnblwiOlwic3RyaW5nXCI9PXR5cGVvZiBpJiZcIlwiIT09aSYmKHRbb109aSk7YnJlYWs7Y2FzZVwid2lkdGhcIjpjYXNlXCJoZWlnaHRcIjooXCJzdHJpbmdcIj09dHlwZW9mIGkmJlwiXCIhPT1pfHxcIm51bWJlclwiPT10eXBlb2YgaSYmaXx8bnVsbD09PWkpJiYodFtvXT1pKTticmVhaztjYXNlXCJyb3RhdGVcIjpcIm51bWJlclwiPT10eXBlb2YgaSYmKHRbb10rPWkpfX19cmV0dXJuIHR9fSkpLGw9ZSgoZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiB0KGUpe3ZhciBuPVwiXCI7c3dpdGNoKGUuaEFsaWduKXtjYXNlXCJsZWZ0XCI6bis9XCJ4TWluXCI7YnJlYWs7Y2FzZVwicmlnaHRcIjpuKz1cInhNYXhcIjticmVhaztkZWZhdWx0Om4rPVwieE1pZFwifXN3aXRjaChlLnZBbGlnbil7Y2FzZVwidG9wXCI6bis9XCJZTWluXCI7YnJlYWs7Y2FzZVwiYm90dG9tXCI6bis9XCJZTWF4XCI7YnJlYWs7ZGVmYXVsdDpuKz1cIllNaWRcIn1yZXR1cm4gbis9ZS5zbGljZT9cIiBzbGljZVwiOlwiIG1lZXRcIn1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmljb25Ub1NWRz12b2lkIDAsbi5pY29uVG9TVkc9ZnVuY3Rpb24oZSxuKXt2YXIgcixvLGk9e2xlZnQ6ZS5sZWZ0LHRvcDplLnRvcCx3aWR0aDplLndpZHRoLGhlaWdodDplLmhlaWdodH0sYT1lLmJvZHk7W2Usbl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG4sdD1bXSxyPWUuaEZsaXAsbz1lLnZGbGlwLGM9ZS5yb3RhdGU7c3dpdGNoKHI/bz9jKz0yOih0LnB1c2goXCJ0cmFuc2xhdGUoXCIrKGkud2lkdGgraS5sZWZ0KStcIiBcIisoMC1pLnRvcCkrXCIpXCIpLHQucHVzaChcInNjYWxlKC0xIDEpXCIpLGkudG9wPWkubGVmdD0wKTpvJiYodC5wdXNoKFwidHJhbnNsYXRlKFwiKygwLWkubGVmdCkrXCIgXCIrKGkuaGVpZ2h0K2kudG9wKStcIilcIiksdC5wdXNoKFwic2NhbGUoMSAtMSlcIiksaS50b3A9aS5sZWZ0PTApLGM8MCYmKGMtPTQqTWF0aC5mbG9vcihjLzQpKSxjJT00KXtjYXNlIDE6bj1pLmhlaWdodC8yK2kudG9wLHQudW5zaGlmdChcInJvdGF0ZSg5MCBcIituK1wiIFwiK24rXCIpXCIpO2JyZWFrO2Nhc2UgMjp0LnVuc2hpZnQoXCJyb3RhdGUoMTgwIFwiKyhpLndpZHRoLzIraS5sZWZ0KStcIiBcIisoaS5oZWlnaHQvMitpLnRvcCkrXCIpXCIpO2JyZWFrO2Nhc2UgMzpuPWkud2lkdGgvMitpLmxlZnQsdC51bnNoaWZ0KFwicm90YXRlKC05MCBcIituK1wiIFwiK24rXCIpXCIpfWMlMj09MSYmKDA9PT1pLmxlZnQmJjA9PT1pLnRvcHx8KG49aS5sZWZ0LGkubGVmdD1pLnRvcCxpLnRvcD1uKSxpLndpZHRoIT09aS5oZWlnaHQmJihuPWkud2lkdGgsaS53aWR0aD1pLmhlaWdodCxpLmhlaWdodD1uKSksdC5sZW5ndGgmJihhPSc8ZyB0cmFuc2Zvcm09XCInK3Quam9pbihcIiBcIikrJ1wiPicrYStcIjwvZz5cIil9KSksbnVsbD09PW4ud2lkdGgmJm51bGw9PT1uLmhlaWdodD8obz1cIjFlbVwiLHI9dS5jYWxjdWxhdGVTaXplKG8saS53aWR0aC9pLmhlaWdodCkpOm51bGwhPT1uLndpZHRoJiZudWxsIT09bi5oZWlnaHQ/KHI9bi53aWR0aCxvPW4uaGVpZ2h0KTpudWxsIT09bi5oZWlnaHQ/KG89bi5oZWlnaHQscj11LmNhbGN1bGF0ZVNpemUobyxpLndpZHRoL2kuaGVpZ2h0KSk6KHI9bi53aWR0aCxvPXUuY2FsY3VsYXRlU2l6ZShyLGkuaGVpZ2h0L2kud2lkdGgpKSxcImF1dG9cIj09PXImJihyPWkud2lkdGgpLFwiYXV0b1wiPT09byYmKG89aS5oZWlnaHQpO3ZhciBjPXthdHRyaWJ1dGVzOnt3aWR0aDpyPVwic3RyaW5nXCI9PXR5cGVvZiByP3I6citcIlwiLGhlaWdodDpvPVwic3RyaW5nXCI9PXR5cGVvZiBvP286bytcIlwiLHByZXNlcnZlQXNwZWN0UmF0aW86dChuKSx2aWV3Qm94OmkubGVmdCtcIiBcIitpLnRvcCtcIiBcIitpLndpZHRoK1wiIFwiK2kuaGVpZ2h0fSxib2R5OmF9O3JldHVybiBuLmlubGluZSYmKGMuaW5saW5lPSEwKSxjfX0pKSxzPWUoKGZ1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5idWlsZGVyRnVuY3Rpb25zPXZvaWQgMCx0LmJ1aWxkZXJGdW5jdGlvbnM9e3JlcGxhY2VJRHM6Yy5yZXBsYWNlSURzLGNhbGN1bGF0ZVNpemU6dS5jYWxjdWxhdGVTaXplLGJ1aWxkSWNvbjpmdW5jdGlvbihlLHQpe3JldHVybiBsLmljb25Ub1NWRyhuLmZ1bGxJY29uKGUpLGYubWVyZ2VDdXN0b21pc2F0aW9ucyhmLmRlZmF1bHRzLHQpKX19fSkpLGQ9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmNvcmVNb2R1bGVzPXZvaWQgMCxuLmNvcmVNb2R1bGVzPXt9fSkpLHY9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnN0b3JlQ2FjaGU9bi5sb2FkQ2FjaGU9bi5tb2NrPW4uZW1wdHlMaXN0PW4uY291bnQ9bi5jb25maWc9dm9pZCAwO3ZhciB0PVwiaWNvbmlmeTJcIixyPVwiaWNvbmlmeVwiLG89XCJpY29uaWZ5LWNvdW50XCIsYT1cImljb25pZnktdmVyc2lvblwiLGM9MzZlNTtuLmNvbmZpZz17bG9jYWw6ITAsc2Vzc2lvbjohMH07dmFyIHU9ITE7bi5jb3VudD17bG9jYWw6MCxzZXNzaW9uOjB9LG4uZW1wdHlMaXN0PXtsb2NhbDpbXSxzZXNzaW9uOltdfTt2YXIgZj1cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdztmdW5jdGlvbiBsKGUpe3ZhciB0PWUrXCJTdG9yYWdlXCI7dHJ5e2lmKGYmJmZbdF0mJlwibnVtYmVyXCI9PXR5cGVvZiBmW3RdLmxlbmd0aClyZXR1cm4gZlt0XX1jYXRjaChlKXt9cmV0dXJuIG4uY29uZmlnW2VdPSExLG51bGx9ZnVuY3Rpb24gcyhlLHQscil7dHJ5e3JldHVybiBlLnNldEl0ZW0obyxyK1wiXCIpLG4uY291bnRbdF09ciwhMH1jYXRjaChlKXtyZXR1cm4hMX19ZnVuY3Rpb24gZChlKXt2YXIgbj1lLmdldEl0ZW0obyk7aWYobil7dmFyIHQ9cGFyc2VJbnQobik7cmV0dXJuIHR8fDB9cmV0dXJuIDB9bi5tb2NrPWZ1bmN0aW9uKGUpe3U9ITEsZj1lfTtuLmxvYWRDYWNoZT1mdW5jdGlvbigpe2lmKCF1KXt1PSEwO3ZhciBlPU1hdGguZmxvb3IoRGF0ZS5ub3coKS9jKS0xNjg7Zm9yKHZhciBvIGluIG4uY29uZmlnKWYobyl9ZnVuY3Rpb24gZihvKXt2YXIgYz1sKG8pO2lmKGMpe3ZhciB1PWZ1bmN0aW9uKG4pe3ZhciB0PXIrbixvPWMuZ2V0SXRlbSh0KTtpZihcInN0cmluZ1wiIT10eXBlb2YgbylyZXR1cm4hMTt2YXIgYT0hMDt0cnl7dmFyIHU9SlNPTi5wYXJzZShvKTtpZihcIm9iamVjdFwiIT10eXBlb2YgdXx8XCJudW1iZXJcIiE9dHlwZW9mIHUuY2FjaGVkfHx1LmNhY2hlZDxlfHxcInN0cmluZ1wiIT10eXBlb2YgdS5wcm92aWRlcnx8XCJvYmplY3RcIiE9dHlwZW9mIHUuZGF0YXx8XCJzdHJpbmdcIiE9dHlwZW9mIHUuZGF0YS5wcmVmaXgpYT0hMTtlbHNle3ZhciBmPXUucHJvdmlkZXIsbD11LmRhdGEucHJlZml4LHM9aS5nZXRTdG9yYWdlKGYsbCk7YT1pLmFkZEljb25TZXQocyx1LmRhdGEpfX1jYXRjaChlKXthPSExfXJldHVybiBhfHxjLnJlbW92ZUl0ZW0odCksYX07dHJ5e3ZhciBmPWMuZ2V0SXRlbShhKTtpZihmIT09dClyZXR1cm4gZiYmZnVuY3Rpb24oZSl7dHJ5e2Zvcih2YXIgbj1kKGUpLHQ9MDt0PG47dCsrKWUucmVtb3ZlSXRlbShyK3QpfWNhdGNoKGUpe319KGMpLHZvaWQgZnVuY3Rpb24oZSxuKXt0cnl7ZS5zZXRJdGVtKGEsdCl9Y2F0Y2goZSl7fXMoZSxuLDApfShjLG8pO2Zvcih2YXIgdj1kKGMpLHA9di0xO3A+PTA7cC0tKXUocCl8fChwPT09di0xP3YtLTpuLmVtcHR5TGlzdFtvXS5wdXNoKHApKTtzKGMsbyx2KX1jYXRjaChlKXt9fX19O24uc3RvcmVDYWNoZT1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG8obyl7aWYoIW4uY29uZmlnW29dKXJldHVybiExO3ZhciBpPWwobyk7aWYoIWkpcmV0dXJuITE7dmFyIGE9bi5lbXB0eUxpc3Rbb10uc2hpZnQoKTtpZih2b2lkIDA9PT1hJiYhcyhpLG8sKGE9bi5jb3VudFtvXSkrMSkpcmV0dXJuITE7dHJ5e3ZhciB1PXtjYWNoZWQ6TWF0aC5mbG9vcihEYXRlLm5vdygpL2MpLHByb3ZpZGVyOmUsZGF0YTp0fTtpLnNldEl0ZW0ocithLEpTT04uc3RyaW5naWZ5KHUpKX1jYXRjaChlKXtyZXR1cm4hMX1yZXR1cm4hMH11fHxuLmxvYWRDYWNoZSgpLG8oXCJsb2NhbFwiKXx8byhcInNlc3Npb25cIil9fSkpLHA9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnRvZ2dsZUJyb3dzZXJDYWNoZT12b2lkIDAsbi50b2dnbGVCcm93c2VyQ2FjaGU9ZnVuY3Rpb24oZSxuKXtzd2l0Y2goZSl7Y2FzZVwibG9jYWxcIjpjYXNlXCJzZXNzaW9uXCI6di5jb25maWdbZV09bjticmVhaztjYXNlXCJhbGxcIjpmb3IodmFyIHQgaW4gdi5jb25maWcpdi5jb25maWdbdF09bn19fSkpLGg9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmRlZmF1bHRDb25maWc9dm9pZCAwLG4uZGVmYXVsdENvbmZpZz17cmVzb3VyY2VzOltdLGluZGV4OjAsdGltZW91dDoyZTMscm90YXRlOjc1MCxyYW5kb206ITEsZGF0YUFmdGVyVGltZW91dDohMX19KSksZz1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uc2VuZFF1ZXJ5PXZvaWQgMCxuLnNlbmRRdWVyeT1mdW5jdGlvbihlLG4sdCxyLG8pe3ZhciBpLGE9ZS5yZXNvdXJjZXMubGVuZ3RoLGM9ZS5yYW5kb20/TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKmEpOmUuaW5kZXg7aWYoZS5yYW5kb20pe3ZhciB1PWUucmVzb3VyY2VzLnNsaWNlKDApO2ZvcihpPVtdO3UubGVuZ3RoPjE7KXt2YXIgZj1NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdS5sZW5ndGgpO2kucHVzaCh1W2ZdKSx1PXUuc2xpY2UoMCxmKS5jb25jYXQodS5zbGljZShmKzEpKX1pPWkuY29uY2F0KHUpfWVsc2UgaT1lLnJlc291cmNlcy5zbGljZShjKS5jb25jYXQoZS5yZXNvdXJjZXMuc2xpY2UoMCxjKSk7dmFyIGw9RGF0ZS5ub3coKSxzPVwicGVuZGluZ1wiLGQ9MCx2PXZvaWQgMCxwPW51bGwsaD1bXSxnPVtdO2Z1bmN0aW9uIG0oKXtwJiYoY2xlYXJUaW1lb3V0KHApLHA9bnVsbCl9ZnVuY3Rpb24gYigpe1wicGVuZGluZ1wiPT09cyYmKHM9XCJhYm9ydGVkXCIpLG0oKSxoLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UuYWJvcnQmJmUuYWJvcnQoKSxcInBlbmRpbmdcIj09PWUuc3RhdHVzJiYoZS5zdGF0dXM9XCJhYm9ydGVkXCIpfSkpLGg9W119ZnVuY3Rpb24geShlLG4pe24mJihnPVtdKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZnLnB1c2goZSl9ZnVuY3Rpb24gSSgpe3JldHVybntzdGFydFRpbWU6bCxwYXlsb2FkOm4sc3RhdHVzOnMscXVlcmllc1NlbnQ6ZCxxdWVyaWVzUGVuZGluZzpoLmxlbmd0aCxzdWJzY3JpYmU6eSxhYm9ydDpifX1mdW5jdGlvbiBqKCl7cz1cImZhaWxlZFwiLGcuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZSh2b2lkIDAsdil9KSl9ZnVuY3Rpb24geCgpe2g9aC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVyblwicGVuZGluZ1wiPT09ZS5zdGF0dXMmJihlLnN0YXR1cz1cImFib3J0ZWRcIiksZS5hYm9ydCYmZS5hYm9ydCgpLCExfSkpfWZ1bmN0aW9uIE8oKXtpZihcInBlbmRpbmdcIj09PXMpe20oKTt2YXIgcj1pLnNoaWZ0KCk7aWYodm9pZCAwIT09cil7dmFyIGE9e2dldFF1ZXJ5U3RhdHVzOkksc3RhdHVzOlwicGVuZGluZ1wiLHJlc291cmNlOnIsZG9uZTpmdW5jdGlvbihuLHQpeyFmdW5jdGlvbihuLHQscil7dmFyIGE9dm9pZCAwPT09dDtzd2l0Y2goaD1oLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT1ufSkpLHMpe2Nhc2VcInBlbmRpbmdcIjpicmVhaztjYXNlXCJmYWlsZWRcIjppZihhfHwhZS5kYXRhQWZ0ZXJUaW1lb3V0KXJldHVybjticmVhaztkZWZhdWx0OnJldHVybn1pZihhKXJldHVybiB2b2lkIDAhPT1yJiYodj1yKSx2b2lkKGgubGVuZ3RofHwoaS5sZW5ndGg/TygpOmooKSkpO2lmKG0oKSx4KCksbyYmIWUucmFuZG9tKXt2YXIgYz1lLnJlc291cmNlcy5pbmRleE9mKG4ucmVzb3VyY2UpOy0xIT09YyYmYyE9PWUuaW5kZXgmJm8oYyl9cz1cImNvbXBsZXRlZFwiLGcuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZSh0KX0pKX0oYSxuLHQpfX07aC5wdXNoKGEpLGQrKzt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnJvdGF0ZT9lLnJvdGF0ZShkLGwpOmUucm90YXRlO3A9c2V0VGltZW91dChPLGMpLHQocixuLGEpfWVsc2V7aWYoaC5sZW5ndGgpe3ZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIGUudGltZW91dD9lLnRpbWVvdXQobCk6ZS50aW1lb3V0O2lmKHUpcmV0dXJuIHZvaWQocD1zZXRUaW1lb3V0KChmdW5jdGlvbigpe20oKSxcInBlbmRpbmdcIj09PXMmJih4KCksaigpKX0pLHUpKX1qKCl9fX1yZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiByJiZnLnB1c2gociksc2V0VGltZW91dChPKSxJfX0pKSxtPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5pbml0UmVkdW5kYW5jeT12b2lkIDAsbi5pbml0UmVkdW5kYW5jeT1mdW5jdGlvbihlKXt2YXIgbj1mdW5jdGlvbihlKXtpZighKFwib2JqZWN0XCI9PXR5cGVvZiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZS5yZXNvdXJjZXMmJmUucmVzb3VyY2VzIGluc3RhbmNlb2YgQXJyYXkmJmUucmVzb3VyY2VzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSZWR1bmNhbmN5IGNvbmZpZ3VyYXRpb25cIik7dmFyIG4sdD1PYmplY3QuY3JlYXRlKG51bGwpO2ZvcihuIGluIGguZGVmYXVsdENvbmZpZyl2b2lkIDAhPT1lW25dP3Rbbl09ZVtuXTp0W25dPWguZGVmYXVsdENvbmZpZ1tuXTtyZXR1cm4gdH0oZSksdD1bXTtmdW5jdGlvbiByKCl7dD10LmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuXCJwZW5kaW5nXCI9PT1lKCkuc3RhdHVzfSkpfXJldHVybntxdWVyeTpmdW5jdGlvbihlLG8saSl7dmFyIGE9Zy5zZW5kUXVlcnkobixlLG8sKGZ1bmN0aW9uKGUsbil7cigpLGkmJmkoZSxuKX0pLChmdW5jdGlvbihlKXtuLmluZGV4PWV9KSk7cmV0dXJuIHQucHVzaChhKSxhfSxmaW5kOmZ1bmN0aW9uKGUpe3ZhciBuPXQuZmluZCgoZnVuY3Rpb24obil7cmV0dXJuIGUobil9KSk7cmV0dXJuIHZvaWQgMCE9PW4/bjpudWxsfSxzZXRJbmRleDpmdW5jdGlvbihlKXtuLmluZGV4PWV9LGdldEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIG4uaW5kZXh9LGNsZWFudXA6cn19fSkpLGI9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnNvcnRJY29ucz12b2lkIDAsbi5zb3J0SWNvbnM9ZnVuY3Rpb24oZSl7dmFyIG49e2xvYWRlZDpbXSxtaXNzaW5nOltdLHBlbmRpbmc6W119LHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtlLnNvcnQoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGUucHJvdmlkZXIhPT1uLnByb3ZpZGVyP2UucHJvdmlkZXIubG9jYWxlQ29tcGFyZShuLnByb3ZpZGVyKTplLnByZWZpeCE9PW4ucHJlZml4P2UucHJlZml4LmxvY2FsZUNvbXBhcmUobi5wcmVmaXgpOmUubmFtZS5sb2NhbGVDb21wYXJlKG4ubmFtZSl9KSk7dmFyIHI9e3Byb3ZpZGVyOlwiXCIscHJlZml4OlwiXCIsbmFtZTpcIlwifTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlKXtpZihyLm5hbWUhPT1lLm5hbWV8fHIucHJlZml4IT09ZS5wcmVmaXh8fHIucHJvdmlkZXIhPT1lLnByb3ZpZGVyKXtyPWU7dmFyIG89ZS5wcm92aWRlcixhPWUucHJlZml4LGM9ZS5uYW1lO3ZvaWQgMD09PXRbb10mJih0W29dPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciB1PXRbb107dm9pZCAwPT09dVthXSYmKHVbYV09aS5nZXRTdG9yYWdlKG8sYSkpO3ZhciBmPXVbYV0sbD17cHJvdmlkZXI6byxwcmVmaXg6YSxuYW1lOmN9Oyh2b2lkIDAhPT1mLmljb25zW2NdP24ubG9hZGVkOlwiXCI9PT1hfHx2b2lkIDAhPT1mLm1pc3NpbmdbY10/bi5taXNzaW5nOm4ucGVuZGluZykucHVzaChsKX19KSksbn19KSkseT1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uc3RvcmVDYWxsYmFjaz1uLnVwZGF0ZUNhbGxiYWNrcz1uLmNhbGxiYWNrcz12b2lkIDAsbi5jYWxsYmFja3M9T2JqZWN0LmNyZWF0ZShudWxsKTt2YXIgdD1PYmplY3QuY3JlYXRlKG51bGwpO2Z1bmN0aW9uIHIoZSx0KXtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPWUucHJvdmlkZXI7aWYodm9pZCAwIT09bi5jYWxsYmFja3Nbcl0pe3ZhciBvPW4uY2FsbGJhY2tzW3JdLGk9ZS5wcmVmaXgsYT1vW2ldO2EmJihvW2ldPWEuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZCE9PXR9KSkpfX0pKX1uLnVwZGF0ZUNhbGxiYWNrcz1mdW5jdGlvbihlLG8pe3ZvaWQgMD09PXRbZV0mJih0W2VdPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciBhPXRbZV07YVtvXXx8KGFbb109ITAsc2V0VGltZW91dCgoZnVuY3Rpb24oKXtpZihhW29dPSExLHZvaWQgMCE9PW4uY2FsbGJhY2tzW2VdJiZ2b2lkIDAhPT1uLmNhbGxiYWNrc1tlXVtvXSl7dmFyIHQ9bi5jYWxsYmFja3NbZV1bb10uc2xpY2UoMCk7aWYodC5sZW5ndGgpe3ZhciBjPWkuZ2V0U3RvcmFnZShlLG8pLHU9ITE7dC5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgdD1uLmljb25zLGk9dC5wZW5kaW5nLmxlbmd0aDt0LnBlbmRpbmc9dC5wZW5kaW5nLmZpbHRlcigoZnVuY3Rpb24obil7aWYobi5wcmVmaXghPT1vKXJldHVybiEwO3ZhciByPW4ubmFtZTtpZih2b2lkIDAhPT1jLmljb25zW3JdKXQubG9hZGVkLnB1c2goe3Byb3ZpZGVyOmUscHJlZml4Om8sbmFtZTpyfSk7ZWxzZXtpZih2b2lkIDA9PT1jLm1pc3Npbmdbcl0pcmV0dXJuIHU9ITAsITA7dC5taXNzaW5nLnB1c2goe3Byb3ZpZGVyOmUscHJlZml4Om8sbmFtZTpyfSl9cmV0dXJuITF9KSksdC5wZW5kaW5nLmxlbmd0aCE9PWkmJih1fHxyKFt7cHJvdmlkZXI6ZSxwcmVmaXg6b31dLG4uaWQpLG4uY2FsbGJhY2sodC5sb2FkZWQuc2xpY2UoMCksdC5taXNzaW5nLnNsaWNlKDApLHQucGVuZGluZy5zbGljZSgwKSxuLmFib3J0KSl9KSl9fX0pKSl9O3ZhciBvPTA7bi5zdG9yZUNhbGxiYWNrPWZ1bmN0aW9uKGUsdCxpKXt2YXIgYT1vKyssYz1yLmJpbmQobnVsbCxpLGEpO2lmKCF0LnBlbmRpbmcubGVuZ3RoKXJldHVybiBjO3ZhciB1PXtpZDphLGljb25zOnQsY2FsbGJhY2s6ZSxhYm9ydDpjfTtyZXR1cm4gaS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1lLnByb3ZpZGVyLHI9ZS5wcmVmaXg7dm9pZCAwPT09bi5jYWxsYmFja3NbdF0mJihuLmNhbGxiYWNrc1t0XT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgbz1uLmNhbGxiYWNrc1t0XTt2b2lkIDA9PT1vW3JdJiYob1tyXT1bXSksb1tyXS5wdXNoKHUpfSkpLGN9fSkpLEk9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmdldEFQSU1vZHVsZT1uLnNldEFQSU1vZHVsZT12b2lkIDA7dmFyIHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtuLnNldEFQSU1vZHVsZT1mdW5jdGlvbihlLG4pe3RbZV09bn0sbi5nZXRBUElNb2R1bGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PXRbZV0/dFtcIlwiXTp0W2VdfX0pKSxqPWUoKGZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gdChlKXt2YXIgbjtpZihcInN0cmluZ1wiPT10eXBlb2YgZS5yZXNvdXJjZXMpbj1bZS5yZXNvdXJjZXNdO2Vsc2UgaWYoISgobj1lLnJlc291cmNlcylpbnN0YW5jZW9mIEFycmF5JiZuLmxlbmd0aCkpcmV0dXJuIG51bGw7cmV0dXJue3Jlc291cmNlczpuLHBhdGg6dm9pZCAwPT09ZS5wYXRoP1wiL1wiOmUucGF0aCxtYXhVUkw6ZS5tYXhVUkw/ZS5tYXhVUkw6NTAwLHJvdGF0ZTplLnJvdGF0ZT9lLnJvdGF0ZTo3NTAsdGltZW91dDplLnRpbWVvdXQ/ZS50aW1lb3V0OjVlMyxyYW5kb206ITA9PT1lLnJhbmRvbSxpbmRleDplLmluZGV4P2UuaW5kZXg6MCxkYXRhQWZ0ZXJUaW1lb3V0OiExIT09ZS5kYXRhQWZ0ZXJUaW1lb3V0fX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmdldEFQSUNvbmZpZz1uLnNldEFQSUNvbmZpZz12b2lkIDA7Zm9yKHZhciByPU9iamVjdC5jcmVhdGUobnVsbCksbz1bXCJodHRwczovL2FwaS5zaW1wbGVzdmcuY29tXCIsXCJodHRwczovL2FwaS51bmlzdmcuY29tXCJdLGk9W107by5sZW5ndGg+MDspMT09PW8ubGVuZ3RofHxNYXRoLnJhbmRvbSgpPi41P2kucHVzaChvLnNoaWZ0KCkpOmkucHVzaChvLnBvcCgpKTtyW1wiXCJdPXQoe3Jlc291cmNlczpbXCJodHRwczovL2FwaS5pY29uaWZ5LmRlc2lnblwiXS5jb25jYXQoaSl9KSxuLnNldEFQSUNvbmZpZz1mdW5jdGlvbihlLG4pe3ZhciBvPXQobik7cmV0dXJuIG51bGwhPT1vJiYocltlXT1vLCEwKX07bi5nZXRBUElDb25maWc9ZnVuY3Rpb24oZSl7cmV0dXJuIHJbZV19fSkpLHg9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmdldFByb3ZpZGVycz1uLmxpc3RUb0ljb25zPXZvaWQgMCxuLmxpc3RUb0ljb25zPWZ1bmN0aW9uKGUsbix0KXt2b2lkIDA9PT1uJiYobj0hMCksdm9pZCAwPT09dCYmKHQ9ITEpO3ZhciByPVtdO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBpPVwic3RyaW5nXCI9PXR5cGVvZiBlP28uc3RyaW5nVG9JY29uKGUsITEsdCk6ZTtuJiYhby52YWxpZGF0ZUljb24oaSx0KXx8ci5wdXNoKHtwcm92aWRlcjppLnByb3ZpZGVyLHByZWZpeDppLnByZWZpeCxuYW1lOmkubmFtZX0pfSkpLHJ9LG4uZ2V0UHJvdmlkZXJzPWZ1bmN0aW9uKGUpe3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bltlLnByb3ZpZGVyXT0hMH0pKSxPYmplY3Qua2V5cyhuKX19KSksTz1lKChmdW5jdGlvbihlLG4pe2Z1bmN0aW9uIHQoKXt9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5BUEk9bi5nZXRSZWR1bmRhbmN5Q2FjaGU9dm9pZCAwO3ZhciByPU9iamVjdC5jcmVhdGUobnVsbCksbz1PYmplY3QuY3JlYXRlKG51bGwpLGM9T2JqZWN0LmNyZWF0ZShudWxsKSx1PU9iamVjdC5jcmVhdGUobnVsbCksZj1PYmplY3QuY3JlYXRlKG51bGwpO2Z1bmN0aW9uIGwoZSl7aWYodm9pZCAwPT09ZltlXSl7dmFyIG49ai5nZXRBUElDb25maWcoZSk7aWYoIW4pcmV0dXJuO3ZhciB0PXtjb25maWc6bixyZWR1bmRhbmN5Om0uaW5pdFJlZHVuZGFuY3kobil9O2ZbZV09dH1yZXR1cm4gZltlXX1uLmdldFJlZHVuZGFuY3lDYWNoZT1sO3ZhciBzPU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gdihlLG4sdCl7ZnVuY3Rpb24gYSgpe3ZhciB0PShcIlwiPT09ZT9cIlwiOlwiQFwiK2UrXCI6XCIpK24scj1NYXRoLmZsb29yKERhdGUubm93KCkvNmU0KTtzW3RdPHImJihzW3RdPXIsY29uc29sZS5lcnJvcignVW5hYmxlIHRvIHJldHJpZXZlIGljb25zIGZvciBcIicrdCsnXCIgYmVjYXVzZSBBUEkgaXMgbm90IGNvbmZpZ3VyZWQgcHJvcGVybHkuJykpfXZvaWQgMD09PW9bZV0mJihvW2VdPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciBmPW9bZV07dm9pZCAwPT09dVtlXSYmKHVbZV09T2JqZWN0LmNyZWF0ZShudWxsKSk7dmFyIHY9dVtlXTt2b2lkIDA9PT1yW2VdJiYocltlXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgcCxoPXJbZV07dm9pZCAwPT09ZltuXT9mW25dPXQ6ZltuXT1mW25dLmNvbmNhdCh0KS5zb3J0KCksdltuXXx8KHZbbl09ITAsc2V0VGltZW91dCgoZnVuY3Rpb24oKXt2W25dPSExO3ZhciB0PWZbbl07ZGVsZXRlIGZbbl07dmFyIHI9SS5nZXRBUElNb2R1bGUoZSk7aWYocil7aWYodm9pZCAwPT09cCl7dmFyIG89bChlKTtpZih2b2lkIDA9PT1vKXJldHVybiB2b2lkIGEoKTtwPW99ci5wcmVwYXJlKGUsbix0KS5mb3JFYWNoKChmdW5jdGlvbih0KXtwLnJlZHVuZGFuY3kucXVlcnkodCxyLnNlbmQsKGZ1bmN0aW9uKHIsbyl7dmFyIGE9aS5nZXRTdG9yYWdlKGUsbik7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHIpe2lmKDQwNCE9PW8pcmV0dXJuO3ZhciB1PURhdGUubm93KCk7dC5pY29ucy5mb3JFYWNoKChmdW5jdGlvbihlKXthLm1pc3NpbmdbZV09dX0pKX1lbHNlIHRyeXt2YXIgZj1pLmFkZEljb25TZXQoYSxyLFwiYWxsXCIpO2lmKFwiYm9vbGVhblwiPT10eXBlb2YgZilyZXR1cm47dmFyIGw9aFtuXTtmLmZvckVhY2goKGZ1bmN0aW9uKGUpe2RlbGV0ZSBsW2VdfSkpLGQuY29yZU1vZHVsZXMuY2FjaGUmJmQuY29yZU1vZHVsZXMuY2FjaGUoZSxyKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGUpfSFmdW5jdGlvbihlLG4pe3ZvaWQgMD09PWNbZV0mJihjW2VdPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciB0PWNbZV07dFtuXXx8KHRbbl09ITAsc2V0VGltZW91dCgoZnVuY3Rpb24oKXt0W25dPSExLHkudXBkYXRlQ2FsbGJhY2tzKGUsbil9KSkpfShlLG4pfSkpfSkpfWVsc2UgYSgpfSkpKX1uLkFQST17aXNQZW5kaW5nOmZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1yW2UucHJvdmlkZXJdJiZ2b2lkIDAhPT1yW2UucHJvdmlkZXJdW2UucHJlZml4XSYmdm9pZCAwIT09cltlLnByb3ZpZGVyXVtlLnByZWZpeF1bZS5uYW1lXX0sbG9hZEljb25zOmZ1bmN0aW9uKGUsbil7dmFyIG89eC5saXN0VG9JY29ucyhlLCEwLGEuYWxsb3dTaW1wbGVOYW1lcygpKSxpPWIuc29ydEljb25zKG8pO2lmKCFpLnBlbmRpbmcubGVuZ3RoKXt2YXIgYz0hMDtyZXR1cm4gbiYmc2V0VGltZW91dCgoZnVuY3Rpb24oKXtjJiZuKGkubG9hZGVkLGkubWlzc2luZyxpLnBlbmRpbmcsdCl9KSksZnVuY3Rpb24oKXtjPSExfX12YXIgdSxmLGw9T2JqZWN0LmNyZWF0ZShudWxsKSxzPVtdO2kucGVuZGluZy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lLnByb3ZpZGVyLHQ9ZS5wcmVmaXg7aWYodCE9PWZ8fG4hPT11KXt1PW4sZj10LHMucHVzaCh7cHJvdmlkZXI6bixwcmVmaXg6dH0pLHZvaWQgMD09PXJbbl0mJihyW25dPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciBvPXJbbl07dm9pZCAwPT09b1t0XSYmKG9bdF09T2JqZWN0LmNyZWF0ZShudWxsKSksdm9pZCAwPT09bFtuXSYmKGxbbl09T2JqZWN0LmNyZWF0ZShudWxsKSk7dmFyIGk9bFtuXTt2b2lkIDA9PT1pW3RdJiYoaVt0XT1bXSl9fSkpO3ZhciBkPURhdGUubm93KCk7cmV0dXJuIGkucGVuZGluZy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lLnByb3ZpZGVyLHQ9ZS5wcmVmaXgsbz1lLm5hbWUsaT1yW25dW3RdO3ZvaWQgMD09PWlbb10mJihpW29dPWQsbFtuXVt0XS5wdXNoKG8pKX0pKSxzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWUucHJvdmlkZXIsdD1lLnByZWZpeDtsW25dW3RdLmxlbmd0aCYmdihuLHQsbFtuXVt0XSl9KSksbj95LnN0b3JlQ2FsbGJhY2sobixpLHMpOnR9fX0pKSxQPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5BUElJbnRlcm5hbEZ1bmN0aW9ucz1uLkFQSUZ1bmN0aW9ucz12b2lkIDAsbi5BUElGdW5jdGlvbnM9e2xvYWRJY29uczpPLkFQSS5sb2FkSWNvbnMsYWRkQVBJUHJvdmlkZXI6ai5zZXRBUElDb25maWd9LG4uQVBJSW50ZXJuYWxGdW5jdGlvbnM9e2dldEFQSTpPLmdldFJlZHVuZGFuY3lDYWNoZSxnZXRBUElDb25maWc6ai5nZXRBUElDb25maWcsc2V0QVBJTW9kdWxlOkkuc2V0QVBJTW9kdWxlfX0pKSx3PWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5nZXRBUElNb2R1bGU9dm9pZCAwO3ZhciB0PW51bGwscj1cIntwcmVmaXh9LmpzP2ljb25zPXtpY29uc30mY2FsbGJhY2s9e2NhbGxiYWNrfVwiLG89T2JqZWN0LmNyZWF0ZShudWxsKSxpPU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gYSgpe2lmKG51bGw9PT10KXt2YXIgZT1zZWxmLG49XCJJY29uaWZ5XCIsbz1cIi5jYlwiO2lmKHZvaWQgMD09PWVbbl0pbz1cIlwiLHZvaWQgMD09PWVbbj1cIkljb25pZnlKU09OUFwiXSYmKGVbbl09T2JqZWN0LmNyZWF0ZShudWxsKSksdD1lW25dO2Vsc2V7dmFyIGk9ZVtuXTt2b2lkIDA9PT1pLmNiJiYoaS5jYj1PYmplY3QuY3JlYXRlKG51bGwpKSx0PWkuY2J9cj1yLnJlcGxhY2UoXCJ7Y2FsbGJhY2t9XCIsbitvK1wiLntjYn1cIil9cmV0dXJuIHR9bi5nZXRBUElNb2R1bGU9ZnVuY3Rpb24oZSl7cmV0dXJue3ByZXBhcmU6ZnVuY3Rpb24obix0LGMpe3ZhciB1PVtdLGY9b1tuK1wiOlwiK3RdO3ZvaWQgMD09PWYmJihmPWZ1bmN0aW9uKG4sdCl7dmFyIGMsdT1lKG4pO2lmKCF1KXJldHVybiAwO2lmKHUubWF4VVJMKXt2YXIgZj0wO3UucmVzb3VyY2VzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWU7Zj1NYXRoLm1heChmLG4ubGVuZ3RoKX0pKSxhKCksYz11Lm1heFVSTC1mLXUucGF0aC5sZW5ndGgtci5yZXBsYWNlKFwie3Byb3ZpZGVyfVwiLG4pLnJlcGxhY2UoXCJ7cHJlZml4fVwiLHQpLnJlcGxhY2UoXCJ7aWNvbnN9XCIsXCJcIikubGVuZ3RoLTN9ZWxzZSBjPTA7dmFyIGw9bitcIjpcIit0O3JldHVybiBpW2xdPXUucGF0aCxvW2xdPWMsY30obix0KSk7dmFyIGw9e3Byb3ZpZGVyOm4scHJlZml4OnQsaWNvbnM6W119LHM9MDtyZXR1cm4gYy5mb3JFYWNoKChmdW5jdGlvbihlLHIpeyhzKz1lLmxlbmd0aCsxKT49ZiYmcj4wJiYodS5wdXNoKGwpLGw9e3Byb3ZpZGVyOm4scHJlZml4OnQsaWNvbnM6W119LHM9ZS5sZW5ndGgpLGwuaWNvbnMucHVzaChlKX0pKSx1LnB1c2gobCksdX0sc2VuZDpmdW5jdGlvbihlLG4sdCl7Zm9yKHZhciBvPW4ucHJvdmlkZXIsYz1uLnByZWZpeCx1PW4uaWNvbnMuam9pbihcIixcIiksZj1vK1wiOlwiK2MsbD1jLnNwbGl0KFwiLVwiKS5zaGlmdCgpLnNsaWNlKDAsMykscz1hKCksZD1mdW5jdGlvbihlKXt2YXIgbix0PTA7Zm9yKG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0Kz1lLmNoYXJDb2RlQXQobik7cmV0dXJuIHQlOTk5fShvK1wiOlwiK2UrXCI6XCIrYytcIjpcIit1KTt2b2lkIDAhPT1zW2wrZF07KWQrKzt2YXIgdj1sK2QscD1pW2ZdK3IucmVwbGFjZShcIntwcm92aWRlcn1cIixvKS5yZXBsYWNlKFwie3ByZWZpeH1cIixjKS5yZXBsYWNlKFwie2ljb25zfVwiLHUpLnJlcGxhY2UoXCJ7Y2J9XCIsdik7c1t2XT1mdW5jdGlvbihlKXtkZWxldGUgc1t2XSx0LmRvbmUoZSl9O3ZhciBoPWUrcCxnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7Zy50eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIsZy5hc3luYz0hMCxnLnNyYz1oLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZyl9fX19KSksTT1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uZ2V0QVBJTW9kdWxlPW4uc2V0RmV0Y2g9dm9pZCAwO3ZhciB0PVwie3ByZWZpeH0uanNvbj9pY29ucz17aWNvbnN9XCIscj1PYmplY3QuY3JlYXRlKG51bGwpLG89T2JqZWN0LmNyZWF0ZShudWxsKSxpPW51bGw7dHJ5e2k9ZmV0Y2h9Y2F0Y2goZSl7fW4uc2V0RmV0Y2g9ZnVuY3Rpb24oZSl7aT1lfTtuLmdldEFQSU1vZHVsZT1mdW5jdGlvbihlKXtyZXR1cm57cHJlcGFyZTpmdW5jdGlvbihuLGksYSl7dmFyIGM9W10sdT1yW2ldO3ZvaWQgMD09PXUmJih1PWZ1bmN0aW9uKG4saSl7dmFyIGEsYz1lKG4pO2lmKCFjKXJldHVybiAwO2lmKGMubWF4VVJMKXt2YXIgdT0wO2MucmVzb3VyY2VzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWU7dT1NYXRoLm1heCh1LG4ubGVuZ3RoKX0pKSxhPWMubWF4VVJMLXUtYy5wYXRoLmxlbmd0aC10LnJlcGxhY2UoXCJ7cHJvdmlkZXJ9XCIsbikucmVwbGFjZShcIntwcmVmaXh9XCIsaSkucmVwbGFjZShcIntpY29uc31cIixcIlwiKS5sZW5ndGh9ZWxzZSBhPTA7dmFyIGY9bitcIjpcIitpO3JldHVybiBvW2ZdPWMucGF0aCxyW2ZdPWEsYX0obixpKSk7dmFyIGY9e3Byb3ZpZGVyOm4scHJlZml4OmksaWNvbnM6W119LGw9MDtyZXR1cm4gYS5mb3JFYWNoKChmdW5jdGlvbihlLHQpeyhsKz1lLmxlbmd0aCsxKT49dSYmdD4wJiYoYy5wdXNoKGYpLGY9e3Byb3ZpZGVyOm4scHJlZml4OmksaWNvbnM6W119LGw9ZS5sZW5ndGgpLGYuaWNvbnMucHVzaChlKX0pKSxjLnB1c2goZiksY30sc2VuZDpmdW5jdGlvbihlLG4scil7dmFyIGE9bi5wcm92aWRlcixjPW4ucHJlZml4LHU9bi5pY29ucy5qb2luKFwiLFwiKSxmPW9bYStcIjpcIitjXSt0LnJlcGxhY2UoXCJ7cHJvdmlkZXJ9XCIsYSkucmVwbGFjZShcIntwcmVmaXh9XCIsYykucmVwbGFjZShcIntpY29uc31cIix1KTtpP2koZStmKS50aGVuKChmdW5jdGlvbihlKXtpZigyMDA9PT1lLnN0YXR1cylyZXR1cm4gZS5qc29uKCk7ci5kb25lKHZvaWQgMCxlLnN0YXR1cyl9KSkudGhlbigoZnVuY3Rpb24oZSl7XCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZyLmRvbmUoZSl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe3IuZG9uZSh2b2lkIDAsZS5lcnJubyl9KSk6ci5kb25lKHZvaWQgMCw0MjQpfX19fSkpLEE9XCJpY29uaWZ5RmluZGVyXCIrRGF0ZS5ub3coKSxTPVwiaWNvbmlmeURhdGFcIitEYXRlLm5vdygpO2Z1bmN0aW9uIF8oZSxuLHQscil7dmFyIG87dHJ5e289ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIil9Y2F0Y2goZSl7cmV0dXJuIHI/XCJcIjpudWxsfXZhciBpPWwuaWNvblRvU1ZHKHQsZi5tZXJnZUN1c3RvbWlzYXRpb25zKGYuZGVmYXVsdHMsbikpLGE9ZS5lbGVtZW50LHU9ZS5maW5kZXIscz1lLm5hbWUsZD1hP2EuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik6XCJcIix2PXU/dS5jbGFzc0ZpbHRlcihkP2Quc3BsaXQoL1xccysvKTpbXSk6W10scD0nPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgcm9sZT1cImltZ1wiIGNsYXNzPVwiJysoXCJpY29uaWZ5IGljb25pZnktLVwiK3MucHJlZml4KyhcIlwiPT09cy5wcm92aWRlcj9cIlwiOlwiIGljb25pZnktLVwiK3MucHJvdmlkZXIpKyh2Lmxlbmd0aD9cIiBcIit2LmpvaW4oXCIgXCIpOlwiXCIpKSsnXCI+JytjLnJlcGxhY2VJRHMoaS5ib2R5KStcIjwvc3ZnPlwiO28uaW5uZXJIVE1MPXA7dmFyIGg9by5jaGlsZE5vZGVzWzBdLGc9aC5zdHlsZSxtPWkuYXR0cmlidXRlcztpZihPYmplY3Qua2V5cyhtKS5mb3JFYWNoKChmdW5jdGlvbihlKXtoLnNldEF0dHJpYnV0ZShlLG1bZV0pfSkpLGkuaW5saW5lJiYoZy52ZXJ0aWNhbEFsaWduPVwiLTAuMTI1ZW1cIiksYSl7Zm9yKHZhciBiPWEuYXR0cmlidXRlcyx5PTA7eTxiLmxlbmd0aDt5Kyspe3ZhciBJPWIuaXRlbSh5KTtpZihJKXt2YXIgaj1JLm5hbWU7aWYoXCJjbGFzc1wiIT09aiYmXCJzdHlsZVwiIT09aiYmdm9pZCAwPT09bVtqXSl0cnl7aC5zZXRBdHRyaWJ1dGUoaixJLnZhbHVlKX1jYXRjaChlKXt9fX1mb3IodmFyIHg9YS5zdHlsZSxPPTA7Tzx4Lmxlbmd0aDtPKyspe3ZhciBQPXhbT107Z1tQXT14W1BdfX1pZih1KXt2YXIgdz17bmFtZTpzLHN0YXR1czpcImxvYWRlZFwiLGN1c3RvbWlzYXRpb25zOm59O2hbU109dyxoW0FdPXV9dmFyIE09cj9vLmlubmVySFRNTDpoO3JldHVybiBhJiZhLnBhcmVudE5vZGU/YS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChoLGEpOm8ucmVtb3ZlQ2hpbGQoaCksTX12YXIgRT1bXTtmdW5jdGlvbiBrKGUpe2Zvcih2YXIgbj0wO248RS5sZW5ndGg7bisrKXt2YXIgdD1FW25dO2lmKChcImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lm5vZGU/dC5ub2RlKCk6dC5ub2RlKT09PWUpcmV0dXJuIHR9fWZ1bmN0aW9uIEMoZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHQ9ayhlKTtyZXR1cm4gdD8odC50ZW1wb3JhcnkmJih0LnRlbXBvcmFyeT1uKSx0KToodD17bm9kZTplLHRlbXBvcmFyeTpufSxFLnB1c2godCksdCl9ZnVuY3Rpb24gRigpe3JldHVybiBFfXZhciBUPW51bGwsRD17Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITAsYXR0cmlidXRlczohMH07ZnVuY3Rpb24gTihlKXtpZihlLm9ic2VydmVyKXt2YXIgbj1lLm9ic2VydmVyO24ucGVuZGluZ1NjYW58fChuLnBlbmRpbmdTY2FuPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZGVsZXRlIG4ucGVuZGluZ1NjYW4sVCYmVChlKX0pKSl9fWZ1bmN0aW9uIEwoZSxuKXtpZihlLm9ic2VydmVyKXt2YXIgdD1lLm9ic2VydmVyO2lmKCF0LnBlbmRpbmdTY2FuKWZvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbz1uW3JdO2lmKG8uYWRkZWROb2RlcyYmby5hZGRlZE5vZGVzLmxlbmd0aD4wfHxcImF0dHJpYnV0ZXNcIj09PW8udHlwZSYmdm9pZCAwIT09by50YXJnZXRbQV0pcmV0dXJuIHZvaWQodC5wYXVzZWR8fE4oZSkpfX19ZnVuY3Rpb24geihlLG4pe2Uub2JzZXJ2ZXIuaW5zdGFuY2Uub2JzZXJ2ZShuLEQpfWZ1bmN0aW9uIFIoZSl7dmFyIG49ZS5vYnNlcnZlcjtpZighbnx8IW4uaW5zdGFuY2Upe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIGUubm9kZT9lLm5vZGUoKTplLm5vZGU7dCYmKG58fChuPXtwYXVzZWQ6MH0sZS5vYnNlcnZlcj1uKSxuLmluc3RhbmNlPW5ldyBNdXRhdGlvbk9ic2VydmVyKEwuYmluZChudWxsLGUpKSx6KGUsdCksbi5wYXVzZWR8fE4oZSkpfX1mdW5jdGlvbiBxKCl7RigpLmZvckVhY2goUil9ZnVuY3Rpb24gVShlKXtpZihlLm9ic2VydmVyKXt2YXIgbj1lLm9ic2VydmVyO24ucGVuZGluZ1NjYW4mJihjbGVhclRpbWVvdXQobi5wZW5kaW5nU2NhbiksZGVsZXRlIG4ucGVuZGluZ1NjYW4pLG4uaW5zdGFuY2UmJihuLmluc3RhbmNlLmRpc2Nvbm5lY3QoKSxkZWxldGUgbi5pbnN0YW5jZSl9fWZ1bmN0aW9uIFYoZSl7dmFyIG49bnVsbCE9PVQ7VCE9PWUmJihUPWUsbiYmRigpLmZvckVhY2goVSkpLG4/cSgpOmZ1bmN0aW9uKGUpe3ZhciBuPWRvY3VtZW50O1wiY29tcGxldGVcIj09PW4ucmVhZHlTdGF0ZXx8XCJsb2FkaW5nXCIhPT1uLnJlYWR5U3RhdGUmJiFuLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbD9lKCk6KG4uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixlKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixlKSl9KHEpfWZ1bmN0aW9uIEcoZSl7KGU/W2VdOkYoKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aWYoZS5vYnNlcnZlcil7dmFyIG49ZS5vYnNlcnZlcjtpZihuLnBhdXNlZCsrLCEobi5wYXVzZWQ+MSkmJm4uaW5zdGFuY2Upbi5pbnN0YW5jZS5kaXNjb25uZWN0KCl9ZWxzZSBlLm9ic2VydmVyPXtwYXVzZWQ6MX19KSl9ZnVuY3Rpb24gJChlKXsoZT9bZV06RigpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtpZihlLm9ic2VydmVyKXt2YXIgbj1lLm9ic2VydmVyO2lmKG4ucGF1c2VkJiYobi5wYXVzZWQtLSwhbi5wYXVzZWQpKXt2YXIgdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLm5vZGU/ZS5ub2RlKCk6ZS5ub2RlO2lmKCF0KXJldHVybjtuLmluc3RhbmNlP3ooZSx0KTpSKGUpfX1lbHNlIFIoZSl9KSl9ZnVuY3Rpb24gQihlLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgdD1DKGUsbik7cmV0dXJuIFIodCksdH1mdW5jdGlvbiBRKGUpe3ZhciBuPWsoZSk7biYmKFUobiksZnVuY3Rpb24oZSl7RT1FLmZpbHRlcigoZnVuY3Rpb24obil7dmFyIHQ9XCJmdW5jdGlvblwiPT10eXBlb2Ygbi5ub2RlP24ubm9kZSgpOm4ubm9kZTtyZXR1cm4gZSE9PXR9KSl9KGUpKX12YXIgSD1bXTtmdW5jdGlvbiBKKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1vLnN0cmluZ1RvSWNvbihlKSksbnVsbCE9PWUmJm8udmFsaWRhdGVJY29uKGUpP2U6bnVsbH1mdW5jdGlvbiBZKGUpe3ZhciBuPVtdO0guZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9dC5maW5kKGUpO0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwociwoZnVuY3Rpb24oZSl7dmFyIHI9ZTtpZih2b2lkIDA9PT1yW0FdfHxyW0FdPT09dCl7dmFyIG89Sih0Lm5hbWUocikpO2lmKG51bGwhPT1vKXtyW0FdPXQ7dmFyIGk9e2VsZW1lbnQ6cixmaW5kZXI6dCxuYW1lOm99O24ucHVzaChpKX19fSkpfSkpO3ZhciB0PWUucXVlcnlTZWxlY3RvckFsbChcInN2Zy5pY29uaWZ5XCIpO3JldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHQsKGZ1bmN0aW9uKGUpe3ZhciB0PWUscj10W0FdLG89dFtTXTtpZihyJiZvKXt2YXIgaT1KKHIubmFtZSh0KSk7aWYobnVsbCE9PWkpe3ZhciBhLGM9ITE7aWYoaS5wcmVmaXghPT1vLm5hbWUucHJlZml4fHxpLm5hbWUhPT1vLm5hbWUubmFtZT9jPSEwOihhPXIuY3VzdG9taXNhdGlvbnModCksZnVuY3Rpb24oZSxuKXt2YXIgdD1PYmplY3Qua2V5cyhlKSxyPU9iamVjdC5rZXlzKG4pO2lmKHQubGVuZ3RoIT09ci5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciBpPXRbb107aWYobltpXSE9PWVbaV0pcmV0dXJuITF9cmV0dXJuITB9KG8uY3VzdG9taXNhdGlvbnMsYSl8fChjPSEwKSksYyl7dmFyIHU9e2VsZW1lbnQ6dCxmaW5kZXI6cixuYW1lOmksY3VzdG9taXNhdGlvbnM6YX07bi5wdXNoKHUpfX19fSkpLG59dmFyIFo9ITE7ZnVuY3Rpb24gSygpe1p8fChaPSEwLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7WiYmKFo9ITEsVygpKX0pKSl9ZnVuY3Rpb24gVyhlLG4pe3ZvaWQgMD09PW4mJihuPSExKSxaPSExO3ZhciB0PU9iamVjdC5jcmVhdGUobnVsbCk7aWYoKGU/W2VdOkYoKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHI9XCJmdW5jdGlvblwiPT10eXBlb2YgZS5ub2RlP2Uubm9kZSgpOmUubm9kZTtpZihyJiZyLnF1ZXJ5U2VsZWN0b3JBbGwpe3ZhciBvPSExLGE9ITE7WShyKS5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgcixjLHU9bi5lbGVtZW50LGY9bi5uYW1lLGw9Zi5wcm92aWRlcixzPWYucHJlZml4LHY9Zi5uYW1lLHA9dVtTXTtpZih2b2lkIDAhPT1wJiYocj1wLm5hbWUsYz1mLG51bGwhPT1yJiZudWxsIT09YyYmci5uYW1lPT09Yy5uYW1lJiZyLnByZWZpeD09PWMucHJlZml4KSlzd2l0Y2gocC5zdGF0dXMpe2Nhc2VcIm1pc3NpbmdcIjpyZXR1cm47Y2FzZVwibG9hZGluZ1wiOmlmKGQuY29yZU1vZHVsZXMuYXBpJiZkLmNvcmVNb2R1bGVzLmFwaS5pc1BlbmRpbmcoe3Byb3ZpZGVyOmwscHJlZml4OnMsbmFtZTp2fSkpcmV0dXJuIHZvaWQobz0hMCl9dmFyIGg9aS5nZXRTdG9yYWdlKGwscyk7aWYodm9pZCAwPT09aC5pY29uc1t2XSl7aWYoaC5taXNzaW5nW3ZdKXJldHVybiBwPXtuYW1lOmYsc3RhdHVzOlwibWlzc2luZ1wiLGN1c3RvbWlzYXRpb25zOnt9fSx2b2lkKHVbU109cCk7aWYoZC5jb3JlTW9kdWxlcy5hcGkmJiFkLmNvcmVNb2R1bGVzLmFwaS5pc1BlbmRpbmcoe3Byb3ZpZGVyOmwscHJlZml4OnMsbmFtZTp2fSkpe3ZvaWQgMD09PXRbbF0mJih0W2xdPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciBnPXRbbF07dm9pZCAwPT09Z1tzXSYmKGdbc109T2JqZWN0LmNyZWF0ZShudWxsKSksZ1tzXVt2XT0hMH1wPXtuYW1lOmYsc3RhdHVzOlwibG9hZGluZ1wiLGN1c3RvbWlzYXRpb25zOnt9fSx1W1NdPXAsbz0hMH1lbHNleyFhJiZlLm9ic2VydmVyJiYoRyhlKSxhPSEwKTt2YXIgbT12b2lkIDAhPT1uLmN1c3RvbWlzYXRpb25zP24uY3VzdG9taXNhdGlvbnM6bi5maW5kZXIuY3VzdG9taXNhdGlvbnModSk7XyhuLG0saS5nZXRJY29uKGgsdikpfX0pKSxlLnRlbXBvcmFyeSYmIW8/UShyKTpuJiZvP0IociwhMCk6YSYmZS5vYnNlcnZlciYmJChlKX19KSksZC5jb3JlTW9kdWxlcy5hcGkpe3ZhciByPWQuY29yZU1vZHVsZXMuYXBpO09iamVjdC5rZXlzKHQpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPXRbZV07T2JqZWN0LmtleXMobikuZm9yRWFjaCgoZnVuY3Rpb24odCl7ci5sb2FkSWNvbnMoT2JqZWN0LmtleXMoblt0XSkubWFwKChmdW5jdGlvbihuKXtyZXR1cm57cHJvdmlkZXI6ZSxwcmVmaXg6dCxuYW1lOm59fSkpLEspfSkpfSkpfX12YXIgWD1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ucm90YXRlRnJvbVN0cmluZz12b2lkIDAsbi5yb3RhdGVGcm9tU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciBuPWUucmVwbGFjZSgvXi0/WzAtOS5dKi8sXCJcIik7ZnVuY3Rpb24gdChlKXtmb3IoO2U8MDspZSs9NDtyZXR1cm4gZSU0fWlmKFwiXCI9PT1uKXt2YXIgcj1wYXJzZUludChlKTtyZXR1cm4gaXNOYU4ocik/MDp0KHIpfWlmKG4hPT1lKXt2YXIgbz0wO3N3aXRjaChuKXtjYXNlXCIlXCI6bz0yNTticmVhaztjYXNlXCJkZWdcIjpvPTkwfWlmKG8pe3ZhciBpPXBhcnNlRmxvYXQoZS5zbGljZSgwLGUubGVuZ3RoLW4ubGVuZ3RoKSk7cmV0dXJuIGlzTmFOKGkpPzA6KGkvPW8pJTE9PTA/dChpKTowfX1yZXR1cm4gMH19KSksZWU9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmFsaWdubWVudEZyb21TdHJpbmc9bi5mbGlwRnJvbVN0cmluZz12b2lkIDA7dmFyIHQ9L1tcXHMsXSsvO24uZmxpcEZyb21TdHJpbmc9ZnVuY3Rpb24oZSxuKXtuLnNwbGl0KHQpLmZvckVhY2goKGZ1bmN0aW9uKG4pe3N3aXRjaChuLnRyaW0oKSl7Y2FzZVwiaG9yaXpvbnRhbFwiOmUuaEZsaXA9ITA7YnJlYWs7Y2FzZVwidmVydGljYWxcIjplLnZGbGlwPSEwfX0pKX0sbi5hbGlnbm1lbnRGcm9tU3RyaW5nPWZ1bmN0aW9uKGUsbil7bi5zcGxpdCh0KS5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgdD1uLnRyaW0oKTtzd2l0Y2godCl7Y2FzZVwibGVmdFwiOmNhc2VcImNlbnRlclwiOmNhc2VcInJpZ2h0XCI6ZS5oQWxpZ249dDticmVhaztjYXNlXCJ0b3BcIjpjYXNlXCJtaWRkbGVcIjpjYXNlXCJib3R0b21cIjplLnZBbGlnbj10O2JyZWFrO2Nhc2VcInNsaWNlXCI6Y2FzZVwiY3JvcFwiOmUuc2xpY2U9ITA7YnJlYWs7Y2FzZVwibWVldFwiOmUuc2xpY2U9ITF9fSkpfX0pKTtmdW5jdGlvbiBuZShlLG4pe3JldHVybiBlLmhhc0F0dHJpYnV0ZShuKX1mdW5jdGlvbiB0ZShlLG4pe3JldHVybiBlLmdldEF0dHJpYnV0ZShuKX12YXIgcmU9W1wiaW5saW5lXCIsXCJoRmxpcFwiLFwidkZsaXBcIl0sb2U9W1wid2lkdGhcIixcImhlaWdodFwiXSxpZT1cImljb25pZnktaW5saW5lXCIsYWU9e2ZpbmQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucXVlcnlTZWxlY3RvckFsbChcImkuaWNvbmlmeSwgc3Bhbi5pY29uaWZ5LCBpLmljb25pZnktaW5saW5lLCBzcGFuLmljb25pZnktaW5saW5lXCIpfSxuYW1lOmZ1bmN0aW9uKGUpe3JldHVybiBuZShlLFwiZGF0YS1pY29uXCIpP3RlKGUsXCJkYXRhLWljb25cIik6bnVsbH0sY3VzdG9taXNhdGlvbnM6ZnVuY3Rpb24oZSxuKXt2b2lkIDA9PT1uJiYobj17aW5saW5lOiExfSk7dmFyIHQ9bixyPWUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7aWYoLTEhPT0ocj9yLnNwbGl0KC9cXHMrLyk6W10pLmluZGV4T2YoaWUpJiYodC5pbmxpbmU9ITApLG5lKGUsXCJkYXRhLXJvdGF0ZVwiKSl7dmFyIG89WC5yb3RhdGVGcm9tU3RyaW5nKHRlKGUsXCJkYXRhLXJvdGF0ZVwiKSk7byYmKHQucm90YXRlPW8pfXJldHVybiBuZShlLFwiZGF0YS1mbGlwXCIpJiZlZS5mbGlwRnJvbVN0cmluZyh0LHRlKGUsXCJkYXRhLWZsaXBcIikpLG5lKGUsXCJkYXRhLWFsaWduXCIpJiZlZS5hbGlnbm1lbnRGcm9tU3RyaW5nKHQsdGUoZSxcImRhdGEtYWxpZ25cIikpLHJlLmZvckVhY2goKGZ1bmN0aW9uKG4pe2lmKG5lKGUsXCJkYXRhLVwiK24pKXt2YXIgcj1mdW5jdGlvbihlLG4pe3ZhciB0PWUuZ2V0QXR0cmlidXRlKG4pO3JldHVybiB0PT09bnx8XCJ0cnVlXCI9PT10fHxcIlwiIT09dCYmXCJmYWxzZVwiIT09dCYmbnVsbH0oZSxcImRhdGEtXCIrbik7XCJib29sZWFuXCI9PXR5cGVvZiByJiYodFtuXT1yKX19KSksb2UuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYobmUoZSxcImRhdGEtXCIrbikpe3ZhciByPXRlKGUsXCJkYXRhLVwiK24pO1wiXCIhPT1yJiYodFtuXT1yKX19KSksdH0sY2xhc3NGaWx0ZXI6ZnVuY3Rpb24oZSl7dmFyIG49W107cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7XCJpY29uaWZ5XCIhPT1lJiZcIlwiIT09ZSYmXCJpY29uaWZ5LS1cIiE9PWUuc2xpY2UoMCw5KSYmbi5wdXNoKGUpfSkpLG59fTtmdW5jdGlvbiBjZShlLG4sdCl7dmFyIHI9YS5nZXRJY29uRGF0YShlKTtyZXR1cm4gcj9fKHtuYW1lOm8uc3RyaW5nVG9JY29uKGUpfSxmLm1lcmdlQ3VzdG9taXNhdGlvbnMoZi5kZWZhdWx0cyxcIm9iamVjdFwiPT10eXBlb2Ygbj9uOnt9KSxyLHQpOm51bGx9dmFyIHVlPXtnZXRWZXJzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuXCIyLjAuNFwifSxyZW5kZXJTVkc6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gY2UoZSxuLCExKX0scmVuZGVySFRNTDpmdW5jdGlvbihlLG4pe3JldHVybiBjZShlLG4sITApfSxyZW5kZXJJY29uOmZ1bmN0aW9uKGUsbil7dmFyIHQ9YS5nZXRJY29uRGF0YShlKTtpZighdClyZXR1cm4gbnVsbDt2YXIgcj1mLm1lcmdlQ3VzdG9taXNhdGlvbnMoZi5kZWZhdWx0cyxcIm9iamVjdFwiPT10eXBlb2Ygbj9uOnt9KTtyZXR1cm4gbC5pY29uVG9TVkcodCxyKX0sc2NhbjpmdW5jdGlvbihlKXtlP2Z1bmN0aW9uKGUpe3ZhciBuPWsoZSk7bj9XKG4pOlcoe25vZGU6ZSx0ZW1wb3Jhcnk6ITB9LCEwKX0oZSk6VygpfSxvYnNlcnZlOmZ1bmN0aW9uKGUpe0IoZSl9LHN0b3BPYnNlcnZpbmc6ZnVuY3Rpb24oZSl7UShlKX0scGF1c2VPYnNlcnZlcjpmdW5jdGlvbihlKXtpZihlKXt2YXIgbj1rKGUpO24mJkcobil9ZWxzZSBHKCl9LHJlc3VtZU9ic2VydmVyOmZ1bmN0aW9uKGUpe2lmKGUpe3ZhciBuPWsoZSk7biYmJChuKX1lbHNlICQoKX19O2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl7IWZ1bmN0aW9uKCl7aWYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KXJldHVybiBDKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7RS5wdXNoKHtub2RlOmZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudH19KX0oKSxmdW5jdGlvbihlKXstMT09PUguaW5kZXhPZihlKSYmSC5wdXNoKGUpfShhZSk7dmFyIGZlPXdpbmRvdztpZih2b2lkIDAhPT1mZS5JY29uaWZ5UHJlbG9hZCl7dmFyIGxlPWZlLkljb25pZnlQcmVsb2FkLHNlPVwiSW52YWxpZCBJY29uaWZ5UHJlbG9hZCBzeW50YXguXCI7XCJvYmplY3RcIj09dHlwZW9mIGxlJiZudWxsIT09bGUmJihsZSBpbnN0YW5jZW9mIEFycmF5P2xlOltsZV0pLmZvckVhY2goKGZ1bmN0aW9uKGUpe3RyeXsoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lfHxlIGluc3RhbmNlb2YgQXJyYXl8fFwib2JqZWN0XCIhPXR5cGVvZiBlLmljb25zfHxcInN0cmluZ1wiIT10eXBlb2YgZS5wcmVmaXh8fCFhLnN0b3JhZ2VGdW5jdGlvbnMuYWRkQ29sbGVjdGlvbihlKSkmJmNvbnNvbGUuZXJyb3Ioc2UpfWNhdGNoKGUpe2NvbnNvbGUuZXJyb3Ioc2UpfX0pKX1zZXRUaW1lb3V0KChmdW5jdGlvbigpe1YoVyksVygpfSkpfXZhciBkZT17ZW5hYmxlQ2FjaGU6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gcC50b2dnbGVCcm93c2VyQ2FjaGUoZSwhMSE9PW4pfSxkaXNhYmxlQ2FjaGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHAudG9nZ2xlQnJvd3NlckNhY2hlKGUsITApfX0sdmU9e19hcGk6UC5BUElJbnRlcm5hbEZ1bmN0aW9uc307W2Euc3RvcmFnZUZ1bmN0aW9ucyxzLmJ1aWxkZXJGdW5jdGlvbnMsdWUsZGUsUC5BUElGdW5jdGlvbnNdLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Zvcih2YXIgbiBpbiBlKXZlW25dPWVbbl19KSksZC5jb3JlTW9kdWxlcy5hcGk9Ty5BUEk7dmFyIHBlPU0uZ2V0QVBJTW9kdWxlO3RyeXtcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJihwZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmXCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZT9NLmdldEFQSU1vZHVsZTp3LmdldEFQSU1vZHVsZSl9Y2F0Y2goc2Upe31pZihJLnNldEFQSU1vZHVsZShcIlwiLHBlKGouZ2V0QVBJQ29uZmlnKSksdmUuX2FwaS5zZXRGZXRjaD1mdW5jdGlvbihlKXtNLnNldEZldGNoKGUpLHBlIT09TS5nZXRBUElNb2R1bGUmJihwZT1NLmdldEFQSU1vZHVsZSxJLnNldEFQSU1vZHVsZShcIlwiLHBlKGouZ2V0QVBJQ29uZmlnKSkpfSxcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cpe2QuY29yZU1vZHVsZXMuY2FjaGU9di5zdG9yZUNhY2hlLHYubG9hZENhY2hlKCk7dmFyIGhlPXdpbmRvdztpZih2b2lkIDAhPT1oZS5JY29uaWZ5UHJvdmlkZXJzKXt2YXIgZ2U9aGUuSWNvbmlmeVByb3ZpZGVycztpZihcIm9iamVjdFwiPT10eXBlb2YgZ2UmJm51bGwhPT1nZSlmb3IodmFyIG1lIGluIGdlKXt2YXIgYmU9XCJJY29uaWZ5UHJvdmlkZXJzW1wiK21lK1wiXSBpcyBpbnZhbGlkLlwiO3RyeXt2YXIgeWU9Z2VbbWVdO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB5ZXx8IXllfHx2b2lkIDA9PT15ZS5yZXNvdXJjZXMpY29udGludWU7ai5zZXRBUElDb25maWcobWUseWUpfHxjb25zb2xlLmVycm9yKGJlKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGJlKX19fX1yZXR1cm4gdmV9KCk7dHJ5e3ZvaWQgMD09PXNlbGYuSWNvbmlmeSYmKHNlbGYuSWNvbmlmeT1JY29uaWZ5KX1jYXRjaChlKXt9aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMpdHJ5e2V4cG9ydHMuX19lc01vZHVsZT0hMCxleHBvcnRzLmRlZmF1bHQ9SWNvbmlmeX1jYXRjaChlKXt9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@iconify/iconify/dist/iconify.min.js\n");

/***/ }),

/***/ "./resources/js/Helper/File.js":
/*!*************************************!*\
  !*** ./resources/js/Helper/File.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar FileHelper = /*#__PURE__*/function () {\n  function FileHelper() {\n    _classCallCheck(this, FileHelper);\n  }\n\n  _createClass(FileHelper, null, [{\n    key: \"fileSizeH\",\n    value: function fileSizeH(size) {\n      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var base = 0;\n\n      if (size > 0) {\n        base = Math.log(size) / Math.log(1000);\n        size = Math.pow(1000, base - Math.floor(base)).toFixed(precision);\n      }\n\n      return [size, FileHelper.fileSizeSuffix[Math.floor(base)]].join(' ');\n    }\n  }]);\n\n  return FileHelper;\n}();\n\nObject.defineProperty(FileHelper, 'fileSizeSuffix', {\n  value: ['Bytes', 'KB', 'MB', 'GB', 'TB'],\n  writable: false,\n  configurable: false,\n  enumerable: false\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FileHelper);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvSGVscGVyL0ZpbGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztJQUFNQTs7Ozs7OztXQUVGLG1CQUFpQkMsSUFBakIsRUFBc0M7QUFBQSxVQUFmQyxTQUFlLHVFQUFILENBQUc7QUFFbEMsVUFBSUMsSUFBSSxHQUFHLENBQVg7O0FBQ0EsVUFBSUYsSUFBSSxHQUFHLENBQVgsRUFBYztBQUNWRSxRQUFBQSxJQUFJLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTSixJQUFULElBQWlCRyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxJQUFULENBQXhCO0FBQ0FKLFFBQUFBLElBQUksR0FBR0csSUFBSSxDQUFDRSxHQUFMLENBQVMsSUFBVCxFQUFlSCxJQUFJLEdBQUdDLElBQUksQ0FBQ0csS0FBTCxDQUFXSixJQUFYLENBQXRCLEVBQXdDSyxPQUF4QyxDQUFnRE4sU0FBaEQsQ0FBUDtBQUNIOztBQUNELGFBQU8sQ0FBQ0QsSUFBRCxFQUFPRCxVQUFVLENBQUNTLGNBQVgsQ0FBMEJMLElBQUksQ0FBQ0csS0FBTCxDQUFXSixJQUFYLENBQTFCLENBQVAsRUFBb0RPLElBQXBELENBQXlELEdBQXpELENBQVA7QUFDSDs7Ozs7O0FBR0xDLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQlosVUFBdEIsRUFBa0MsZ0JBQWxDLEVBQW9EO0FBQ2hEYSxFQUFBQSxLQUFLLEVBQUUsQ0FBQyxPQUFELEVBQVUsSUFBVixFQUFnQixJQUFoQixFQUFzQixJQUF0QixFQUE0QixJQUE1QixDQUR5QztBQUVoREMsRUFBQUEsUUFBUSxFQUFFLEtBRnNDO0FBR2hEQyxFQUFBQSxZQUFZLEVBQUUsS0FIa0M7QUFJaERDLEVBQUFBLFVBQVUsRUFBRTtBQUpvQyxDQUFwRDtBQU9BLGlFQUFlaEIsVUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9IZWxwZXIvRmlsZS5qcz9iMDFlIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEZpbGVIZWxwZXIge1xuXG4gICAgc3RhdGljIGZpbGVTaXplSChzaXplLCBwcmVjaXNpb24gPSAxKSB7XG5cbiAgICAgICAgbGV0IGJhc2UgPSAwO1xuICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGJhc2UgPSBNYXRoLmxvZyhzaXplKSAvIE1hdGgubG9nKDEwMDApO1xuICAgICAgICAgICAgc2l6ZSA9IE1hdGgucG93KDEwMDAsIGJhc2UgLSBNYXRoLmZsb29yKGJhc2UpKS50b0ZpeGVkKHByZWNpc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzaXplLCBGaWxlSGVscGVyLmZpbGVTaXplU3VmZml4W01hdGguZmxvb3IoYmFzZSldXS5qb2luKCcgJyk7XG4gICAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmlsZUhlbHBlciwgJ2ZpbGVTaXplU3VmZml4Jywge1xuICAgIHZhbHVlOiBbJ0J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJ10sXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2Vcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IEZpbGVIZWxwZXIiXSwibmFtZXMiOlsiRmlsZUhlbHBlciIsInNpemUiLCJwcmVjaXNpb24iLCJiYXNlIiwiTWF0aCIsImxvZyIsInBvdyIsImZsb29yIiwidG9GaXhlZCIsImZpbGVTaXplU3VmZml4Iiwiam9pbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/Helper/File.js\n");

/***/ }),

/***/ "./resources/js/Helper/String.js":
/*!***************************************!*\
  !*** ./resources/js/Helper/String.js ***!
  \***************************************/
/***/ (() => {

eval("String.prototype.wrapSquareBrackets = function () {\n  return \"[\".concat(this, \"]\");\n};\n\nString.prototype.wrapBrackets = function () {\n  return \"(\".concat(this, \")\");\n};\n\nString.prototype.wrap = function () {\n  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return \"\".concat(start).concat(this).concat(end);\n};\n\nString.prototype.ucfirst = function () {\n  return \"\".concat(this[0].toUpperCase()).concat(this.slice(1));\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvSGVscGVyL1N0cmluZy5qcz8wODdmIl0sIm5hbWVzIjpbIlN0cmluZyIsInByb3RvdHlwZSIsIndyYXBTcXVhcmVCcmFja2V0cyIsIndyYXBCcmFja2V0cyIsIndyYXAiLCJzdGFydCIsImVuZCIsInVjZmlyc3QiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIl0sIm1hcHBpbmdzIjoiQUFBQUEsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxrQkFBakIsR0FBc0MsWUFBVztBQUM3QyxvQkFBVyxJQUFYO0FBQ0gsQ0FGRDs7QUFJQUYsTUFBTSxDQUFDQyxTQUFQLENBQWlCRSxZQUFqQixHQUFnQyxZQUFXO0FBQ3ZDLG9CQUFXLElBQVg7QUFDSCxDQUZEOztBQUlBSCxNQUFNLENBQUNDLFNBQVAsQ0FBaUJHLElBQWpCLEdBQXdCLFlBQStCO0FBQUEsTUFBdEJDLEtBQXNCLHVFQUFkLEVBQWM7QUFBQSxNQUFWQyxHQUFVLHVFQUFKLEVBQUk7QUFDbkQsbUJBQVVELEtBQVYsU0FBa0IsSUFBbEIsU0FBeUJDLEdBQXpCO0FBQ0gsQ0FGRDs7QUFJQU4sTUFBTSxDQUFDQyxTQUFQLENBQWlCTSxPQUFqQixHQUEyQixZQUFXO0FBQ2xDLG1CQUFVLEtBQUssQ0FBTCxFQUFRQyxXQUFSLEVBQVYsU0FBa0MsS0FBS0MsS0FBTCxDQUFXLENBQVgsQ0FBbEM7QUFDSCxDQUZEIiwic291cmNlc0NvbnRlbnQiOlsiU3RyaW5nLnByb3RvdHlwZS53cmFwU3F1YXJlQnJhY2tldHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYFske3RoaXN9XWBcbn1cblxuU3RyaW5nLnByb3RvdHlwZS53cmFwQnJhY2tldHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYCgke3RoaXN9KWBcbn1cblxuU3RyaW5nLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RhcnQgPSAnJywgZW5kID0gJycpIHtcbiAgICByZXR1cm4gYCR7c3RhcnR9JHt0aGlzfSR7ZW5kfWBcbn1cblxuU3RyaW5nLnByb3RvdHlwZS51Y2ZpcnN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGAke3RoaXNbMF0udG9VcHBlckNhc2UoKX0ke3RoaXMuc2xpY2UoMSl9YFxufSJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvSGVscGVyL1N0cmluZy5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/Helper/String.js\n");

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bootstrap */ \"./resources/js/bootstrap.js\");\n/* harmony import */ var _Helper_String__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Helper/String */ \"./resources/js/Helper/String.js\");\n/* harmony import */ var _Helper_String__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Helper_String__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_partials__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/partials */ \"./resources/js/components/partials/index.js\");\n/* harmony import */ var _components_Transcoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/Transcoder */ \"./resources/js/components/Transcoder.js\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9hcHAuanM/NmQ0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vYm9vdHN0cmFwJ1xuXG5pbXBvcnQgJy4vSGVscGVyL1N0cmluZydcbmltcG9ydCAnQC9jb21wb25lbnRzL3BhcnRpYWxzJ1xuaW1wb3J0ICcuL2NvbXBvbmVudHMvVHJhbnNjb2RlciciXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var laravel_echo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! laravel-echo */ \"./node_modules/laravel-echo/dist/echo.js\");\n/**\n * Echo exposes an expressive API for subscribing to channels and listening\n * for events that are broadcast by Laravel. Echo and event broadcasting\n * allows your team to easily build robust real-time web applications.\n */\n\nwindow.Pusher = __webpack_require__(/*! pusher-js */ \"./node_modules/pusher-js/dist/web/pusher.js\");\nwindow.Echo = new laravel_echo__WEBPACK_IMPORTED_MODULE_0__.default({\n  broadcaster: \"pusher\",\n  key: LARAVEL_WEBSOCKETS_KEY,\n  wsHost: window.location.hostname,\n  wsPort: LARAVEL_WEBSOCKETS_PORT,\n  forceTLS: false,\n  disableStats: true\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNDO0FBRUFDLE1BQU0sQ0FBQ0MsTUFBUCxHQUFnQkMsbUJBQU8sQ0FBQyw4REFBRCxDQUF2QjtBQUVERixNQUFNLENBQUNELElBQVAsR0FBYyxJQUFJQSxpREFBSixDQUFTO0FBQ25CSSxFQUFBQSxXQUFXLEVBQUUsUUFETTtBQUVuQkMsRUFBQUEsR0FBRyxFQUFFQyxzQkFGYztBQUduQkMsRUFBQUEsTUFBTSxFQUFFTixNQUFNLENBQUNPLFFBQVAsQ0FBZ0JDLFFBSEw7QUFJbkJDLEVBQUFBLE1BQU0sRUFBRUMsdUJBSlc7QUFLbkJDLEVBQUFBLFFBQVEsRUFBRSxLQUxTO0FBTW5CQyxFQUFBQSxZQUFZLEVBQUU7QUFOSyxDQUFULENBQWQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzP2Y1NjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFY2hvIGV4cG9zZXMgYW4gZXhwcmVzc2l2ZSBBUEkgZm9yIHN1YnNjcmliaW5nIHRvIGNoYW5uZWxzIGFuZCBsaXN0ZW5pbmdcbiAqIGZvciBldmVudHMgdGhhdCBhcmUgYnJvYWRjYXN0IGJ5IExhcmF2ZWwuIEVjaG8gYW5kIGV2ZW50IGJyb2FkY2FzdGluZ1xuICogYWxsb3dzIHlvdXIgdGVhbSB0byBlYXNpbHkgYnVpbGQgcm9idXN0IHJlYWwtdGltZSB3ZWIgYXBwbGljYXRpb25zLlxuICovXG4gaW1wb3J0IEVjaG8gZnJvbSBcImxhcmF2ZWwtZWNob1wiXG5cbiB3aW5kb3cuUHVzaGVyID0gcmVxdWlyZSgncHVzaGVyLWpzJyk7XG5cbndpbmRvdy5FY2hvID0gbmV3IEVjaG8oe1xuICAgIGJyb2FkY2FzdGVyOiBcInB1c2hlclwiLFxuICAgIGtleTogTEFSQVZFTF9XRUJTT0NLRVRTX0tFWSxcbiAgICB3c0hvc3Q6IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSxcbiAgICB3c1BvcnQ6IExBUkFWRUxfV0VCU09DS0VUU19QT1JULFxuICAgIGZvcmNlVExTOiBmYWxzZSxcbiAgICBkaXNhYmxlU3RhdHM6IHRydWUsXG59KTtcbiJdLCJuYW1lcyI6WyJFY2hvIiwid2luZG93IiwiUHVzaGVyIiwicmVxdWlyZSIsImJyb2FkY2FzdGVyIiwia2V5IiwiTEFSQVZFTF9XRUJTT0NLRVRTX0tFWSIsIndzSG9zdCIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJ3c1BvcnQiLCJMQVJBVkVMX1dFQlNPQ0tFVFNfUE9SVCIsImZvcmNlVExTIiwiZGlzYWJsZVN0YXRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/bootstrap.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/CardCss.js":
/*!*********************************************************!*\
  !*** ./resources/js/components/Configurator/CardCss.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar CARD_CSS =\n/*css*/\n\"\\n<style>\\nmain {\\n    background-color: var(--clr-bg-100);\\n    border-radius: .75rem;\\n    padding: .75rem;\\n}\\nmain h2 {\\n    margin: 0;\\n    padding: 0;\\n    font-size: 1rem;\\n    user-select: none;\\n}\\nsection {\\n    background-color: var(--clr-bg-150);\\n    border-radius: .5rem;\\n    padding: .5rem;\\n    margin: .35rem 0;\\n    font-size: --var(--font-size-50);\\n    flex-grow: 1;\\n}\\nsection:last-child {\\n    margin-bottom: 0;\\n}\\nsection.toggle > div {\\n    display: none;\\n}\\nsection.toggle > div.visible {\\n    display: flex;\\n    align-items: center;\\n}\\nsection.toggle > div[data-toggle=\\\"true\\\"] {\\n    cursor: pointer;\\n}\\nsection.toggle > div:not([data-toggle=\\\"true\\\"]) {\\n    padding-left: 1rem;\\n}\\ndiv.stream {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n    gap: .5rem;\\n}\\n</style>\\n\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CARD_CSS);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvQ2FyZENzcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBTUEsUUFBUTtBQUFHO0FBQUgsZzFCQUFkO0FBOENBLGlFQUFlQSxRQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL0NhcmRDc3MuanM/OTFjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDQVJEX0NTUyA9IC8qY3NzKi9gXG48c3R5bGU+XG5tYWluIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jbHItYmctMTAwKTtcbiAgICBib3JkZXItcmFkaXVzOiAuNzVyZW07XG4gICAgcGFkZGluZzogLjc1cmVtO1xufVxubWFpbiBoMiB7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgZm9udC1zaXplOiAxcmVtO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xufVxuc2VjdGlvbiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY2xyLWJnLTE1MCk7XG4gICAgYm9yZGVyLXJhZGl1czogLjVyZW07XG4gICAgcGFkZGluZzogLjVyZW07XG4gICAgbWFyZ2luOiAuMzVyZW0gMDtcbiAgICBmb250LXNpemU6IC0tdmFyKC0tZm9udC1zaXplLTUwKTtcbiAgICBmbGV4LWdyb3c6IDE7XG59XG5zZWN0aW9uOmxhc3QtY2hpbGQge1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG59XG5zZWN0aW9uLnRvZ2dsZSA+IGRpdiB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbnNlY3Rpb24udG9nZ2xlID4gZGl2LnZpc2libGUge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbnNlY3Rpb24udG9nZ2xlID4gZGl2W2RhdGEtdG9nZ2xlPVwidHJ1ZVwiXSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuc2VjdGlvbi50b2dnbGUgPiBkaXY6bm90KFtkYXRhLXRvZ2dsZT1cInRydWVcIl0pIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDFyZW07XG59XG5kaXYuc3RyZWFtIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGdhcDogLjVyZW07XG59XG48L3N0eWxlPlxuYFxuXG5leHBvcnQgZGVmYXVsdCBDQVJEX0NTUyJdLCJuYW1lcyI6WyJDQVJEX0NTUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/CardCss.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Clips/Clip.js":
/*!************************************************************!*\
  !*** ./resources/js/components/Configurator/Clips/Clip.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\n/* harmony import */ var _CardCss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CardCss */ \"./resources/js/components/Configurator/CardCss.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar Clip = /*#__PURE__*/function (_Slim) {\n  _inherits(Clip, _Slim);\n\n  var _super = _createSuper(Clip);\n\n  function Clip() {\n    var _this;\n\n    _classCallCheck(this, Clip);\n\n    _this = _super.call(this);\n    _this.setTimecode = _this.setTimecode.bind(_assertThisInitialized(_this));\n    _this.handleKey = _this.handleKey.bind(_assertThisInitialized(_this));\n\n    _this.bindListener();\n\n    _this.valid = true;\n    return _this;\n  }\n\n  _createClass(Clip, [{\n    key: \"bindListener\",\n    value: function bindListener() {\n      this.handleAdd = this.handleAdd.bind(this);\n      this.handleRemove = this.handleRemove.bind(this);\n      this.handleFocus = this.handleFocus.bind(this);\n      this.handleBlur = this.handleBlur.bind(this);\n    }\n  }, {\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      requestAnimationFrame(function () {\n        Iconify.scan(_this2.shadowRoot);\n\n        _this2.shadowRoot.querySelectorAll('input').forEach(function (i) {\n          i.setCustomValidity(\"Timecode invalid: 00:00:00.000\");\n          requestAnimationFrame(function () {\n            return i.setCustomValidity(\"\");\n          });\n        });\n      });\n    }\n  }, {\n    key: \"setTimecode\",\n    value: function setTimecode(e) {\n      var input = e.currentTarget;\n      this.clipData[input.name] = input.value;\n      input.reportValidity();\n\n      if (input.validity.patternMismatch) {\n        input.setCustomValidity(\"Timecode invalid: HH:MM:SS.mss\");\n      } else {\n        input.setCustomValidity(\"\");\n      }\n\n      this.valid = this.shadowRoot.querySelectorAll('input:valid').length === 2;\n      this.dispatchEvent(new CustomEvent('updateclip', {\n        detail: this.clipData\n      }));\n    }\n  }, {\n    key: \"handleAdd\",\n    value: function handleAdd() {\n      this.dispatchEvent(new CustomEvent('clipinsert', {\n        detail: this.clipData\n      }));\n    }\n  }, {\n    key: \"handleRemove\",\n    value: function handleRemove() {\n      this.dispatchEvent(new CustomEvent('clipremove', {\n        detail: this.clipData\n      }));\n    }\n  }, {\n    key: \"handleFocus\",\n    value: function handleFocus() {\n      this.dispatchEvent(new CustomEvent('clipfocus', {\n        detail: this.clipData\n      }));\n    }\n  }, {\n    key: \"handleBlur\",\n    value: function handleBlur() {\n      this.dispatchEvent(new CustomEvent('clipblur', {\n        detail: this.clipData\n      }));\n    }\n  }, {\n    key: \"handleKey\",\n    value: function handleKey(e) {\n      var prevent = false;\n\n      switch (e.key) {\n        case 'Tab':\n          if (!e.shiftKey && this.isLast && e.currentTarget === this.inputTo) {\n            this.handleAdd();\n            prevent = true;\n          }\n\n          break;\n\n        case '-':\n          this.handleRemove();\n          prevent = true;\n          break;\n\n        case '+':\n          this.handleAdd();\n          prevent = true;\n          break;\n      }\n\n      prevent && e.preventDefault();\n    }\n  }, {\n    key: \"getCutpoint\",\n    value: function getCutpoint() {\n      if (this.cutpoint !== '') {\n        return \"(Cutpoint: \".concat(this.cutpoint, \")\");\n      }\n\n      return '';\n    }\n  }]);\n\n  return Clip;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nClip.prototype.pattern = '^([0-9]+:)?[0-9]+:[0-9]+:[0-9]+\\.[0-9]+$';\nClip.template =\n/*html*/\n\"\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_1__.ICON_STACK_CSS, \"\\n\").concat(_CardCss__WEBPACK_IMPORTED_MODULE_2__.default, \"\\n<style>\\nsection {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n    gap: .5rem;\\n}\\n.input {\\n    display: flex;\\n    flex-direction: column;\\n    gap: .5rem;\\n    flex-grow: 1;\\n}\\n.input > div {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n    gap: .5rem;\\n}\\n.input span {\\n    flex-grow: 1;\\n}\\n.cutpoint {\\n    font-size: max(10px, .75rem);\\n    padding-left: .5rem;\\n}\\ninput {\\n    border: 3px solid transparent;\\n    text-align: right;\\n    width: 12ch;\\n}\\ninput:invalid {\\n    border: 3px dashed hsla(var(--hue-alert), var(--sat-alert), var(--lit-alert), var(--clr-base-alpha));\\n}\\n.icon-stack {\\n    font-size: var(--font-size-200);\\n    height: 1em;\\n    cursor: pointer;\\n}\\n.minus:disabled {\\n    cursor: default;\\n}\\n</style>\\n<section>\\n    <div class=\\\"input\\\">\\n        <div>\\n            <span>From:</span>\\n            <input #ref=\\\"inputFrom\\\" @focus=\\\"{{ this.handleFocus }}\\\" @blur=\\\"{{ this.handleBlur }}\\\" placeholder=\\\"0:0:0.0\\\" @input=\\\"{{ this.setTimecode }}\\\" @keydown=\\\"{{ this.handleKey }}\\\" name=\\\"from\\\" pattern=\\\"{{ this.pattern }}\\\" .value=\\\"{{ this.clipData.from }}\\\">\\n        </div>\\n        <div>\\n            <span>To:<span class=\\\"cutpoint\\\">{{ this.cutpoint }}</span></span>\\n            <input #ref=\\\"inputTo\\\" @focus=\\\"{{ this.handleFocus }}\\\" @blur=\\\"{{ this.handleBlur }}\\\" placeholder=\\\"0:0:0.0\\\" @input=\\\"{{ this.setTimecode }}\\\" @keydown=\\\"{{ this.handleKey }}\\\" name=\\\"to\\\" pattern=\\\"{{ this.pattern }}\\\" .value=\\\"{{ this.clipData.to }}\\\">\\n        </div>\\n    </div>\\n    <div class=\\\"icon-stack plus\\\" @click=\\\"{{ this.handleAdd }}\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-plus-outline\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-plus-outline\\\"></span>\\n    </div>\\n    <button disabled=\\\"{{ !this.canRemove }}\\\" class=\\\"icon-stack minus\\\" @click=\\\"{{ this.handleRemove }}\\\" tabindex=\\\"-1\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-minus\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-minus\\\"></span>\\n    </button>\\n</section>\\n\");\ncustomElements.define('transcode-configurator-clip', Clip);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvQ2xpcHMvQ2xpcC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7SUFFTUk7Ozs7O0FBRUYsa0JBQWM7QUFBQTs7QUFBQTs7QUFDVjtBQUNBLFVBQUtDLFdBQUwsR0FBbUIsTUFBS0EsV0FBTCxDQUFpQkMsSUFBakIsK0JBQW5CO0FBQ0EsVUFBS0MsU0FBTCxHQUFpQixNQUFLQSxTQUFMLENBQWVELElBQWYsK0JBQWpCOztBQUNBLFVBQUtFLFlBQUw7O0FBQ0EsVUFBS0MsS0FBTCxHQUFhLElBQWI7QUFMVTtBQU1iOzs7O1dBRUQsd0JBQWU7QUFDWCxXQUFLQyxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsQ0FBZUosSUFBZixDQUFvQixJQUFwQixDQUFqQjtBQUNBLFdBQUtLLFlBQUwsR0FBb0IsS0FBS0EsWUFBTCxDQUFrQkwsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBcEI7QUFDQSxXQUFLTSxXQUFMLEdBQW1CLEtBQUtBLFdBQUwsQ0FBaUJOLElBQWpCLENBQXNCLElBQXRCLENBQW5CO0FBQ0EsV0FBS08sVUFBTCxHQUFrQixLQUFLQSxVQUFMLENBQWdCUCxJQUFoQixDQUFxQixJQUFyQixDQUFsQjtBQUNIOzs7V0FFRCxtQkFBVTtBQUFBOztBQUNOUSxNQUFBQSxxQkFBcUIsQ0FBQyxZQUFNO0FBQ3hCQyxRQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSxNQUFJLENBQUNDLFVBQWxCOztBQUNBLGNBQUksQ0FBQ0EsVUFBTCxDQUFnQkMsZ0JBQWhCLENBQWlDLE9BQWpDLEVBQTBDQyxPQUExQyxDQUFrRCxVQUFBQyxDQUFDLEVBQUk7QUFDbkRBLFVBQUFBLENBQUMsQ0FBQ0MsaUJBQUYsQ0FBb0IsZ0NBQXBCO0FBQ0FQLFVBQUFBLHFCQUFxQixDQUFDO0FBQUEsbUJBQU1NLENBQUMsQ0FBQ0MsaUJBQUYsQ0FBb0IsRUFBcEIsQ0FBTjtBQUFBLFdBQUQsQ0FBckI7QUFDSCxTQUhEO0FBSUgsT0FOb0IsQ0FBckI7QUFPSDs7O1dBRUQscUJBQVlDLENBQVosRUFBZTtBQUNYLFVBQUlDLEtBQUssR0FBR0QsQ0FBQyxDQUFDRSxhQUFkO0FBQ0EsV0FBS0MsUUFBTCxDQUFjRixLQUFLLENBQUNHLElBQXBCLElBQTRCSCxLQUFLLENBQUNJLEtBQWxDO0FBQ0FKLE1BQUFBLEtBQUssQ0FBQ0ssY0FBTjs7QUFDQSxVQUFJTCxLQUFLLENBQUNNLFFBQU4sQ0FBZUMsZUFBbkIsRUFBb0M7QUFDaENQLFFBQUFBLEtBQUssQ0FBQ0YsaUJBQU4sQ0FBd0IsZ0NBQXhCO0FBQ0gsT0FGRCxNQUVPO0FBQ0hFLFFBQUFBLEtBQUssQ0FBQ0YsaUJBQU4sQ0FBd0IsRUFBeEI7QUFDSDs7QUFDRCxXQUFLWixLQUFMLEdBQWEsS0FBS1EsVUFBTCxDQUFnQkMsZ0JBQWhCLENBQWlDLGFBQWpDLEVBQWdEYSxNQUFoRCxLQUEyRCxDQUF4RTtBQUNBLFdBQUtDLGFBQUwsQ0FBbUIsSUFBSUMsV0FBSixDQUFnQixZQUFoQixFQUE4QjtBQUFDQyxRQUFBQSxNQUFNLEVBQUUsS0FBS1Q7QUFBZCxPQUE5QixDQUFuQjtBQUNIOzs7V0FFRCxxQkFBWTtBQUNSLFdBQUtPLGFBQUwsQ0FBbUIsSUFBSUMsV0FBSixDQUFnQixZQUFoQixFQUE4QjtBQUFDQyxRQUFBQSxNQUFNLEVBQUUsS0FBS1Q7QUFBZCxPQUE5QixDQUFuQjtBQUNIOzs7V0FFRCx3QkFBZTtBQUNYLFdBQUtPLGFBQUwsQ0FBbUIsSUFBSUMsV0FBSixDQUFnQixZQUFoQixFQUE4QjtBQUFDQyxRQUFBQSxNQUFNLEVBQUUsS0FBS1Q7QUFBZCxPQUE5QixDQUFuQjtBQUNIOzs7V0FFRCx1QkFBYztBQUNWLFdBQUtPLGFBQUwsQ0FBbUIsSUFBSUMsV0FBSixDQUFnQixXQUFoQixFQUE2QjtBQUFDQyxRQUFBQSxNQUFNLEVBQUUsS0FBS1Q7QUFBZCxPQUE3QixDQUFuQjtBQUNIOzs7V0FFRCxzQkFBYTtBQUNULFdBQUtPLGFBQUwsQ0FBbUIsSUFBSUMsV0FBSixDQUFnQixVQUFoQixFQUE0QjtBQUFDQyxRQUFBQSxNQUFNLEVBQUUsS0FBS1Q7QUFBZCxPQUE1QixDQUFuQjtBQUNIOzs7V0FFRCxtQkFBVUgsQ0FBVixFQUFhO0FBQ1QsVUFBSWEsT0FBTyxHQUFHLEtBQWQ7O0FBQ0EsY0FBUWIsQ0FBQyxDQUFDYyxHQUFWO0FBQ0ksYUFBSyxLQUFMO0FBQ0ksY0FBSSxDQUFDZCxDQUFDLENBQUNlLFFBQUgsSUFBZSxLQUFLQyxNQUFwQixJQUE4QmhCLENBQUMsQ0FBQ0UsYUFBRixLQUFvQixLQUFLZSxPQUEzRCxFQUFvRTtBQUNoRSxpQkFBSzdCLFNBQUw7QUFDQXlCLFlBQUFBLE9BQU8sR0FBRyxJQUFWO0FBQ0g7O0FBQ0Q7O0FBQ0osYUFBSyxHQUFMO0FBQ0ksZUFBS3hCLFlBQUw7QUFDQXdCLFVBQUFBLE9BQU8sR0FBRyxJQUFWO0FBQ0E7O0FBQ0osYUFBSyxHQUFMO0FBQ0ksZUFBS3pCLFNBQUw7QUFDQXlCLFVBQUFBLE9BQU8sR0FBRyxJQUFWO0FBQ0E7QUFkUjs7QUFnQkFBLE1BQUFBLE9BQU8sSUFBSWIsQ0FBQyxDQUFDa0IsY0FBRixFQUFYO0FBQ0g7OztXQUVELHVCQUFjO0FBQ1YsVUFBSSxLQUFLQyxRQUFMLEtBQWtCLEVBQXRCLEVBQTBCO0FBQ3RCLG9DQUFxQixLQUFLQSxRQUExQjtBQUNIOztBQUNELGFBQU8sRUFBUDtBQUNIOzs7O0VBbEZjekM7O0FBcUZuQkksSUFBSSxDQUFDc0MsU0FBTCxDQUFlQyxPQUFmLEdBQXlCLDBDQUF6QjtBQUVBdkMsSUFBSSxDQUFDd0MsUUFBTDtBQUFnQjtBQUFoQixZQUNFMUMsdUVBREYsZUFFRUMsNkNBRkY7QUFvRUEwQyxjQUFjLENBQUNDLE1BQWYsQ0FBc0IsNkJBQXRCLEVBQXFEMUMsSUFBckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvQ2xpcHMvQ2xpcC5qcz8xYzQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaW0sIFV0aWxzIH0gZnJvbSAnQC9jb21wb25lbnRzL2xpYic7XG5pbXBvcnQgeyBJQ09OX1NUQUNLX0NTUyB9IGZyb20gJ0AvY29tcG9uZW50cy9JY29ucy9TdGFjay5jc3MnXG5pbXBvcnQgQ0FSRF9DU1MgZnJvbSAnLi4vQ2FyZENzcyc7XG5cbmNsYXNzIENsaXAgZXh0ZW5kcyBTbGltIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuc2V0VGltZWNvZGUgPSB0aGlzLnNldFRpbWVjb2RlLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5oYW5kbGVLZXkgPSB0aGlzLmhhbmRsZUtleS5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVyKClcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWVcbiAgICB9XG5cbiAgICBiaW5kTGlzdGVuZXIoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQWRkID0gdGhpcy5oYW5kbGVBZGQuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmhhbmRsZVJlbW92ZSA9IHRoaXMuaGFuZGxlUmVtb3ZlLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1cyA9IHRoaXMuaGFuZGxlRm9jdXMuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmhhbmRsZUJsdXIgPSB0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKVxuICAgIH1cblxuICAgIG9uQWRkZWQoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBJY29uaWZ5LnNjYW4odGhpcy5zaGFkb3dSb290KVxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JykuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgICAgICBpLnNldEN1c3RvbVZhbGlkaXR5KFwiVGltZWNvZGUgaW52YWxpZDogMDA6MDA6MDAuMDAwXCIpXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGkuc2V0Q3VzdG9tVmFsaWRpdHkoXCJcIikpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHNldFRpbWVjb2RlKGUpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gZS5jdXJyZW50VGFyZ2V0XG4gICAgICAgIHRoaXMuY2xpcERhdGFbaW5wdXQubmFtZV0gPSBpbnB1dC52YWx1ZVxuICAgICAgICBpbnB1dC5yZXBvcnRWYWxpZGl0eSgpXG4gICAgICAgIGlmIChpbnB1dC52YWxpZGl0eS5wYXR0ZXJuTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIGlucHV0LnNldEN1c3RvbVZhbGlkaXR5KFwiVGltZWNvZGUgaW52YWxpZDogSEg6TU06U1MubXNzXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dC5zZXRDdXN0b21WYWxpZGl0eShcIlwiKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWQgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6dmFsaWQnKS5sZW5ndGggPT09IDJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndXBkYXRlY2xpcCcsIHtkZXRhaWw6IHRoaXMuY2xpcERhdGF9KSlcbiAgICB9XG5cbiAgICBoYW5kbGVBZGQoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2NsaXBpbnNlcnQnLCB7ZGV0YWlsOiB0aGlzLmNsaXBEYXRhfSkpXG4gICAgfVxuXG4gICAgaGFuZGxlUmVtb3ZlKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjbGlwcmVtb3ZlJywge2RldGFpbDogdGhpcy5jbGlwRGF0YX0pKVxuICAgIH1cblxuICAgIGhhbmRsZUZvY3VzKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjbGlwZm9jdXMnLCB7ZGV0YWlsOiB0aGlzLmNsaXBEYXRhfSkpXG4gICAgfVxuXG4gICAgaGFuZGxlQmx1cigpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2xpcGJsdXInLCB7ZGV0YWlsOiB0aGlzLmNsaXBEYXRhfSkpXG4gICAgfVxuXG4gICAgaGFuZGxlS2V5KGUpIHtcbiAgICAgICAgbGV0IHByZXZlbnQgPSBmYWxzZVxuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdUYWInOlxuICAgICAgICAgICAgICAgIGlmICghZS5zaGlmdEtleSAmJiB0aGlzLmlzTGFzdCAmJiBlLmN1cnJlbnRUYXJnZXQgPT09IHRoaXMuaW5wdXRUbykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFkZCgpXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZW1vdmUoKVxuICAgICAgICAgICAgICAgIHByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFkZCgpXG4gICAgICAgICAgICAgICAgcHJldmVudCA9IHRydWVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2ZW50ICYmIGUucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIGdldEN1dHBvaW50KCkge1xuICAgICAgICBpZiAodGhpcy5jdXRwb2ludCAhPT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBgKEN1dHBvaW50OiAke3RoaXMuY3V0cG9pbnR9KWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICB9XG59XG5cbkNsaXAucHJvdG90eXBlLnBhdHRlcm4gPSAnXihbMC05XSs6KT9bMC05XSs6WzAtOV0rOlswLTldK1xcLlswLTldKyQnXG5cbkNsaXAudGVtcGxhdGUgPSAvKmh0bWwqLyBgXG4ke0lDT05fU1RBQ0tfQ1NTfVxuJHtDQVJEX0NTU31cbjxzdHlsZT5cbnNlY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgZ2FwOiAuNXJlbTtcbn1cbi5pbnB1dCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGdhcDogLjVyZW07XG4gICAgZmxleC1ncm93OiAxO1xufVxuLmlucHV0ID4gZGl2IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGdhcDogLjVyZW07XG59XG4uaW5wdXQgc3BhbiB7XG4gICAgZmxleC1ncm93OiAxO1xufVxuLmN1dHBvaW50IHtcbiAgICBmb250LXNpemU6IG1heCgxMHB4LCAuNzVyZW0pO1xuICAgIHBhZGRpbmctbGVmdDogLjVyZW07XG59XG5pbnB1dCB7XG4gICAgYm9yZGVyOiAzcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgd2lkdGg6IDEyY2g7XG59XG5pbnB1dDppbnZhbGlkIHtcbiAgICBib3JkZXI6IDNweCBkYXNoZWQgaHNsYSh2YXIoLS1odWUtYWxlcnQpLCB2YXIoLS1zYXQtYWxlcnQpLCB2YXIoLS1saXQtYWxlcnQpLCB2YXIoLS1jbHItYmFzZS1hbHBoYSkpO1xufVxuLmljb24tc3RhY2sge1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tZm9udC1zaXplLTIwMCk7XG4gICAgaGVpZ2h0OiAxZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuLm1pbnVzOmRpc2FibGVkIHtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG59XG48L3N0eWxlPlxuPHNlY3Rpb24+XG4gICAgPGRpdiBjbGFzcz1cImlucHV0XCI+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8c3Bhbj5Gcm9tOjwvc3Bhbj5cbiAgICAgICAgICAgIDxpbnB1dCAjcmVmPVwiaW5wdXRGcm9tXCIgQGZvY3VzPVwie3sgdGhpcy5oYW5kbGVGb2N1cyB9fVwiIEBibHVyPVwie3sgdGhpcy5oYW5kbGVCbHVyIH19XCIgcGxhY2Vob2xkZXI9XCIwOjA6MC4wXCIgQGlucHV0PVwie3sgdGhpcy5zZXRUaW1lY29kZSB9fVwiIEBrZXlkb3duPVwie3sgdGhpcy5oYW5kbGVLZXkgfX1cIiBuYW1lPVwiZnJvbVwiIHBhdHRlcm49XCJ7eyB0aGlzLnBhdHRlcm4gfX1cIiAudmFsdWU9XCJ7eyB0aGlzLmNsaXBEYXRhLmZyb20gfX1cIj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8c3Bhbj5Ubzo8c3BhbiBjbGFzcz1cImN1dHBvaW50XCI+e3sgdGhpcy5jdXRwb2ludCB9fTwvc3Bhbj48L3NwYW4+XG4gICAgICAgICAgICA8aW5wdXQgI3JlZj1cImlucHV0VG9cIiBAZm9jdXM9XCJ7eyB0aGlzLmhhbmRsZUZvY3VzIH19XCIgQGJsdXI9XCJ7eyB0aGlzLmhhbmRsZUJsdXIgfX1cIiBwbGFjZWhvbGRlcj1cIjA6MDowLjBcIiBAaW5wdXQ9XCJ7eyB0aGlzLnNldFRpbWVjb2RlIH19XCIgQGtleWRvd249XCJ7eyB0aGlzLmhhbmRsZUtleSB9fVwiIG5hbWU9XCJ0b1wiIHBhdHRlcm49XCJ7eyB0aGlzLnBhdHRlcm4gfX1cIiAudmFsdWU9XCJ7eyB0aGlzLmNsaXBEYXRhLnRvIH19XCI+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJpY29uLXN0YWNrIHBsdXNcIiBAY2xpY2s9XCJ7eyB0aGlzLmhhbmRsZUFkZCB9fVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktcGx1cy1vdXRsaW5lXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktcGx1cy1vdXRsaW5lXCI+PC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxidXR0b24gZGlzYWJsZWQ9XCJ7eyAhdGhpcy5jYW5SZW1vdmUgfX1cIiBjbGFzcz1cImljb24tc3RhY2sgbWludXNcIiBAY2xpY2s9XCJ7eyB0aGlzLmhhbmRsZVJlbW92ZSB9fVwiIHRhYmluZGV4PVwiLTFcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLW1pbnVzXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktbWludXNcIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG48L3NlY3Rpb24+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RyYW5zY29kZS1jb25maWd1cmF0b3ItY2xpcCcsIENsaXApO1xuIl0sIm5hbWVzIjpbIlNsaW0iLCJVdGlscyIsIklDT05fU1RBQ0tfQ1NTIiwiQ0FSRF9DU1MiLCJDbGlwIiwic2V0VGltZWNvZGUiLCJiaW5kIiwiaGFuZGxlS2V5IiwiYmluZExpc3RlbmVyIiwidmFsaWQiLCJoYW5kbGVBZGQiLCJoYW5kbGVSZW1vdmUiLCJoYW5kbGVGb2N1cyIsImhhbmRsZUJsdXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJJY29uaWZ5Iiwic2NhbiIsInNoYWRvd1Jvb3QiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImkiLCJzZXRDdXN0b21WYWxpZGl0eSIsImUiLCJpbnB1dCIsImN1cnJlbnRUYXJnZXQiLCJjbGlwRGF0YSIsIm5hbWUiLCJ2YWx1ZSIsInJlcG9ydFZhbGlkaXR5IiwidmFsaWRpdHkiLCJwYXR0ZXJuTWlzbWF0Y2giLCJsZW5ndGgiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJwcmV2ZW50Iiwia2V5Iiwic2hpZnRLZXkiLCJpc0xhc3QiLCJpbnB1dFRvIiwicHJldmVudERlZmF1bHQiLCJjdXRwb2ludCIsInByb3RvdHlwZSIsInBhdHRlcm4iLCJ0ZW1wbGF0ZSIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Clips/Clip.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Clips/index.js":
/*!*************************************************************!*\
  !*** ./resources/js/components/Configurator/Clips/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _CardCss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CardCss */ \"./resources/js/components/Configurator/CardCss.js\");\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\n/* harmony import */ var _Clip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Clip */ \"./resources/js/components/Configurator/Clips/Clip.js\");\n/* harmony import */ var html5sortable_dist_html5sortable_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! html5sortable/dist/html5sortable.es */ \"./node_modules/html5sortable/dist/html5sortable.es.js\");\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\nvar dataFactory = /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function dataFactory() {\n  var id;\n  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function dataFactory$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          id = 0;\n\n        case 1:\n          if (false) {}\n\n          _context.next = 4;\n          return {\n            from: null,\n            to: null,\n            id: id++\n          };\n\n        case 4:\n          _context.next = 1;\n          break;\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, dataFactory);\n});\n\nvar getClipInitData = function getClipInitData(factory) {\n  return factory.next().value;\n};\n\nvar WS_CHANNEL = \"Transcode.Clips\";\n\nvar _mode = /*#__PURE__*/new WeakMap();\n\nvar Clips = /*#__PURE__*/function (_Slim) {\n  _inherits(Clips, _Slim);\n\n  var _super = _createSuper(Clips);\n\n  function Clips() {\n    var _this;\n\n    _classCallCheck(this, Clips);\n\n    _this = _super.call(this);\n\n    _mode.set(_assertThisInitialized(_this), {\n      writable: true,\n      value: void 0\n    });\n\n    _this.clips = [_this.newClip()]; //this.clips = [this.newClip(), this.newClip(), this.newClip(), this.newClip()]\n\n    _this.valid = true;\n\n    _this.bindListener();\n\n    _this.mode = \"clips\";\n    return _this;\n  }\n\n  _createClass(Clips, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      this.initWebsocket();\n      requestAnimationFrame(function () {\n        (0,html5sortable_dist_html5sortable_es__WEBPACK_IMPORTED_MODULE_5__.default)(_this2.sortable);\n        _components_lib__WEBPACK_IMPORTED_MODULE_1__.Iconify.scan(_this2.shadowRoot);\n      });\n    }\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved() {\n      this.leaveWebsocket();\n    }\n  }, {\n    key: \"initWebsocket\",\n    value: function initWebsocket() {\n      this.channel = window.Echo.channel(WS_CHANNEL);\n      this.channel.listen(WS_CHANNEL, this.handleClipsEvent.bind(this));\n      this.channel.subscribed(this.requestClips.bind(this));\n    }\n  }, {\n    key: \"leaveWebsocket\",\n    value: function leaveWebsocket() {\n      this.channel.stopListening(WS_CHANNEL);\n      window.Echo.leave(WS_CHANNEL);\n      delete this.channel;\n    }\n  }, {\n    key: \"requestClips\",\n    value: function requestClips() {\n      try {\n        console.info(\"Request clips of %s\", this.path);\n        _components_Request__WEBPACK_IMPORTED_MODULE_6__.Request.get(\"/clips/\".concat(encodeURIComponent(this.path)));\n      } catch (error) {\n        console.error(error);\n        this.leaveWebsocket();\n      }\n    }\n  }, {\n    key: \"bindListener\",\n    value: function bindListener() {\n      this.handleUpdate = this.handleUpdate.bind(this);\n      this.handleAdd = this.handleAdd.bind(this);\n      this.handleRemove = this.handleRemove.bind(this);\n      this.handleSortupdate = this.handleSortupdate.bind(this);\n      this.handleFocus = this.handleFocus.bind(this);\n      this.handleBlur = this.handleBlur.bind(this);\n      this.handleCopy = this.handleCopy.bind(this);\n    }\n  }, {\n    key: \"newClip\",\n    value: function newClip() {\n      if (!this.dataFactory) {\n        this.dataFactory = dataFactory();\n      }\n\n      return getClipInitData(this.dataFactory);\n    }\n  }, {\n    key: \"handleClipsEvent\",\n    value: function handleClipsEvent(ws) {\n      var _this3 = this;\n\n      if (ws.clips.length) {\n        this.clips = [];\n        ws.clips.forEach(function (c) {\n          return _this3.addClip(c.from, c.to);\n        });\n        this.update();\n      }\n    }\n  }, {\n    key: \"addClip\",\n    value: function addClip(from, to) {\n      var clip = this.newClip();\n      clip.from = from;\n      clip.to = to;\n      this.clips.push(clip);\n    }\n  }, {\n    key: \"handleSortupdate\",\n    value: function handleSortupdate(e) {\n      this.clips.splice(e.detail.destination.index, 0, this.clips.splice(e.detail.origin.index, 1)[0]);\n      this.update();\n    }\n  }, {\n    key: \"handleAdd\",\n    value: function () {\n      var _handleAdd = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(e) {\n        var idx, clip;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                idx = this.clips.findIndex(function (c) {\n                  return c.id === e.detail.id;\n                });\n                clip = this.newClip();\n                this.clips.splice(idx + 1, 0, clip);\n                _context2.next = 5;\n                return this.update();\n\n              case 5:\n                this.sortable.querySelector(\"[data-clip=\\\"\".concat(clip.id, \"\\\"]\")).inputFrom.focus();\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handleAdd(_x) {\n        return _handleAdd.apply(this, arguments);\n      }\n\n      return handleAdd;\n    }()\n  }, {\n    key: \"handleRemove\",\n    value: function () {\n      var _handleRemove = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee2(e) {\n        var idx, focus;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee2$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.clips.length > 1)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                idx = this.clips.findIndex(function (c) {\n                  return c.id === e.detail.id;\n                });\n                focus = Math.max(0, idx - 1);\n                this.clips.splice(idx, 1);\n                _context3.next = 6;\n                return this.update();\n\n              case 6:\n                this.sortable.querySelector(\"[data-clip=\\\"\".concat(this.clips[focus].id, \"\\\"]\")).inputFrom.focus();\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function handleRemove(_x2) {\n        return _handleRemove.apply(this, arguments);\n      }\n\n      return handleRemove;\n    }()\n  }, {\n    key: \"handleUpdate\",\n    value: function handleUpdate(e) {\n      this.update();\n      this.valid = Array.from(this.shadowRoot.querySelectorAll(\"transcode-configurator-clip\")).every(function (c) {\n        return c.valid;\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this4 = this;\n\n      return new Promise(function (resolve) {\n        _components_lib__WEBPACK_IMPORTED_MODULE_1__.Utils.forceUpdate(_this4, \"clips\");\n        requestAnimationFrame(function () {\n          (0,html5sortable_dist_html5sortable_es__WEBPACK_IMPORTED_MODULE_5__.default)(_this4.sortable, \"reload\");\n\n          _this4.shadowRoot.querySelectorAll(\"transcode-configurator-clip\").forEach(function (c, i) {\n            return c.clipData = _this4.clips[i];\n          });\n\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: \"handleFocus\",\n    value: function handleFocus() {\n      (0,html5sortable_dist_html5sortable_es__WEBPACK_IMPORTED_MODULE_5__.default)(this.sortable, \"disable\");\n    }\n  }, {\n    key: \"handleBlur\",\n    value: function handleBlur() {\n      (0,html5sortable_dist_html5sortable_es__WEBPACK_IMPORTED_MODULE_5__.default)(this.sortable, \"enable\");\n    }\n  }, {\n    key: \"getCutpoint\",\n    value: function getCutpoint(clip) {\n      var _this5 = this;\n\n      if (this.clips.length > 1) {\n        var cutpoint = this.clips.filter(function (c) {\n          return c.id <= clip.id;\n        }).reverse().reduce(function (acc, cur) {\n          return acc + _this5.toSeconds(cur.to) - _this5.toSeconds(cur.from);\n        }, 0);\n\n        if (isNaN(cutpoint)) {\n          return \"\";\n        }\n\n        return this.fromSeconds(cutpoint);\n      }\n\n      return \"\";\n    }\n  }, {\n    key: \"toSeconds\",\n    value: function toSeconds(coord) {\n      var _coord$split = coord.split(\":\"),\n          _coord$split2 = _slicedToArray(_coord$split, 3),\n          hours = _coord$split2[0],\n          minutes = _coord$split2[1],\n          seconds = _coord$split2[2];\n\n      return parseFloat(hours) * 60 * 60 + parseFloat(minutes) * 60 + parseFloat(seconds);\n    }\n  }, {\n    key: \"fromSeconds\",\n    value: function fromSeconds(coord) {\n      var d = new Date(null);\n      d.setMilliseconds(coord * 1000);\n      return \"\".concat(d.getUTCHours().toString().padStart(2, \"0\"), \":\").concat(d.getUTCMinutes().toString().padStart(2, \"0\"), \":\").concat(d.getUTCSeconds().toString().padStart(2, \"0\"), \".\").concat(d.getUTCMilliseconds());\n    }\n  }, {\n    key: \"milliSeconds\",\n    value: function milliSeconds(coord) {\n      return this.toSeconds(coord) * 1000;\n    }\n  }, {\n    key: \"getTimestamps\",\n    value: function getTimestamps() {\n      var _this6 = this;\n\n      return this.clips.reduce(function (acc, cur) {\n        if (cur.from) {\n          acc.push(_this6.milliSeconds(cur.from));\n        }\n\n        if (cur.to) {\n          acc.push(_this6.milliSeconds(cur.to));\n        }\n\n        return acc;\n      }, []);\n    }\n  }, {\n    key: \"handleCopy\",\n    value: function handleCopy() {\n      var _this7 = this;\n\n      this.mode = this.mode === \"clips\" ? \"copy\" : \"clips\";\n\n      if (this.mode === \"copy\") {\n        this.copyarea.rows = Math.max(10, Math.min(20, this.clips.length * 2));\n        this.copyarea.value = this.getCopyClips();\n        this.copyarea.select();\n      } else {\n        var raw = this.copyarea.value.split(\"\\n\");\n        var clips = [];\n\n        for (var i = 0; i < raw.length; i += 2) {\n          if (raw[i]) {\n            var _raw;\n\n            var clip = {\n              from: raw[i],\n              to: (_raw = raw[i + 1]) !== null && _raw !== void 0 ? _raw : null\n            };\n            clips.push(clip);\n          }\n        }\n\n        if (clips.length === 0) {\n          clips.push({\n            from: null,\n            to: null\n          });\n        }\n\n        this.clips = [];\n        clips.forEach(function (c) {\n          return _this7.addClip(c.from, c.to);\n        });\n        this.update();\n      }\n    }\n  }, {\n    key: \"getCopyClips\",\n    value: function getCopyClips() {\n      return this.clips.reduce(function (acc, cur) {\n        if (cur.from) {\n          acc.push(cur.from);\n        }\n\n        if (cur.to) {\n          acc.push(cur.to);\n        }\n\n        return acc;\n      }, []).join(\"\\n\");\n    }\n  }]);\n\n  return Clips;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_1__.Slim);\n\nClips.template =\n/*html*/\n\"\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_3__.ICON_STACK_CSS, \"\\n\").concat(_CardCss__WEBPACK_IMPORTED_MODULE_2__.default, \"\\n<style>\\n    :host {\\n        user-select: none;\\n    }\\n    h2 {\\n        display: flex;\\n        justify-content: space-between;\\n    }\\n    div.copy, div.clips {\\n        display: none;\\n    }\\n    .copy div.copy {\\n        display: block;\\n    }\\n    .clips div.clips {\\n        display: flex;\\n        flex-direction: column;\\n        gap: .5rem;\\n    }\\n</style>\\n<main class=\\\"{{ this.mode }}\\\">\\n    <h2>\\n        Clips\\n        <div class=\\\"icon-stack\\\" @click=\\\"{{ this.handleCopy }}\\\">\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-content-copy\\\"></span>\\n            <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-content-copy\\\"></span>\\n        </div>\\n    </h2>\\n    <div class=\\\"copy\\\">\\n        <textarea #ref=\\\"copyarea\\\"></textarea>\\n    </div>\\n    <div class=\\\"clips\\\" #ref=\\\"sortable\\\" @sortupdate=\\\"{{ this.handleSortupdate }}\\\">\\n        <transcode-configurator-clip\\n            data-clip=\\\"{{ item.id }}\\\"\\n            *foreach=\\\"{{ this.clips }}\\\"\\n            .can-remove=\\\"{{ this.clips.length > 1 }}\\\"\\n            .is-last=\\\"{{ this.clips.indexOf(item) === this.clips.length - 1 }}\\\"\\n            @updateclip=\\\"{{ this.handleUpdate }}\\\"\\n            @clipinsert=\\\"{{ this.handleAdd }}\\\"\\n            @clipremove=\\\"{{ this.handleRemove }}\\\"\\n            @clipfocus=\\\"{{ this.handleFocus }}\\\"\\n            @clipblur=\\\"{{ this.handleBlur }}\\\"\\n            .clip-data=\\\"{{ item }}\\\"\\n            .cutpoint=\\\"{{ this.getCutpoint(item) }}\\\">\\n        </transcode-configurator-clip>\\n    </div>\\n</main>\\n\");\ncustomElements.define(\"transcode-configurator-clips\", Clips);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvQ2xpcHMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQU1PLFdBQVcsdUZBQUcsU0FBZEEsV0FBYztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDWkMsVUFBQUEsRUFEWSxHQUNQLENBRE87O0FBQUE7QUFBQTs7QUFBQTtBQUlaLGlCQUFNO0FBQUVDLFlBQUFBLElBQUksRUFBRSxJQUFSO0FBQWNDLFlBQUFBLEVBQUUsRUFBRSxJQUFsQjtBQUF3QkYsWUFBQUEsRUFBRSxFQUFFQSxFQUFFO0FBQTlCLFdBQU47O0FBSlk7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFkRCxXQUFjO0FBQUEsQ0FBSCxDQUFqQjs7QUFRQSxJQUFNSSxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQUNDLE9BQUQ7QUFBQSxTQUFhQSxPQUFPLENBQUNDLElBQVIsR0FBZUMsS0FBNUI7QUFBQSxDQUF4Qjs7QUFFQSxJQUFNQyxVQUFVLEdBQUcsaUJBQW5COzs7O0lBRU1DOzs7OztBQUdGLG1CQUFjO0FBQUE7O0FBQUE7O0FBQ1Y7O0FBRFU7QUFBQTtBQUFBO0FBQUE7O0FBRVYsVUFBS0MsS0FBTCxHQUFhLENBQUMsTUFBS0MsT0FBTCxFQUFELENBQWIsQ0FGVSxDQUdWOztBQUNBLFVBQUtDLEtBQUwsR0FBYSxJQUFiOztBQUNBLFVBQUtDLFlBQUw7O0FBQ0EsVUFBS0MsSUFBTCxHQUFZLE9BQVo7QUFOVTtBQU9iOzs7O1dBRUQsbUJBQVU7QUFBQTs7QUFDTixXQUFLQyxhQUFMO0FBQ0FDLE1BQUFBLHFCQUFxQixDQUFDLFlBQU07QUFDeEJsQixRQUFBQSw0RUFBUSxDQUFDLE1BQUksQ0FBQ0EsUUFBTixDQUFSO0FBQ0FILFFBQUFB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SDtBQUNKOztBQUNELFlBQUl2QyxLQUFLLENBQUNrQyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3BCbEMsVUFBQUEsS0FBSyxDQUFDd0MsSUFBTixDQUFXO0FBQUVoRCxZQUFBQSxJQUFJLEVBQUUsSUFBUjtBQUFjQyxZQUFBQSxFQUFFLEVBQUU7QUFBbEIsV0FBWDtBQUNIOztBQUNELGFBQUtPLEtBQUwsR0FBYSxFQUFiO0FBQ0FBLFFBQUFBLEtBQUssQ0FBQ21DLE9BQU4sQ0FBYyxVQUFDQyxDQUFEO0FBQUEsaUJBQU8sTUFBSSxDQUFDQyxPQUFMLENBQWFELENBQUMsQ0FBQzVDLElBQWYsRUFBcUI0QyxDQUFDLENBQUMzQyxFQUF2QixDQUFQO0FBQUEsU0FBZDtBQUNBLGFBQUs2QyxNQUFMO0FBQ0g7QUFDSjs7O1dBRUQsd0JBQWU7QUFDWCxhQUFPLEtBQUt0QyxLQUFMLENBQ0ZpRSxNQURFLENBQ0ssVUFBQ0MsR0FBRCxFQUFNQyxHQUFOLEVBQWM7QUFDbEIsWUFBSUEsR0FBRyxDQUFDM0UsSUFBUixFQUFjO0FBQ1YwRSxVQUFBQSxHQUFHLENBQUMxQixJQUFKLENBQVMyQixHQUFHLENBQUMzRSxJQUFiO0FBQ0g7O0FBQ0QsWUFBSTJFLEdBQUcsQ0FBQzFFLEVBQVIsRUFBWTtBQUNSeUUsVUFBQUEsR0FBRyxDQUFDMUIsSUFBSixDQUFTMkIsR0FBRyxDQUFDMUUsRUFBYjtBQUNIOztBQUNELGVBQU95RSxHQUFQO0FBQ0gsT0FURSxFQVNBLEVBVEEsRUFVRjJCLElBVkUsQ0FVRyxJQVZILENBQVA7QUFXSDs7OztFQTFPZTlHOztBQTZPcEJnQixLQUFLLENBQUMrRixRQUFOO0FBQWlCO0FBQWpCLFlBQ0UzRyx1RUFERixlQUVFRCw2Q0FGRjtBQW1EQTZHLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQiw4QkFBdEIsRUFBc0RqRyxLQUF0RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9DbGlwcy9pbmRleC5qcz9hZjNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaW0sIFV0aWxzLCBJY29uaWZ5IH0gZnJvbSBcIkAvY29tcG9uZW50cy9saWJcIjtcbmltcG9ydCBDQVJEX0NTUyBmcm9tIFwiLi4vQ2FyZENzc1wiO1xuaW1wb3J0IHsgSUNPTl9TVEFDS19DU1MgfSBmcm9tIFwiQC9jb21wb25lbnRzL0ljb25zL1N0YWNrLmNzc1wiO1xuaW1wb3J0IFwiLi9DbGlwXCI7XG5pbXBvcnQgc29ydGFibGUgZnJvbSBcImh0bWw1c29ydGFibGUvZGlzdC9odG1sNXNvcnRhYmxlLmVzXCI7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSBcIkAvY29tcG9uZW50cy9SZXF1ZXN0XCI7XG5cbmNvbnN0IGRhdGFGYWN0b3J5ID0gZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgaWQgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIHlpZWxkIHtmcm9tOiBgMDowOiR7aWR9LjBgLCB0bzogbnVsbCwgaWQ6IGlkKyt9XG4gICAgICAgIHlpZWxkIHsgZnJvbTogbnVsbCwgdG86IG51bGwsIGlkOiBpZCsrIH07XG4gICAgfVxufTtcblxuY29uc3QgZ2V0Q2xpcEluaXREYXRhID0gKGZhY3RvcnkpID0+IGZhY3RvcnkubmV4dCgpLnZhbHVlO1xuXG5jb25zdCBXU19DSEFOTkVMID0gXCJUcmFuc2NvZGUuQ2xpcHNcIjtcblxuY2xhc3MgQ2xpcHMgZXh0ZW5kcyBTbGltIHtcbiAgICAjbW9kZTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNsaXBzID0gW3RoaXMubmV3Q2xpcCgpXTtcbiAgICAgICAgLy90aGlzLmNsaXBzID0gW3RoaXMubmV3Q2xpcCgpLCB0aGlzLm5ld0NsaXAoKSwgdGhpcy5uZXdDbGlwKCksIHRoaXMubmV3Q2xpcCgpXVxuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5iaW5kTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5tb2RlID0gXCJjbGlwc1wiO1xuICAgIH1cblxuICAgIG9uQWRkZWQoKSB7XG4gICAgICAgIHRoaXMuaW5pdFdlYnNvY2tldCgpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgc29ydGFibGUodGhpcy5zb3J0YWJsZSk7XG4gICAgICAgICAgICBJY29uaWZ5LnNjYW4odGhpcy5zaGFkb3dSb290KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25SZW1vdmVkKCkge1xuICAgICAgICB0aGlzLmxlYXZlV2Vic29ja2V0KCk7XG4gICAgfVxuXG4gICAgaW5pdFdlYnNvY2tldCgpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gd2luZG93LkVjaG8uY2hhbm5lbChXU19DSEFOTkVMKTtcbiAgICAgICAgdGhpcy5jaGFubmVsLmxpc3RlbihXU19DSEFOTkVMLCB0aGlzLmhhbmRsZUNsaXBzRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5zdWJzY3JpYmVkKHRoaXMucmVxdWVzdENsaXBzLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGxlYXZlV2Vic29ja2V0KCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwuc3RvcExpc3RlbmluZyhXU19DSEFOTkVMKTtcbiAgICAgICAgd2luZG93LkVjaG8ubGVhdmUoV1NfQ0hBTk5FTCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNoYW5uZWw7XG4gICAgfVxuXG4gICAgcmVxdWVzdENsaXBzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiUmVxdWVzdCBjbGlwcyBvZiAlc1wiLCB0aGlzLnBhdGgpO1xuICAgICAgICAgICAgUmVxdWVzdC5nZXQoYC9jbGlwcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLnBhdGgpfWApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmxlYXZlV2Vic29ja2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiaW5kTGlzdGVuZXIoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVXBkYXRlID0gdGhpcy5oYW5kbGVVcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVBZGQgPSB0aGlzLmhhbmRsZUFkZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVJlbW92ZSA9IHRoaXMuaGFuZGxlUmVtb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlU29ydHVwZGF0ZSA9IHRoaXMuaGFuZGxlU29ydHVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzID0gdGhpcy5oYW5kbGVGb2N1cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUJsdXIgPSB0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb3B5ID0gdGhpcy5oYW5kbGVDb3B5LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgbmV3Q2xpcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFGYWN0b3J5KSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFGYWN0b3J5ID0gZGF0YUZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0Q2xpcEluaXREYXRhKHRoaXMuZGF0YUZhY3RvcnkpO1xuICAgIH1cblxuICAgIGhhbmRsZUNsaXBzRXZlbnQod3MpIHtcbiAgICAgICAgaWYgKHdzLmNsaXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jbGlwcyA9IFtdO1xuICAgICAgICAgICAgd3MuY2xpcHMuZm9yRWFjaCgoYykgPT4gdGhpcy5hZGRDbGlwKGMuZnJvbSwgYy50bykpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZENsaXAoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGNsaXAgPSB0aGlzLm5ld0NsaXAoKTtcbiAgICAgICAgY2xpcC5mcm9tID0gZnJvbTtcbiAgICAgICAgY2xpcC50byA9IHRvO1xuICAgICAgICB0aGlzLmNsaXBzLnB1c2goY2xpcCk7XG4gICAgfVxuXG4gICAgaGFuZGxlU29ydHVwZGF0ZShlKSB7XG4gICAgICAgIHRoaXMuY2xpcHMuc3BsaWNlKFxuICAgICAgICAgICAgZS5kZXRhaWwuZGVzdGluYXRpb24uaW5kZXgsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5jbGlwcy5zcGxpY2UoZS5kZXRhaWwub3JpZ2luLmluZGV4LCAxKVswXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGFzeW5jIGhhbmRsZUFkZChlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuY2xpcHMuZmluZEluZGV4KChjKSA9PiBjLmlkID09PSBlLmRldGFpbC5pZCk7XG4gICAgICAgIGxldCBjbGlwID0gdGhpcy5uZXdDbGlwKCk7XG4gICAgICAgIHRoaXMuY2xpcHMuc3BsaWNlKGlkeCArIDEsIDAsIGNsaXApO1xuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLnNvcnRhYmxlXG4gICAgICAgICAgICAucXVlcnlTZWxlY3RvcihgW2RhdGEtY2xpcD1cIiR7Y2xpcC5pZH1cIl1gKVxuICAgICAgICAgICAgLmlucHV0RnJvbS5mb2N1cygpO1xuICAgIH1cblxuICAgIGFzeW5jIGhhbmRsZVJlbW92ZShlKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuY2xpcHMuZmluZEluZGV4KChjKSA9PiBjLmlkID09PSBlLmRldGFpbC5pZCk7XG4gICAgICAgICAgICBjb25zdCBmb2N1cyA9IE1hdGgubWF4KDAsIGlkeCAtIDEpO1xuICAgICAgICAgICAgdGhpcy5jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnNvcnRhYmxlXG4gICAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWNsaXA9XCIke3RoaXMuY2xpcHNbZm9jdXNdLmlkfVwiXWApXG4gICAgICAgICAgICAgICAgLmlucHV0RnJvbS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlVXBkYXRlKGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgdGhpcy52YWxpZCA9IEFycmF5LmZyb20oXG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbChcInRyYW5zY29kZS1jb25maWd1cmF0b3ItY2xpcFwiKVxuICAgICAgICApLmV2ZXJ5KChjKSA9PiBjLnZhbGlkKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgVXRpbHMuZm9yY2VVcGRhdGUodGhpcywgXCJjbGlwc1wiKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc29ydGFibGUodGhpcy5zb3J0YWJsZSwgXCJyZWxvYWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290XG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKFwidHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1jbGlwXCIpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChjLCBpKSA9PiAoYy5jbGlwRGF0YSA9IHRoaXMuY2xpcHNbaV0pKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlRm9jdXMoKSB7XG4gICAgICAgIHNvcnRhYmxlKHRoaXMuc29ydGFibGUsIFwiZGlzYWJsZVwiKTtcbiAgICB9XG5cbiAgICBoYW5kbGVCbHVyKCkge1xuICAgICAgICBzb3J0YWJsZSh0aGlzLnNvcnRhYmxlLCBcImVuYWJsZVwiKTtcbiAgICB9XG5cbiAgICBnZXRDdXRwb2ludChjbGlwKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1dHBvaW50ID0gdGhpcy5jbGlwc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGMpID0+IGMuaWQgPD0gY2xpcC5pZClcbiAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgKGFjYywgY3VyKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjICsgdGhpcy50b1NlY29uZHMoY3VyLnRvKSAtIHRoaXMudG9TZWNvbmRzKGN1ci5mcm9tKSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oY3V0cG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tU2Vjb25kcyhjdXRwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgdG9TZWNvbmRzKGNvb3JkKSB7XG4gICAgICAgIGNvbnN0IFtob3VycywgbWludXRlcywgc2Vjb25kc10gPSBjb29yZC5zcGxpdChcIjpcIik7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGhvdXJzKSAqIDYwICogNjAgK1xuICAgICAgICAgICAgcGFyc2VGbG9hdChtaW51dGVzKSAqIDYwICtcbiAgICAgICAgICAgIHBhcnNlRmxvYXQoc2Vjb25kcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmcm9tU2Vjb25kcyhjb29yZCkge1xuICAgICAgICBjb25zdCBkID0gbmV3IERhdGUobnVsbCk7XG4gICAgICAgIGQuc2V0TWlsbGlzZWNvbmRzKGNvb3JkICogMTAwMCk7XG4gICAgICAgIHJldHVybiBgJHtkLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIil9OiR7ZFxuICAgICAgICAgICAgLmdldFVUQ01pbnV0ZXMoKVxuICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9OiR7ZFxuICAgICAgICAgICAgLmdldFVUQ1NlY29uZHMoKVxuICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9LiR7ZC5nZXRVVENNaWxsaXNlY29uZHMoKX1gO1xuICAgIH1cblxuICAgIG1pbGxpU2Vjb25kcyhjb29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1NlY29uZHMoY29vcmQpICogMTAwMDtcbiAgICB9XG5cbiAgICBnZXRUaW1lc3RhbXBzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGlwcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VyLmZyb20pIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaCh0aGlzLm1pbGxpU2Vjb25kcyhjdXIuZnJvbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1ci50bykge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKHRoaXMubWlsbGlTZWNvbmRzKGN1ci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIGhhbmRsZUNvcHkoKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IHRoaXMubW9kZSA9PT0gXCJjbGlwc1wiID8gXCJjb3B5XCIgOiBcImNsaXBzXCI7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwiY29weVwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvcHlhcmVhLnJvd3MgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAxMCxcbiAgICAgICAgICAgICAgICBNYXRoLm1pbigyMCwgdGhpcy5jbGlwcy5sZW5ndGggKiAyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuY29weWFyZWEudmFsdWUgPSB0aGlzLmdldENvcHlDbGlwcygpO1xuICAgICAgICAgICAgdGhpcy5jb3B5YXJlYS5zZWxlY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9IHRoaXMuY29weWFyZWEudmFsdWUuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBjb25zdCBjbGlwcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmF3W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbGlwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogcmF3W2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHJhd1tpICsgMV0gPz8gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2xpcHMucHVzaCh7IGZyb206IG51bGwsIHRvOiBudWxsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGlwcyA9IFtdO1xuICAgICAgICAgICAgY2xpcHMuZm9yRWFjaCgoYykgPT4gdGhpcy5hZGRDbGlwKGMuZnJvbSwgYy50bykpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENvcHlDbGlwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpcHNcbiAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYy5wdXNoKGN1ci5mcm9tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1ci50bykge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaChjdXIudG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgICAuam9pbihcIlxcblwiKTtcbiAgICB9XG59XG5cbkNsaXBzLnRlbXBsYXRlID0gLypodG1sKi8gYFxuJHtJQ09OX1NUQUNLX0NTU31cbiR7Q0FSRF9DU1N9XG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICB9XG4gICAgaDIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgfVxuICAgIGRpdi5jb3B5LCBkaXYuY2xpcHMge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAuY29weSBkaXYuY29weSB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIH1cbiAgICAuY2xpcHMgZGl2LmNsaXBzIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgZ2FwOiAuNXJlbTtcbiAgICB9XG48L3N0eWxlPlxuPG1haW4gY2xhc3M9XCJ7eyB0aGlzLm1vZGUgfX1cIj5cbiAgICA8aDI+XG4gICAgICAgIENsaXBzXG4gICAgICAgIDxkaXYgY2xhc3M9XCJpY29uLXN0YWNrXCIgQGNsaWNrPVwie3sgdGhpcy5oYW5kbGVDb3B5IH19XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktY29udGVudC1jb3B5XCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5IGhvdmVyXCIgZGF0YS1pY29uPVwibWRpLWNvbnRlbnQtY29weVwiPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9oMj5cbiAgICA8ZGl2IGNsYXNzPVwiY29weVwiPlxuICAgICAgICA8dGV4dGFyZWEgI3JlZj1cImNvcHlhcmVhXCI+PC90ZXh0YXJlYT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY2xpcHNcIiAjcmVmPVwic29ydGFibGVcIiBAc29ydHVwZGF0ZT1cInt7IHRoaXMuaGFuZGxlU29ydHVwZGF0ZSB9fVwiPlxuICAgICAgICA8dHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1jbGlwXG4gICAgICAgICAgICBkYXRhLWNsaXA9XCJ7eyBpdGVtLmlkIH19XCJcbiAgICAgICAgICAgICpmb3JlYWNoPVwie3sgdGhpcy5jbGlwcyB9fVwiXG4gICAgICAgICAgICAuY2FuLXJlbW92ZT1cInt7IHRoaXMuY2xpcHMubGVuZ3RoID4gMSB9fVwiXG4gICAgICAgICAgICAuaXMtbGFzdD1cInt7IHRoaXMuY2xpcHMuaW5kZXhPZihpdGVtKSA9PT0gdGhpcy5jbGlwcy5sZW5ndGggLSAxIH19XCJcbiAgICAgICAgICAgIEB1cGRhdGVjbGlwPVwie3sgdGhpcy5oYW5kbGVVcGRhdGUgfX1cIlxuICAgICAgICAgICAgQGNsaXBpbnNlcnQ9XCJ7eyB0aGlzLmhhbmRsZUFkZCB9fVwiXG4gICAgICAgICAgICBAY2xpcHJlbW92ZT1cInt7IHRoaXMuaGFuZGxlUmVtb3ZlIH19XCJcbiAgICAgICAgICAgIEBjbGlwZm9jdXM9XCJ7eyB0aGlzLmhhbmRsZUZvY3VzIH19XCJcbiAgICAgICAgICAgIEBjbGlwYmx1cj1cInt7IHRoaXMuaGFuZGxlQmx1ciB9fVwiXG4gICAgICAgICAgICAuY2xpcC1kYXRhPVwie3sgaXRlbSB9fVwiXG4gICAgICAgICAgICAuY3V0cG9pbnQ9XCJ7eyB0aGlzLmdldEN1dHBvaW50KGl0ZW0pIH19XCI+XG4gICAgICAgIDwvdHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1jbGlwPlxuICAgIDwvZGl2PlxuPC9tYWluPlxuYDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcInRyYW5zY29kZS1jb25maWd1cmF0b3ItY2xpcHNcIiwgQ2xpcHMpO1xuIl0sIm5hbWVzIjpbIlNsaW0iLCJVdGlscyIsIkljb25pZnkiLCJDQVJEX0NTUyIsIklDT05fU1RBQ0tfQ1NTIiwic29ydGFibGUiLCJSZXF1ZXN0IiwiZGF0YUZhY3RvcnkiLCJpZCIsImZyb20iLCJ0byIsImdldENsaXBJbml0RGF0YSIsImZhY3RvcnkiLCJuZXh0IiwidmFsdWUiLCJXU19DSEFOTkVMIiwiQ2xpcHMiLCJjbGlwcyIsIm5ld0NsaXAiLCJ2YWxpZCIsImJpbmRMaXN0ZW5lciIsIm1vZGUiLCJpbml0V2Vic29ja2V0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2NhbiIsInNoYWRvd1Jvb3QiLCJsZWF2ZVdlYnNvY2tldCIsImNoYW5uZWwiLCJ3aW5kb3ciLCJFY2hvIiwibGlzdGVuIiwiaGFuZGxlQ2xpcHNFdmVudCIsImJpbmQiLCJzdWJzY3JpYmVkIiwicmVxdWVzdENsaXBzIiwic3RvcExpc3RlbmluZyIsImxlYXZlIiwiY29uc29sZSIsImluZm8iLCJwYXRoIiwiZ2V0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZXJyb3IiLCJoYW5kbGVVcGRhdGUiLCJoYW5kbGVBZGQiLCJoYW5kbGVSZW1vdmUiLCJoYW5kbGVTb3J0dXBkYXRlIiwiaGFuZGxlRm9jdXMiLCJoYW5kbGVCbHVyIiwiaGFuZGxlQ29weSIsIndzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImMiLCJhZGRDbGlwIiwidXBkYXRlIiwiY2xpcCIsInB1c2giLCJlIiwic3BsaWNlIiwiZGV0YWlsIiwiZGVzdGluYXRpb24iLCJpbmRleCIsIm9yaWdpbiIsImlkeCIsImZpbmRJbmRleCIsInF1ZXJ5U2VsZWN0b3IiLCJpbnB1dEZyb20iLCJmb2N1cyIsIk1hdGgiLCJtYXgiLCJBcnJheSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJldmVyeSIsIlByb21pc2UiLCJyZXNvbHZlIiwiZm9yY2VVcGRhdGUiLCJpIiwiY2xpcERhdGEiLCJjdXRwb2ludCIsImZpbHRlciIsInJldmVyc2UiLCJyZWR1Y2UiLCJhY2MiLCJjdXIiLCJ0b1NlY29uZHMiLCJpc05hTiIsImZyb21TZWNvbmRzIiwiY29vcmQiLCJzcGxpdCIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJwYXJzZUZsb2F0IiwiZCIsIkRhdGUiLCJzZXRNaWxsaXNlY29uZHMiLCJnZXRVVENIb3VycyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbGxpc2Vjb25kcyIsIm1pbGxpU2Vjb25kcyIsImNvcHlhcmVhIiwicm93cyIsIm1pbiIsImdldENvcHlDbGlwcyIsInNlbGVjdCIsInJhdyIsImpvaW4iLCJ0ZW1wbGF0ZSIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Clips/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Dialogues/Clipper/index.js":
/*!*************************************************************************!*\
  !*** ./resources/js/components/Configurator/Dialogues/Clipper/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VideoEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VideoEditor */ \"./resources/js/components/Configurator/Dialogues/VideoEditor/index.js\");\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _mixins_handleKey__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mixins/handleKey */ \"./resources/js/components/Configurator/Dialogues/Clipper/mixins/handleKey.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar Clipper = /*#__PURE__*/function (_VideoEditor) {\n  _inherits(Clipper, _VideoEditor);\n\n  var _super = _createSuper(Clipper);\n\n  function Clipper() {\n    var _this;\n\n    _classCallCheck(this, Clipper);\n\n    _this = _super.call(this);\n    _this.clips = [];\n    _this.raw = [];\n    return _this;\n  }\n\n  _createClass(Clipper, [{\n    key: \"bindListeners\",\n    value: function bindListeners() {\n      _get(_getPrototypeOf(Clipper.prototype), \"bindListeners\", this).call(this);\n\n      this.rwd = _mixins_handleKey__WEBPACK_IMPORTED_MODULE_2__.rwd.bind(this);\n      this.ffwd = _mixins_handleKey__WEBPACK_IMPORTED_MODULE_2__.ffwd.bind(this);\n      this.handleKey = _mixins_handleKey__WEBPACK_IMPORTED_MODULE_2__.handleKey.bind(this);\n      this.add = this.add.bind(this);\n      this.remove = this.remove.bind(this);\n      this.getClipPos = this.getClipPos.bind(this);\n      this.activateClip = this.activateClip.bind(this);\n    }\n  }, {\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(Clipper.prototype), \"onAdded\", this).call(this);\n\n      document.addEventListener(\"keydown\", this.handleKey);\n      requestAnimationFrame(function () {\n        _this2.calculateClips();\n\n        _this2.initImages();\n      });\n    }\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved() {\n      document.removeEventListener(\"keydown\", this.handleKey);\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      this.raw.push(this.current);\n      this.raw.sort(function (a, b) {\n        return a > b;\n      });\n      this.calculateClips();\n      _components_lib__WEBPACK_IMPORTED_MODULE_1__.Utils.forceUpdate(this, \"clips,raw\");\n      this.dispatchEvent(new CustomEvent(\"clipper\", {\n        detail: this.timestamp()\n      }));\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var idx = this.raw.indexOf(this.current);\n\n      if (idx > -1) {\n        this.raw.splice(idx, 1);\n        this.calculateClips();\n        _components_lib__WEBPACK_IMPORTED_MODULE_1__.Utils.forceUpdate(this, \"clips,raw\");\n      }\n    }\n  }, {\n    key: \"setClips\",\n    value: function setClips(clips) {\n      this.raw = clips;\n\n      if (this.parentNode) {\n        _components_lib__WEBPACK_IMPORTED_MODULE_1__.Utils.forceUpdate(this);\n      }\n    }\n  }, {\n    key: \"activateClip\",\n    value: function activateClip(e) {\n      var item = this.clips[e.target.dataset.index];\n\n      if (this.current === item.raw.start && item.raw.end) {\n        this.current = item.raw.end;\n      } else {\n        this.current = item.raw.start;\n      }\n\n      this.updateImages();\n    }\n  }, {\n    key: \"clipEndTimestamp\",\n    value: function clipEndTimestamp(seconds) {\n      return seconds ? this.timestamp(seconds) : \"-\";\n    }\n  }, {\n    key: \"calculateClips\",\n    value: function calculateClips() {\n      var _this3 = this;\n\n      this.clips.forEach(function (c) {\n        c.node.removeEventListener(\"click\", _this3.activateClip);\n        c.node.remove();\n      });\n      this.clips = [];\n\n      for (var i = 0; i < this.raw.length; i += 2) {\n        var start = this.raw[i] ? this.timestamp(this.raw[i]) : null;\n        var end = this.raw[i + 1] ? this.timestamp(this.raw[i + 1]) : null;\n        var percentage = 100 / this.duration;\n        var clip = {\n          index: this.clips.length,\n          timestamps: {\n            start: start,\n            end: end\n          },\n          raw: {\n            start: start ? this.raw[i] : null,\n            end: end ? this.raw[i + 1] : null\n          },\n          percentage: {\n            start: start ? percentage * this.raw[i] : null,\n            length: end ? percentage * (this.raw[i + 1] - this.raw[i]) : null\n          }\n        };\n        clip.node = document.createElement(\"div\");\n        clip.node.style.left = \"\".concat(clip.percentage.start, \"%\");\n        clip.node.style.width = end ? \"\".concat(clip.percentage.length, \"%\") : \"1px\";\n        clip.node.dataset.index = clip.index;\n        clip.node.classList.add(\"clip\");\n        clip.node.addEventListener(\"click\", this.activateClip);\n        this.indicator.appendChild(clip.node);\n        this.clips.push(clip);\n      }\n\n      _components_lib__WEBPACK_IMPORTED_MODULE_1__.Utils.forceUpdate(this);\n    }\n  }, {\n    key: \"getClipPos\",\n    value: function getClipPos(item) {\n      if (item.percentage.start && item.percentage.length) {\n        return \"left: \".concat(item.percentage.start, \"%;width:\").concat(item.percentage.length, \"%\");\n      }\n\n      return \"left: \".concat(item.percentage.start, \"%;width:1px\");\n    }\n  }]);\n\n  return Clipper;\n}(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.VideoEditor);\n\nClipper.template =\n/*html*/\n\"\\n\".concat(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.EDITOR_CSS, \"\\n<style>\\n    .indicator .clip {\\n        position: absolute;\\n        inset-block: 0;\\n        background: hsla(var(--hue-success) var(--sat-alert) var(--lit-alert) / .5);\\n        z-index: 1;\\n    }\\n    .help, .clips {\\n        font-size: .75rem;\\n        white-space: nowrap;\\n    }\\n    .help {\\n        grid-area: left;\\n    }\\n    .help dl {\\n        display: grid;\\n        grid-template-columns: auto 1fr;\\n        grid-column-gap: .5rem;\\n    }\\n    .help dd {\\n        margin: 0;\\n    }\\n    .clips {\\n        grid-area: right;\\n        display: grid;\\n        grid-template-columns: 1fr;\\n        grid-auto-rows: min-content;\\n        overflow-y: auto;\\n        grid-row-gap: .25rem;\\n    }\\n    .clips .clip:nth-child(odd) {\\n        background: var(--clr-bg-100);\\n    }\\n    .clips .clip .timestamp {\\n        cursor: pointer;\\n        padding: .125rem;\\n    }\\n    .clips .clip .timestamp.active {\\n        background: var(--clr-bg-200);\\n    }\\n</style>\\n\").concat(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.EDITOR_TEMPLATE, \"\\n<div class=\\\"help\\\">\\n    <dl>\\n        <dt><span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-horizontal-bold\\\"></span></dt><dd>+/-1 Frame</dd>\\n        <dt><span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-horizontal-bold\\\"></span> + Shift</dt><dd>+/-2 Seconds</dd>\\n        <dt><span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-horizontal-bold\\\"></span> + Ctrl</dt><dd>+/-5 Seconds</dd>\\n    </dl>\\n    <dl>\\n        <dt><span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-vertical-bold\\\"></span></dt><dd>+/-1 Minute</dd>\\n        <dt><span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-vertical-bold\\\"></span> + Shift</dt><dd>+/-5 Minutes</dd>\\n        <dt><span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-vertical-bold\\\"></span> + Ctrl</dt><dd>+/-10 Minutes</dd>\\n    </dl>\\n    <dl>\\n        <dt>+</dt><dd>Add</dd>\\n        <dt>-</dt><dd>Remove</dd>\\n    </dl>\\n    <dl>\\n        <dt>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-horizontal-bold\\\"></span>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-vertical-bold\\\"></span> + Alt\\n        </dt>\\n        <dd>Move</dd>\\n        <dt>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-horizontal-bold\\\"></span> + Ctrl/Shift\\n        </dt>\\n        <dd>Skip</dd>\\n    </dl>\\n</div>\\n<div class=\\\"clips\\\">\\n    <div class=\\\"clip\\\" *foreach=\\\"{{ this.clips }}\\\">\\n        <div data-index=\\\"{{ item.index }}\\\" @click=\\\"{{ this.activateClip }}\\\"\\n            class=\\\"{{ item.raw.start === this.current ? 'timestamp active' : 'timestamp' }}\\\"\\n        >\\n            {{ this.timestamp(item.raw.start) }}\\n        </div>\\n        <div data-index=\\\"{{ item.index }}\\\" @click=\\\"{{ this.activateClip }}\\\"\\n            class=\\\"{{ item.raw.end === this.current ? 'timestamp active' : 'timestamp' }}\\\"\\n        >\\n            {{ this.clipEndTimestamp(item.raw.end) }}\\n        </div>\\n    </div>\\n</div>\\n\");\ncustomElements.define(\"dialogue-clipper\", Clipper);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL0NsaXBwZXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztJQUNNTzs7Ozs7QUFDRixxQkFBYztBQUFBOztBQUFBOztBQUNWO0FBQ0EsVUFBS0MsS0FBTCxHQUFhLEVBQWI7QUFDQSxVQUFLQyxHQUFMLEdBQVcsRUFBWDtBQUhVO0FBSWI7Ozs7V0FFRCx5QkFBZ0I7QUFDWjs7QUFDQSxXQUFLSixHQUFMLEdBQVdBLHVEQUFBLENBQVMsSUFBVCxDQUFYO0FBQ0EsV0FBS0MsSUFBTCxHQUFZQSx3REFBQSxDQUFVLElBQVYsQ0FBWjtBQUNBLFdBQUtGLFNBQUwsR0FBaUJBLDZEQUFBLENBQWUsSUFBZixDQUFqQjtBQUNBLFdBQUtPLEdBQUwsR0FBVyxLQUFLQSxHQUFMLENBQVNELElBQVQsQ0FBYyxJQUFkLENBQVg7QUFDQSxXQUFLRSxNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZRixJQUFaLENBQWlCLElBQWpCLENBQWQ7QUFDQSxXQUFLRyxVQUFMLEdBQWtCLEtBQUtBLFVBQUwsQ0FBZ0JILElBQWhCLENBQXFCLElBQXJCLENBQWxCO0FBQ0EsV0FBS0ksWUFBTCxHQUFvQixLQUFLQSxZQUFMLENBQWtCSixJQUFsQixDQUF1QixJQUF2QixDQUFwQjtBQUNIOzs7V0FFRCxtQkFBVTtBQUFBOztBQUNOOztBQUNBSyxNQUFBQSxRQUFRLENBQUNDLGdCQUFULENBQTBCLFNBQTFCLEVBQXFDLEtBQUtaLFNBQTFDO0FBQ0FhLE1BQUFBLHFCQUFxQixDQUFDLFlBQU07QUFDeEIsY0FBSSxDQUFDQyxjQUFMOztBQUNBLGNBQUksQ0FBQ0MsVUFBTDtBQUNILE9BSG9CLENBQXJCO0FBSUg7OztXQUVELHFCQUFZO0FBQ1JKLE1BQUFBLFFBQVEsQ0FBQ0ssbUJBQVQsQ0FBNkIsU0FBN0IsRUFBd0MsS0FBS2hCLFNB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LElBQUwsQ0FBVVcsU0FBVixDQUFvQjlDLEdBQXBCLENBQXdCLE1BQXhCO0FBQ0F3QyxRQUFBQSxJQUFJLENBQUNMLElBQUwsQ0FBVTlCLGdCQUFWLENBQTJCLE9BQTNCLEVBQW9DLEtBQUtGLFlBQXpDO0FBQ0EsYUFBSzRDLFNBQUwsQ0FBZUMsV0FBZixDQUEyQlIsSUFBSSxDQUFDTCxJQUFoQztBQUNBLGFBQUt0QyxLQUFMLENBQVdhLElBQVgsQ0FBZ0I4QixJQUFoQjtBQUNIOztBQUNEaEQsTUFBQUEsOERBQUEsQ0FBa0IsSUFBbEI7QUFDSDs7O1dBRUQsb0JBQVdpQyxJQUFYLEVBQWlCO0FBQ2IsVUFBSUEsSUFBSSxDQUFDYSxVQUFMLENBQWdCVCxLQUFoQixJQUF5QkosSUFBSSxDQUFDYSxVQUFMLENBQWdCRCxNQUE3QyxFQUFxRDtBQUNqRCwrQkFBZ0JaLElBQUksQ0FBQ2EsVUFBTCxDQUFnQlQsS0FBaEMscUJBQWdESixJQUFJLENBQUNhLFVBQUwsQ0FBZ0JELE1BQWhFO0FBQ0g7O0FBQ0QsNkJBQWdCWixJQUFJLENBQUNhLFVBQUwsQ0FBZ0JULEtBQWhDO0FBQ0g7Ozs7RUFsSGlCeEM7O0FBcUh0Qk8sT0FBTyxDQUFDcUQsUUFBUjtBQUFtQjtBQUFuQixZQUNFMUQsb0RBREYsMDlCQTJDRUQseURBM0NGO0FBdUZBNEQsY0FBYyxDQUFDQyxNQUFmLENBQXNCLGtCQUF0QixFQUEwQ3ZELE9BQTFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL0RpYWxvZ3Vlcy9DbGlwcGVyL2luZGV4LmpzPzRkMmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmlkZW9FZGl0b3IsIEVESVRPUl9URU1QTEFURSwgRURJVE9SX0NTUyB9IGZyb20gXCIuLi9WaWRlb0VkaXRvclwiO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiQC9jb21wb25lbnRzL2xpYlwiO1xuaW1wb3J0IHsgaGFuZGxlS2V5LCByd2QsIGZmd2QgfSBmcm9tIFwiLi9taXhpbnMvaGFuZGxlS2V5XCI7XG5jbGFzcyBDbGlwcGVyIGV4dGVuZHMgVmlkZW9FZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNsaXBzID0gW107XG4gICAgICAgIHRoaXMucmF3ID0gW107XG4gICAgfVxuXG4gICAgYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgc3VwZXIuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnJ3ZCA9IHJ3ZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZmd2QgPSBmZndkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5ID0gaGFuZGxlS2V5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkID0gdGhpcy5hZGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmUgPSB0aGlzLnJlbW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldENsaXBQb3MgPSB0aGlzLmdldENsaXBQb3MuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZUNsaXAgPSB0aGlzLmFjdGl2YXRlQ2xpcC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIG9uQWRkZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQWRkZWQoKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXkpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVDbGlwcygpO1xuICAgICAgICAgICAgdGhpcy5pbml0SW1hZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uUmVtb3ZlZCgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXkpO1xuICAgIH1cblxuICAgIGFkZCgpIHtcbiAgICAgICAgdGhpcy5yYXcucHVzaCh0aGlzLmN1cnJlbnQpO1xuICAgICAgICB0aGlzLnJhdy5zb3J0KChhLCBiKSA9PiBhID4gYik7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQ2xpcHMoKTtcbiAgICAgICAgVXRpbHMuZm9yY2VVcGRhdGUodGhpcywgXCJjbGlwcyxyYXdcIik7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcImNsaXBwZXJcIiwgeyBkZXRhaWw6IHRoaXMudGltZXN0YW1wKCkgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmF3LmluZGV4T2YodGhpcy5jdXJyZW50KTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJhdy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQ2xpcHMoKTtcbiAgICAgICAgICAgIFV0aWxzLmZvcmNlVXBkYXRlKHRoaXMsIFwiY2xpcHMscmF3XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Q2xpcHMoY2xpcHMpIHtcbiAgICAgICAgdGhpcy5yYXcgPSBjbGlwcztcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgVXRpbHMuZm9yY2VVcGRhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZUNsaXAoZSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5jbGlwc1tlLnRhcmdldC5kYXRhc2V0LmluZGV4XTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCA9PT0gaXRlbS5yYXcuc3RhcnQgJiYgaXRlbS5yYXcuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBpdGVtLnJhdy5lbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBpdGVtLnJhdy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUltYWdlcygpO1xuICAgIH1cblxuICAgIGNsaXBFbmRUaW1lc3RhbXAoc2Vjb25kcykge1xuICAgICAgICByZXR1cm4gc2Vjb25kcyA/IHRoaXMudGltZXN0YW1wKHNlY29uZHMpIDogXCItXCI7XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlQ2xpcHMoKSB7XG4gICAgICAgIHRoaXMuY2xpcHMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgYy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmFjdGl2YXRlQ2xpcCk7XG4gICAgICAgICAgICBjLm5vZGUucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsaXBzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYXcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5yYXdbaV0gPyB0aGlzLnRpbWVzdGFtcCh0aGlzLnJhd1tpXSkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5yYXdbaSArIDFdXG4gICAgICAgICAgICAgICAgPyB0aGlzLnRpbWVzdGFtcCh0aGlzLnJhd1tpICsgMV0pXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IDEwMCAvIHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBjbGlwID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmNsaXBzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBzOiB7IHN0YXJ0LCBlbmQgfSxcbiAgICAgICAgICAgICAgICByYXc6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID8gdGhpcy5yYXdbaV0gOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCA/IHRoaXMucmF3W2kgKyAxXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCA/IHBlcmNlbnRhZ2UgKiB0aGlzLnJhd1tpXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBlcmNlbnRhZ2UgKiAodGhpcy5yYXdbaSArIDFdIC0gdGhpcy5yYXdbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbGlwLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgY2xpcC5ub2RlLnN0eWxlLmxlZnQgPSBgJHtjbGlwLnBlcmNlbnRhZ2Uuc3RhcnR9JWA7XG4gICAgICAgICAgICBjbGlwLm5vZGUuc3R5bGUud2lkdGggPSBlbmQgPyBgJHtjbGlwLnBlcmNlbnRhZ2UubGVuZ3RofSVgIDogXCIxcHhcIjtcbiAgICAgICAgICAgIGNsaXAubm9kZS5kYXRhc2V0LmluZGV4ID0gY2xpcC5pbmRleDtcbiAgICAgICAgICAgIGNsaXAubm9kZS5jbGFzc0xpc3QuYWRkKFwiY2xpcFwiKTtcbiAgICAgICAgICAgIGNsaXAubm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5hY3RpdmF0ZUNsaXApO1xuICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3IuYXBwZW5kQ2hpbGQoY2xpcC5ub2RlKTtcbiAgICAgICAgICAgIHRoaXMuY2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlscy5mb3JjZVVwZGF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXRDbGlwUG9zKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0ucGVyY2VudGFnZS5zdGFydCAmJiBpdGVtLnBlcmNlbnRhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYGxlZnQ6ICR7aXRlbS5wZXJjZW50YWdlLnN0YXJ0fSU7d2lkdGg6JHtpdGVtLnBlcmNlbnRhZ2UubGVuZ3RofSVgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgbGVmdDogJHtpdGVtLnBlcmNlbnRhZ2Uuc3RhcnR9JTt3aWR0aDoxcHhgO1xuICAgIH1cbn1cblxuQ2xpcHBlci50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7RURJVE9SX0NTU31cbjxzdHlsZT5cbiAgICAuaW5kaWNhdG9yIC5jbGlwIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBpbnNldC1ibG9jazogMDtcbiAgICAgICAgYmFja2dyb3VuZDogaHNsYSh2YXIoLS1odWUtc3VjY2VzcykgdmFyKC0tc2F0LWFsZXJ0KSB2YXIoLS1saXQtYWxlcnQpIC8gLjUpO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgIH1cbiAgICAuaGVscCwgLmNsaXBzIHtcbiAgICAgICAgZm9udC1zaXplOiAuNzVyZW07XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgfVxuICAgIC5oZWxwIHtcbiAgICAgICAgZ3JpZC1hcmVhOiBsZWZ0O1xuICAgIH1cbiAgICAuaGVscCBkbCB7XG4gICAgICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogYXV0byAxZnI7XG4gICAgICAgIGdyaWQtY29sdW1uLWdhcDogLjVyZW07XG4gICAgfVxuICAgIC5oZWxwIGRkIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgIH1cbiAgICAuY2xpcHMge1xuICAgICAgICBncmlkLWFyZWE6IHJpZ2h0O1xuICAgICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjtcbiAgICAgICAgZ3JpZC1hdXRvLXJvd3M6IG1pbi1jb250ZW50O1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICBncmlkLXJvdy1nYXA6IC4yNXJlbTtcbiAgICB9XG4gICAgLmNsaXBzIC5jbGlwOm50aC1jaGlsZChvZGQpIHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tY2xyLWJnLTEwMCk7XG4gICAgfVxuICAgIC5jbGlwcyAuY2xpcCAudGltZXN0YW1wIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBwYWRkaW5nOiAuMTI1cmVtO1xuICAgIH1cbiAgICAuY2xpcHMgLmNsaXAgLnRpbWVzdGFtcC5hY3RpdmUge1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMjAwKTtcbiAgICB9XG48L3N0eWxlPlxuJHtFRElUT1JfVEVNUExBVEV9XG48ZGl2IGNsYXNzPVwiaGVscFwiPlxuICAgIDxkbD5cbiAgICAgICAgPGR0PjxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1zd2FwLWhvcml6b250YWwtYm9sZFwiPjwvc3Bhbj48L2R0PjxkZD4rLy0xIEZyYW1lPC9kZD5cbiAgICAgICAgPGR0PjxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1zd2FwLWhvcml6b250YWwtYm9sZFwiPjwvc3Bhbj4gKyBTaGlmdDwvZHQ+PGRkPisvLTIgU2Vjb25kczwvZGQ+XG4gICAgICAgIDxkdD48c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktc3dhcC1ob3Jpem9udGFsLWJvbGRcIj48L3NwYW4+ICsgQ3RybDwvZHQ+PGRkPisvLTUgU2Vjb25kczwvZGQ+XG4gICAgPC9kbD5cbiAgICA8ZGw+XG4gICAgICAgIDxkdD48c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktc3dhcC12ZXJ0aWNhbC1ib2xkXCI+PC9zcGFuPjwvZHQ+PGRkPisvLTEgTWludXRlPC9kZD5cbiAgICAgICAgPGR0PjxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1zd2FwLXZlcnRpY2FsLWJvbGRcIj48L3NwYW4+ICsgU2hpZnQ8L2R0PjxkZD4rLy01IE1pbnV0ZXM8L2RkPlxuICAgICAgICA8ZHQ+PHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLXN3YXAtdmVydGljYWwtYm9sZFwiPjwvc3Bhbj4gKyBDdHJsPC9kdD48ZGQ+Ky8tMTAgTWludXRlczwvZGQ+XG4gICAgPC9kbD5cbiAgICA8ZGw+XG4gICAgICAgIDxkdD4rPC9kdD48ZGQ+QWRkPC9kZD5cbiAgICAgICAgPGR0Pi08L2R0PjxkZD5SZW1vdmU8L2RkPlxuICAgIDwvZGw+XG4gICAgPGRsPlxuICAgICAgICA8ZHQ+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktc3dhcC1ob3Jpem9udGFsLWJvbGRcIj48L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktc3dhcC12ZXJ0aWNhbC1ib2xkXCI+PC9zcGFuPiArIEFsdFxuICAgICAgICA8L2R0PlxuICAgICAgICA8ZGQ+TW92ZTwvZGQ+XG4gICAgICAgIDxkdD5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1zd2FwLWhvcml6b250YWwtYm9sZFwiPjwvc3Bhbj4gKyBDdHJsL1NoaWZ0XG4gICAgICAgIDwvZHQ+XG4gICAgICAgIDxkZD5Ta2lwPC9kZD5cbiAgICA8L2RsPlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwiY2xpcHNcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY2xpcFwiICpmb3JlYWNoPVwie3sgdGhpcy5jbGlwcyB9fVwiPlxuICAgICAgICA8ZGl2IGRhdGEtaW5kZXg9XCJ7eyBpdGVtLmluZGV4IH19XCIgQGNsaWNrPVwie3sgdGhpcy5hY3RpdmF0ZUNsaXAgfX1cIlxuICAgICAgICAgICAgY2xhc3M9XCJ7eyBpdGVtLnJhdy5zdGFydCA9PT0gdGhpcy5jdXJyZW50ID8gJ3RpbWVzdGFtcCBhY3RpdmUnIDogJ3RpbWVzdGFtcCcgfX1cIlxuICAgICAgICA+XG4gICAgICAgICAgICB7eyB0aGlzLnRpbWVzdGFtcChpdGVtLnJhdy5zdGFydCkgfX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgZGF0YS1pbmRleD1cInt7IGl0ZW0uaW5kZXggfX1cIiBAY2xpY2s9XCJ7eyB0aGlzLmFjdGl2YXRlQ2xpcCB9fVwiXG4gICAgICAgICAgICBjbGFzcz1cInt7IGl0ZW0ucmF3LmVuZCA9PT0gdGhpcy5jdXJyZW50ID8gJ3RpbWVzdGFtcCBhY3RpdmUnIDogJ3RpbWVzdGFtcCcgfX1cIlxuICAgICAgICA+XG4gICAgICAgICAgICB7eyB0aGlzLmNsaXBFbmRUaW1lc3RhbXAoaXRlbS5yYXcuZW5kKSB9fVxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYDtcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwiZGlhbG9ndWUtY2xpcHBlclwiLCBDbGlwcGVyKTtcbiJdLCJuYW1lcyI6WyJWaWRlb0VkaXRvciIsIkVESVRPUl9URU1QTEFURSIsIkVESVRPUl9DU1MiLCJVdGlscyIsImhhbmRsZUtleSIsInJ3ZCIsImZmd2QiLCJDbGlwcGVyIiwiY2xpcHMiLCJyYXciLCJiaW5kIiwiYWRkIiwicmVtb3ZlIiwiZ2V0Q2xpcFBvcyIsImFjdGl2YXRlQ2xpcCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbGN1bGF0ZUNsaXBzIiwiaW5pdEltYWdlcyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwdXNoIiwiY3VycmVudCIsInNvcnQiLCJhIiwiYiIsImZvcmNlVXBkYXRlIiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwidGltZXN0YW1wIiwiaWR4IiwiaW5kZXhPZiIsInNwbGljZSIsInBhcmVudE5vZGUiLCJlIiwiaXRlbSIsInRhcmdldCIsImRhdGFzZXQiLCJpbmRleCIsInN0YXJ0IiwiZW5kIiwidXBkYXRlSW1hZ2VzIiwic2Vjb25kcyIsImZvckVhY2giLCJjIiwibm9kZSIsImkiLCJsZW5ndGgiLCJwZXJjZW50YWdlIiwiZHVyYXRpb24iLCJjbGlwIiwidGltZXN0YW1wcyIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImxlZnQiLCJ3aWR0aCIsImNsYXNzTGlzdCIsImluZGljYXRvciIsImFwcGVuZENoaWxkIiwidGVtcGxhdGUiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Dialogues/Clipper/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Dialogues/Clipper/mixins/handleKey.js":
/*!************************************************************************************!*\
  !*** ./resources/js/components/Configurator/Dialogues/Clipper/mixins/handleKey.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"handleKey\": () => (/* binding */ handleKey),\n/* harmony export */   \"rwd\": () => (/* binding */ rwd),\n/* harmony export */   \"ffwd\": () => (/* binding */ ffwd)\n/* harmony export */ });\nvar update = function update(updateIndex) {\n  if (updateIndex > -1) {\n    this.raw.splice(updateIndex, 1, this.current);\n    this.raw.sort(function (a, b) {\n      return a > b;\n    });\n    this.calculateClips();\n  }\n\n  this.updateImages();\n  delete this.updateTimeout;\n};\n\nvar arrow = function arrow(e, back) {\n  var idx = this.raw.indexOf(this.current);\n  var canSkip = back ? canSkipBwd.call(this, idx) : canSkipFwd.call(this, idx);\n\n  if (e.ctrlKey && e.shiftKey && canSkip) {\n    jump.call(this, back ? idx - 1 : idx + 1);\n  } else if (e.ctrlKey != e.shiftKey) {\n    this[back ? \"rwd\" : \"ffwd\"](e.shiftKey ? 2000 : 5000);\n  } else {\n    this[back ? \"rwd\" : \"ffwd\"](1000 / this.fps);\n  }\n};\n\nvar jump = function jump(idx) {\n  if (typeof this.raw[idx] !== \"undefined\") {\n    this.current = this.raw[idx];\n  }\n};\n\nvar canSkipFwd = function canSkipFwd(idx) {\n  return !isLastClipEnd.call(this) && isClipEnd.call(this, idx);\n};\n\nvar canSkipBwd = function canSkipBwd(idx) {\n  return !isFirstClipStart.call(this) && isClipStart.call(this, idx);\n};\n\nvar isFirstClipStart = function isFirstClipStart() {\n  return this.raw[0] === this.current;\n};\n\nvar isLastClipEnd = function isLastClipEnd() {\n  return this.raw[this.raw.length - 1] === this.current;\n};\n\nvar isClipStart = function isClipStart(idx) {\n  return idx > -1 && idx % 2 === 0;\n};\n\nvar isClipEnd = function isClipEnd(idx) {\n  return idx > -1 && idx % 2 > 0;\n};\n\nvar handleKey = function handleKey(e) {\n  // console.log(this);\n  if (this.updateTimeout) {\n    clearTimeout(this.updateTimeout);\n  }\n\n  var action = false;\n  var updateIndex = e.altKey ? this.raw.indexOf(this.current) : -1;\n\n  switch (e.key) {\n    case \"ArrowRight\":\n      arrow.call(this, e);\n      action = true;\n      break;\n\n    case \"ArrowLeft\":\n      arrow.call(this, e, true);\n      action = true;\n      break;\n\n    case \"ArrowUp\":\n      this.ffwd(e.shiftKey ? 300000 : e.ctrlKey ? 600000 : 60000);\n      action = true;\n      break;\n\n    case \"ArrowDown\":\n      this.rwd(e.shiftKey ? 300000 : e.ctrlKey ? 600000 : 60000);\n      action = true;\n      break;\n\n    case \"+\":\n      this.add();\n      action = true;\n      break;\n\n    case \"-\":\n      {\n        this.remove();\n        action = true;\n        break;\n      }\n  }\n\n  if (action) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.updateTimeout = setTimeout(update.bind(this, updateIndex), 150);\n  }\n};\nvar rwd = function rwd(seconds) {\n  this.current = Math.max(this.start * 1000, this.current - seconds);\n};\nvar ffwd = function ffwd(seconds) {\n  this.current = Math.min(this.duration - 1000 / this.fps, this.current + seconds);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL0NsaXBwZXIvbWl4aW5zL2hhbmRsZUtleS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxJQUFNQSxNQUFNLEdBQUcsU0FBVEEsTUFBUyxDQUFVQyxXQUFWLEVBQXVCO0FBQ2xDLE1BQUlBLFdBQVcsR0FBRyxDQUFDLENBQW5CLEVBQXNCO0FBQ2xCLFNBQUtDLEdBQUwsQ0FBU0MsTUFBVCxDQUFnQkYsV0FBaEIsRUFBNkIsQ0FBN0IsRUFBZ0MsS0FBS0csT0FBckM7QUFDQSxTQUFLRixHQUFMLENBQVNHLElBQVQsQ0FBYyxVQUFDQyxDQUFELEVBQUlDLENBQUo7QUFBQSxhQUFVRCxDQUFDLEdBQUdDLENBQWQ7QUFBQSxLQUFkO0FBQ0EsU0FBS0MsY0FBTDtBQUNIOztBQUNELE9BQUtDLFlBQUw7QUFDQSxTQUFPLEtBQUtDLGFBQVo7QUFDSCxDQVJEOztBQVVBLElBQU1DLEtBQUssR0FBRyxTQUFSQSxLQUFRLENBQVVDLENBQVYsRUFBYUMsSUFBYixFQUFtQjtBQUM3QixNQUFNQyxHQUFHLEdBQUcsS0FBS1osR0FBTCxDQUFTYSxPQUFULENBQWlCLEtBQUtYLE9BQXRCLENBQVo7QUFDQSxNQUFNWSxPQUFPLEdBQUdILElBQUksR0FDZEksVUFBVSxDQUFDQyxJQUFYLENBQWdCLElBQWhCLEVBQXNCSixHQUF0QixDQURjLEdBRWRLLFVBQVUsQ0FBQ0QsSUFBWCxDQUFnQixJQUFoQixFQUFzQkosR0FBdEIsQ0FGTjs7QUFHQSxNQUFJRixDQUFDLENBQUNRLE9BQUYsSUFBYVIsQ0FBQyxDQUFDUyxRQUFmLElBQTJCTCxPQUEvQixFQUF3QztBQUNwQ00sSUFBQUEsSUFBSSxDQUFDSixJQUFMLENBQVUsSUFBVixFQUFnQkwsSUFBSSxHQUFHQyxHQUFHLEdBQUcsQ0FBVCxHQUFhQSxHQUFHLEdBQUcsQ0FBdkM7QUFDSCxHQUZELE1BRU8sSUFBSUYsQ0FBQyxDQUFDUSxPQUFGLElB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bXBvbmVudHMvQ29uZmlndXJhdG9yL0RpYWxvZ3Vlcy9DbGlwcGVyL21peGlucy9oYW5kbGVLZXkuanM/YWFkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1cGRhdGUgPSBmdW5jdGlvbiAodXBkYXRlSW5kZXgpIHtcbiAgICBpZiAodXBkYXRlSW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLnJhdy5zcGxpY2UodXBkYXRlSW5kZXgsIDEsIHRoaXMuY3VycmVudCk7XG4gICAgICAgIHRoaXMucmF3LnNvcnQoKGEsIGIpID0+IGEgPiBiKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVDbGlwcygpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUltYWdlcygpO1xuICAgIGRlbGV0ZSB0aGlzLnVwZGF0ZVRpbWVvdXQ7XG59O1xuXG5jb25zdCBhcnJvdyA9IGZ1bmN0aW9uIChlLCBiYWNrKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5yYXcuaW5kZXhPZih0aGlzLmN1cnJlbnQpO1xuICAgIGNvbnN0IGNhblNraXAgPSBiYWNrXG4gICAgICAgID8gY2FuU2tpcEJ3ZC5jYWxsKHRoaXMsIGlkeClcbiAgICAgICAgOiBjYW5Ta2lwRndkLmNhbGwodGhpcywgaWR4KTtcbiAgICBpZiAoZS5jdHJsS2V5ICYmIGUuc2hpZnRLZXkgJiYgY2FuU2tpcCkge1xuICAgICAgICBqdW1wLmNhbGwodGhpcywgYmFjayA/IGlkeCAtIDEgOiBpZHggKyAxKTtcbiAgICB9IGVsc2UgaWYgKGUuY3RybEtleSAhPSBlLnNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXNbYmFjayA/IFwicndkXCIgOiBcImZmd2RcIl0oZS5zaGlmdEtleSA/IDIwMDAgOiA1MDAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2JhY2sgPyBcInJ3ZFwiIDogXCJmZndkXCJdKDEwMDAgLyB0aGlzLmZwcyk7XG4gICAgfVxufTtcblxuY29uc3QganVtcCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMucmF3W2lkeF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5yYXdbaWR4XTtcbiAgICB9XG59O1xuXG5jb25zdCBjYW5Ta2lwRndkID0gZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiAhaXNMYXN0Q2xpcEVuZC5jYWxsKHRoaXMpICYmIGlzQ2xpcEVuZC5jYWxsKHRoaXMsIGlkeCk7XG59O1xuXG5jb25zdCBjYW5Ta2lwQndkID0gZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiAhaXNGaXJzdENsaXBTdGFydC5jYWxsKHRoaXMpICYmIGlzQ2xpcFN0YXJ0LmNhbGwodGhpcywgaWR4KTtcbn07XG5cbmNvbnN0IGlzRmlyc3RDbGlwU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmF3WzBdID09PSB0aGlzLmN1cnJlbnQ7XG59O1xuXG5jb25zdCBpc0xhc3RDbGlwRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJhd1t0aGlzLnJhdy5sZW5ndGggLSAxXSA9PT0gdGhpcy5jdXJyZW50O1xufTtcblxuY29uc3QgaXNDbGlwU3RhcnQgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA+IC0xICYmIGlkeCAlIDIgPT09IDA7XG59O1xuXG5jb25zdCBpc0NsaXBFbmQgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA+IC0xICYmIGlkeCAlIDIgPiAwO1xufTtcblxuZXhwb3J0IGNvbnN0IGhhbmRsZUtleSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gY29uc29sZS5sb2codGhpcyk7XG4gICAgaWYgKHRoaXMudXBkYXRlVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy51cGRhdGVUaW1lb3V0KTtcbiAgICB9XG4gICAgbGV0IGFjdGlvbiA9IGZhbHNlO1xuICAgIGNvbnN0IHVwZGF0ZUluZGV4ID0gZS5hbHRLZXkgPyB0aGlzLnJhdy5pbmRleE9mKHRoaXMuY3VycmVudCkgOiAtMTtcbiAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgICAgICBhcnJvdy5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgICAgICBhcnJvdy5jYWxsKHRoaXMsIGUsIHRydWUpO1xuICAgICAgICAgICAgYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgICAgdGhpcy5mZndkKGUuc2hpZnRLZXkgPyAzMDAwMDAgOiBlLmN0cmxLZXkgPyA2MDAwMDAgOiA2MDAwMCk7XG4gICAgICAgICAgICBhY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgICAgIHRoaXMucndkKGUuc2hpZnRLZXkgPyAzMDAwMDAgOiBlLmN0cmxLZXkgPyA2MDAwMDAgOiA2MDAwMCk7XG4gICAgICAgICAgICBhY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICB0aGlzLmFkZCgpO1xuICAgICAgICAgICAgYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHVwZGF0ZS5iaW5kKHRoaXMsIHVwZGF0ZUluZGV4KSwgMTUwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgcndkID0gZnVuY3Rpb24gKHNlY29uZHMpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBNYXRoLm1heCh0aGlzLnN0YXJ0ICogMTAwMCwgdGhpcy5jdXJyZW50IC0gc2Vjb25kcyk7XG59O1xuXG5leHBvcnQgY29uc3QgZmZ3ZCA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gTWF0aC5taW4oXG4gICAgICAgIHRoaXMuZHVyYXRpb24gLSAxMDAwIC8gdGhpcy5mcHMsXG4gICAgICAgIHRoaXMuY3VycmVudCArIHNlY29uZHNcbiAgICApO1xufTtcbiJdLCJuYW1lcyI6WyJ1cGRhdGUiLCJ1cGRhdGVJbmRleCIsInJhdyIsInNwbGljZSIsImN1cnJlbnQiLCJzb3J0IiwiYSIsImIiLCJjYWxjdWxhdGVDbGlwcyIsInVwZGF0ZUltYWdlcyIsInVwZGF0ZVRpbWVvdXQiLCJhcnJvdyIsImUiLCJiYWNrIiwiaWR4IiwiaW5kZXhPZiIsImNhblNraXAiLCJjYW5Ta2lwQndkIiwiY2FsbCIsImNhblNraXBGd2QiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJqdW1wIiwiZnBzIiwiaXNMYXN0Q2xpcEVuZCIsImlzQ2xpcEVuZCIsImlzRmlyc3RDbGlwU3RhcnQiLCJpc0NsaXBTdGFydCIsImxlbmd0aCIsImhhbmRsZUtleSIsImNsZWFyVGltZW91dCIsImFjdGlvbiIsImFsdEtleSIsImtleSIsImZmd2QiLCJyd2QiLCJhZGQiLCJyZW1vdmUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInNldFRpbWVvdXQiLCJiaW5kIiwic2Vjb25kcyIsIk1hdGgiLCJtYXgiLCJzdGFydCIsIm1pbiIsImR1cmF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Dialogues/Clipper/mixins/handleKey.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Dialogues/Concat.js":
/*!******************************************************************!*\
  !*** ./resources/js/components/Configurator/Dialogues/Concat.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar SKIP_CODECS = [\"dvb_teletext\", \"bin_data\"];\n\nvar Concat = /*#__PURE__*/function (_Slim) {\n  _inherits(Concat, _Slim);\n\n  var _super = _createSuper(Concat);\n\n  function Concat() {\n    _classCallCheck(this, Concat);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Concat, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this = this;\n\n      requestAnimationFrame(function () {\n        if (_this.deferredStreams) {\n          _this.streams = _this.deferredStreams;\n          delete _this.deferredStreams;\n        }\n\n        if (_this.deferredFiles) {\n          _this.files = _this.deferredFiles;\n          delete _this.deferredFiles;\n        }\n      });\n    }\n  }, {\n    key: \"streams\",\n    get: function get() {\n      if (!this.streamsContainer) return [];\n      return Array.from(this.streamsContainer.querySelectorAll(\"input\")).filter(function (i) {\n        return i.checked;\n      }).map(function (i) {\n        return JSON.parse(i.dataset.item);\n      });\n    },\n    set: function set(items) {\n      var _this2 = this;\n\n      if (!this.streamsContainer) {\n        this.deferredStreams = items;\n      } else {\n        this.emptyContainer(this.streamsContainer);\n        items.forEach(function (item) {\n          var l = document.createElement(\"label\");\n          var i = document.createElement(\"input\");\n          var s = document.createElement(\"span\");\n          s.innerText = \"\".concat(item.index, \" \").concat(item.codec_name);\n          i.type = \"checkbox\";\n          i.checked = SKIP_CODECS.indexOf(item.codec_name) < 0;\n          i.dataset.item = JSON.stringify(item);\n          l.appendChild(s);\n          l.appendChild(i);\n\n          _this2.streamsContainer.appendChild(l);\n        });\n      }\n    }\n  }, {\n    key: \"files\",\n    get: function get() {\n      if (!this.filesContainer) return [];\n      return Array.from(this.filesContainer.querySelectorAll(\"input\")).filter(function (i) {\n        return i.checked;\n      }).map(function (i) {\n        return JSON.parse(i.dataset.item);\n      });\n    },\n    set: function set(items) {\n      var _this3 = this;\n\n      if (!this.filesContainer) {\n        this.deferredFiles = items;\n      } else {\n        this.emptyContainer(this.filesContainer);\n        items.forEach(function (item) {\n          var l = document.createElement(\"label\");\n          var i = document.createElement(\"input\");\n          var s = document.createElement(\"span\");\n          s.innerText = \"\".concat(item.name);\n          i.type = \"checkbox\";\n          i.checked = true;\n          i.dataset.item = JSON.stringify(item);\n          l.appendChild(s);\n          l.appendChild(i);\n\n          _this3.filesContainer.appendChild(l);\n        });\n      }\n    }\n  }, {\n    key: \"emptyContainer\",\n    value: function emptyContainer(container) {\n      container.querySelectorAll(\"label\").forEach(function (l) {\n        return l.parentNode.removeChild(l);\n      });\n    }\n  }]);\n\n  return Concat;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nConcat.template =\n/*html*/\n\"\\n<style>\\n    :host {\\n        display: flex;\\n        flex-direction: column;\\n        gap: .5rem;\\n    }\\n    fieldset {\\n        border: 2px solid var(--clr-bg-200);\\n        padding: 1rem;\\n        background: var(--clr-bg-100);\\n        display: flex;\\n        flex-direction: column;\\n        gap: .5rem;\\n        border-radius: 0.25rem;\\n    }\\n    legend {\\n        background: var(--clr-bg-0);\\n        padding: .25rem;\\n        border-radius: 0.25rem;\\n    }\\n    label {\\n        display: flex;\\n        justify-content: space-between;\\n        gap: .5rem;\\n    }\\n    input {\\n        accent-color: var(--clr-enlightened);\\n    }\\n    input:checked {\\n        box-shadow: 0 0 10px 3px var(--clr-enlightened-glow);\\n    }\\n</style>\\n<fieldset #ref=\\\"filesContainer\\\">\\n    <legend>Files:</legend>\\n    <label>\\n        <span>{{ item.name }}</span><input type=\\\"checkbox\\\" value=\\\"{{  }}\\\">\\n    </label>\\n</fieldset>\\n<fieldset #ref=\\\"streamsContainer\\\">\\n    <legend>Streams:</legend>\\n    <label>\\n        <span>{{ item.name }}</span><input type=\\\"checkbox\\\" value=\\\"{{  }}\\\">\\n    </label>\\n</fieldset>\\n\";\ncustomElements.define(\"dialogue-concat\", Concat);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL0NvbmNhdC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBLElBQU1FLFdBQVcsR0FBRyxDQUFDLGNBQUQsRUFBaUIsVUFBakIsQ0FBcEI7O0lBRU1DOzs7Ozs7Ozs7Ozs7O1dBQ0YsbUJBQVU7QUFBQTs7QUFDTkMsTUFBQUEscUJBQXFCLENBQUMsWUFBTTtBQUN4QixZQUFJLEtBQUksQ0FBQ0MsZUFBVCxFQUEwQjtBQUN0QixlQUFJLENBQUNDLE9BQUwsR0FBZSxLQUFJLENBQUNELGVBQXBCO0FBQ0EsaUJBQU8sS0FBSSxDQUFDQSxlQUFaO0FBQ0g7O0FBQ0QsWUFBSSxLQUFJLENBQUNFLGFBQVQsRUFBd0I7QUFDcEIsZUFBSSxDQUFDQyxLQUFMLEdBQWEsS0FBSSxDQUFDRCxhQUFsQjtBQUNBLGlCQUFPLEtBQUksQ0FBQ0EsYUFBWjtBQUNIO0FBQ0osT0FUb0IsQ0FBckI7QUFVSDs7O1NBc0JELGVBQWM7QUFDVixVQUFJLENBQUMsS0FBS0UsZ0JBQVYsRUFBNEIsT0FBTyxFQUFQO0FBQzVCLGFBQU9DLEtBQUssQ0FBQ0MsSUFBTixDQUFXLEtBQUtGLGdCQUFMLENBQXNCRyxnQkFBdEIsQ0FBdUMsT0FBdkMsQ0FBWCxFQUNGQyxNQURFLENBQ0ssVUFBQ0MsQ0FBRDtBQUFBLGVBQU9BLENBQUMsQ0FBQ0MsT0FBVDtBQUFBLE9BREwsRUFFRkMsR0FGRSxDQUVFLFVBQUNGLENBQUQ7QUFBQSxlQUFPRyxJQUFJLENBQUNDLEtBQUwsQ0FBV0osQ0FBQyxDQUFDSyxPQUFGLENBQVVDLElBQXJCLENBQVA7QUFBQSxPQUZGLENBQVA7QUFHSDtTQXpCRCxhQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQ2YsVUFBSSxDQUFDLEtBQUtaLGdCQUFWLEVBQTRCO0FBQ3hCLGFBQUtKLGVBQUwsR0FBdUJnQixLQUF2QjtBQUNILE9BRkQsTUFFTztBQUNI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QUQ7QUFBQSxlQUFPQSxDQUFDLENBQUNjLFVBQUYsQ0FBYUMsV0FBYixDQUF5QmYsQ0FBekIsQ0FBUDtBQUFBLE9BRmI7QUFHSDs7OztFQXhFZ0J4Qjs7QUEyRXJCRyxNQUFNLENBQUNxQyxRQUFQO0FBQWtCO0FBQWxCO0FBK0NBQyxjQUFjLENBQUNDLE1BQWYsQ0FBc0IsaUJBQXRCLEVBQXlDdkMsTUFBekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL0NvbmNhdC5qcz82MjZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaW0sIFV0aWxzIH0gZnJvbSBcIkAvY29tcG9uZW50cy9saWJcIjtcblxuY29uc3QgU0tJUF9DT0RFQ1MgPSBbXCJkdmJfdGVsZXRleHRcIiwgXCJiaW5fZGF0YVwiXTtcblxuY2xhc3MgQ29uY2F0IGV4dGVuZHMgU2xpbSB7XG4gICAgb25BZGRlZCgpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmVycmVkU3RyZWFtcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtcyA9IHRoaXMuZGVmZXJyZWRTdHJlYW1zO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRlZmVycmVkU3RyZWFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmVycmVkRmlsZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVzID0gdGhpcy5kZWZlcnJlZEZpbGVzO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRlZmVycmVkRmlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldCBzdHJlYW1zKGl0ZW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW1zQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkU3RyZWFtcyA9IGl0ZW1zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbXB0eUNvbnRhaW5lcih0aGlzLnN0cmVhbXNDb250YWluZXIpO1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgcy5pbm5lclRleHQgPSBgJHtpdGVtLmluZGV4fSAke2l0ZW0uY29kZWNfbmFtZX1gO1xuICAgICAgICAgICAgICAgIGkudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgICAgICAgICBpLmNoZWNrZWQgPSBTS0lQX0NPREVDUy5pbmRleE9mKGl0ZW0uY29kZWNfbmFtZSkgPCAwO1xuICAgICAgICAgICAgICAgIGkuZGF0YXNldC5pdGVtID0gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgICAgICAgICAgICAgbC5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgICAgICAgICBsLmFwcGVuZENoaWxkKGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtc0NvbnRhaW5lci5hcHBlbmRDaGlsZChsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHN0cmVhbXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW1zQ29udGFpbmVyKSByZXR1cm4gW107XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3RyZWFtc0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIikpXG4gICAgICAgICAgICAuZmlsdGVyKChpKSA9PiBpLmNoZWNrZWQpXG4gICAgICAgICAgICAubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZGF0YXNldC5pdGVtKSk7XG4gICAgfVxuXG4gICAgc2V0IGZpbGVzKGl0ZW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5maWxlc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZEZpbGVzID0gaXRlbXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtcHR5Q29udGFpbmVyKHRoaXMuZmlsZXNDb250YWluZXIpO1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgcy5pbm5lclRleHQgPSBgJHtpdGVtLm5hbWV9YDtcbiAgICAgICAgICAgICAgICBpLnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgICAgICAgICAgaS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpLmRhdGFzZXQuaXRlbSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICAgICAgICAgICAgICAgIGwuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgICAgICAgbC5hcHBlbmRDaGlsZChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVzQ29udGFpbmVyLmFwcGVuZENoaWxkKGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZmlsZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5maWxlc0NvbnRhaW5lcikgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmZpbGVzQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGkpID0+IGkuY2hlY2tlZClcbiAgICAgICAgICAgIC5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5kYXRhc2V0Lml0ZW0pKTtcbiAgICB9XG5cbiAgICBlbXB0eUNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbChcImxhYmVsXCIpXG4gICAgICAgICAgICAuZm9yRWFjaCgobCkgPT4gbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGwpKTtcbiAgICB9XG59XG5cbkNvbmNhdC50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGdhcDogLjVyZW07XG4gICAgfVxuICAgIGZpZWxkc2V0IHtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgdmFyKC0tY2xyLWJnLTIwMCk7XG4gICAgICAgIHBhZGRpbmc6IDFyZW07XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWNsci1iZy0xMDApO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBnYXA6IC41cmVtO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xuICAgIH1cbiAgICBsZWdlbmQge1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMCk7XG4gICAgICAgIHBhZGRpbmc6IC4yNXJlbTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcbiAgICB9XG4gICAgbGFiZWwge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIGdhcDogLjVyZW07XG4gICAgfVxuICAgIGlucHV0IHtcbiAgICAgICAgYWNjZW50LWNvbG9yOiB2YXIoLS1jbHItZW5saWdodGVuZWQpO1xuICAgIH1cbiAgICBpbnB1dDpjaGVja2VkIHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggM3B4IHZhcigtLWNsci1lbmxpZ2h0ZW5lZC1nbG93KTtcbiAgICB9XG48L3N0eWxlPlxuPGZpZWxkc2V0ICNyZWY9XCJmaWxlc0NvbnRhaW5lclwiPlxuICAgIDxsZWdlbmQ+RmlsZXM6PC9sZWdlbmQ+XG4gICAgPGxhYmVsPlxuICAgICAgICA8c3Bhbj57eyBpdGVtLm5hbWUgfX08L3NwYW4+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwie3sgIH19XCI+XG4gICAgPC9sYWJlbD5cbjwvZmllbGRzZXQ+XG48ZmllbGRzZXQgI3JlZj1cInN0cmVhbXNDb250YWluZXJcIj5cbiAgICA8bGVnZW5kPlN0cmVhbXM6PC9sZWdlbmQ+XG4gICAgPGxhYmVsPlxuICAgICAgICA8c3Bhbj57eyBpdGVtLm5hbWUgfX08L3NwYW4+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwie3sgIH19XCI+XG4gICAgPC9sYWJlbD5cbjwvZmllbGRzZXQ+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJkaWFsb2d1ZS1jb25jYXRcIiwgQ29uY2F0KTtcbiJdLCJuYW1lcyI6WyJTbGltIiwiVXRpbHMiLCJTS0lQX0NPREVDUyIsIkNvbmNhdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRlZmVycmVkU3RyZWFtcyIsInN0cmVhbXMiLCJkZWZlcnJlZEZpbGVzIiwiZmlsZXMiLCJzdHJlYW1zQ29udGFpbmVyIiwiQXJyYXkiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsImZpbHRlciIsImkiLCJjaGVja2VkIiwibWFwIiwiSlNPTiIsInBhcnNlIiwiZGF0YXNldCIsIml0ZW0iLCJpdGVtcyIsImVtcHR5Q29udGFpbmVyIiwiZm9yRWFjaCIsImwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzIiwiaW5uZXJUZXh0IiwiaW5kZXgiLCJjb2RlY19uYW1lIiwidHlwZSIsImluZGV4T2YiLCJzdHJpbmdpZnkiLCJhcHBlbmRDaGlsZCIsImZpbGVzQ29udGFpbmVyIiwibmFtZSIsImNvbnRhaW5lciIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Dialogues/Concat.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Dialogues/Cropper/index.js":
/*!*************************************************************************!*\
  !*** ./resources/js/components/Configurator/Dialogues/Cropper/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VideoEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VideoEditor */ \"./resources/js/components/Configurator/Dialogues/VideoEditor/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar Cropper = /*#__PURE__*/function (_VideoEditor) {\n  _inherits(Cropper, _VideoEditor);\n\n  var _super = _createSuper(Cropper);\n\n  function Cropper() {\n    var _this;\n\n    _classCallCheck(this, Cropper);\n\n    _this = _super.call(this);\n    _this.cropOffsetTop = 0;\n    _this.cropOffsetLeft = 0;\n    _this.cropOffsetBottom = null;\n    _this.cropOffsetRight = null;\n    _this.video = null;\n    _this.aspectDecimal = 0;\n    _this.zoomed = 0;\n    _this.startCrop = false;\n    _this.valid = true;\n    return _this;\n  }\n\n  _createClass(Cropper, [{\n    key: \"bindListeners\",\n    value: function bindListeners() {\n      _get(_getPrototypeOf(Cropper.prototype), \"bindListeners\", this).call(this);\n\n      this.run = this.run.bind(this);\n      this.initCrop = this.initCrop.bind(this);\n      this.handleKey = this.handleKey.bind(this);\n      this.handleClick = this.handleClick.bind(this);\n      this.updateCropBox = this.updateCropBox.bind(this);\n    }\n  }, {\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(Cropper.prototype), \"onAdded\", this).call(this);\n\n      this.aspectDecimal = this.video.width / this.video.height;\n      requestAnimationFrame(function () {\n        var _parseInt;\n\n        _this2.image.addEventListener(\"load\", _this2.initCrop, {\n          once: true\n        });\n\n        _this2.runButton.disabled = true;\n        _this2.current = (_parseInt = parseInt(_this2.duration / 2, 10)) !== null && _parseInt !== void 0 ? _parseInt : 0;\n\n        _this2.initImages();\n\n        _this2.width = parseInt(_this2.video.width, 10);\n        _this2.height = parseInt(_this2.video.height, 10);\n      });\n    }\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved() {\n      this.image.removeEventListener(\"load\", this.updateCropBox);\n      document.removeEventListener(\"keydown\", this.handleKey);\n      document.removeEventListener(\"keyup\", this.handleKey);\n    }\n  }, {\n    key: \"initCrop\",\n    value: function initCrop() {\n      this.image.removeEventListener(\"load\", this.initCrop);\n      this.image.addEventListener(\"load\", this.updateCropBox);\n      document.addEventListener(\"keydown\", this.handleKey);\n      document.addEventListener(\"keyup\", this.handleKey);\n      this.cropImage.addEventListener(\"click\", this.handleClick);\n\n      if (this.cropOffsetBottom === null) {\n        this.cropOffsetBottom = this.image.naturalHeight;\n      }\n\n      if (this.cropOffsetRight === null) {\n        this.cropOffsetRight = this.image.naturalWidth;\n      }\n\n      this.updateCropBox();\n    }\n  }, {\n    key: \"updateCropBox\",\n    value: function updateCropBox() {\n      this.image.style.display = \"block\";\n\n      if (!this.zoomed) {\n        this.cropOverlay.style.width = \"\".concat(this.image.offsetWidth, \"px\");\n        this.cropOverlay.style.height = \"\".concat(this.image.offsetHeight, \"px\");\n      }\n\n      this.cropImage.style.backgroundImage = \"\".concat(this.gradients, \",url(\\\"\").concat(this.image.src, \"\\\")\");\n      this.image.style.display = \"none\";\n      this.info.classList.toggle(\"height-error\", (this.cropOffsetBottom - this.cropOffsetTop) % 16 !== 0);\n      this.validateDimensions();\n    }\n  }, {\n    key: \"validateDimensions\",\n    value: function validateDimensions() {\n      var croppedWidth = this.cropOffsetRight - this.cropOffsetLeft;\n      var croppedHeight = this.cropOffsetBottom - this.cropOffsetTop;\n      var ratios = this.aspectRatio.split(\":\").map(function (r) {\n        return parseInt(r, 10);\n      });\n      var padWidth = croppedHeight / ratios[1] * ratios[0];\n      this.valid = this.replaceBlackBorders || this.aspectRatio === \"custom\" || croppedHeight <= this.height && croppedWidth <= padWidth;\n      this.runButton.disabled = !this.valid;\n\n      if (this.aspectRatio === \"custom\") {\n        this.inputHeight.value = this.cropOffsetBottom - this.cropOffsetTop;\n      }\n    }\n  }, {\n    key: \"gradients\",\n    get: function get() {\n      var top = \"linear-gradient(180deg, var(--clr-cropper-gradient) \".concat(this.cropPercentTop, \"%, transparent \").concat(this.cropPercentTop, \"%)\");\n      var bottom = \"linear-gradient(180deg, transparent \".concat(this.cropPercentBottom, \"%, var(--clr-cropper-gradient) \").concat(this.cropPercentBottom, \"%)\");\n      var left = \"linear-gradient(90deg, var(--clr-cropper-gradient) \".concat(this.cropPercentLeft, \"%, transparent \").concat(this.cropPercentLeft, \"%)\");\n      var right = \"linear-gradient(90deg, transparent \".concat(this.cropPercentRight, \"%, var(--clr-cropper-gradient) \").concat(this.cropPercentRight, \"%)\");\n      return [top, bottom, left, right].join(\",\");\n    }\n  }, {\n    key: \"cropPercentTop\",\n    get: function get() {\n      return 100 / this.image.naturalHeight * this.cropOffsetTop;\n    }\n  }, {\n    key: \"cropPercentBottom\",\n    get: function get() {\n      return 100 / this.image.naturalHeight * this.cropOffsetBottom;\n    }\n  }, {\n    key: \"cropPercentLeft\",\n    get: function get() {\n      return 100 / this.image.naturalWidth * this.cropOffsetLeft;\n    }\n  }, {\n    key: \"cropPercentRight\",\n    get: function get() {\n      return 100 / this.image.naturalWidth * this.cropOffsetRight;\n    }\n  }, {\n    key: \"handleKey\",\n    value: function handleKey(e) {\n      var _this3 = this;\n\n      if (e.key === \"Control\" || e.key === \"Shift\") {\n        if (e.type === \"keydown\") {\n          this.cropImage.addEventListener(\"transitionend\", function () {\n            _this3.zoomed = e.key === \"Control\" ? 1 : 2;\n          }, {\n            once: true\n          });\n          this.cropImage.style.width = \"\".concat(this.image.naturalWidth, \"px\");\n          this.cropImage.style.height = \"\".concat(this.image.naturalHeight, \"px\");\n\n          if (e.key === \"Shift\") {\n            this.cropImage.style.inset = \"auto 0 0 auto\";\n          }\n        } else {\n          this.cropImage.addEventListener(\"transitionend\", function () {\n            _this3.cropImage.style.inset = \"\";\n            _this3.zoomed = 0;\n          }, {\n            once: true\n          });\n          this.cropImage.style.width = \"\";\n          this.cropImage.style.height = \"\";\n        }\n      }\n\n      if (e.ctrlKey && e.type === \"keydown\") {\n        if (e.key === \"ArrowRight\") {\n          e.preventDefault();\n          this.cropOffsetLeft = Math.min(Math.floor(this.image.naturalWidth / 2), this.cropOffsetLeft + 1);\n\n          if (this.equal) {\n            this.cropOffsetRight = Math.max(Math.floor(this.image.naturalWidth / 2), this.image.naturalWidth - this.cropOffsetLeft);\n          }\n\n          this.updateCropBox();\n        }\n\n        if (e.key === \"ArrowLeft\") {\n          e.preventDefault();\n          this.cropOffsetLeft = Math.max(0, this.cropOffsetLeft - 1);\n\n          if (this.equal) {\n            this.cropOffsetRight = Math.max(Math.floor(this.image.naturalWidth / 2), this.image.naturalWidth - this.cropOffsetLeft);\n          }\n\n          this.updateCropBox();\n        }\n\n        if (e.key === \"ArrowDown\") {\n          e.preventDefault();\n          this.cropOffsetTop = Math.min(Math.floor(this.image.naturalHeight / 2), this.cropOffsetTop + 1);\n\n          if (this.equal) {\n            this.cropOffsetBottom = Math.max(Math.floor(this.image.naturalHeight / 2), this.image.naturalHeight - this.cropOffsetTop);\n          }\n\n          this.updateCropBox();\n        }\n\n        if (e.key === \"ArrowUp\") {\n          e.preventDefault();\n          this.cropOffsetTop = Math.max(0, this.cropOffsetTop - 1);\n\n          if (this.equal) {\n            this.cropOffsetBottom = Math.min(this.image.naturalHeight, this.image.naturalHeight - this.cropOffsetTop);\n          }\n\n          this.updateCropBox();\n        }\n      }\n\n      if (e.shiftKey && e.type === \"keydown\") {\n        if (e.key === \"ArrowRight\") {\n          e.preventDefault();\n          this.cropOffsetRight = Math.min(this.image.naturalWidth, this.cropOffsetRight + 1);\n\n          if (this.equal) {\n            this.cropOffsetLeft = Math.max(0, this.image.naturalWidth - this.cropOffsetRight);\n          }\n\n          this.updateCropBox();\n        }\n\n        if (e.key === \"ArrowLeft\") {\n          e.preventDefault();\n          this.cropOffsetRight = Math.max(Math.floor(this.image.naturalWidth / 2), this.cropOffsetRight - 1);\n\n          if (this.equal) {\n            if (this.equal) {\n              this.cropOffsetLeft = Math.min(Math.floor(this.image.naturalWidth / 2), this.image.naturalWidth - this.cropOffsetRight);\n            }\n          }\n\n          this.updateCropBox();\n        }\n\n        if (e.key === \"ArrowDown\") {\n          e.preventDefault();\n          this.cropOffsetBottom = Math.min(this.image.naturalHeight, this.cropOffsetBottom + 1);\n\n          if (this.equal) {\n            this.cropOffsetTop = Math.max(0, this.image.naturalHeight - this.cropOffsetBottom);\n          }\n\n          this.updateCropBox();\n        }\n\n        if (e.key === \"ArrowUp\") {\n          e.preventDefault();\n          this.cropOffsetBottom = Math.max(Math.floor(this.image.naturalHeight / 2), this.cropOffsetBottom - 1);\n\n          if (this.equal) {\n            this.cropOffsetTop = Math.min(Math.floor(this.image.naturalHeight / 2), this.image.naturalHeight - this.cropOffsetBottom);\n          }\n\n          this.updateCropBox();\n        }\n      }\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this4 = this;\n\n      console.log(e);\n      requestAnimationFrame(function () {\n        var imageRect = _this4.cropImage.getBoundingClientRect();\n\n        if (_this4.zoomed === 1) {\n          _this4.cropOffsetLeft = parseInt(e.pageX - imageRect.left);\n          _this4.cropOffsetTop = parseInt(e.pageY - imageRect.top);\n        } else if (_this4.zoomed === 2) {\n          _this4.cropOffsetBottom = parseInt(e.pageY - imageRect.top);\n          _this4.cropOffsetRight = parseInt(e.pageX - imageRect.left);\n        }\n\n        _this4.updateCropBox();\n      });\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      this.startCrop = true;\n      this.parentNode.confirmAction();\n    }\n  }, {\n    key: \"aspectRatio\",\n    get: function get() {\n      var _this$shadowRoot$quer, _this$shadowRoot$quer2;\n\n      return (_this$shadowRoot$quer = (_this$shadowRoot$quer2 = this.shadowRoot.querySelector('[name=\"input-aspect\"]:checked')) === null || _this$shadowRoot$quer2 === void 0 ? void 0 : _this$shadowRoot$quer2.value) !== null && _this$shadowRoot$quer !== void 0 ? _this$shadowRoot$quer : this.video.display_aspect_ratio;\n    },\n    set: function set(value) {\n      if ([\"4:3\", \"16:9\"].indexOf(value) > -1) {\n        this.shadowRoot.querySelector(\"[name=\\\"input-aspect\\\"][value=\\\"\".concat(value, \"\\\"]\")).checked = true;\n      } else if (value.match(/([0-9]+):([0-9]+)/)) {\n        this.shadowRoot.querySelector(\"[name=\\\"input-aspect\\\"][value=\\\"custom\\\"]\").checked = true;\n      }\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return parseInt(this.inputWidth.value, 10);\n    },\n    set: function set(value) {\n      if (value instanceof InputEvent) {\n        this.inputWidth.value = parseInt(value.target.value, 10);\n      } else {\n        this.inputWidth.value = parseInt(value, 10);\n      }\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return parseInt(this.inputHeight.value, 10);\n    },\n    set: function set(value) {\n      if (value instanceof InputEvent) {\n        this.inputHeight.value = parseInt(value.target.value, 10);\n      } else {\n        this.inputHeight.value = parseInt(value, 10);\n      }\n    }\n  }, {\n    key: \"replaceBlackBorders\",\n    get: function get() {\n      return this.inputReplaceBlackBorders.checked;\n    }\n  }, {\n    key: \"equal\",\n    get: function get() {\n      return this.inputEqual.checked;\n    }\n  }, {\n    key: \"crop\",\n    get: function get() {\n      return {\n        cw: this.cropOffsetRight - this.cropOffsetLeft,\n        ch: this.cropOffsetBottom - this.cropOffsetTop,\n        cx: this.cropOffsetLeft,\n        cy: this.cropOffsetTop,\n        width: this.width,\n        height: this.height,\n        aspect: this.aspectRatio === \"custom\" ? \"\".concat(this.cropOffsetRight - this.cropOffsetLeft, \":\").concat(this.cropOffsetBottom - this.cropOffsetTop) : this.aspectRatio,\n        type: this.type,\n        replaceBlackBorders: this.replaceBlackBorders,\n        mirror: this.inputMirror.checked\n      };\n    },\n    set: function set(crop) {\n      var _crop$cy, _crop$cx;\n\n      this.cropOffsetTop = (_crop$cy = crop.cy) !== null && _crop$cy !== void 0 ? _crop$cy : 0;\n      this.cropOffsetLeft = (_crop$cx = crop.cx) !== null && _crop$cx !== void 0 ? _crop$cx : 0;\n\n      if (typeof crop.cy !== \"undefined\" && typeof crop.ch !== \"undefined\") {\n        this.cropOffsetBottom = crop.cy + crop.ch;\n      }\n\n      if (typeof crop.cx !== \"undefined\" && typeof crop.cw !== \"undefined\") {\n        this.cropOffsetRight = crop.cx + crop.cw;\n      }\n    }\n  }]);\n\n  return Cropper;\n}(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.VideoEditor);\n\nCropper.template =\n/*html*/\n\"\\n\".concat(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.EDITOR_CSS, \"\\n<style>\\n    .toggle-aspect {\\n        display: none;\\n    }\\n    .crop {\\n        box-sizing: border-box;\\n        grid-area: frame;\\n        border: 0 solid hsla(0 50% 50% / .5);\\n        justify-self: center;\\n        cursor: crosshair;\\n        position: relative;\\n        overflow: hidden;\\n    }\\n    .crop div {\\n        position: absolute;\\n        inset: 0 auto auto 0;\\n        width: 100%;\\n        height: 100%;\\n        transition: 250ms ease-in-out;\\n        background-size: 100%;\\n        background-blend-mode: lighten;\\n    }\\n\\n    .info {\\n        grid-area: left;\\n        display: grid;\\n        grid-auto-rows: min-content;\\n        gap: .5rem;\\n        font-size: .75rem;\\n        white-space: nowrap;\\n        width: 250px;\\n    }\\n    fieldset {\\n        border: 2px solid var(--clr-bg-200);\\n        padding: .5rem;\\n        background: var(--clr-bg-100);\\n        display: flex;\\n        flex-direction: column;\\n        gap: .5rem;\\n        border-radius: 0.25rem;\\n    }\\n    legend {\\n        background: var(--clr-bg-0);\\n        padding: .25rem;\\n        border-radius: 0.25rem;\\n    }\\n    label {\\n        display: flex;\\n        justify-content: space-between;\\n        gap: .5rem;\\n    }\\n    input {\\n        accent-color: var(--clr-enlightened);\\n    }\\n    input:checked {\\n        box-shadow: 0 0 10px 3px var(--clr-enlightened-glow);\\n    }\\n    .info .warning {\\n        opacity: 0;\\n        font-size: 1.5rem;\\n        color: hsl(var(--hue-warning) var(--sat-alert) var(--lit-alert));\\n        transition: opacity var(--transition-medium) ease-in-out;\\n        transform: scale(0);\\n    }\\n    .info .error {\\n        white-space: normal;\\n        background: hsl(var(--hue-error) var(--sat-alert) var(--lit-alert));\\n        padding: .5rem;\\n        border-radius: .25rem;\\n    }\\n    .height-error .height-warning {\\n        opacity: 1;\\n        transform: scale(1);\\n    }\\n    input[type=\\\"number\\\"] {\\n        max-width: 4rem;\\n    }\\n    .help dl {\\n        display: grid;\\n        grid-template-columns: auto 1fr;\\n        grid-column-gap: .5rem;\\n    }\\n    .help dd {\\n        margin: 0;\\n    }\\n</style>\\n\").concat(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.EDITOR_TEMPLATE, \"\\n<div #ref=\\\"cropOverlay\\\" class=\\\"crop\\\"><div #ref=\\\"cropImage\\\"></div></div>\\n<div class=\\\"info\\\" #ref=\\\"info\\\">\\n    <div *if=\\\"{{ !this.valid }}\\\" class=\\\"error\\\">\\n        Resulting video does not fit into target aspect ratio;\\n    </div>\\n    <fieldset>\\n        <legend>Scale:</legend>\\n        <label>\\n            <span>Width:</span>\\n            <input type=\\\"number\\\" #ref=\\\"inputWidth\\\">\\n        </label>\\n        <label>\\n            <span>Height:</span>\\n            <input type=\\\"number\\\" #ref=\\\"inputHeight\\\">\\n        </label>\\n        <label>\\n            <span>Replace Borders</span>\\n            <input type=\\\"checkbox\\\" name=\\\"replaceBlackBorders\\\" #ref=\\\"inputReplaceBlackBorders\\\" @change=\\\"{{ this.validateDimensions() }}\\\">\\n        </label>\\n        <label>\\n            <span>Mirror</span>\\n            <input type=\\\"checkbox\\\" name=\\\"mirror\\\" #ref=\\\"inputMirror\\\">\\n        </label>\\n        <label>\\n            <span>Equal Borders</span>\\n            <input type=\\\"checkbox\\\" name=\\\"equal\\\" #ref=\\\"inputEqual\\\" checked=\\\"checked\\\">\\n        </label>\\n    </fieldset>\\n    <fieldset class=\\\"aspect-ratio\\\">\\n        <legend>Aspect Ratio:</legend>\\n        <label>\\n            <span>4:3</span>\\n            <input type=\\\"radio\\\" name=\\\"input-aspect\\\" value=\\\"4:3\\\" @change=\\\"{{ this.validateDimensions() }}\\\">\\n        </label>\\n        <label>\\n            <span>16:9</span>\\n            <input type=\\\"radio\\\" name=\\\"input-aspect\\\" value=\\\"16:9\\\" @change=\\\"{{ this.validateDimensions() }}\\\">\\n        </label>\\n        <label>\\n            <span>Custom ({{ this.cropOffsetRight - this.cropOffsetLeft }}x{{ this.cropOffsetBottom - this.cropOffsetTop }})</span>\\n            <input type=\\\"radio\\\" name=\\\"input-aspect\\\" value=\\\"custom\\\" @change=\\\"{{ this.validateDimensions() }}\\\">\\n        </label>\\n    </fieldset>\\n    <fieldset>\\n        <legend>Crop Box:</legend>\\n        <label><span>w:h</span><span>{{ this.cropOffsetRight - this.cropOffsetLeft }}:{{ this.cropOffsetBottom - this.cropOffsetTop }}</span></label>\\n        <label><span>x:y</span><span>{{ this.cropOffsetLeft }}:{{ this.cropOffsetTop }}</span></label>\\n    </fieldset>\\n    <div class=\\\"help\\\">\\n        <dl>\\n            <dt>\\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-mouse\\\"></span> / \\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-vertical-bold\\\"></span>\\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-horizontal-bold\\\"></span> + Ctrl\\n            </dt>\\n            </dt>\\n            <dd>Set upper left</dd>\\n        </dl>\\n        <dl>\\n            <dt>\\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-mouse\\\"></span> / \\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-vertical-bold\\\"></span>\\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-horizontal-bold\\\"></span> + Shift\\n            </dt>\\n            <dd>Set lower right</dd>\\n        </dl>\\n    </div>\\n    <div *v-if=\\\"{{ this.divisionBySixteenError }}\\\" class=\\\"warning height-warning\\\" title=\\\"For best results height should be dividable by 16\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-alert-outline\\\"></span>\\n    </div>\\n</div>\\n<theme-button #ref=\\\"runButton\\\" class=\\\"run\\\" @click=\\\"{{ this.run }}\\\">Start</theme-button>\\n\");\ncustomElements.define(\"dialogue-cropper\", Cropper);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL0Nyb3BwZXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztJQUVNRzs7Ozs7QUFDRixxQkFBYztBQUFBOztBQUFBOztBQUNWO0FBQ0EsVUFBS0MsYUFBTCxHQUFxQixDQUFyQjtBQUNBLFVBQUtDLGNBQUwsR0FBc0IsQ0FBdEI7QUFDQSxVQUFLQyxnQkFBTCxHQUF3QixJQUF4QjtBQUNBLFVBQUtDLGVBQUwsR0FBdUIsSUFBdkI7QUFDQSxVQUFLQyxLQUFMLEdBQWEsSUFBYjtBQUNBLFVBQUtDLGFBQUwsR0FBcUIsQ0FBckI7QUFDQSxVQUFLQyxNQUFMLEdBQWMsQ0FBZDtBQUNBLFVBQUtDLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxVQUFLQyxLQUFMLEdBQWEsSUFBYjtBQVZVO0FBV2I7Ozs7V0FFRCx5QkFBZ0I7QUFDWjs7QUFDQSxXQUFLQyxHQUFMLEdBQVcsS0FBS0EsR0FBTCxDQUFTQyxJQUFULENBQWMsSUFBZCxDQUFYO0FBQ0EsV0FBS0MsUUFBTCxHQUFnQixLQUFLQSxRQUFMLENBQWNELElBQWQsQ0FBbUIsSUFBbkIsQ0FBaEI7QUFDQSxXQUFLRSxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsQ0FBZUYsSUFBZixDQUFvQixJQUFwQixDQUFqQjtBQUNBLFdBQUtHLFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQkgsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBbkI7QUFDQSxXQUFLSSxhQUFMLEdBQXFCLEtBQUtBLGFBQUwsQ0FBbUJKLElBQW5CLENBQXdCLElBQXhCLENBQXJCO0FBQ0g7OztXQUVELG1CQUFVO0FBQUE7O0FBQ047O0FBQ0EsV0FBS0wsYUFBTCxHQUFxQixLQUFLRCxLQUFMLENBQVdXLEtBQVgsR0FBbUIsS0FBS1gsS0FBTCxDQUFXWSxNQUFuRDtBQUNBQyxNQUFBQSxxQkFBcUIsQ0FBQyxZQUFNO0FBQUE7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T0ksSUFBSSxDQUFDTixFQUFaLEtBQW1CLFdBQXpELEVBQXNFO0FBQ2xFLGFBQUs5RixnQkFBTCxHQUF3Qm9HLElBQUksQ0FBQ0osRUFBTCxHQUFVSSxJQUFJLENBQUNOLEVBQXZDO0FBQ0g7O0FBQ0QsVUFBSSxPQUFPTSxJQUFJLENBQUNMLEVBQVosS0FBbUIsV0FBbkIsSUFBa0MsT0FBT0ssSUFBSSxDQUFDUCxFQUFaLEtBQW1CLFdBQXpELEVBQXNFO0FBQ2xFLGFBQUs1RixlQUFMLEdBQXVCbUcsSUFBSSxDQUFDTCxFQUFMLEdBQVVLLElBQUksQ0FBQ1AsRUFBdEM7QUFDSDtBQUNKOzs7O0VBbldpQm5HOztBQXNXdEJHLE9BQU8sQ0FBQ3dHLFFBQVI7QUFBbUI7QUFBbkIsWUFDRXpHLG9EQURGLCtuRUF3RkVELHlEQXhGRjtBQW1LQTJHLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixrQkFBdEIsRUFBMEMxRyxPQUExQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9EaWFsb2d1ZXMvQ3JvcHBlci9pbmRleC5qcz82MzY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZpZGVvRWRpdG9yLCBFRElUT1JfVEVNUExBVEUsIEVESVRPUl9DU1MgfSBmcm9tIFwiLi4vVmlkZW9FZGl0b3JcIjtcblxuY2xhc3MgQ3JvcHBlciBleHRlbmRzIFZpZGVvRWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jcm9wT2Zmc2V0VG9wID0gMDtcbiAgICAgICAgdGhpcy5jcm9wT2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgIHRoaXMuY3JvcE9mZnNldEJvdHRvbSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3JvcE9mZnNldFJpZ2h0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWRlbyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXNwZWN0RGVjaW1hbCA9IDA7XG4gICAgICAgIHRoaXMuem9vbWVkID0gMDtcbiAgICAgICAgdGhpcy5zdGFydENyb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgc3VwZXIuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnJ1biA9IHRoaXMucnVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdENyb3AgPSB0aGlzLmluaXRDcm9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5ID0gdGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGljayA9IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVDcm9wQm94ID0gdGhpcy51cGRhdGVDcm9wQm94LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgb25BZGRlZCgpIHtcbiAgICAgICAgc3VwZXIub25BZGRlZCgpO1xuICAgICAgICB0aGlzLmFzcGVjdERlY2ltYWwgPSB0aGlzLnZpZGVvLndpZHRoIC8gdGhpcy52aWRlby5oZWlnaHQ7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuaW5pdENyb3AsIHtcbiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBwYXJzZUludCh0aGlzLmR1cmF0aW9uIC8gMiwgMTApID8/IDA7XG4gICAgICAgICAgICB0aGlzLmluaXRJbWFnZXMoKTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBwYXJzZUludCh0aGlzLnZpZGVvLndpZHRoLCAxMCk7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHBhcnNlSW50KHRoaXMudmlkZW8uaGVpZ2h0LCAxMCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uUmVtb3ZlZCgpIHtcbiAgICAgICAgdGhpcy5pbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLnVwZGF0ZUNyb3BCb3gpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmhhbmRsZUtleSk7XG4gICAgfVxuXG4gICAgaW5pdENyb3AoKSB7XG4gICAgICAgIHRoaXMuaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5pbml0Q3JvcCk7XG4gICAgICAgIHRoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy51cGRhdGVDcm9wQm94KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXkpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVLZXkpO1xuICAgICAgICB0aGlzLmNyb3BJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICAgIGlmICh0aGlzLmNyb3BPZmZzZXRCb3R0b20gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3JvcE9mZnNldEJvdHRvbSA9IHRoaXMuaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jcm9wT2Zmc2V0UmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3JvcE9mZnNldFJpZ2h0ID0gdGhpcy5pbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVDcm9wQm94KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQ3JvcEJveCgpIHtcbiAgICAgICAgdGhpcy5pbWFnZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICBpZiAoIXRoaXMuem9vbWVkKSB7XG4gICAgICAgICAgICB0aGlzLmNyb3BPdmVybGF5LnN0eWxlLndpZHRoID0gYCR7dGhpcy5pbWFnZS5vZmZzZXRXaWR0aH1weGA7XG4gICAgICAgICAgICB0aGlzLmNyb3BPdmVybGF5LnN0eWxlLmhlaWdodCA9IGAke3RoaXMuaW1hZ2Uub2Zmc2V0SGVpZ2h0fXB4YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyb3BJbWFnZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgJHt0aGlzLmdyYWRpZW50c30sdXJsKFwiJHt0aGlzLmltYWdlLnNyY31cIilgO1xuICAgICAgICB0aGlzLmltYWdlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5pbmZvLmNsYXNzTGlzdC50b2dnbGUoXG4gICAgICAgICAgICBcImhlaWdodC1lcnJvclwiLFxuICAgICAgICAgICAgKHRoaXMuY3JvcE9mZnNldEJvdHRvbSAtIHRoaXMuY3JvcE9mZnNldFRvcCkgJSAxNiAhPT0gMFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnZhbGlkYXRlRGltZW5zaW9ucygpO1xuICAgIH1cblxuICAgIHZhbGlkYXRlRGltZW5zaW9ucygpIHtcbiAgICAgICAgY29uc3QgY3JvcHBlZFdpZHRoID0gdGhpcy5jcm9wT2Zmc2V0UmlnaHQgLSB0aGlzLmNyb3BPZmZzZXRMZWZ0O1xuICAgICAgICBjb25zdCBjcm9wcGVkSGVpZ2h0ID0gdGhpcy5jcm9wT2Zmc2V0Qm90dG9tIC0gdGhpcy5jcm9wT2Zmc2V0VG9wO1xuICAgICAgICBjb25zdCByYXRpb3MgPSB0aGlzLmFzcGVjdFJhdGlvLnNwbGl0KFwiOlwiKS5tYXAoKHIpID0+IHBhcnNlSW50KHIsIDEwKSk7XG4gICAgICAgIGNvbnN0IHBhZFdpZHRoID0gKGNyb3BwZWRIZWlnaHQgLyByYXRpb3NbMV0pICogcmF0aW9zWzBdO1xuICAgICAgICB0aGlzLnZhbGlkID1cbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUJsYWNrQm9yZGVycyB8fFxuICAgICAgICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9PT0gXCJjdXN0b21cIiB8fFxuICAgICAgICAgICAgKGNyb3BwZWRIZWlnaHQgPD0gdGhpcy5oZWlnaHQgJiYgY3JvcHBlZFdpZHRoIDw9IHBhZFdpZHRoKTtcbiAgICAgICAgdGhpcy5ydW5CdXR0b24uZGlzYWJsZWQgPSAhdGhpcy52YWxpZDtcbiAgICAgICAgaWYgKHRoaXMuYXNwZWN0UmF0aW8gPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRIZWlnaHQudmFsdWUgPSB0aGlzLmNyb3BPZmZzZXRCb3R0b20gLSB0aGlzLmNyb3BPZmZzZXRUb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZ3JhZGllbnRzKCkge1xuICAgICAgICBsZXQgdG9wID0gYGxpbmVhci1ncmFkaWVudCgxODBkZWcsIHZhcigtLWNsci1jcm9wcGVyLWdyYWRpZW50KSAke3RoaXMuY3JvcFBlcmNlbnRUb3B9JSwgdHJhbnNwYXJlbnQgJHt0aGlzLmNyb3BQZXJjZW50VG9wfSUpYDtcbiAgICAgICAgbGV0IGJvdHRvbSA9IGBsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCB0cmFuc3BhcmVudCAke3RoaXMuY3JvcFBlcmNlbnRCb3R0b219JSwgdmFyKC0tY2xyLWNyb3BwZXItZ3JhZGllbnQpICR7dGhpcy5jcm9wUGVyY2VudEJvdHRvbX0lKWA7XG4gICAgICAgIGxldCBsZWZ0ID0gYGxpbmVhci1ncmFkaWVudCg5MGRlZywgdmFyKC0tY2xyLWNyb3BwZXItZ3JhZGllbnQpICR7dGhpcy5jcm9wUGVyY2VudExlZnR9JSwgdHJhbnNwYXJlbnQgJHt0aGlzLmNyb3BQZXJjZW50TGVmdH0lKWA7XG4gICAgICAgIGxldCByaWdodCA9IGBsaW5lYXItZ3JhZGllbnQoOTBkZWcsIHRyYW5zcGFyZW50ICR7dGhpcy5jcm9wUGVyY2VudFJpZ2h0fSUsIHZhcigtLWNsci1jcm9wcGVyLWdyYWRpZW50KSAke3RoaXMuY3JvcFBlcmNlbnRSaWdodH0lKWA7XG4gICAgICAgIHJldHVybiBbdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0XS5qb2luKFwiLFwiKTtcbiAgICB9XG5cbiAgICBnZXQgY3JvcFBlcmNlbnRUb3AoKSB7XG4gICAgICAgIHJldHVybiAoMTAwIC8gdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0KSAqIHRoaXMuY3JvcE9mZnNldFRvcDtcbiAgICB9XG5cbiAgICBnZXQgY3JvcFBlcmNlbnRCb3R0b20oKSB7XG4gICAgICAgIHJldHVybiAoMTAwIC8gdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0KSAqIHRoaXMuY3JvcE9mZnNldEJvdHRvbTtcbiAgICB9XG5cbiAgICBnZXQgY3JvcFBlcmNlbnRMZWZ0KCkge1xuICAgICAgICByZXR1cm4gKDEwMCAvIHRoaXMuaW1hZ2UubmF0dXJhbFdpZHRoKSAqIHRoaXMuY3JvcE9mZnNldExlZnQ7XG4gICAgfVxuXG4gICAgZ2V0IGNyb3BQZXJjZW50UmlnaHQoKSB7XG4gICAgICAgIHJldHVybiAoMTAwIC8gdGhpcy5pbWFnZS5uYXR1cmFsV2lkdGgpICogdGhpcy5jcm9wT2Zmc2V0UmlnaHQ7XG4gICAgfVxuXG4gICAgaGFuZGxlS2V5KGUpIHtcbiAgICAgICAgaWYgKGUua2V5ID09PSBcIkNvbnRyb2xcIiB8fCBlLmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBcImtleWRvd25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JvcEltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb21lZCA9IGUua2V5ID09PSBcIkNvbnRyb2xcIiA/IDEgOiAyO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wSW1hZ2Uuc3R5bGUud2lkdGggPSBgJHt0aGlzLmltYWdlLm5hdHVyYWxXaWR0aH1weGA7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wSW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0fXB4YDtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiU2hpZnRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3BJbWFnZS5zdHlsZS5pbnNldCA9IFwiYXV0byAwIDAgYXV0b1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2l0aW9uZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JvcEltYWdlLnN0eWxlLmluc2V0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbWVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JvcEltYWdlLnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3BJbWFnZS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlLmN0cmxLZXkgJiYgZS50eXBlID09PSBcImtleWRvd25cIikge1xuICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkFycm93UmlnaHRcIikge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3BPZmZzZXRMZWZ0ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5pbWFnZS5uYXR1cmFsV2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0TGVmdCArIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JvcE9mZnNldFJpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuaW1hZ2UubmF0dXJhbFdpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlLm5hdHVyYWxXaWR0aCAtIHRoaXMuY3JvcE9mZnNldExlZnRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDcm9wQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0TGVmdCA9IE1hdGgubWF4KDAsIHRoaXMuY3JvcE9mZnNldExlZnQgLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3BPZmZzZXRSaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmltYWdlLm5hdHVyYWxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5uYXR1cmFsV2lkdGggLSB0aGlzLmNyb3BPZmZzZXRMZWZ0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3JvcEJveCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkFycm93RG93blwiKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JvcE9mZnNldFRvcCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuaW1hZ2UubmF0dXJhbEhlaWdodCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3BPZmZzZXRUb3AgKyAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3BPZmZzZXRCb3R0b20gPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0IC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlLm5hdHVyYWxIZWlnaHQgLSB0aGlzLmNyb3BPZmZzZXRUb3BcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDcm9wQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JvcE9mZnNldFRvcCA9IE1hdGgubWF4KDAsIHRoaXMuY3JvcE9mZnNldFRvcCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JvcE9mZnNldEJvdHRvbSA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0IC0gdGhpcy5jcm9wT2Zmc2V0VG9wXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3JvcEJveCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlLnNoaWZ0S2V5ICYmIGUudHlwZSA9PT0gXCJrZXlkb3duXCIpIHtcbiAgICAgICAgICAgIGlmIChlLmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0UmlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JvcE9mZnNldFJpZ2h0ICsgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0TGVmdCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UubmF0dXJhbFdpZHRoIC0gdGhpcy5jcm9wT2Zmc2V0UmlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDcm9wQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0UmlnaHQgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmltYWdlLm5hdHVyYWxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3BPZmZzZXRSaWdodCAtIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0TGVmdCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmltYWdlLm5hdHVyYWxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5uYXR1cmFsV2lkdGggLSB0aGlzLmNyb3BPZmZzZXRSaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDcm9wQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0Qm90dG9tID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UubmF0dXJhbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0Qm90dG9tICsgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0VG9wID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0IC0gdGhpcy5jcm9wT2Zmc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3JvcEJveCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkFycm93VXBcIikge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3BPZmZzZXRCb3R0b20gPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmltYWdlLm5hdHVyYWxIZWlnaHQgLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0Qm90dG9tIC0gMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0VG9wID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuaW1hZ2UubmF0dXJhbEhlaWdodCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0IC0gdGhpcy5jcm9wT2Zmc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3JvcEJveCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xpY2soZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlUmVjdCA9IHRoaXMuY3JvcEltYWdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuem9vbWVkID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0TGVmdCA9IHBhcnNlSW50KGUucGFnZVggLSBpbWFnZVJlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0VG9wID0gcGFyc2VJbnQoZS5wYWdlWSAtIGltYWdlUmVjdC50b3ApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnpvb21lZCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JvcE9mZnNldEJvdHRvbSA9IHBhcnNlSW50KGUucGFnZVkgLSBpbWFnZVJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3BPZmZzZXRSaWdodCA9IHBhcnNlSW50KGUucGFnZVggLSBpbWFnZVJlY3QubGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNyb3BCb3goKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcnVuKCkge1xuICAgICAgICB0aGlzLnN0YXJ0Q3JvcCA9IHRydWU7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5jb25maXJtQWN0aW9uKCk7XG4gICAgfVxuXG4gICAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPVwiaW5wdXQtYXNwZWN0XCJdOmNoZWNrZWQnKVxuICAgICAgICAgICAgICAgID8udmFsdWUgPz8gdGhpcy52aWRlby5kaXNwbGF5X2FzcGVjdF9yYXRpb1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldCBhc3BlY3RSYXRpbyh2YWx1ZSkge1xuICAgICAgICBpZiAoW1wiNDozXCIsIFwiMTY6OVwiXS5pbmRleE9mKHZhbHVlKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICBgW25hbWU9XCJpbnB1dC1hc3BlY3RcIl1bdmFsdWU9XCIke3ZhbHVlfVwiXWBcbiAgICAgICAgICAgICkuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubWF0Y2goLyhbMC05XSspOihbMC05XSspLykpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgIGBbbmFtZT1cImlucHV0LWFzcGVjdFwiXVt2YWx1ZT1cImN1c3RvbVwiXWBcbiAgICAgICAgICAgICkuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLmlucHV0V2lkdGgudmFsdWUsIDEwKTtcbiAgICB9XG5cbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW5wdXRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFdpZHRoLnZhbHVlID0gcGFyc2VJbnQodmFsdWUudGFyZ2V0LnZhbHVlLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0V2lkdGgudmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuaW5wdXRIZWlnaHQudmFsdWUsIDEwKTtcbiAgICB9XG5cbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElucHV0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRIZWlnaHQudmFsdWUgPSBwYXJzZUludCh2YWx1ZS50YXJnZXQudmFsdWUsIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRIZWlnaHQudmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHJlcGxhY2VCbGFja0JvcmRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0UmVwbGFjZUJsYWNrQm9yZGVycy5jaGVja2VkO1xuICAgIH1cblxuICAgIGdldCBlcXVhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRFcXVhbC5jaGVja2VkO1xuICAgIH1cblxuICAgIGdldCBjcm9wKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3c6IHRoaXMuY3JvcE9mZnNldFJpZ2h0IC0gdGhpcy5jcm9wT2Zmc2V0TGVmdCxcbiAgICAgICAgICAgIGNoOiB0aGlzLmNyb3BPZmZzZXRCb3R0b20gLSB0aGlzLmNyb3BPZmZzZXRUb3AsXG4gICAgICAgICAgICBjeDogdGhpcy5jcm9wT2Zmc2V0TGVmdCxcbiAgICAgICAgICAgIGN5OiB0aGlzLmNyb3BPZmZzZXRUb3AsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBhc3BlY3Q6XG4gICAgICAgICAgICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9PT0gXCJjdXN0b21cIlxuICAgICAgICAgICAgICAgICAgICA/IGAke3RoaXMuY3JvcE9mZnNldFJpZ2h0IC0gdGhpcy5jcm9wT2Zmc2V0TGVmdH06JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0Qm90dG9tIC0gdGhpcy5jcm9wT2Zmc2V0VG9wXG4gICAgICAgICAgICAgICAgICAgICAgfWBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgcmVwbGFjZUJsYWNrQm9yZGVyczogdGhpcy5yZXBsYWNlQmxhY2tCb3JkZXJzLFxuICAgICAgICAgICAgbWlycm9yOiB0aGlzLmlucHV0TWlycm9yLmNoZWNrZWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2V0IGNyb3AoY3JvcCkge1xuICAgICAgICB0aGlzLmNyb3BPZmZzZXRUb3AgPSBjcm9wLmN5ID8/IDA7XG4gICAgICAgIHRoaXMuY3JvcE9mZnNldExlZnQgPSBjcm9wLmN4ID8/IDA7XG4gICAgICAgIGlmICh0eXBlb2YgY3JvcC5jeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY3JvcC5jaCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5jcm9wT2Zmc2V0Qm90dG9tID0gY3JvcC5jeSArIGNyb3AuY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjcm9wLmN4ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjcm9wLmN3ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNyb3BPZmZzZXRSaWdodCA9IGNyb3AuY3ggKyBjcm9wLmN3O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5Dcm9wcGVyLnRlbXBsYXRlID0gLypodG1sKi8gYFxuJHtFRElUT1JfQ1NTfVxuPHN0eWxlPlxuICAgIC50b2dnbGUtYXNwZWN0IHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgLmNyb3Age1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBncmlkLWFyZWE6IGZyYW1lO1xuICAgICAgICBib3JkZXI6IDAgc29saWQgaHNsYSgwIDUwJSA1MCUgLyAuNSk7XG4gICAgICAgIGp1c3RpZnktc2VsZjogY2VudGVyO1xuICAgICAgICBjdXJzb3I6IGNyb3NzaGFpcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIH1cbiAgICAuY3JvcCBkaXYge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGluc2V0OiAwIGF1dG8gYXV0byAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB0cmFuc2l0aW9uOiAyNTBtcyBlYXNlLWluLW91dDtcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kLWJsZW5kLW1vZGU6IGxpZ2h0ZW47XG4gICAgfVxuXG4gICAgLmluZm8ge1xuICAgICAgICBncmlkLWFyZWE6IGxlZnQ7XG4gICAgICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgICAgIGdyaWQtYXV0by1yb3dzOiBtaW4tY29udGVudDtcbiAgICAgICAgZ2FwOiAuNXJlbTtcbiAgICAgICAgZm9udC1zaXplOiAuNzVyZW07XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgIHdpZHRoOiAyNTBweDtcbiAgICB9XG4gICAgZmllbGRzZXQge1xuICAgICAgICBib3JkZXI6IDJweCBzb2xpZCB2YXIoLS1jbHItYmctMjAwKTtcbiAgICAgICAgcGFkZGluZzogLjVyZW07XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWNsci1iZy0xMDApO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBnYXA6IC41cmVtO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xuICAgIH1cbiAgICBsZWdlbmQge1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMCk7XG4gICAgICAgIHBhZGRpbmc6IC4yNXJlbTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcbiAgICB9XG4gICAgbGFiZWwge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIGdhcDogLjVyZW07XG4gICAgfVxuICAgIGlucHV0IHtcbiAgICAgICAgYWNjZW50LWNvbG9yOiB2YXIoLS1jbHItZW5saWdodGVuZWQpO1xuICAgIH1cbiAgICBpbnB1dDpjaGVja2VkIHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggM3B4IHZhcigtLWNsci1lbmxpZ2h0ZW5lZC1nbG93KTtcbiAgICB9XG4gICAgLmluZm8gLndhcm5pbmcge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBmb250LXNpemU6IDEuNXJlbTtcbiAgICAgICAgY29sb3I6IGhzbCh2YXIoLS1odWUtd2FybmluZykgdmFyKC0tc2F0LWFsZXJ0KSB2YXIoLS1saXQtYWxlcnQpKTtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSB2YXIoLS10cmFuc2l0aW9uLW1lZGl1bSkgZWFzZS1pbi1vdXQ7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XG4gICAgfVxuICAgIC5pbmZvIC5lcnJvciB7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XG4gICAgICAgIGJhY2tncm91bmQ6IGhzbCh2YXIoLS1odWUtZXJyb3IpIHZhcigtLXNhdC1hbGVydCkgdmFyKC0tbGl0LWFsZXJ0KSk7XG4gICAgICAgIHBhZGRpbmc6IC41cmVtO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAuMjVyZW07XG4gICAgfVxuICAgIC5oZWlnaHQtZXJyb3IgLmhlaWdodC13YXJuaW5nIHtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgICB9XG4gICAgaW5wdXRbdHlwZT1cIm51bWJlclwiXSB7XG4gICAgICAgIG1heC13aWR0aDogNHJlbTtcbiAgICB9XG4gICAgLmhlbHAgZGwge1xuICAgICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IGF1dG8gMWZyO1xuICAgICAgICBncmlkLWNvbHVtbi1nYXA6IC41cmVtO1xuICAgIH1cbiAgICAuaGVscCBkZCB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICB9XG48L3N0eWxlPlxuJHtFRElUT1JfVEVNUExBVEV9XG48ZGl2ICNyZWY9XCJjcm9wT3ZlcmxheVwiIGNsYXNzPVwiY3JvcFwiPjxkaXYgI3JlZj1cImNyb3BJbWFnZVwiPjwvZGl2PjwvZGl2PlxuPGRpdiBjbGFzcz1cImluZm9cIiAjcmVmPVwiaW5mb1wiPlxuICAgIDxkaXYgKmlmPVwie3sgIXRoaXMudmFsaWQgfX1cIiBjbGFzcz1cImVycm9yXCI+XG4gICAgICAgIFJlc3VsdGluZyB2aWRlbyBkb2VzIG5vdCBmaXQgaW50byB0YXJnZXQgYXNwZWN0IHJhdGlvO1xuICAgIDwvZGl2PlxuICAgIDxmaWVsZHNldD5cbiAgICAgICAgPGxlZ2VuZD5TY2FsZTo8L2xlZ2VuZD5cbiAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgPHNwYW4+V2lkdGg6PC9zcGFuPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiAjcmVmPVwiaW5wdXRXaWR0aFwiPlxuICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8bGFiZWw+XG4gICAgICAgICAgICA8c3Bhbj5IZWlnaHQ6PC9zcGFuPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiAjcmVmPVwiaW5wdXRIZWlnaHRcIj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgPHNwYW4+UmVwbGFjZSBCb3JkZXJzPC9zcGFuPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCJyZXBsYWNlQmxhY2tCb3JkZXJzXCIgI3JlZj1cImlucHV0UmVwbGFjZUJsYWNrQm9yZGVyc1wiIEBjaGFuZ2U9XCJ7eyB0aGlzLnZhbGlkYXRlRGltZW5zaW9ucygpIH19XCI+XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgIDxzcGFuPk1pcnJvcjwvc3Bhbj5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwibWlycm9yXCIgI3JlZj1cImlucHV0TWlycm9yXCI+XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgIDxzcGFuPkVxdWFsIEJvcmRlcnM8L3NwYW4+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmFtZT1cImVxdWFsXCIgI3JlZj1cImlucHV0RXF1YWxcIiBjaGVja2VkPVwiY2hlY2tlZFwiPlxuICAgICAgICA8L2xhYmVsPlxuICAgIDwvZmllbGRzZXQ+XG4gICAgPGZpZWxkc2V0IGNsYXNzPVwiYXNwZWN0LXJhdGlvXCI+XG4gICAgICAgIDxsZWdlbmQ+QXNwZWN0IFJhdGlvOjwvbGVnZW5kPlxuICAgICAgICA8bGFiZWw+XG4gICAgICAgICAgICA8c3Bhbj40OjM8L3NwYW4+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImlucHV0LWFzcGVjdFwiIHZhbHVlPVwiNDozXCIgQGNoYW5nZT1cInt7IHRoaXMudmFsaWRhdGVEaW1lbnNpb25zKCkgfX1cIj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgPHNwYW4+MTY6OTwvc3Bhbj5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiaW5wdXQtYXNwZWN0XCIgdmFsdWU9XCIxNjo5XCIgQGNoYW5nZT1cInt7IHRoaXMudmFsaWRhdGVEaW1lbnNpb25zKCkgfX1cIj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgPHNwYW4+Q3VzdG9tICh7eyB0aGlzLmNyb3BPZmZzZXRSaWdodCAtIHRoaXMuY3JvcE9mZnNldExlZnQgfX14e3sgdGhpcy5jcm9wT2Zmc2V0Qm90dG9tIC0gdGhpcy5jcm9wT2Zmc2V0VG9wIH19KTwvc3Bhbj5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiaW5wdXQtYXNwZWN0XCIgdmFsdWU9XCJjdXN0b21cIiBAY2hhbmdlPVwie3sgdGhpcy52YWxpZGF0ZURpbWVuc2lvbnMoKSB9fVwiPlxuICAgICAgICA8L2xhYmVsPlxuICAgIDwvZmllbGRzZXQ+XG4gICAgPGZpZWxkc2V0PlxuICAgICAgICA8bGVnZW5kPkNyb3AgQm94OjwvbGVnZW5kPlxuICAgICAgICA8bGFiZWw+PHNwYW4+dzpoPC9zcGFuPjxzcGFuPnt7IHRoaXMuY3JvcE9mZnNldFJpZ2h0IC0gdGhpcy5jcm9wT2Zmc2V0TGVmdCB9fTp7eyB0aGlzLmNyb3BPZmZzZXRCb3R0b20gLSB0aGlzLmNyb3BPZmZzZXRUb3AgfX08L3NwYW4+PC9sYWJlbD5cbiAgICAgICAgPGxhYmVsPjxzcGFuPng6eTwvc3Bhbj48c3Bhbj57eyB0aGlzLmNyb3BPZmZzZXRMZWZ0IH19Ont7IHRoaXMuY3JvcE9mZnNldFRvcCB9fTwvc3Bhbj48L2xhYmVsPlxuICAgIDwvZmllbGRzZXQ+XG4gICAgPGRpdiBjbGFzcz1cImhlbHBcIj5cbiAgICAgICAgPGRsPlxuICAgICAgICAgICAgPGR0PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1tb3VzZVwiPjwvc3Bhbj4gLyBcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktc3dhcC12ZXJ0aWNhbC1ib2xkXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1zd2FwLWhvcml6b250YWwtYm9sZFwiPjwvc3Bhbj4gKyBDdHJsXG4gICAgICAgICAgICA8L2R0PlxuICAgICAgICAgICAgPC9kdD5cbiAgICAgICAgICAgIDxkZD5TZXQgdXBwZXIgbGVmdDwvZGQ+XG4gICAgICAgIDwvZGw+XG4gICAgICAgIDxkbD5cbiAgICAgICAgICAgIDxkdD5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktbW91c2VcIj48L3NwYW4+IC8gXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLXN3YXAtdmVydGljYWwtYm9sZFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktc3dhcC1ob3Jpem9udGFsLWJvbGRcIj48L3NwYW4+ICsgU2hpZnRcbiAgICAgICAgICAgIDwvZHQ+XG4gICAgICAgICAgICA8ZGQ+U2V0IGxvd2VyIHJpZ2h0PC9kZD5cbiAgICAgICAgPC9kbD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2ICp2LWlmPVwie3sgdGhpcy5kaXZpc2lvbkJ5U2l4dGVlbkVycm9yIH19XCIgY2xhc3M9XCJ3YXJuaW5nIGhlaWdodC13YXJuaW5nXCIgdGl0bGU9XCJGb3IgYmVzdCByZXN1bHRzIGhlaWdodCBzaG91bGQgYmUgZGl2aWRhYmxlIGJ5IDE2XCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1hbGVydC1vdXRsaW5lXCI+PC9zcGFuPlxuICAgIDwvZGl2PlxuPC9kaXY+XG48dGhlbWUtYnV0dG9uICNyZWY9XCJydW5CdXR0b25cIiBjbGFzcz1cInJ1blwiIEBjbGljaz1cInt7IHRoaXMucnVuIH19XCI+U3RhcnQ8L3RoZW1lLWJ1dHRvbj5cbmA7XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcImRpYWxvZ3VlLWNyb3BwZXJcIiwgQ3JvcHBlcik7XG4iXSwibmFtZXMiOlsiVmlkZW9FZGl0b3IiLCJFRElUT1JfVEVNUExBVEUiLCJFRElUT1JfQ1NTIiwiQ3JvcHBlciIsImNyb3BPZmZzZXRUb3AiLCJjcm9wT2Zmc2V0TGVmdCIsImNyb3BPZmZzZXRCb3R0b20iLCJjcm9wT2Zmc2V0UmlnaHQiLCJ2aWRlbyIsImFzcGVjdERlY2ltYWwiLCJ6b29tZWQiLCJzdGFydENyb3AiLCJ2YWxpZCIsInJ1biIsImJpbmQiLCJpbml0Q3JvcCIsImhhbmRsZUtleSIsImhhbmRsZUNsaWNrIiwidXBkYXRlQ3JvcEJveCIsIndpZHRoIiwiaGVpZ2h0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaW1hZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsInJ1bkJ1dHRvbiIsImRpc2FibGVkIiwiY3VycmVudCIsInBhcnNlSW50IiwiZHVyYXRpb24iLCJpbml0SW1hZ2VzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRvY3VtZW50IiwiY3JvcEltYWdlIiwibmF0dXJhbEhlaWdodCIsIm5hdHVyYWxXaWR0aCIsInN0eWxlIiwiZGlzcGxheSIsImNyb3BPdmVybGF5Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJncmFkaWVudHMiLCJzcmMiLCJpbmZvIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwidmFsaWRhdGVEaW1lbnNpb25zIiwiY3JvcHBlZFdpZHRoIiwiY3JvcHBlZEhlaWdodCIsInJhdGlvcyIsImFzcGVjdFJhdGlvIiwic3BsaXQiLCJtYXAiLCJyIiwicGFkV2lkdGgiLCJyZXBsYWNlQmxhY2tCb3JkZXJzIiwiaW5wdXRIZWlnaHQiLCJ2YWx1ZSIsInRvcCIsImNyb3BQZXJjZW50VG9wIiwiYm90dG9tIiwiY3JvcFBlcmNlbnRCb3R0b20iLCJsZWZ0IiwiY3JvcFBlcmNlbnRMZWZ0IiwicmlnaHQiLCJjcm9wUGVyY2VudFJpZ2h0Iiwiam9pbiIsImUiLCJrZXkiLCJ0eXBlIiwiaW5zZXQiLCJjdHJsS2V5IiwicHJldmVudERlZmF1bHQiLCJNYXRoIiwibWluIiwiZmxvb3IiLCJlcXVhbCIsIm1heCIsInNoaWZ0S2V5IiwiY29uc29sZSIsImxvZyIsImltYWdlUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VYIiwicGFnZVkiLCJwYXJlbnROb2RlIiwiY29uZmlybUFjdGlvbiIsInNoYWRvd1Jvb3QiLCJxdWVyeVNlbGVjdG9yIiwiZGlzcGxheV9hc3BlY3RfcmF0aW8iLCJpbmRleE9mIiwiY2hlY2tlZCIsIm1hdGNoIiwiaW5wdXRXaWR0aCIsIklucHV0RXZlbnQiLCJ0YXJnZXQiLCJpbnB1dFJlcGxhY2VCbGFja0JvcmRlcnMiLCJpbnB1dEVxdWFsIiwiY3ciLCJjaCIsImN4IiwiY3kiLCJhc3BlY3QiLCJtaXJyb3IiLCJpbnB1dE1pcnJvciIsImNyb3AiLCJ0ZW1wbGF0ZSIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Dialogues/Cropper/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Dialogues/Delogo/index.js":
/*!************************************************************************!*\
  !*** ./resources/js/components/Configurator/Dialogues/Delogo/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VideoEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VideoEditor */ \"./resources/js/components/Configurator/Dialogues/VideoEditor/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar DeLogo = /*#__PURE__*/function (_VideoEditor) {\n  _inherits(DeLogo, _VideoEditor);\n\n  var _super = _createSuper(DeLogo);\n\n  function DeLogo() {\n    var _this;\n\n    _classCallCheck(this, DeLogo);\n\n    _this = _super.call(this);\n    _this.delogoOffsetTop = 0;\n    _this.delogoOffsetLeft = 0;\n    _this.delogoOffsetBottom = null;\n    _this.delogoOffsetRight = null;\n    return _this;\n  }\n\n  _createClass(DeLogo, [{\n    key: \"bindListeners\",\n    value: function bindListeners() {\n      _get(_getPrototypeOf(DeLogo.prototype), \"bindListeners\", this).call(this);\n\n      this.run = this.run.bind(this);\n      this.initDelogo = this.initDelogo.bind(this);\n      this.addDelogoBox = this.addDelogoBox.bind(this);\n      this.handleKey = this.handleKey.bind(this);\n    }\n  }, {\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(DeLogo.prototype), \"onAdded\", this).call(this);\n\n      requestAnimationFrame(function () {\n        _this2.image.addEventListener(\"load\", _this2.initDelogo, {\n          once: true\n        });\n\n        _this2.initImages();\n      });\n    }\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved() {\n      this.image.removeEventListener(\"click\", this.addDelogoBox);\n      document.removeEventListener(\"keydown\", this.handleKey);\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      this.startDelogo = true;\n      this.parentNode.confirmAction();\n    }\n  }, {\n    key: \"initDelogo\",\n    value: function initDelogo() {\n      console.info(\"Initialize Delogo\");\n      this.image.addEventListener(\"click\", this.addDelogoBox);\n      document.addEventListener(\"keydown\", this.handleKey);\n      this.zoomImage = this.zoom.appendChild(document.createElement(\"img\"));\n      this.zoomImage.src = this.image.src;\n      this.addDelogoBox({\n        offsetX: Math.round(this.image.offsetLeft + this.image.width / 2 - 10),\n        offsetY: Math.round(this.image.offsetTop + this.image.height / 2 - 10)\n      });\n    }\n  }, {\n    key: \"handleIndicatorClick\",\n    value: function handleIndicatorClick(e) {\n      var _this3 = this;\n\n      this.image.addEventListener(\"load\", function () {\n        console.log(_this3.image.src);\n        _this3.zoomImage.src = _this3.image.src;\n      }, {\n        once: true\n      });\n\n      _get(_getPrototypeOf(DeLogo.prototype), \"handleIndicatorClick\", this).call(this, e);\n    }\n  }, {\n    key: \"addDelogoBox\",\n    value: function addDelogoBox(e) {\n      var _this4 = this;\n\n      requestAnimationFrame(function () {\n        // need to wait for offset properties to be calculated properly\n        if (!_this4.delogoBox) {\n          _this4.delogoBox = document.createElement(\"div\");\n\n          _this4.shadowRoot.appendChild(_this4.delogoBox);\n\n          _this4.delogoBox.classList.add(\"box\");\n\n          _this4.zoomDelogoBox = _this4.zoom.appendChild(_this4.delogoBox.cloneNode(true));\n          _this4.delogoBox.style.width = \"20px\";\n          _this4.delogoBox.style.height = \"20px\";\n        }\n\n        console.log(e, e.offsetX, e.offsetY);\n        _this4.delogoOffsetTop = e.offsetY - Math.round(_this4.delogoBox.offsetHeight / 2);\n        _this4.delogoOffsetLeft = e.offsetX - Math.round(_this4.delogoBox.offsetWidth / 2);\n        _this4.delogoBox.style.top = \"\".concat(Math.max(_this4.image.offsetTop, Math.min(_this4.image.offsetTop + _this4.image.height - _this4.delogoBox.offsetHeight, _this4.delogoOffsetTop)), \"px\");\n        _this4.delogoBox.style.left = \"\".concat(Math.max(_this4.image.offsetLeft, Math.min(_this4.image.offsetLeft + _this4.image.width - _this4.delogoBox.offsetWidth, _this4.delogoOffsetLeft)), \"px\");\n\n        _this4.updateZoom();\n      });\n    }\n  }, {\n    key: \"updateZoom\",\n    value: function updateZoom() {\n      var tr = \"translate(\\n            \".concat((this.coords.x - this.zoom.offsetWidth / 2 + this.coords.w / 2) * -1, \"px,\\n            \").concat((this.coords.y - this.zoom.offsetHeight / 2 + this.coords.h / 2) * -1, \"px\\n            )\");\n      this.zoomImage.style.transform = tr;\n      this.zoomDelogoBox.style.top = \"\".concat(this.coords.y, \"px\");\n      this.zoomDelogoBox.style.left = \"\".concat(this.coords.x, \"px\");\n      this.zoomDelogoBox.style.width = \"\".concat(this.coords.w, \"px\");\n      this.zoomDelogoBox.style.height = \"\".concat(this.coords.h, \"px\");\n      this.zoomDelogoBox.style.transform = tr;\n      this.displayLeft.innerText = \"\".concat(this.coords.x, \"px\");\n      this.displayTop.innerText = \"\".concat(this.coords.y, \"px\");\n      this.displayWidth.innerText = \"\".concat(this.coords.w, \"px\");\n      this.displayHeight.innerText = \"\".concat(this.coords.h, \"px\");\n    }\n  }, {\n    key: \"handleKey\",\n    value: function handleKey(e) {\n      if (this.delogoBox) {\n        e.preventDefault();\n\n        if (e.ctrlKey) {\n          if (e.key === \"ArrowRight\") {\n            this.delogoBox.style.left = \"\".concat(Math.min(this.delogoBox.offsetLeft + 1, this.image.offsetLeft + this.image.width - this.delogoBox.offsetWidth), \"px\");\n          }\n\n          if (e.key === \"ArrowLeft\") {\n            this.delogoBox.style.left = \"\".concat(Math.max(this.delogoBox.offsetLeft - 1, this.image.offsetLeft), \"px\");\n          }\n\n          if (e.key === \"ArrowDown\") {\n            this.delogoBox.style.top = \"\".concat(Math.min(this.delogoBox.offsetTop + 1, this.image.offsetTop + this.image.height - this.delogoBox.offsetHeight), \"px\");\n          }\n\n          if (e.key === \"ArrowUp\") {\n            this.delogoBox.style.top = \"\".concat(Math.max(this.delogoBox.offsetTop - 1, this.image.offsetTop), \"px\");\n          }\n        } else {\n          var box = this.delogoBox.getBoundingClientRect();\n\n          if (e.key === \"ArrowRight\") {\n            this.delogoBox.style.width = \"\".concat(Math.min(this.delogoBox.offsetWidth + 1, this.image.offsetLeft + this.image.offsetWidth - this.delogoBox.offsetLeft), \"px\");\n          }\n\n          if (e.key === \"ArrowLeft\") {\n            this.delogoBox.style.width = \"\".concat(Math.max(this.delogoBox.offsetWidth - 1, 5), \"px\");\n          }\n\n          if (e.key === \"ArrowDown\") {\n            this.delogoBox.style.height = \"\".concat(Math.min(this.delogoBox.offsetHeight + 1, this.image.offsetTop + this.image.offsetHeight - this.delogoBox.offsetTop), \"px\");\n          }\n\n          if (e.key === \"ArrowUp\") {\n            this.delogoBox.style.height = \"\".concat(Math.max(this.delogoBox.offsetHeight - 1, 5), \"px\");\n          }\n        }\n\n        this.updateZoom();\n      }\n    }\n  }, {\n    key: \"coords\",\n    get: function get() {\n      if (this.delogoBox) {\n        var box = this.delogoBox.getBoundingClientRect();\n        var image = this.image.getBoundingClientRect();\n        return {\n          x: parseInt((box.left - image.left) * this.video.width / image.width, 10),\n          y: parseInt((box.top - image.top) * this.video.height / image.height, 10),\n          w: parseInt(box.width * this.video.width / image.width, 10),\n          h: parseInt(box.height * this.video.height / image.height, 10)\n        };\n      } else {\n        return null;\n      }\n    }\n  }]);\n\n  return DeLogo;\n}(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.VideoEditor);\n\nDeLogo.template =\n/*html*/\n\"\\n\".concat(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.EDITOR_CSS, \"\\n<style>\\n    :host {\\n        position: relative;\\n    }\\n    .box {\\n        position: absolute;\\n        background-color: hsla(0 100% 50% / .5);\\n    }\\n    .info {\\n        grid-area: left;\\n        display: grid;\\n        grid-auto-rows: min-content;\\n        gap: .5rem;\\n        font-size: .75rem;\\n    }\\n    .zoom {\\n        width: 250px;\\n        aspect-ratio: 1;\\n        overflow: hidden;\\n        position: relative;\\n        z-index: 1;\\n        transform-origin: left top;\\n        transition: transform 200ms linear;\\n    }\\n    .zoom:hover {\\n        transform: scale(2);\\n    }\\n    .toggle-aspect {\\n        display: none;\\n    }\\n    .info dl {\\n        display: flex;\\n        justify-content: space-between;\\n        margin: 0;\\n    }\\n    p {\\n        max-width: 250px;\\n        margin: 0;\\n    }\\n</style>\\n\").concat(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.EDITOR_TEMPLATE, \"\\n<div class=\\\"info\\\">\\n    <div class=\\\"zoom\\\" #ref=\\\"zoom\\\"></div>\\n    <p>\\n        Click on image to set delogo rectangle\\n    </p>\\n    <dl>\\n        <dt>x/y</dt>\\n        <dd><span #ref=\\\"displayLeft\\\">0px</span>&nbsp;/&nbsp;<span #ref=\\\"displayTop\\\">0px</span></dd>\\n    </dl>\\n    <dl>\\n        <dt>w/h</dt>\\n        <dd><span #ref=\\\"displayWidth\\\">0px</span>&nbsp;/&nbsp;<span #ref=\\\"displayHeight\\\">0px</span></dd>\\n    </dl>\\n    <dl>\\n        <dt>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-vertical-bold\\\"></span>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-horizontal-bold\\\"></span>\\n        </dt>\\n        <dd>Adjust dimensions</dd>\\n    </dl>\\n    <dl>\\n        <dt>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-vertical-bold\\\"></span>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-swap-horizontal-bold\\\"></span> + Ctrl\\n        </dt>\\n        <dd>Adjust position</dd>\\n    </dl>\\n</div>\\n<theme-button #ref=\\\"runButton\\\" class=\\\"run\\\" @click=\\\"{{ this.run }}\\\">Start</theme-button>\\n\");\ncustomElements.define(\"dialogue-delogo\", DeLogo);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL0RlbG9nby9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0lBRU1HOzs7OztBQUNGLG9CQUFjO0FBQUE7O0FBQUE7O0FBQ1Y7QUFDQSxVQUFLQyxlQUFMLEdBQXVCLENBQXZCO0FBQ0EsVUFBS0MsZ0JBQUwsR0FBd0IsQ0FBeEI7QUFDQSxVQUFLQyxrQkFBTCxHQUEwQixJQUExQjtBQUNBLFVBQUtDLGlCQUFMLEdBQXlCLElBQXpCO0FBTFU7QUFNYjs7OztXQUVELHlCQUFnQjtBQUNaOztBQUNBLFdBQUtDLEdBQUwsR0FBVyxLQUFLQSxHQUFMLENBQVNDLElBQVQsQ0FBYyxJQUFkLENBQVg7QUFDQSxXQUFLQyxVQUFMLEdBQWtCLEtBQUtBLFVBQUwsQ0FBZ0JELElBQWhCLENBQXFCLElBQXJCLENBQWxCO0FBQ0EsV0FBS0UsWUFBTCxHQUFvQixLQUFLQSxZQUFMLENBQWtCRixJQUFsQixDQUF1QixJQUF2QixDQUFwQjtBQUNBLFdBQUtHLFNBQUwsR0FBaUIsS0FBS0EsU0FBTCxDQUFlSCxJQUFmLENBQW9CLElBQXBCLENBQWpCO0FBQ0g7OztXQUVELG1CQUFVO0FBQUE7O0FBQ047O0FBQ0FJLE1BQUFBLHFCQUFxQixDQUFDLFlBQU07QUFDeEIsY0FBSSxDQUFDQyxLQUFMLENBQVdDLGdCQUFYLENBQTRCLE1BQTVCLEVBQW9DLE1BQUksQ0FBQ0wsVUFBekMsRUFBcUQ7QUFDakRNLFVBQUFBLElBQUksRUFBRTtBQUQyQyxTQUFyRDs7QUFHQSxjQUFJLENBQUNDLFVBQUw7QUFDSCxPQUxvQixDQUFyQjtBQU1IOzs7V0FFRCxxQkFBWTtBQUNSLFdBQUtILEtBQUwsQ0FBV0ksbUJBQVgsQ0FBK0IsT0FBL0IsRUFBd0MsS0FBS1AsWUFBN0M7QUFDQVEsTUFBQUEsUUFBUSxDQUFDRCxtQkFBVCxDQUE2QixTQUE3QixFQUF3QyxL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ZUFBTztBQUNIZCxVQUFBQSxDQUFDLEVBQUVlLFFBQVEsQ0FDTixDQUFDRixHQUFHLENBQUNqQixJQUFKLEdBQVd0QyxLQUFLLENBQUNzQyxJQUFsQixJQUEwQixLQUFLb0IsS0FBTCxDQUFXdEMsS0FBdEMsR0FBK0NwQixLQUFLLENBQUNvQixLQUQ5QyxFQUVQLEVBRk8sQ0FEUjtBQUtId0IsVUFBQUEsQ0FBQyxFQUFFYSxRQUFRLENBQ04sQ0FBQ0YsR0FBRyxDQUFDcEIsR0FBSixHQUFVbkMsS0FBSyxDQUFDbUMsR0FBakIsSUFBd0IsS0FBS3VCLEtBQUwsQ0FBV25DLE1BQXBDLEdBQThDdkIsS0FBSyxDQUFDdUIsTUFEN0MsRUFFUCxFQUZPLENBTFI7QUFTSG9CLFVBQUFBLENBQUMsRUFBRWMsUUFBUSxDQUFFRixHQUFHLENBQUNuQyxLQUFKLEdBQVksS0FBS3NDLEtBQUwsQ0FBV3RDLEtBQXhCLEdBQWlDcEIsS0FBSyxDQUFDb0IsS0FBeEMsRUFBK0MsRUFBL0MsQ0FUUjtBQVVIeUIsVUFBQUEsQ0FBQyxFQUFFWSxRQUFRLENBQ05GLEdBQUcsQ0FBQ2hDLE1BQUosR0FBYSxLQUFLbUMsS0FBTCxDQUFXbkMsTUFBekIsR0FBbUN2QixLQUFLLENBQUN1QixNQURsQyxFQUVQLEVBRk87QUFWUixTQUFQO0FBZUgsT0FsQkQsTUFrQk87QUFDSCxlQUFPLElBQVA7QUFDSDtBQUNKOzs7O0VBN05nQnJDOztBQWdPckJHLE1BQU0sQ0FBQ3NFLFFBQVA7QUFBa0I7QUFBbEIsWUFDRXZFLG9EQURGLDgwQkEwQ0VELHlEQTFDRjtBQTBFQXlFLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixpQkFBdEIsRUFBeUN4RSxNQUF6QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9EaWFsb2d1ZXMvRGVsb2dvL2luZGV4LmpzP2E2MDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmlkZW9FZGl0b3IsIEVESVRPUl9URU1QTEFURSwgRURJVE9SX0NTUyB9IGZyb20gXCIuLi9WaWRlb0VkaXRvclwiO1xuXG5jbGFzcyBEZUxvZ28gZXh0ZW5kcyBWaWRlb0VkaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGVsb2dvT2Zmc2V0VG9wID0gMDtcbiAgICAgICAgdGhpcy5kZWxvZ29PZmZzZXRMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5kZWxvZ29PZmZzZXRCb3R0b20gPSBudWxsO1xuICAgICAgICB0aGlzLmRlbG9nb09mZnNldFJpZ2h0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICBzdXBlci5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMucnVuID0gdGhpcy5ydW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0RGVsb2dvID0gdGhpcy5pbml0RGVsb2dvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRGVsb2dvQm94ID0gdGhpcy5hZGREZWxvZ29Cb3guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVLZXkgPSB0aGlzLmhhbmRsZUtleS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIG9uQWRkZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQWRkZWQoKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5pbml0RGVsb2dvLCB7XG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5pbml0SW1hZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uUmVtb3ZlZCgpIHtcbiAgICAgICAgdGhpcy5pbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5hZGREZWxvZ29Cb3gpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleSk7XG4gICAgfVxuXG4gICAgcnVuKCkge1xuICAgICAgICB0aGlzLnN0YXJ0RGVsb2dvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLmNvbmZpcm1BY3Rpb24oKTtcbiAgICB9XG5cbiAgICBpbml0RGVsb2dvKCkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJJbml0aWFsaXplIERlbG9nb1wiKTtcbiAgICAgICAgdGhpcy5pbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5hZGREZWxvZ29Cb3gpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleSk7XG4gICAgICAgIHRoaXMuem9vbUltYWdlID0gdGhpcy56b29tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIikpO1xuICAgICAgICB0aGlzLnpvb21JbWFnZS5zcmMgPSB0aGlzLmltYWdlLnNyYztcbiAgICAgICAgdGhpcy5hZGREZWxvZ29Cb3goe1xuICAgICAgICAgICAgb2Zmc2V0WDogTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlLm9mZnNldExlZnQgKyB0aGlzLmltYWdlLndpZHRoIC8gMiAtIDEwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgb2Zmc2V0WTogTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlLm9mZnNldFRvcCArIHRoaXMuaW1hZ2UuaGVpZ2h0IC8gMiAtIDEwXG4gICAgICAgICAgICApLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVJbmRpY2F0b3JDbGljayhlKSB7XG4gICAgICAgIHRoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwibG9hZFwiLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuaW1hZ2Uuc3JjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21JbWFnZS5zcmMgPSB0aGlzLmltYWdlLnNyYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICBzdXBlci5oYW5kbGVJbmRpY2F0b3JDbGljayhlKTtcbiAgICB9XG5cbiAgICBhZGREZWxvZ29Cb3goZSkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gbmVlZCB0byB3YWl0IGZvciBvZmZzZXQgcHJvcGVydGllcyB0byBiZSBjYWxjdWxhdGVkIHByb3Blcmx5XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVsb2dvQm94KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLmRlbG9nb0JveCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3guY2xhc3NMaXN0LmFkZChcImJveFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21EZWxvZ29Cb3ggPSB0aGlzLnpvb20uYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3guc3R5bGUud2lkdGggPSBgMjBweGA7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3guc3R5bGUuaGVpZ2h0ID0gYDIwcHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coZSwgZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xuICAgICAgICAgICAgdGhpcy5kZWxvZ29PZmZzZXRUb3AgPVxuICAgICAgICAgICAgICAgIGUub2Zmc2V0WSAtIE1hdGgucm91bmQodGhpcy5kZWxvZ29Cb3gub2Zmc2V0SGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB0aGlzLmRlbG9nb09mZnNldExlZnQgPVxuICAgICAgICAgICAgICAgIGUub2Zmc2V0WCAtIE1hdGgucm91bmQodGhpcy5kZWxvZ29Cb3gub2Zmc2V0V2lkdGggLyAyKTtcbiAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94LnN0eWxlLnRvcCA9IGAke01hdGgubWF4KFxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2Uub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgIE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlLm9mZnNldFRvcCArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlLmhlaWdodCAtXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbG9nb0JveC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvT2Zmc2V0VG9wXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKX1weGA7XG4gICAgICAgICAgICB0aGlzLmRlbG9nb0JveC5zdHlsZS5sZWZ0ID0gYCR7TWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlLm9mZnNldExlZnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS53aWR0aCAtXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbG9nb0JveC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29PZmZzZXRMZWZ0XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKX1weGA7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlWm9vbSgpIHtcbiAgICAgICAgY29uc3QgdHIgPSBgdHJhbnNsYXRlKFxuICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAodGhpcy5jb29yZHMueCAtXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbS5vZmZzZXRXaWR0aCAvIDIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy53IC8gMikgKlxuICAgICAgICAgICAgICAgIC0xXG4gICAgICAgICAgICB9cHgsXG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICh0aGlzLmNvb3Jkcy55IC1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tLm9mZnNldEhlaWdodCAvIDIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkcy5oIC8gMikgKlxuICAgICAgICAgICAgICAgIC0xXG4gICAgICAgICAgICB9cHhcbiAgICAgICAgICAgIClgO1xuICAgICAgICB0aGlzLnpvb21JbWFnZS5zdHlsZS50cmFuc2Zvcm0gPSB0cjtcbiAgICAgICAgdGhpcy56b29tRGVsb2dvQm94LnN0eWxlLnRvcCA9IGAke3RoaXMuY29vcmRzLnl9cHhgO1xuICAgICAgICB0aGlzLnpvb21EZWxvZ29Cb3guc3R5bGUubGVmdCA9IGAke3RoaXMuY29vcmRzLnh9cHhgO1xuICAgICAgICB0aGlzLnpvb21EZWxvZ29Cb3guc3R5bGUud2lkdGggPSBgJHt0aGlzLmNvb3Jkcy53fXB4YDtcbiAgICAgICAgdGhpcy56b29tRGVsb2dvQm94LnN0eWxlLmhlaWdodCA9IGAke3RoaXMuY29vcmRzLmh9cHhgO1xuICAgICAgICB0aGlzLnpvb21EZWxvZ29Cb3guc3R5bGUudHJhbnNmb3JtID0gdHI7XG4gICAgICAgIHRoaXMuZGlzcGxheUxlZnQuaW5uZXJUZXh0ID0gYCR7dGhpcy5jb29yZHMueH1weGA7XG4gICAgICAgIHRoaXMuZGlzcGxheVRvcC5pbm5lclRleHQgPSBgJHt0aGlzLmNvb3Jkcy55fXB4YDtcbiAgICAgICAgdGhpcy5kaXNwbGF5V2lkdGguaW5uZXJUZXh0ID0gYCR7dGhpcy5jb29yZHMud31weGA7XG4gICAgICAgIHRoaXMuZGlzcGxheUhlaWdodC5pbm5lclRleHQgPSBgJHt0aGlzLmNvb3Jkcy5ofXB4YDtcbiAgICB9XG5cbiAgICBoYW5kbGVLZXkoZSkge1xuICAgICAgICBpZiAodGhpcy5kZWxvZ29Cb3gpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dSaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94LnN0eWxlLmxlZnQgPSBgJHtNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94Lm9mZnNldExlZnQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5vZmZzZXRMZWZ0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlLndpZHRoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbG9nb0JveC5vZmZzZXRXaWR0aFxuICAgICAgICAgICAgICAgICAgICApfXB4YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkFycm93TGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94LnN0eWxlLmxlZnQgPSBgJHtNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94Lm9mZnNldExlZnQgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5vZmZzZXRMZWZ0XG4gICAgICAgICAgICAgICAgICAgICl9cHhgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3guc3R5bGUudG9wID0gYCR7TWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbG9nb0JveC5vZmZzZXRUb3AgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5vZmZzZXRUb3AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbG9nb0JveC5vZmZzZXRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKX1weGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlLmtleSA9PT0gXCJBcnJvd1VwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3guc3R5bGUudG9wID0gYCR7TWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbG9nb0JveC5vZmZzZXRUb3AgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5vZmZzZXRUb3BcbiAgICAgICAgICAgICAgICAgICAgKX1weGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBib3ggPSB0aGlzLmRlbG9nb0JveC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dSaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94LnN0eWxlLndpZHRoID0gYCR7TWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbG9nb0JveC5vZmZzZXRXaWR0aCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlLm9mZnNldExlZnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2Uub2Zmc2V0V2lkdGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94Lm9mZnNldExlZnRcbiAgICAgICAgICAgICAgICAgICAgKX1weGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlLmtleSA9PT0gXCJBcnJvd0xlZnRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbG9nb0JveC5zdHlsZS53aWR0aCA9IGAke01hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3gub2Zmc2V0V2lkdGggLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICApfXB4YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkFycm93RG93blwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94LnN0eWxlLmhlaWdodCA9IGAke01hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3gub2Zmc2V0SGVpZ2h0ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2Uub2Zmc2V0VG9wICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlLm9mZnNldEhlaWdodCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3gub2Zmc2V0VG9wXG4gICAgICAgICAgICAgICAgICAgICl9cHhgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsb2dvQm94LnN0eWxlLmhlaWdodCA9IGAke01hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxvZ29Cb3gub2Zmc2V0SGVpZ2h0IC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgKX1weGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVab29tKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY29vcmRzKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxvZ29Cb3gpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IHRoaXMuZGVsb2dvQm94LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICAgKChib3gubGVmdCAtIGltYWdlLmxlZnQpICogdGhpcy52aWRlby53aWR0aCkgLyBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHk6IHBhcnNlSW50KFxuICAgICAgICAgICAgICAgICAgICAoKGJveC50b3AgLSBpbWFnZS50b3ApICogdGhpcy52aWRlby5oZWlnaHQpIC8gaW1hZ2UuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdzogcGFyc2VJbnQoKGJveC53aWR0aCAqIHRoaXMudmlkZW8ud2lkdGgpIC8gaW1hZ2Uud2lkdGgsIDEwKSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICAgKGJveC5oZWlnaHQgKiB0aGlzLnZpZGVvLmhlaWdodCkgLyBpbWFnZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuRGVMb2dvLnRlbXBsYXRlID0gLypodG1sKi8gYFxuJHtFRElUT1JfQ1NTfVxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cbiAgICAuYm94IHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2xhKDAgMTAwJSA1MCUgLyAuNSk7XG4gICAgfVxuICAgIC5pbmZvIHtcbiAgICAgICAgZ3JpZC1hcmVhOiBsZWZ0O1xuICAgICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgICBncmlkLWF1dG8tcm93czogbWluLWNvbnRlbnQ7XG4gICAgICAgIGdhcDogLjVyZW07XG4gICAgICAgIGZvbnQtc2l6ZTogLjc1cmVtO1xuICAgIH1cbiAgICAuem9vbSB7XG4gICAgICAgIHdpZHRoOiAyNTBweDtcbiAgICAgICAgYXNwZWN0LXJhdGlvOiAxO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMjAwbXMgbGluZWFyO1xuICAgIH1cbiAgICAuem9vbTpob3ZlciB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMik7XG4gICAgfVxuICAgIC50b2dnbGUtYXNwZWN0IHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgLmluZm8gZGwge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICB9XG4gICAgcCB7XG4gICAgICAgIG1heC13aWR0aDogMjUwcHg7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICB9XG48L3N0eWxlPlxuJHtFRElUT1JfVEVNUExBVEV9XG48ZGl2IGNsYXNzPVwiaW5mb1wiPlxuICAgIDxkaXYgY2xhc3M9XCJ6b29tXCIgI3JlZj1cInpvb21cIj48L2Rpdj5cbiAgICA8cD5cbiAgICAgICAgQ2xpY2sgb24gaW1hZ2UgdG8gc2V0IGRlbG9nbyByZWN0YW5nbGVcbiAgICA8L3A+XG4gICAgPGRsPlxuICAgICAgICA8ZHQ+eC95PC9kdD5cbiAgICAgICAgPGRkPjxzcGFuICNyZWY9XCJkaXNwbGF5TGVmdFwiPjBweDwvc3Bhbj4mbmJzcDsvJm5ic3A7PHNwYW4gI3JlZj1cImRpc3BsYXlUb3BcIj4wcHg8L3NwYW4+PC9kZD5cbiAgICA8L2RsPlxuICAgIDxkbD5cbiAgICAgICAgPGR0PncvaDwvZHQ+XG4gICAgICAgIDxkZD48c3BhbiAjcmVmPVwiZGlzcGxheVdpZHRoXCI+MHB4PC9zcGFuPiZuYnNwOy8mbmJzcDs8c3BhbiAjcmVmPVwiZGlzcGxheUhlaWdodFwiPjBweDwvc3Bhbj48L2RkPlxuICAgIDwvZGw+XG4gICAgPGRsPlxuICAgICAgICA8ZHQ+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktc3dhcC12ZXJ0aWNhbC1ib2xkXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLXN3YXAtaG9yaXpvbnRhbC1ib2xkXCI+PC9zcGFuPlxuICAgICAgICA8L2R0PlxuICAgICAgICA8ZGQ+QWRqdXN0IGRpbWVuc2lvbnM8L2RkPlxuICAgIDwvZGw+XG4gICAgPGRsPlxuICAgICAgICA8ZHQ+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktc3dhcC12ZXJ0aWNhbC1ib2xkXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLXN3YXAtaG9yaXpvbnRhbC1ib2xkXCI+PC9zcGFuPiArIEN0cmxcbiAgICAgICAgPC9kdD5cbiAgICAgICAgPGRkPkFkanVzdCBwb3NpdGlvbjwvZGQ+XG4gICAgPC9kbD5cbjwvZGl2PlxuPHRoZW1lLWJ1dHRvbiAjcmVmPVwicnVuQnV0dG9uXCIgY2xhc3M9XCJydW5cIiBAY2xpY2s9XCJ7eyB0aGlzLnJ1biB9fVwiPlN0YXJ0PC90aGVtZS1idXR0b24+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJkaWFsb2d1ZS1kZWxvZ29cIiwgRGVMb2dvKTtcbiJdLCJuYW1lcyI6WyJWaWRlb0VkaXRvciIsIkVESVRPUl9URU1QTEFURSIsIkVESVRPUl9DU1MiLCJEZUxvZ28iLCJkZWxvZ29PZmZzZXRUb3AiLCJkZWxvZ29PZmZzZXRMZWZ0IiwiZGVsb2dvT2Zmc2V0Qm90dG9tIiwiZGVsb2dvT2Zmc2V0UmlnaHQiLCJydW4iLCJiaW5kIiwiaW5pdERlbG9nbyIsImFkZERlbG9nb0JveCIsImhhbmRsZUtleSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImltYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJpbml0SW1hZ2VzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRvY3VtZW50Iiwic3RhcnREZWxvZ28iLCJwYXJlbnROb2RlIiwiY29uZmlybUFjdGlvbiIsImNvbnNvbGUiLCJpbmZvIiwiem9vbUltYWdlIiwiem9vbSIsImFwcGVuZENoaWxkIiwiY3JlYXRlRWxlbWVudCIsInNyYyIsIm9mZnNldFgiLCJNYXRoIiwicm91bmQiLCJvZmZzZXRMZWZ0Iiwid2lkdGgiLCJvZmZzZXRZIiwib2Zmc2V0VG9wIiwiaGVpZ2h0IiwiZSIsImxvZyIsImRlbG9nb0JveCIsInNoYWRvd1Jvb3QiLCJjbGFzc0xpc3QiLCJhZGQiLCJ6b29tRGVsb2dvQm94IiwiY2xvbmVOb2RlIiwic3R5bGUiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInRvcCIsIm1heCIsIm1pbiIsImxlZnQiLCJ1cGRhdGVab29tIiwidHIiLCJjb29yZHMiLCJ4IiwidyIsInkiLCJoIiwidHJhbnNmb3JtIiwiZGlzcGxheUxlZnQiLCJpbm5lclRleHQiLCJkaXNwbGF5VG9wIiwiZGlzcGxheVdpZHRoIiwiZGlzcGxheUhlaWdodCIsInByZXZlbnREZWZhdWx0IiwiY3RybEtleSIsImtleSIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhcnNlSW50IiwidmlkZW8iLCJ0ZW1wbGF0ZSIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Dialogues/Delogo/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Dialogues/Player/index.js":
/*!************************************************************************!*\
  !*** ./resources/js/components/Configurator/Dialogues/Player/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\n/* harmony import */ var hls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hls.js */ \"./node_modules/hls.js/dist/hls.mjs\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar Player = /*#__PURE__*/function (_Slim) {\n  _inherits(Player, _Slim);\n\n  var _super = _createSuper(Player);\n\n  function Player() {\n    _classCallCheck(this, Player);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Player, [{\n    key: \"onAdded\",\n    value: function () {\n      var _onAdded = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n        var _this = this;\n\n        var response;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _components_Request__WEBPACK_IMPORTED_MODULE_2__.Request.post(\"/stream/\".concat(encodeURIComponent(this.path)), this.config);\n\n              case 2:\n                response = _context.sent;\n                requestAnimationFrame(function () {\n                  _this.hls = new hls_js__WEBPACK_IMPORTED_MODULE_3__.default();\n\n                  _this.hls.loadSource(\"/stream-playlist/\".concat(encodeURIComponent(_this.path), \".m3u8\"));\n\n                  _this.hls.attachMedia(_this.video);\n                });\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function onAdded() {\n        return _onAdded.apply(this, arguments);\n      }\n\n      return onAdded;\n    }()\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved() {\n      this.hls.detachMedia();\n      this.hls.destroy();\n      _components_Request__WEBPACK_IMPORTED_MODULE_2__.Request.delete(\"/stream/\".concat(encodeURIComponent(this.path)));\n    }\n  }]);\n\n  return Player;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_1__.Slim);\n\nPlayer.template =\n/*html*/\n\"\\n<style>\\n    :host {\\n        display: grid;\\n        place-items: center;\\n        height: 100%;\\n    }\\n    video {\\n        width: 100%;\\n        max-height: 99%;\\n        max-width: 1920px;\\n    }\\n</style>\\n<video #ref=\\\"video\\\" controls></video>\\n\";\ncustomElements.define(\"dialogue-player\", Player);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL1BsYXllci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztJQUVNSTs7Ozs7Ozs7Ozs7Ozs7NEhBQ0Y7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx1QkFDeUJGLDZEQUFBLG1CQUNOSSxrQkFBa0IsQ0FBQyxLQUFLQyxJQUFOLENBRFosR0FFakIsS0FBS0MsTUFGWSxDQUR6Qjs7QUFBQTtBQUNRQyxnQkFBQUEsUUFEUjtBQUtJQyxnQkFBQUEscUJBQXFCLENBQUMsWUFBTTtBQUN4Qix1QkFBSSxDQUFDQyxHQUFMLEdBQVcsSUFBSVIsMkNBQUosRUFBWDs7QUFDQSx1QkFBSSxDQUFDUSxHQUFMLENBQVNDLFVBQVQsNEJBQ3dCTixrQkFBa0IsQ0FBQyxLQUFJLENBQUNDLElBQU4sQ0FEMUM7O0FBR0EsdUJBQUksQ0FBQ0ksR0FBTCxDQUFTRSxXQUFULENBQXFCLEtBQUksQ0FBQ0MsS0FBMUI7QUFDSCxpQkFOb0IsQ0FBckI7O0FBTEo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7V0FjQSxxQkFBWTtBQUNSLFdBQUtILEdBQUwsQ0FBU0ksV0FBVDtBQUNBLFdBQUtKLEdBQUwsQ0FBU0ssT0FBVDtBQUNBZCxNQUFBQSwrREFBQSxtQkFBMEJJLGtCQUFrQixDQUFDLEtBQUtDLElBQU4sQ0FBNUM7QUFDSDs7OztFQW5CZ0JQOztBQXNCckJJLE1BQU0sQ0FBQ2EsUUFBUDtBQUFrQjtBQUFsQjtBQWdCQUMsY0FBYyxDQUFDQyxNQUFmLENBQXNCLGlCQUF0QixFQUF5Q2YsTUFBekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL1BsYXllci9pbmRleC5qcz84YzFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaW0sIEljb25pZnkgfSBmcm9tIFwiQC9jb21wb25lbnRzL2xpYlwiO1xuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvUmVxdWVzdFwiO1xuaW1wb3J0IEhscyBmcm9tIFwiaGxzLmpzXCI7XG5cbmNsYXNzIFBsYXllciBleHRlbmRzIFNsaW0ge1xuICAgIGFzeW5jIG9uQWRkZWQoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IFJlcXVlc3QucG9zdChcbiAgICAgICAgICAgIGAvc3RyZWFtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMucGF0aCl9YCxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnXG4gICAgICAgICk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhscyA9IG5ldyBIbHMoKTtcbiAgICAgICAgICAgIHRoaXMuaGxzLmxvYWRTb3VyY2UoXG4gICAgICAgICAgICAgICAgYC9zdHJlYW0tcGxheWxpc3QvJHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5wYXRoKX0ubTN1OGBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmhscy5hdHRhY2hNZWRpYSh0aGlzLnZpZGVvKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25SZW1vdmVkKCkge1xuICAgICAgICB0aGlzLmhscy5kZXRhY2hNZWRpYSgpO1xuICAgICAgICB0aGlzLmhscy5kZXN0cm95KCk7XG4gICAgICAgIFJlcXVlc3QuZGVsZXRlKGAvc3RyZWFtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMucGF0aCl9YCk7XG4gICAgfVxufVxuXG5QbGF5ZXIudGVtcGxhdGUgPSAvKmh0bWwqLyBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgICBwbGFjZS1pdGVtczogY2VudGVyO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuICAgIHZpZGVvIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG1heC1oZWlnaHQ6IDk5JTtcbiAgICAgICAgbWF4LXdpZHRoOiAxOTIwcHg7XG4gICAgfVxuPC9zdHlsZT5cbjx2aWRlbyAjcmVmPVwidmlkZW9cIiBjb250cm9scz48L3ZpZGVvPlxuYDtcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwiZGlhbG9ndWUtcGxheWVyXCIsIFBsYXllcik7XG4iXSwibmFtZXMiOlsiU2xpbSIsIkljb25pZnkiLCJSZXF1ZXN0IiwiSGxzIiwiUGxheWVyIiwicG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInBhdGgiLCJjb25maWciLCJyZXNwb25zZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImhscyIsImxvYWRTb3VyY2UiLCJhdHRhY2hNZWRpYSIsInZpZGVvIiwiZGV0YWNoTWVkaWEiLCJkZXN0cm95IiwidGVtcGxhdGUiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Dialogues/Player/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Dialogues/RemoveLogo/index.js":
/*!****************************************************************************!*\
  !*** ./resources/js/components/Configurator/Dialogues/RemoveLogo/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VideoEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VideoEditor */ \"./resources/js/components/Configurator/Dialogues/VideoEditor/index.js\");\n/* harmony import */ var _Clipper_mixins_handleKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Clipper/mixins/handleKey */ \"./resources/js/components/Configurator/Dialogues/Clipper/mixins/handleKey.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar IMAGE_TYPE_ORIGINAL = \"Original\";\nvar IMAGE_TYPE_MASK = \"Mask\";\n\nvar RemoveLogo = /*#__PURE__*/function (_VideoEditor) {\n  _inherits(RemoveLogo, _VideoEditor);\n\n  var _super = _createSuper(RemoveLogo);\n\n  function RemoveLogo() {\n    var _this;\n\n    _classCallCheck(this, RemoveLogo);\n\n    _this = _super.call(this);\n    _this.raw = [-1];\n    _this.imageType = IMAGE_TYPE_ORIGINAL;\n    return _this;\n  }\n\n  _createClass(RemoveLogo, [{\n    key: \"bindListeners\",\n    value: function bindListeners() {\n      _get(_getPrototypeOf(RemoveLogo.prototype), \"bindListeners\", this).call(this);\n\n      this.run = this.run.bind(this);\n      this.initRemovelogo = this.initRemovelogo.bind(this);\n      this.rwd = _Clipper_mixins_handleKey__WEBPACK_IMPORTED_MODULE_1__.rwd.bind(this);\n      this.ffwd = _Clipper_mixins_handleKey__WEBPACK_IMPORTED_MODULE_1__.ffwd.bind(this);\n      this.handleKey = _Clipper_mixins_handleKey__WEBPACK_IMPORTED_MODULE_1__.handleKey.bind(this);\n    }\n  }, {\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(RemoveLogo.prototype), \"onAdded\", this).call(this);\n\n      document.addEventListener(\"keydown\", this.handleKey);\n      requestAnimationFrame(function () {\n        _this2.image.addEventListener(\"load\", _this2.initRemovelogo, {\n          once: true\n        });\n\n        _this2.initImages();\n      });\n    }\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved() {\n      document.removeEventListener(\"keydown\", this.handleKey);\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      this.startRemoveLogo = true;\n      this.parentNode.confirmAction();\n    }\n  }, {\n    key: \"initRemovelogo\",\n    value: function initRemovelogo() {\n      console.info(\"Initialize Removelogo\");\n    }\n  }, {\n    key: \"toggleType\",\n    value: function toggleType() {\n      if (this.imageType === IMAGE_TYPE_ORIGINAL) {\n        this.imageType = IMAGE_TYPE_MASK;\n      } else {\n        this.imageType = IMAGE_TYPE_ORIGINAL;\n      }\n\n      this.updateFrameUrl();\n    }\n  }, {\n    key: \"baseThumbUrl\",\n    get: function get() {\n      return _get(_getPrototypeOf(RemoveLogo.prototype), \"baseUrl\", this);\n    }\n  }, {\n    key: \"baseUrl\",\n    get: function get() {\n      return this.imageType === IMAGE_TYPE_ORIGINAL ? _get(_getPrototypeOf(RemoveLogo.prototype), \"baseUrl\", this) : \"/removelogoImage/\".concat(encodeURIComponent(this.path), \"?timestamp=\");\n    }\n  }, {\n    key: \"removeLogo\",\n    get: function get() {\n      return {\n        timestamp: this.timestamp(),\n        w: this.video.width,\n        h: this.video.height,\n        type: this.type\n      };\n    }\n  }, {\n    key: \"add\",\n    value: function add() {}\n  }]);\n\n  return RemoveLogo;\n}(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.VideoEditor);\n\nRemoveLogo.template =\n/*html*/\n\"\\n\".concat(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.EDITOR_CSS, \"\\n<style>\\n    :host {\\n        position: relative;\\n    }\\n    .box {\\n        position: absolute;\\n        background-color: hsla(0 100% 50% / .5);\\n    }\\n    .info {\\n        grid-area: left;\\n        display: grid;\\n        grid-auto-rows: min-content;\\n        gap: .5rem;\\n        font-size: .75rem;\\n    }\\n    .toggle-type::part(button) {\\n        min-width: 150px;\\n    }\\n    .toggle-aspect {\\n        display: none;\\n    }\\n    .info p {\\n        max-width: 150px;\\n    }\\n</style>\\n\").concat(_VideoEditor__WEBPACK_IMPORTED_MODULE_0__.EDITOR_TEMPLATE, \"\\n<div class=\\\"info\\\">\\n    <theme-button class=\\\"toggle-type\\\" @click=\\\"{{ this.toggleType() }}\\\">{{ this.imageType }}</theme-button>\\n    <p>\\n        Find a black frame containing only the logo\\n    </p>\\n</div>\\n<!-- TODO: Create logomask without running action -->\\n<theme-button #ref=\\\"runButton\\\" class=\\\"run\\\" @click=\\\"{{ this.run }}\\\">Start</theme-button>\\n\");\ncustomElements.define(\"dialogue-removelogo\", RemoveLogo);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL1JlbW92ZUxvZ28vaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUEsSUFBTU0sbUJBQW1CLEdBQUcsVUFBNUI7QUFDQSxJQUFNQyxlQUFlLEdBQUcsTUFBeEI7O0lBQ01DOzs7OztBQUNGLHdCQUFjO0FBQUE7O0FBQUE7O0FBQ1Y7QUFDQSxVQUFLQyxHQUFMLEdBQVcsQ0FBQyxDQUFDLENBQUYsQ0FBWDtBQUNBLFVBQUtDLFNBQUwsR0FBaUJKLG1CQUFqQjtBQUhVO0FBSWI7Ozs7V0FFRCx5QkFBZ0I7QUFDWjs7QUFDQSxXQUFLSyxHQUFMLEdBQVcsS0FBS0EsR0FBTCxDQUFTQyxJQUFULENBQWMsSUFBZCxDQUFYO0FBQ0EsV0FBS0MsY0FBTCxHQUFzQixLQUFLQSxjQUFMLENBQW9CRCxJQUFwQixDQUF5QixJQUF6QixDQUF0QjtBQUNBLFdBQUtSLEdBQUwsR0FBV0EsK0RBQUEsQ0FBUyxJQUFULENBQVg7QUFDQSxXQUFLQyxJQUFMLEdBQVlBLGdFQUFBLENBQVUsSUFBVixDQUFaO0FBQ0EsV0FBS0YsU0FBTCxHQUFpQkEscUVBQUEsQ0FBZSxJQUFmLENBQWpCO0FBQ0g7OztXQUVELG1CQUFVO0FBQUE7O0FBQ047O0FBQ0FXLE1BQUFBLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsU0FBMUIsRUFBcUMsS0FBS1osU0FBMUM7QUFDQWEsTUFBQUEscUJBQXFCLENBQUMsWUFBTTtBQUN4QixjQUFJLENBQUNDLEtBQUwsQ0FBV0YsZ0JBQVgsQ0FBNEIsTUFBNUIsRUFBb0MsTUFBSSxDQUFDRixjQUF6QyxFQUF5RDtBQUNyREssVUFBQUEsSUFBSSxFQUFFO0FBRCtDLFNBQXpEOztBQUdBLGNBQUksQ0FBQ0MsVUFBTDtBQUNILE9BTG9CLENBQXJCO0FBTUg7OztXQUVELHFCQUFZO0FBQ1JMLE1BQUFBLFFBQVEsQ0FBQ00sbUJBQVQsQ0FBNkIsU0FBN0IsRUFBd0MsS0FBS2pCLFNBQTdDO0FBQ0g7OztXQUVELGVBQU07QUFDRixXQUFLa0IsZUFBTCxHQUF1QixJQUF2QjtBQUNBLFdBQUtDLFVBQUwsQ0FBZ0JDLGFBQWhCO0FBQ0g7OztXQUVELDBCQUFpQjtBQUNiQyxNQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSx1QkFBYjtBQUNIOzs7V0FFRCxzQkFBYTtBQUNULFVBQUksS0FBS2YsU0FBTCxLQUFtQkosbUJBQXZCLEVBQTRDO0FBQ3hDLGFBQUtJLFNBQUwsR0FBaUJILGVBQWpCO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsYUFBS0csU0FBTCxHQUFpQkosbUJBQWpCO0FBQ0g7O0FBQ0QsV0FBS29CLGNBQUw7QUFDSDs7O1NBRUQsZUFBbUI7QUFDZjtBQUNIOzs7U0FFRCxlQUFjO0FBQ1YsYUFBTyxLQUFLaEIsU0FBTCxLQUFtQkosbUJBQW5CLDZGQUVtQnFCLGtCQUFrQixDQUFDLEtBQUtDLElBQU4sQ0FGckMsZ0JBQVA7QUFHSDs7O1NBRUQsZUFBaUI7QUFDYixhQUFPO0FBQ0hDLFFBQUFBLFNBQVMsRUFBRSxLQUFLQSxTQUFMLEVBRFI7QUFFSEMsUUFBQUEsQ0FBQyxFQUFFLEtBQUtDLEtBQUwsQ0FBV0MsS0FGWDtBQUdIQyxRQUFBQSxDQUFDLEVBQUUsS0FBS0YsS0FBTCxDQUFXRyxNQUhYO0FBSUhDLFFBQUFBLElBQUksRUFBRSxLQUFLQTtBQUpSLE9BQVA7QUFNSDs7O1dBRUQsZUFBTSxDQUFFOzs7O0VBcEVhbkM7O0FBdUV6QlEsVUFBVSxDQUFDNEIsUUFBWDtBQUFzQjtBQUF0QixZQUNFbEMsb0RBREYsNGZBMkJFRCx5REEzQkY7QUFzQ0FvQyxjQUFjLENBQUNDLE1BQWYsQ0FBc0IscUJBQXRCLEVBQTZDOUIsVUFBN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL1JlbW92ZUxvZ28vaW5kZXguanM/NDNhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWaWRlb0VkaXRvciwgRURJVE9SX1RFTVBMQVRFLCBFRElUT1JfQ1NTIH0gZnJvbSBcIi4uL1ZpZGVvRWRpdG9yXCI7XG5pbXBvcnQgeyBoYW5kbGVLZXksIHJ3ZCwgZmZ3ZCB9IGZyb20gXCIuLi9DbGlwcGVyL21peGlucy9oYW5kbGVLZXlcIjtcblxuY29uc3QgSU1BR0VfVFlQRV9PUklHSU5BTCA9IFwiT3JpZ2luYWxcIjtcbmNvbnN0IElNQUdFX1RZUEVfTUFTSyA9IFwiTWFza1wiO1xuY2xhc3MgUmVtb3ZlTG9nbyBleHRlbmRzIFZpZGVvRWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yYXcgPSBbLTFdO1xuICAgICAgICB0aGlzLmltYWdlVHlwZSA9IElNQUdFX1RZUEVfT1JJR0lOQUw7XG4gICAgfVxuXG4gICAgYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgc3VwZXIuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnJ1biA9IHRoaXMucnVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdFJlbW92ZWxvZ28gPSB0aGlzLmluaXRSZW1vdmVsb2dvLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucndkID0gcndkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmZ3ZCA9IGZmd2QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVLZXkgPSBoYW5kbGVLZXkuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBvbkFkZGVkKCkge1xuICAgICAgICBzdXBlci5vbkFkZGVkKCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5pbml0UmVtb3ZlbG9nbywge1xuICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaW5pdEltYWdlcygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvblJlbW92ZWQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5KTtcbiAgICB9XG5cbiAgICBydW4oKSB7XG4gICAgICAgIHRoaXMuc3RhcnRSZW1vdmVMb2dvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLmNvbmZpcm1BY3Rpb24oKTtcbiAgICB9XG5cbiAgICBpbml0UmVtb3ZlbG9nbygpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiSW5pdGlhbGl6ZSBSZW1vdmVsb2dvXCIpO1xuICAgIH1cblxuICAgIHRvZ2dsZVR5cGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlVHlwZSA9PT0gSU1BR0VfVFlQRV9PUklHSU5BTCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZVR5cGUgPSBJTUFHRV9UWVBFX01BU0s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlVHlwZSA9IElNQUdFX1RZUEVfT1JJR0lOQUw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVGcmFtZVVybCgpO1xuICAgIH1cblxuICAgIGdldCBiYXNlVGh1bWJVcmwoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5iYXNlVXJsO1xuICAgIH1cblxuICAgIGdldCBiYXNlVXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZVR5cGUgPT09IElNQUdFX1RZUEVfT1JJR0lOQUxcbiAgICAgICAgICAgID8gc3VwZXIuYmFzZVVybFxuICAgICAgICAgICAgOiBgL3JlbW92ZWxvZ29JbWFnZS8ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLnBhdGgpfT90aW1lc3RhbXA9YDtcbiAgICB9XG5cbiAgICBnZXQgcmVtb3ZlTG9nbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy50aW1lc3RhbXAoKSxcbiAgICAgICAgICAgIHc6IHRoaXMudmlkZW8ud2lkdGgsXG4gICAgICAgICAgICBoOiB0aGlzLnZpZGVvLmhlaWdodCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkKCkge31cbn1cblxuUmVtb3ZlTG9nby50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7RURJVE9SX0NTU31cbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG4gICAgLmJveCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogaHNsYSgwIDEwMCUgNTAlIC8gLjUpO1xuICAgIH1cbiAgICAuaW5mbyB7XG4gICAgICAgIGdyaWQtYXJlYTogbGVmdDtcbiAgICAgICAgZGlzcGxheTogZ3JpZDtcbiAgICAgICAgZ3JpZC1hdXRvLXJvd3M6IG1pbi1jb250ZW50O1xuICAgICAgICBnYXA6IC41cmVtO1xuICAgICAgICBmb250LXNpemU6IC43NXJlbTtcbiAgICB9XG4gICAgLnRvZ2dsZS10eXBlOjpwYXJ0KGJ1dHRvbikge1xuICAgICAgICBtaW4td2lkdGg6IDE1MHB4O1xuICAgIH1cbiAgICAudG9nZ2xlLWFzcGVjdCB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICAgIC5pbmZvIHAge1xuICAgICAgICBtYXgtd2lkdGg6IDE1MHB4O1xuICAgIH1cbjwvc3R5bGU+XG4ke0VESVRPUl9URU1QTEFURX1cbjxkaXYgY2xhc3M9XCJpbmZvXCI+XG4gICAgPHRoZW1lLWJ1dHRvbiBjbGFzcz1cInRvZ2dsZS10eXBlXCIgQGNsaWNrPVwie3sgdGhpcy50b2dnbGVUeXBlKCkgfX1cIj57eyB0aGlzLmltYWdlVHlwZSB9fTwvdGhlbWUtYnV0dG9uPlxuICAgIDxwPlxuICAgICAgICBGaW5kIGEgYmxhY2sgZnJhbWUgY29udGFpbmluZyBvbmx5IHRoZSBsb2dvXG4gICAgPC9wPlxuPC9kaXY+XG48IS0tIFRPRE86IENyZWF0ZSBsb2dvbWFzayB3aXRob3V0IHJ1bm5pbmcgYWN0aW9uIC0tPlxuPHRoZW1lLWJ1dHRvbiAjcmVmPVwicnVuQnV0dG9uXCIgY2xhc3M9XCJydW5cIiBAY2xpY2s9XCJ7eyB0aGlzLnJ1biB9fVwiPlN0YXJ0PC90aGVtZS1idXR0b24+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJkaWFsb2d1ZS1yZW1vdmVsb2dvXCIsIFJlbW92ZUxvZ28pO1xuIl0sIm5hbWVzIjpbIlZpZGVvRWRpdG9yIiwiRURJVE9SX1RFTVBMQVRFIiwiRURJVE9SX0NTUyIsImhhbmRsZUtleSIsInJ3ZCIsImZmd2QiLCJJTUFHRV9UWVBFX09SSUdJTkFMIiwiSU1BR0VfVFlQRV9NQVNLIiwiUmVtb3ZlTG9nbyIsInJhdyIsImltYWdlVHlwZSIsInJ1biIsImJpbmQiLCJpbml0UmVtb3ZlbG9nbyIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImltYWdlIiwib25jZSIsImluaXRJbWFnZXMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3RhcnRSZW1vdmVMb2dvIiwicGFyZW50Tm9kZSIsImNvbmZpcm1BY3Rpb24iLCJjb25zb2xlIiwiaW5mbyIsInVwZGF0ZUZyYW1lVXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicGF0aCIsInRpbWVzdGFtcCIsInciLCJ2aWRlbyIsIndpZHRoIiwiaCIsImhlaWdodCIsInR5cGUiLCJ0ZW1wbGF0ZSIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Dialogues/RemoveLogo/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Dialogues/Scale.js":
/*!*****************************************************************!*\
  !*** ./resources/js/components/Configurator/Dialogues/Scale.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _Streams_Video__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Streams/Video */ \"./resources/js/components/Configurator/Streams/Video.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar DEFAULT_WIDTH = 720;\nvar DEFAULT_HEIGHT = 576;\nvar DEFAULT_ASPECT = \"4:3\";\n\n\nvar Scale = /*#__PURE__*/function (_Slim) {\n  _inherits(Scale, _Slim);\n\n  var _super = _createSuper(Scale);\n\n  function Scale() {\n    var _this;\n\n    _classCallCheck(this, Scale);\n\n    _this = _super.call(this);\n    _this.scale = {\n      width: DEFAULT_WIDTH,\n      height: DEFAULT_HEIGHT,\n      aspectRatio: DEFAULT_ASPECT\n    };\n    _this.handleWidth = _this.handleWidth.bind(_assertThisInitialized(_this));\n    _this.handleHeight = _this.handleHeight.bind(_assertThisInitialized(_this));\n    _this.handleAspectRatio = _this.handleAspectRatio.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Scale, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      this.calculateWidth();\n    }\n  }, {\n    key: \"setWidth\",\n    value: function setWidth(value) {\n      this.scale.width = value;\n    }\n  }, {\n    key: \"setHeight\",\n    value: function setHeight(value) {\n      this.scale.height = value;\n      this.calculateWidth();\n    }\n  }, {\n    key: \"setAspectRatio\",\n    value: function setAspectRatio(value) {\n      if (_Streams_Video__WEBPACK_IMPORTED_MODULE_1__.VALID_ASPECT_RATIOS.indexOf(value) > -1) {\n        this.scale.aspectRatio = value;\n        this.calculateWidth();\n      }\n    }\n  }, {\n    key: \"calculateWidth\",\n    value: function calculateWidth() {\n      var _this2 = this;\n\n      var ratio = this.scale.aspectRatio.split(\":\");\n      this.scale.width = this.scale.height / ratio[1] * ratio[0];\n      requestAnimationFrame(function () {\n        return _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(_this2, \"scale\");\n      });\n    }\n  }, {\n    key: \"handleWidth\",\n    value: function handleWidth(e) {\n      this.setWidth(e.currentTarget.value);\n    }\n  }, {\n    key: \"handleHeight\",\n    value: function handleHeight(e) {\n      this.setHeight(e.currentTarget.value);\n    }\n  }, {\n    key: \"handleAspectRatio\",\n    value: function handleAspectRatio(e) {\n      this.setAspectRatio(e.currentTarget.value);\n    }\n  }]);\n\n  return Scale;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nScale.template =\n/*html*/\n\"\\n<style>\\n    :host {\\n        display: flex;\\n        flex-direction: column;\\n        gap: .5rem;\\n    }\\n    fieldset {\\n        border: 2px solid var(--clr-bg-200);\\n        padding: 1rem;\\n        background: var(--clr-bg-100);\\n        display: flex;\\n        flex-direction: column;\\n        gap: .5rem;\\n        border-radius: 0.25rem;\\n    }\\n    legend {\\n        background: var(--clr-bg-0);\\n        padding: .25rem;\\n        border-radius: 0.25rem;\\n    }\\n    label {\\n        display: flex;\\n        justify-content: space-between;\\n        gap: .5rem;\\n    }\\n    input {\\n        accent-color: var(--clr-enlightened);\\n    }\\n    input:checked {\\n        box-shadow: 0 0 10px 3px var(--clr-enlightened-glow);\\n    }\\n</style>\\n<fieldset>\\n    <legend>Dimensions:</legend>\\n    <label>\\n        <span>Width:</span><input type=\\\"number\\\" value=\\\"{{ this.scale.width }}\\\" placeholder=\\\"Width\\\" @input=\\\"{{ this.handleWidth }}\\\">\\n    </label>\\n    <label>\\n        <span>Height:</span><input type=\\\"number\\\" value=\\\"{{ this.scale.height }}\\\" placeholder=\\\"Height\\\" @input=\\\"{{ this.handleHeight }}\\\">\\n    </label>\\n</fieldset>\\n<fieldset>\\n    <legend>Aspect-Ratio:</legend>\\n    <label>\\n        <span>4:3</span>\\n        <input type=\\\"radio\\\" name=\\\"aspect\\\" value=\\\"4:3\\\" @change=\\\"{{ this.handleAspectRatio }}\\\" .checked=\\\"{{ this.scale.aspectRatio === '4:3' }}\\\">\\n    </label>\\n    <label>\\n        <span>16:9</span>\\n        <input type=\\\"radio\\\" name=\\\"aspect\\\" value=\\\"16:9\\\" @change=\\\"{{ this.handleAspectRatio }}\\\" .checked=\\\"{{ this.scale.aspectRatio === '16:9' }}\\\">\\n    </label>\\n</fieldset>\\n\";\ncustomElements.define(\"dialogue-scale\", Scale);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL1NjYWxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBLElBQU1FLGFBQWEsR0FBRyxHQUF0QjtBQUNBLElBQU1DLGNBQWMsR0FBRyxHQUF2QjtBQUNBLElBQU1DLGNBQWMsR0FBRyxLQUF2QjtBQUVBOztJQUVNRTs7Ozs7QUFDRixtQkFBYztBQUFBOztBQUFBOztBQUNWO0FBQ0EsVUFBS0MsS0FBTCxHQUFhO0FBQ1RDLE1BQUFBLEtBQUssRUFBRU4sYUFERTtBQUVUTyxNQUFBQSxNQUFNLEVBQUVOLGNBRkM7QUFHVE8sTUFBQUEsV0FBVyxFQUFFTjtBQUhKLEtBQWI7QUFLQSxVQUFLTyxXQUFMLEdBQW1CLE1BQUtBLFdBQUwsQ0FBaUJDLElBQWpCLCtCQUFuQjtBQUNBLFVBQUtDLFlBQUwsR0FBb0IsTUFBS0EsWUFBTCxDQUFrQkQsSUFBbEIsK0JBQXBCO0FBQ0EsVUFBS0UsaUJBQUwsR0FBeUIsTUFBS0EsaUJBQUwsQ0FBdUJGLElBQXZCLCtCQUF6QjtBQVRVO0FBVWI7Ozs7V0FFRCxtQkFBVTtBQUNOLFdBQUtHLGNBQUw7QUFDSDs7O1dBRUQsa0JBQVNDLEtBQVQsRUFBZ0I7QUFDWixXQUFLVCxLQUFMLENBQVdDLEtBQVgsR0FBbUJRLEtBQW5CO0FBQ0g7OztXQUNELG1CQUFVQSxLQUFWLEVBQWlCO0FBQ2IsV0FBS1QsS0FBTCxDQUFXRSxNQUFYLEdBQW9CTyxLQUFwQjtBQUNBLFdBQUtELGNBQUw7QUFDSDs7O1dBQ0Qsd0JBQWVDLEtBQWYsRUFBc0I7QUFDbEIsVUFBSVgsdUVBQUEsQ0FBNEJXLEtBQTVCLElBQXFDLENBQUMsQ0FBMUMsRUFBNkM7QUFDekMsYUFBS1QsS0FBTCxDQUFXRyxXQUFYLEdBQXlCTSxLQUF6QjtBQUNBLGFBQUtELGNBQUw7QUFDSDtBQUNKOzs7V0FFRCwwQkFBaUI7QUFBQTs7QUFDYixVQUFNRyxLQUFLLEdBQUcsS0FBS1gsS0FBTCxDQUFXRyxXQUFYLENBQXVCUyxLQUF2QixDQUE2QixHQUE3QixDQUFkO0FBQ0EsV0FBS1osS0FBTCxDQUFXQyxLQUFYLEdBQW9CLEtBQUtELEtBQUwsQ0FBV0UsTUFBWCxHQUFvQlMsS0FBSyxDQUFDLENBQUQsQ0FBMUIsR0FBaUNBLEtBQUssQ0FBQyxDQUFELENBQXpEO0FBQ0FFLE1BQUFBLHFCQUFxQixDQUFDO0FBQUEsZUFBTW5CLDhEQUFBLENBQWtCLE1BQWxCLEVBQXdCLE9BQXhCLENBQU47QUFBQSxPQUFELENBQXJCO0FBQ0g7OztXQUVELHFCQUFZcUIsQ0FBWixFQUFlO0FBQ1gsV0FBS0MsUUFBTCxDQUFjRCxDQUFDLENBQUNFLGFBQUYsQ0FBZ0JSLEtBQTlCO0FBQ0g7OztXQUVELHNCQUFhTSxDQUFiLEVBQWdCO0FBQ1osV0FBS0csU0FBTCxDQUFlSCxDQUFDLENBQUNFLGFBQUYsQ0FBZ0JSLEtBQS9CO0FBQ0g7OztXQUVELDJCQUFrQk0sQ0FBbEIsRUFBcUI7QUFDakIsV0FBS0ksY0FBTCxDQUFvQkosQ0FBQyxDQUFDRSxhQUFGLENBQWdCUixLQUFwQztBQUNIOzs7O0VBL0NlaEI7O0FBa0RwQk0sS0FBSyxDQUFDcUIsUUFBTjtBQUFpQjtBQUFqQjtBQXVEQUMsY0FBYyxDQUFDQyxNQUFmLENBQXNCLGdCQUF0QixFQUF3Q3ZCLEtBQXhDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL0RpYWxvZ3Vlcy9TY2FsZS5qcz83Yzk1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaW0sIFV0aWxzIH0gZnJvbSBcIkAvY29tcG9uZW50cy9saWJcIjtcblxuY29uc3QgREVGQVVMVF9XSURUSCA9IDcyMDtcbmNvbnN0IERFRkFVTFRfSEVJR0hUID0gNTc2O1xuY29uc3QgREVGQVVMVF9BU1BFQ1QgPSBcIjQ6M1wiO1xuXG5pbXBvcnQgeyBWQUxJRF9BU1BFQ1RfUkFUSU9TIH0gZnJvbSBcIi4uL1N0cmVhbXMvVmlkZW9cIjtcblxuY2xhc3MgU2NhbGUgZXh0ZW5kcyBTbGltIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBERUZBVUxUX1dJRFRILFxuICAgICAgICAgICAgaGVpZ2h0OiBERUZBVUxUX0hFSUdIVCxcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvOiBERUZBVUxUX0FTUEVDVCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVXaWR0aCA9IHRoaXMuaGFuZGxlV2lkdGguYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVIZWlnaHQgPSB0aGlzLmhhbmRsZUhlaWdodC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUFzcGVjdFJhdGlvID0gdGhpcy5oYW5kbGVBc3BlY3RSYXRpby5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIG9uQWRkZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlV2lkdGgoKTtcbiAgICB9XG5cbiAgICBzZXRXaWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLndpZHRoID0gdmFsdWU7XG4gICAgfVxuICAgIHNldEhlaWdodCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLmhlaWdodCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVdpZHRoKCk7XG4gICAgfVxuICAgIHNldEFzcGVjdFJhdGlvKHZhbHVlKSB7XG4gICAgICAgIGlmIChWQUxJRF9BU1BFQ1RfUkFUSU9TLmluZGV4T2YodmFsdWUpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUuYXNwZWN0UmF0aW8gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlV2lkdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZVdpZHRoKCkge1xuICAgICAgICBjb25zdCByYXRpbyA9IHRoaXMuc2NhbGUuYXNwZWN0UmF0aW8uc3BsaXQoXCI6XCIpO1xuICAgICAgICB0aGlzLnNjYWxlLndpZHRoID0gKHRoaXMuc2NhbGUuaGVpZ2h0IC8gcmF0aW9bMV0pICogcmF0aW9bMF07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBVdGlscy5mb3JjZVVwZGF0ZSh0aGlzLCBcInNjYWxlXCIpKTtcbiAgICB9XG5cbiAgICBoYW5kbGVXaWR0aChlKSB7XG4gICAgICAgIHRoaXMuc2V0V2lkdGgoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVIZWlnaHQoZSkge1xuICAgICAgICB0aGlzLnNldEhlaWdodChlLmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgIH1cblxuICAgIGhhbmRsZUFzcGVjdFJhdGlvKGUpIHtcbiAgICAgICAgdGhpcy5zZXRBc3BlY3RSYXRpbyhlLmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgIH1cbn1cblxuU2NhbGUudGVtcGxhdGUgPSAvKmh0bWwqLyBgXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBnYXA6IC41cmVtO1xuICAgIH1cbiAgICBmaWVsZHNldCB7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHZhcigtLWNsci1iZy0yMDApO1xuICAgICAgICBwYWRkaW5nOiAxcmVtO1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMTAwKTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgZ2FwOiAuNXJlbTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcbiAgICB9XG4gICAgbGVnZW5kIHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tY2xyLWJnLTApO1xuICAgICAgICBwYWRkaW5nOiAuMjVyZW07XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XG4gICAgfVxuICAgIGxhYmVsIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBnYXA6IC41cmVtO1xuICAgIH1cbiAgICBpbnB1dCB7XG4gICAgICAgIGFjY2VudC1jb2xvcjogdmFyKC0tY2xyLWVubGlnaHRlbmVkKTtcbiAgICB9XG4gICAgaW5wdXQ6Y2hlY2tlZCB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IDNweCB2YXIoLS1jbHItZW5saWdodGVuZWQtZ2xvdyk7XG4gICAgfVxuPC9zdHlsZT5cbjxmaWVsZHNldD5cbiAgICA8bGVnZW5kPkRpbWVuc2lvbnM6PC9sZWdlbmQ+XG4gICAgPGxhYmVsPlxuICAgICAgICA8c3Bhbj5XaWR0aDo8L3NwYW4+PGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT1cInt7IHRoaXMuc2NhbGUud2lkdGggfX1cIiBwbGFjZWhvbGRlcj1cIldpZHRoXCIgQGlucHV0PVwie3sgdGhpcy5oYW5kbGVXaWR0aCB9fVwiPlxuICAgIDwvbGFiZWw+XG4gICAgPGxhYmVsPlxuICAgICAgICA8c3Bhbj5IZWlnaHQ6PC9zcGFuPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9XCJ7eyB0aGlzLnNjYWxlLmhlaWdodCB9fVwiIHBsYWNlaG9sZGVyPVwiSGVpZ2h0XCIgQGlucHV0PVwie3sgdGhpcy5oYW5kbGVIZWlnaHQgfX1cIj5cbiAgICA8L2xhYmVsPlxuPC9maWVsZHNldD5cbjxmaWVsZHNldD5cbiAgICA8bGVnZW5kPkFzcGVjdC1SYXRpbzo8L2xlZ2VuZD5cbiAgICA8bGFiZWw+XG4gICAgICAgIDxzcGFuPjQ6Mzwvc3Bhbj5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJhc3BlY3RcIiB2YWx1ZT1cIjQ6M1wiIEBjaGFuZ2U9XCJ7eyB0aGlzLmhhbmRsZUFzcGVjdFJhdGlvIH19XCIgLmNoZWNrZWQ9XCJ7eyB0aGlzLnNjYWxlLmFzcGVjdFJhdGlvID09PSAnNDozJyB9fVwiPlxuICAgIDwvbGFiZWw+XG4gICAgPGxhYmVsPlxuICAgICAgICA8c3Bhbj4xNjo5PC9zcGFuPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImFzcGVjdFwiIHZhbHVlPVwiMTY6OVwiIEBjaGFuZ2U9XCJ7eyB0aGlzLmhhbmRsZUFzcGVjdFJhdGlvIH19XCIgLmNoZWNrZWQ9XCJ7eyB0aGlzLnNjYWxlLmFzcGVjdFJhdGlvID09PSAnMTY6OScgfX1cIj5cbiAgICA8L2xhYmVsPlxuPC9maWVsZHNldD5cbmA7XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcImRpYWxvZ3VlLXNjYWxlXCIsIFNjYWxlKTtcbiJdLCJuYW1lcyI6WyJTbGltIiwiVXRpbHMiLCJERUZBVUxUX1dJRFRIIiwiREVGQVVMVF9IRUlHSFQiLCJERUZBVUxUX0FTUEVDVCIsIlZBTElEX0FTUEVDVF9SQVRJT1MiLCJTY2FsZSIsInNjYWxlIiwid2lkdGgiLCJoZWlnaHQiLCJhc3BlY3RSYXRpbyIsImhhbmRsZVdpZHRoIiwiYmluZCIsImhhbmRsZUhlaWdodCIsImhhbmRsZUFzcGVjdFJhdGlvIiwiY2FsY3VsYXRlV2lkdGgiLCJ2YWx1ZSIsImluZGV4T2YiLCJyYXRpbyIsInNwbGl0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZm9yY2VVcGRhdGUiLCJlIiwic2V0V2lkdGgiLCJjdXJyZW50VGFyZ2V0Iiwic2V0SGVpZ2h0Iiwic2V0QXNwZWN0UmF0aW8iLCJ0ZW1wbGF0ZSIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Dialogues/Scale.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Dialogues/VideoEditor/index.js":
/*!*****************************************************************************!*\
  !*** ./resources/js/components/Configurator/Dialogues/VideoEditor/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EDITOR_CSS\": () => (/* binding */ EDITOR_CSS),\n/* harmony export */   \"EDITOR_TEMPLATE\": () => (/* binding */ EDITOR_TEMPLATE),\n/* harmony export */   \"VideoEditor\": () => (/* binding */ VideoEditor)\n/* harmony export */ });\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar THUMBNAIL_HEIGHT = 30;\n\nvar VideoEditor = /*#__PURE__*/function (_Slim) {\n  _inherits(VideoEditor, _Slim);\n\n  var _super = _createSuper(VideoEditor);\n\n  function VideoEditor() {\n    var _this;\n\n    _classCallCheck(this, VideoEditor);\n\n    _this = _super.call(this);\n\n    _this.bindListeners();\n\n    return _this;\n  }\n\n  _createClass(VideoEditor, [{\n    key: \"bindListeners\",\n    value: function bindListeners() {\n      this.toggleAspect = this.toggleAspect.bind(this);\n      this.handleIndicatorClick = this.handleIndicatorClick.bind(this);\n    }\n  }, {\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _parseInt,\n          _this2 = this;\n\n      this.fps = this.video.avg_frame_rate.split(\"/\")[0] / this.video.avg_frame_rate.split(\"/\")[1];\n      this.start = parseFloat(this.video.start_time);\n      this.current = (_parseInt = parseInt(this.start * 1000, 10)) !== null && _parseInt !== void 0 ? _parseInt : 0;\n      this.duration = this.video.duration * 1000;\n      this.displayDuration = this.timestamp(this.duration);\n      requestAnimationFrame(function () {\n        _this2.aspectRatio = _this2.video.display_aspect_ratio;\n        _components_lib__WEBPACK_IMPORTED_MODULE_0__.Iconify.scan(_this2.shadowRoot);\n      });\n    }\n  }, {\n    key: \"initImages\",\n    value: function initImages() {\n      this.addThumbnails();\n      this.updateImages();\n    }\n  }, {\n    key: \"updateImages\",\n    value: function updateImages() {\n      this.updateFrameUrl();\n      this.updateIndicatorPos();\n      this.currentTimestamp = this.timestamp();\n    }\n  }, {\n    key: \"updateIndicatorPos\",\n    value: function updateIndicatorPos() {\n      var percentage = 100 / this.duration * this.current;\n      this.indicatorPos = \"left: min(\".concat(percentage, \"%, 100% - 1px\");\n    }\n  }, {\n    key: \"addThumbnails\",\n    value: function addThumbnails() {\n      var i = 1;\n      var count = Math.floor(this.indicator.offsetWidth / (THUMBNAIL_HEIGHT * (4 / 3)));\n      var fr = this.duration / (count + 2);\n\n      do {\n        var img = document.createElement(\"img\");\n        var timestamp = this.timestamp(fr * i);\n        img.src = \"\".concat(this.baseThumbUrl).concat(timestamp, \"&width=\").concat(THUMBNAIL_HEIGHT * (4 / 3), \"&height=\").concat(THUMBNAIL_HEIGHT);\n        this.indicator.appendChild(img);\n      } while (i++ <= count);\n    }\n  }, {\n    key: \"handleIndicatorClick\",\n    value: function handleIndicatorClick(e) {\n      if (!e.composedPath().find(function (p) {\n        var _p$classList;\n\n        return (_p$classList = p.classList) === null || _p$classList === void 0 ? void 0 : _p$classList.contains(\"clip\");\n      })) {\n        var indicatorClickPos = parseInt(e.pageX - this.indicator.getBoundingClientRect().left);\n        this.current = this.duration * indicatorClickPos / this.indicator.offsetWidth;\n        this.updateImages();\n      }\n    }\n  }, {\n    key: \"timestamp\",\n    value: function timestamp(current) {\n      return new Date(current !== null && current !== void 0 ? current : this.current).toISOString().replace(/^[0-9-]+T/, \"\").replace(/z$/i, \"\");\n    }\n  }, {\n    key: \"toMilliSeconds\",\n    value: function toMilliSeconds(timestamp) {\n      var parts = timestamp.split(\":\");\n      var t = new Date(0);\n      t.setUTCHours(parts[0]);\n      t.setMinutes(parts[1]);\n      t.setMilliseconds(parts[2] * 1000);\n      return t.getTime();\n    }\n  }, {\n    key: \"updateFrameUrl\",\n    value: function updateFrameUrl() {\n      if (this.aspectDecimal) {\n        var width = this.video.height * this.aspectDecimal;\n        this.frameUrl = \"\".concat(this.baseUrl).concat(this.timestamp(), \"&width=\").concat(width, \"&height=\").concat(this.video.height, \"&filtered=1\");\n      } else {\n        this.frameUrl = \"\".concat(this.baseUrl).concat(this.timestamp(), \"&filtered=1\");\n      }\n    }\n  }, {\n    key: \"toggleAspect\",\n    value: function toggleAspect() {\n      switch (this.aspect) {\n        case \"16:9\":\n          this.aspect = \"4:3\";\n          this.aspectDecimal = 4 / 3;\n          break;\n\n        case \"4:3\":\n          this.aspect = \"Native\";\n          this.aspectDecimal = 0;\n          break;\n\n        default:\n          this.aspect = \"16:9\";\n          this.aspectDecimal = 16 / 9;\n      }\n\n      this.updateImages();\n    }\n  }, {\n    key: \"baseUrl\",\n    get: function get() {\n      return \"/image/\".concat(encodeURIComponent(this.path), \"?timestamp=\");\n    }\n  }, {\n    key: \"baseThumbUrl\",\n    get: function get() {\n      return this.baseUrl;\n    }\n  }, {\n    key: \"aspectRatio\",\n    get: function get() {\n      return this.aspect;\n    },\n    set: function set(value) {\n      if (value.match(/([0-9]+):([0-9]+)/)) {\n        this.aspect = value;\n        this.aspectDecimal = parseInt(RegExp.$1, 10) / parseInt(RegExp.$2, 10);\n\n        if (this.parentNode) {\n          this.updateImages();\n        }\n      }\n    }\n  }]);\n\n  return VideoEditor;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nvar EDITOR_CSS =\n/*html*/\n\"\\n<style>\\n:host {\\n        --thumbnail-height: \".concat(THUMBNAIL_HEIGHT + 16, \"px;\\n        display: grid;\\n        grid-template-columns: auto 1fr auto;\\n        grid-template-rows: calc(100% - var(--thumbnail-height) - var(--font-size-100) * var(--line-height-100)) min-content max-content;\\n        grid-template-areas:\\n            \\\"left frame right\\\"\\n            \\\"status status status\\\"\\n            \\\"thumbnails thumbnails thumbnails\\\";\\n        grid-column-gap: .5rem;\\n        height: 100%;\\n    }\\n\\n    .frame {\\n        grid-area: frame;\\n        max-width: 100%;\\n        max-height: 100%;\\n        justify-self: center;\\n    }\\n    .status {\\n        grid-area: status;\\n        text-align: center;\\n    }\\n    .indicator {\\n        grid-area: thumbnails;\\n        height: var(--thumbnail-height);\\n        position: relative;\\n        --background: var(--clr-bg-200);\\n        --size: 3px;\\n        background-image:\\n            linear-gradient(to right, var(--background) var(--size), transparent var(--size)),\\n            linear-gradient(to bottom, var(--background) var(--size), transparent var(--size)),\\n            linear-gradient(to right, var(--background) var(--size), transparent var(--size)),\\n            linear-gradient(to bottom, var(--background) var(--size), transparent var(--size)),\\n            linear-gradient(to bottom, transparent var(--size), var(--background) var(--size));\\n        background-size: calc(var(--size) * 2) var(--size), calc(var(--size) * 2) var(--size), calc(var(--size) * 2) var(--size), calc(var(--size) * 2) var(--size), 100% calc(100% - var(--size) * 3);\\n        background-repeat: repeat-x;\\n        background-position: 0 var(--size), top left, 0 calc(100% - var(--size)), bottom left, 0 var(--size);\\n        display: grid;\\n        grid-auto-flow: column;\\n        align-content: center;\\n        justify-items: center;\\n        z-index: 0;\\n    }\\n    .indicator img {\\n        max-width: 100%;\\n        max-height: 100%;\\n        z-index: 0;\\n    }\\n    .indicator .current {\\n        position: absolute;\\n        inset-block: -3px;\\n        background: red;\\n        width: 1px;\\n        z-index: 2;\\n    }\\n    .toggle-aspect {\\n        grid-area: frame;\\n        justify-self: start;\\n        align-self: start;\\n    }\\n    .toggle-aspect::part(button) {\\n        font-size: .75rem;\\n        padding: .5rem;\\n    }\\n</style>\");\nvar EDITOR_TEMPLATE =\n/*html*/\n\"\\n<img class=\\\"frame\\\" src=\\\"{{ this.frameUrl }}\\\" #ref=\\\"image\\\">\\n<theme-button class=\\\"toggle-aspect\\\" @click=\\\"{{ this.toggleAspect }}\\\">{{ this.aspect }}</theme-button>\\n<div class=\\\"status\\\">\\n    {{ this.currentTimestamp }} / {{ this.displayDuration }}\\n</div>\\n<div class=\\\"indicator\\\" #ref=\\\"indicator\\\" @click=\\\"{{ this.handleIndicatorClick }}\\\">\\n    <div class=\\\"current\\\" #ref=\\\"indicatorCurrent\\\" style=\\\"{{ this.indicatorPos }}\\\"></div>\\n</div>\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRGlhbG9ndWVzL1ZpZGVvRWRpdG9yL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQSxJQUFNRSxnQkFBZ0IsR0FBRyxFQUF6Qjs7SUFFTUM7Ozs7O0FBQ0YseUJBQWM7QUFBQTs7QUFBQTs7QUFDVjs7QUFDQSxVQUFLQyxhQUFMOztBQUZVO0FBR2I7Ozs7V0FFRCx5QkFBZ0I7QUFDWixXQUFLQyxZQUFMLEdBQW9CLEtBQUtBLFlBQUwsQ0FBa0JDLElBQWxCLENBQXVCLElBQXZCLENBQXBCO0FBQ0EsV0FBS0Msb0JBQUwsR0FBNEIsS0FBS0Esb0JBQUwsQ0FBMEJELElBQTFCLENBQStCLElBQS9CLENBQTVCO0FBQ0g7OztXQUVELG1CQUFVO0FBQUE7QUFBQTs7QUFDTixXQUFLRSxHQUFMLEdBQ0ksS0FBS0MsS0FBTCxDQUFXQyxjQUFYLENBQTBCQyxLQUExQixDQUFnQyxHQUFoQyxFQUFxQyxDQUFyQyxJQUNBLEtBQUtGLEtBQUwsQ0FBV0MsY0FBWCxDQUEwQkMsS0FBMUIsQ0FBZ0MsR0FBaEMsRUFBcUMsQ0FBckMsQ0FGSjtBQUdBLFdBQUtDLEtBQUwsR0FBYUMsVUFBVSxDQUFDLEtBQUtKLEtBQUwsQ0FBV0ssVUFBWixDQUF2QjtBQUNBLFdBQUtDLE9BQUwsZ0JBQWVDLFFBQVEsQ0FBQyxLQUFLSixLQUFMLEdBQWEsSUFBZCxFQUFvQixFQUFwQixDQUF2QixpREFBa0QsQ0FBbEQ7QUFDQSxXQUFLSyxRQUFMLEdBQWdCLEtBQUtSLEtBQUwsQ0FBV1EsUUFBWCxHQUFzQixJQUF0QztBQUNBLFdBQUtDLGVBQUwsR0FBdUIsS0FBS0MsU0FBTCxDQUFlLEtBQUtGLFFBQXBCLENBQXZCO0FBQ0FHLE1BQUFBLHFCQUFxQixDQUFDLFlBQU07QUFDeEIsY0FBSSxDQUFDQyxXQUFMLEdBQW1CLE1BQUksQ0FBQ1osS0FBTCxDQUFXYSxvQkFB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QUksS0FBS0MsVUFBVCxFQUFxQjtBQUNqQixlQUFLbkQsWUFBTDtBQUNIO0FBQ0o7QUFDSjs7OztFQWpJcUIxQjs7QUFvSW5CLElBQU04RSxVQUFVO0FBQUc7QUFBSCwwREFHTzVFLGdCQUFnQixHQUFHLEVBSDFCLG14RUFBaEI7QUFxRUEsSUFBTTZFLGVBQWU7QUFBRztBQUFILDZjQUFyQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9EaWFsb2d1ZXMvVmlkZW9FZGl0b3IvaW5kZXguanM/NDk2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltLCBJY29uaWZ5IH0gZnJvbSBcIkAvY29tcG9uZW50cy9saWJcIjtcblxuY29uc3QgVEhVTUJOQUlMX0hFSUdIVCA9IDMwO1xuXG5jbGFzcyBWaWRlb0VkaXRvciBleHRlbmRzIFNsaW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJpbmRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZUFzcGVjdCA9IHRoaXMudG9nZ2xlQXNwZWN0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5kaWNhdG9yQ2xpY2sgPSB0aGlzLmhhbmRsZUluZGljYXRvckNsaWNrLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgb25BZGRlZCgpIHtcbiAgICAgICAgdGhpcy5mcHMgPVxuICAgICAgICAgICAgdGhpcy52aWRlby5hdmdfZnJhbWVfcmF0ZS5zcGxpdChcIi9cIilbMF0gL1xuICAgICAgICAgICAgdGhpcy52aWRlby5hdmdfZnJhbWVfcmF0ZS5zcGxpdChcIi9cIilbMV07XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwYXJzZUZsb2F0KHRoaXMudmlkZW8uc3RhcnRfdGltZSk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHBhcnNlSW50KHRoaXMuc3RhcnQgKiAxMDAwLCAxMCkgPz8gMDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMudmlkZW8uZHVyYXRpb24gKiAxMDAwO1xuICAgICAgICB0aGlzLmRpc3BsYXlEdXJhdGlvbiA9IHRoaXMudGltZXN0YW1wKHRoaXMuZHVyYXRpb24pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IHRoaXMudmlkZW8uZGlzcGxheV9hc3BlY3RfcmF0aW87XG4gICAgICAgICAgICBJY29uaWZ5LnNjYW4odGhpcy5zaGFkb3dSb290KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5pdEltYWdlcygpIHtcbiAgICAgICAgdGhpcy5hZGRUaHVtYm5haWxzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW1hZ2VzKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlSW1hZ2VzKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZyYW1lVXJsKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5kaWNhdG9yUG9zKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVzdGFtcCA9IHRoaXMudGltZXN0YW1wKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlSW5kaWNhdG9yUG9zKCkge1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKDEwMCAvIHRoaXMuZHVyYXRpb24pICogdGhpcy5jdXJyZW50O1xuICAgICAgICB0aGlzLmluZGljYXRvclBvcyA9IGBsZWZ0OiBtaW4oJHtwZXJjZW50YWdlfSUsIDEwMCUgLSAxcHhgO1xuICAgIH1cblxuICAgIGFkZFRodW1ibmFpbHMoKSB7XG4gICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3Iub2Zmc2V0V2lkdGggLyAoVEhVTUJOQUlMX0hFSUdIVCAqICg0IC8gMykpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGZyID0gdGhpcy5kdXJhdGlvbiAvIChjb3VudCArIDIpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gdGhpcy50aW1lc3RhbXAoZnIgKiBpKTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBgJHt0aGlzLmJhc2VUaHVtYlVybH0ke3RpbWVzdGFtcH0md2lkdGg9JHtUSFVNQk5BSUxfSEVJR0hUICogKDQgLyAzKX0maGVpZ2h0PSR7VEhVTUJOQUlMX0hFSUdIVH1gO1xuICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3IuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgfSB3aGlsZSAoaSsrIDw9IGNvdW50KTtcbiAgICB9XG5cbiAgICBoYW5kbGVJbmRpY2F0b3JDbGljayhlKSB7XG4gICAgICAgIGlmICghZS5jb21wb3NlZFBhdGgoKS5maW5kKChwKSA9PiBwLmNsYXNzTGlzdD8uY29udGFpbnMoXCJjbGlwXCIpKSkge1xuICAgICAgICBjb25zdCBpbmRpY2F0b3JDbGlja1BvcyA9IHBhcnNlSW50KGUucGFnZVggLSB0aGlzLmluZGljYXRvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9XG4gICAgICAgICAgICAgICAgKHRoaXMuZHVyYXRpb24gKiBpbmRpY2F0b3JDbGlja1BvcykgLyB0aGlzLmluZGljYXRvci5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lc3RhbXAoY3VycmVudCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoY3VycmVudCA/PyB0aGlzLmN1cnJlbnQpXG4gICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15bMC05LV0rVC8sIFwiXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgveiQvaSwgXCJcIik7XG4gICAgfVxuXG4gICAgdG9NaWxsaVNlY29uZHModGltZXN0YW1wKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdGltZXN0YW1wLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBEYXRlKDApO1xuICAgICAgICB0LnNldFVUQ0hvdXJzKHBhcnRzWzBdKTtcbiAgICAgICAgdC5zZXRNaW51dGVzKHBhcnRzWzFdKTtcbiAgICAgICAgdC5zZXRNaWxsaXNlY29uZHMocGFydHNbMl0gKiAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHQuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZUZyYW1lVXJsKCkge1xuICAgICAgICBpZiAodGhpcy5hc3BlY3REZWNpbWFsKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMudmlkZW8uaGVpZ2h0ICogdGhpcy5hc3BlY3REZWNpbWFsO1xuICAgICAgICAgICAgdGhpcy5mcmFtZVVybCA9IGAke1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVVybFxuICAgICAgICAgICAgfSR7dGhpcy50aW1lc3RhbXAoKX0md2lkdGg9JHt3aWR0aH0maGVpZ2h0PSR7dGhpcy52aWRlby5oZWlnaHR9JmZpbHRlcmVkPTFgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mcmFtZVVybCA9IGAke3RoaXMuYmFzZVVybH0ke3RoaXMudGltZXN0YW1wKCl9JmZpbHRlcmVkPTFgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlQXNwZWN0KCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYXNwZWN0KSB7XG4gICAgICAgICAgICBjYXNlIFwiMTY6OVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuYXNwZWN0ID0gXCI0OjNcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmFzcGVjdERlY2ltYWwgPSA0IC8gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI0OjNcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmFzcGVjdCA9IFwiTmF0aXZlXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3BlY3REZWNpbWFsID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5hc3BlY3QgPSBcIjE2OjlcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmFzcGVjdERlY2ltYWwgPSAxNiAvIDk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbWFnZXMoKTtcbiAgICB9XG5cbiAgICBnZXQgYmFzZVVybCgpIHtcbiAgICAgICAgcmV0dXJuIGAvaW1hZ2UvJHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5wYXRoKX0/dGltZXN0YW1wPWA7XG4gICAgfVxuXG4gICAgZ2V0IGJhc2VUaHVtYlVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVVybDtcbiAgICB9XG5cbiAgICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzcGVjdDtcbiAgICB9XG5cbiAgICBzZXQgYXNwZWN0UmF0aW8odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC8oWzAtOV0rKTooWzAtOV0rKS8pKSB7XG4gICAgICAgICAgICB0aGlzLmFzcGVjdCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hc3BlY3REZWNpbWFsID1cbiAgICAgICAgICAgICAgICBwYXJzZUludChSZWdFeHAuJDEsIDEwKSAvIHBhcnNlSW50KFJlZ0V4cC4kMiwgMTApO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBFRElUT1JfQ1NTID0gLypodG1sKi8gYFxuPHN0eWxlPlxuOmhvc3Qge1xuICAgICAgICAtLXRodW1ibmFpbC1oZWlnaHQ6ICR7VEhVTUJOQUlMX0hFSUdIVCArIDE2fXB4O1xuICAgICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IGF1dG8gMWZyIGF1dG87XG4gICAgICAgIGdyaWQtdGVtcGxhdGUtcm93czogY2FsYygxMDAlIC0gdmFyKC0tdGh1bWJuYWlsLWhlaWdodCkgLSB2YXIoLS1mb250LXNpemUtMTAwKSAqIHZhcigtLWxpbmUtaGVpZ2h0LTEwMCkpIG1pbi1jb250ZW50IG1heC1jb250ZW50O1xuICAgICAgICBncmlkLXRlbXBsYXRlLWFyZWFzOlxuICAgICAgICAgICAgXCJsZWZ0IGZyYW1lIHJpZ2h0XCJcbiAgICAgICAgICAgIFwic3RhdHVzIHN0YXR1cyBzdGF0dXNcIlxuICAgICAgICAgICAgXCJ0aHVtYm5haWxzIHRodW1ibmFpbHMgdGh1bWJuYWlsc1wiO1xuICAgICAgICBncmlkLWNvbHVtbi1nYXA6IC41cmVtO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuXG4gICAgLmZyYW1lIHtcbiAgICAgICAgZ3JpZC1hcmVhOiBmcmFtZTtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtaGVpZ2h0OiAxMDAlO1xuICAgICAgICBqdXN0aWZ5LXNlbGY6IGNlbnRlcjtcbiAgICB9XG4gICAgLnN0YXR1cyB7XG4gICAgICAgIGdyaWQtYXJlYTogc3RhdHVzO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuICAgIC5pbmRpY2F0b3Ige1xuICAgICAgICBncmlkLWFyZWE6IHRodW1ibmFpbHM7XG4gICAgICAgIGhlaWdodDogdmFyKC0tdGh1bWJuYWlsLWhlaWdodCk7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgLS1iYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMjAwKTtcbiAgICAgICAgLS1zaXplOiAzcHg7XG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6XG4gICAgICAgICAgICBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHZhcigtLWJhY2tncm91bmQpIHZhcigtLXNpemUpLCB0cmFuc3BhcmVudCB2YXIoLS1zaXplKSksXG4gICAgICAgICAgICBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCB2YXIoLS1iYWNrZ3JvdW5kKSB2YXIoLS1zaXplKSwgdHJhbnNwYXJlbnQgdmFyKC0tc2l6ZSkpLFxuICAgICAgICAgICAgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCB2YXIoLS1iYWNrZ3JvdW5kKSB2YXIoLS1zaXplKSwgdHJhbnNwYXJlbnQgdmFyKC0tc2l6ZSkpLFxuICAgICAgICAgICAgbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgdmFyKC0tYmFja2dyb3VuZCkgdmFyKC0tc2l6ZSksIHRyYW5zcGFyZW50IHZhcigtLXNpemUpKSxcbiAgICAgICAgICAgIGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sIHRyYW5zcGFyZW50IHZhcigtLXNpemUpLCB2YXIoLS1iYWNrZ3JvdW5kKSB2YXIoLS1zaXplKSk7XG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogY2FsYyh2YXIoLS1zaXplKSAqIDIpIHZhcigtLXNpemUpLCBjYWxjKHZhcigtLXNpemUpICogMikgdmFyKC0tc2l6ZSksIGNhbGModmFyKC0tc2l6ZSkgKiAyKSB2YXIoLS1zaXplKSwgY2FsYyh2YXIoLS1zaXplKSAqIDIpIHZhcigtLXNpemUpLCAxMDAlIGNhbGMoMTAwJSAtIHZhcigtLXNpemUpICogMyk7XG4gICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcbiAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCB2YXIoLS1zaXplKSwgdG9wIGxlZnQsIDAgY2FsYygxMDAlIC0gdmFyKC0tc2l6ZSkpLCBib3R0b20gbGVmdCwgMCB2YXIoLS1zaXplKTtcbiAgICAgICAgZGlzcGxheTogZ3JpZDtcbiAgICAgICAgZ3JpZC1hdXRvLWZsb3c6IGNvbHVtbjtcbiAgICAgICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgfVxuICAgIC5pbmRpY2F0b3IgaW1nIHtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtaGVpZ2h0OiAxMDAlO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgIH1cbiAgICAuaW5kaWNhdG9yIC5jdXJyZW50IHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBpbnNldC1ibG9jazogLTNweDtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgICB3aWR0aDogMXB4O1xuICAgICAgICB6LWluZGV4OiAyO1xuICAgIH1cbiAgICAudG9nZ2xlLWFzcGVjdCB7XG4gICAgICAgIGdyaWQtYXJlYTogZnJhbWU7XG4gICAgICAgIGp1c3RpZnktc2VsZjogc3RhcnQ7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0YXJ0O1xuICAgIH1cbiAgICAudG9nZ2xlLWFzcGVjdDo6cGFydChidXR0b24pIHtcbiAgICAgICAgZm9udC1zaXplOiAuNzVyZW07XG4gICAgICAgIHBhZGRpbmc6IC41cmVtO1xuICAgIH1cbjwvc3R5bGU+YDtcblxuZXhwb3J0IGNvbnN0IEVESVRPUl9URU1QTEFURSA9IC8qaHRtbCovIGBcbjxpbWcgY2xhc3M9XCJmcmFtZVwiIHNyYz1cInt7IHRoaXMuZnJhbWVVcmwgfX1cIiAjcmVmPVwiaW1hZ2VcIj5cbjx0aGVtZS1idXR0b24gY2xhc3M9XCJ0b2dnbGUtYXNwZWN0XCIgQGNsaWNrPVwie3sgdGhpcy50b2dnbGVBc3BlY3QgfX1cIj57eyB0aGlzLmFzcGVjdCB9fTwvdGhlbWUtYnV0dG9uPlxuPGRpdiBjbGFzcz1cInN0YXR1c1wiPlxuICAgIHt7IHRoaXMuY3VycmVudFRpbWVzdGFtcCB9fSAvIHt7IHRoaXMuZGlzcGxheUR1cmF0aW9uIH19XG48L2Rpdj5cbjxkaXYgY2xhc3M9XCJpbmRpY2F0b3JcIiAjcmVmPVwiaW5kaWNhdG9yXCIgQGNsaWNrPVwie3sgdGhpcy5oYW5kbGVJbmRpY2F0b3JDbGljayB9fVwiPlxuICAgIDxkaXYgY2xhc3M9XCJjdXJyZW50XCIgI3JlZj1cImluZGljYXRvckN1cnJlbnRcIiBzdHlsZT1cInt7IHRoaXMuaW5kaWNhdG9yUG9zIH19XCI+PC9kaXY+XG48L2Rpdj5gO1xuXG5leHBvcnQgeyBWaWRlb0VkaXRvciB9O1xuIl0sIm5hbWVzIjpbIlNsaW0iLCJJY29uaWZ5IiwiVEhVTUJOQUlMX0hFSUdIVCIsIlZpZGVvRWRpdG9yIiwiYmluZExpc3RlbmVycyIsInRvZ2dsZUFzcGVjdCIsImJpbmQiLCJoYW5kbGVJbmRpY2F0b3JDbGljayIsImZwcyIsInZpZGVvIiwiYXZnX2ZyYW1lX3JhdGUiLCJzcGxpdCIsInN0YXJ0IiwicGFyc2VGbG9hdCIsInN0YXJ0X3RpbWUiLCJjdXJyZW50IiwicGFyc2VJbnQiLCJkdXJhdGlvbiIsImRpc3BsYXlEdXJhdGlvbiIsInRpbWVzdGFtcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFzcGVjdFJhdGlvIiwiZGlzcGxheV9hc3BlY3RfcmF0aW8iLCJzY2FuIiwic2hhZG93Um9vdCIsImFkZFRodW1ibmFpbHMiLCJ1cGRhdGVJbWFnZXMiLCJ1cGRhdGVGcmFtZVVybCIsInVwZGF0ZUluZGljYXRvclBvcyIsImN1cnJlbnRUaW1lc3RhbXAiLCJwZXJjZW50YWdlIiwiaW5kaWNhdG9yUG9zIiwiaSIsImNvdW50IiwiTWF0aCIsImZsb29yIiwiaW5kaWNhdG9yIiwib2Zmc2V0V2lkdGgiLCJmciIsImltZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsImJhc2VUaHVtYlVybCIsImFwcGVuZENoaWxkIiwiZSIsImNvbXBvc2VkUGF0aCIsImZpbmQiLCJwIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJpbmRpY2F0b3JDbGlja1BvcyIsInBhZ2VYIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibGVmdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJwYXJ0cyIsInQiLCJzZXRVVENIb3VycyIsInNldE1pbnV0ZXMiLCJzZXRNaWxsaXNlY29uZHMiLCJnZXRUaW1lIiwiYXNwZWN0RGVjaW1hbCIsIndpZHRoIiwiaGVpZ2h0IiwiZnJhbWVVcmwiLCJiYXNlVXJsIiwiYXNwZWN0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicGF0aCIsInZhbHVlIiwibWF0Y2giLCJSZWdFeHAiLCIkMSIsIiQyIiwicGFyZW50Tm9kZSIsIkVESVRPUl9DU1MiLCJFRElUT1JfVEVNUExBVEUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Dialogues/VideoEditor/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/FilterGraph/Filter.js":
/*!********************************************************************!*\
  !*** ./resources/js/components/Configurator/FilterGraph/Filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\n/* harmony import */ var _CardCss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CardCss */ \"./resources/js/components/Configurator/CardCss.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar Filter = /*#__PURE__*/function (_Slim) {\n  _inherits(Filter, _Slim);\n\n  var _super = _createSuper(Filter);\n\n  function Filter() {\n    var _this;\n\n    _classCallCheck(this, Filter);\n\n    _this = _super.call(this);\n\n    _this.bindListener();\n\n    return _this;\n  }\n\n  _createClass(Filter, [{\n    key: \"bindListener\",\n    value: function bindListener() {\n      this.handleDelete = this.handleDelete.bind(this);\n    }\n  }, {\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      requestAnimationFrame(function () {\n        return Iconify.scan(_this2.shadowRoot);\n      });\n    }\n  }, {\n    key: \"handleDelete\",\n    value: function handleDelete(e) {\n      this.configurator.filterGraph.splice(parseInt(this.dataset.id), 1);\n      this.configurator.saveSettings();\n      _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(this.configurator);\n    }\n  }, {\n    key: \"description\",\n    get: function get() {\n      if (this.filterData.filterType === 'crop') {\n        if (this.filterData.replaceBlackBorders) {\n          return \"replace borders\".concat(this.filterData.mirror ? ' (mirrored)' : '');\n        }\n      }\n\n      return '';\n    }\n  }]);\n\n  return Filter;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nFilter.template =\n/*html*/\n\"\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_1__.ICON_STACK_CSS, \"\\n\").concat(_CardCss__WEBPACK_IMPORTED_MODULE_2__.default, \"\\n<style>\\nsection {\\n    display: flex;\\n    justify-content: space-between;\\n    align-items: center;\\n}\\n.icon-stack, .item {\\n    cursor: pointer;\\n}\\n</style>\\n<section>\\n    <div class=\\\"item\\\">\\n        <span>{{ this.filterData.filterType }}</span>\\n        <span>\\n            {{ this.description }}\\n        </span>\\n    </div>\\n    <div @click=\\\"{{ this.handleDelete }}\\\" class=\\\"icon-stack\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-close\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-close\\\"></span>\\n    </div>\\n</section>\\n\");\ncustomElements.define('transcode-configurator-filter', Filter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRmlsdGVyR3JhcGgvRmlsdGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztJQUVNSTs7Ozs7QUFFRixvQkFBYztBQUFBOztBQUFBOztBQUNWOztBQUNBLFVBQUtDLFlBQUw7O0FBRlU7QUFHYjs7OztXQUVELHdCQUFlO0FBQ1gsV0FBS0MsWUFBTCxHQUFvQixLQUFLQSxZQUFMLENBQWtCQyxJQUFsQixDQUF1QixJQUF2QixDQUFwQjtBQUNIOzs7V0FFRCxtQkFBVTtBQUFBOztBQUNOQyxNQUFBQSxxQkFBcUIsQ0FBQztBQUFBLGVBQU1DLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLE1BQUksQ0FBQ0MsVUFBbEIsQ0FBTjtBQUFBLE9BQUQsQ0FBckI7QUFDSDs7O1dBRUQsc0JBQWFDLENBQWIsRUFBZ0I7QUFDWixXQUFLQyxZQUFMLENBQWtCQyxXQUFsQixDQUE4QkMsTUFBOUIsQ0FBcUNDLFFBQVEsQ0FBQyxLQUFLQyxPQUFMLENBQWFDLEVBQWQsQ0FBN0MsRUFBZ0UsQ0FBaEU7QUFDQSxXQUFLTCxZQUFMLENBQWtCTSxZQUFsQjtBQUNBbEIsTUFBQUEsOERBQUEsQ0FBa0IsS0FBS1ksWUFBdkI7QUFDSDs7O1NBRUQsZUFBa0I7QUFDZCxVQUFJLEtBQUtRLFVBQUwsQ0FBZ0JDLFVBQWhCLEtBQStCLE1BQW5DLEVBQTJDO0FBQ3ZDLFlBQUksS0FBS0QsVUFBTCxDQUFnQkUsbUJBQXBCLEVBQXlDO0FBQ3JDLDBDQUF5QixLQUFLRixVQUFMLENBQWdCRyxNQUFoQixHQUF5QixhQUF6QixHQUF5QyxFQUFsRTtBQUNIO0FBQ0o7O0FBQ0QsYUFBTyxFQUFQO0FBQ0g7Ozs7RUE1QmdCeEI7O0FBK0JyQkksTUFBTSxDQUFDcUIsUUFBUDtBQUFrQjtBQUFsQixZQUNFdkIsdUVBREYsZUFFRUMsNkNBRkY7QUEyQkF1QixjQUFjLENBQUNDLE1BQWYsQ0FBc0IsK0JBQXRCLEVBQXVEdkIsTUFBdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRmlsdGVyR3JhcGgvRmlsdGVyLmpzPzk1MzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2xpbSwgVXRpbHMgfSBmcm9tICdAL2NvbXBvbmVudHMvbGliJztcbmltcG9ydCB7IElDT05fU1RBQ0tfQ1NTIH0gZnJvbSAnQC9jb21wb25lbnRzL0ljb25zL1N0YWNrLmNzcydcbmltcG9ydCBDQVJEX0NTUyBmcm9tICcuLi9DYXJkQ3NzJztcblxuY2xhc3MgRmlsdGVyIGV4dGVuZHMgU2xpbSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5iaW5kTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICBiaW5kTGlzdGVuZXIoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRGVsZXRlID0gdGhpcy5oYW5kbGVEZWxldGUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBvbkFkZGVkKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gSWNvbmlmeS5zY2FuKHRoaXMuc2hhZG93Um9vdCkpO1xuICAgIH1cblxuICAgIGhhbmRsZURlbGV0ZShlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdG9yLmZpbHRlckdyYXBoLnNwbGljZShwYXJzZUludCh0aGlzLmRhdGFzZXQuaWQpLCAxKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIFV0aWxzLmZvcmNlVXBkYXRlKHRoaXMuY29uZmlndXJhdG9yKTtcbiAgICB9XG5cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlckRhdGEuZmlsdGVyVHlwZSA9PT0gJ2Nyb3AnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJEYXRhLnJlcGxhY2VCbGFja0JvcmRlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHJlcGxhY2UgYm9yZGVycyR7dGhpcy5maWx0ZXJEYXRhLm1pcnJvciA/ICcgKG1pcnJvcmVkKScgOiAnJ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbkZpbHRlci50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7SUNPTl9TVEFDS19DU1N9XG4ke0NBUkRfQ1NTfVxuPHN0eWxlPlxuc2VjdGlvbiB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5pY29uLXN0YWNrLCAuaXRlbSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuPC9zdHlsZT5cbjxzZWN0aW9uPlxuICAgIDxkaXYgY2xhc3M9XCJpdGVtXCI+XG4gICAgICAgIDxzcGFuPnt7IHRoaXMuZmlsdGVyRGF0YS5maWx0ZXJUeXBlIH19PC9zcGFuPlxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgIHt7IHRoaXMuZGVzY3JpcHRpb24gfX1cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgQGNsaWNrPVwie3sgdGhpcy5oYW5kbGVEZWxldGUgfX1cIiBjbGFzcz1cImljb24tc3RhY2tcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWNsb3NlXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktY2xvc2VcIj48L3NwYW4+XG4gICAgPC9kaXY+XG48L3NlY3Rpb24+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RyYW5zY29kZS1jb25maWd1cmF0b3ItZmlsdGVyJywgRmlsdGVyKTsiXSwibmFtZXMiOlsiU2xpbSIsIlV0aWxzIiwiSUNPTl9TVEFDS19DU1MiLCJDQVJEX0NTUyIsIkZpbHRlciIsImJpbmRMaXN0ZW5lciIsImhhbmRsZURlbGV0ZSIsImJpbmQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJJY29uaWZ5Iiwic2NhbiIsInNoYWRvd1Jvb3QiLCJlIiwiY29uZmlndXJhdG9yIiwiZmlsdGVyR3JhcGgiLCJzcGxpY2UiLCJwYXJzZUludCIsImRhdGFzZXQiLCJpZCIsInNhdmVTZXR0aW5ncyIsImZvcmNlVXBkYXRlIiwiZmlsdGVyRGF0YSIsImZpbHRlclR5cGUiLCJyZXBsYWNlQmxhY2tCb3JkZXJzIiwibWlycm9yIiwidGVtcGxhdGUiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/FilterGraph/Filter.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/FilterGraph/index.js":
/*!*******************************************************************!*\
  !*** ./resources/js/components/Configurator/FilterGraph/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _CardCss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CardCss */ \"./resources/js/components/Configurator/CardCss.js\");\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\n/* harmony import */ var _Filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Filter */ \"./resources/js/components/Configurator/FilterGraph/Filter.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\nvar FilterGraph = /*#__PURE__*/function (_Slim) {\n  _inherits(FilterGraph, _Slim);\n\n  var _super = _createSuper(FilterGraph);\n\n  function FilterGraph() {\n    _classCallCheck(this, FilterGraph);\n\n    return _super.apply(this, arguments);\n  }\n\n  return FilterGraph;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nFilterGraph.template =\n/*html*/\n\"\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_2__.ICON_STACK_CSS, \"\\n\").concat(_CardCss__WEBPACK_IMPORTED_MODULE_1__.default, \"\\n<main>\\n    <h2>FilterGraph</h2>\\n    <div class=\\\"filters\\\">\\n        <transcode-configurator-filter\\n            data-id=\\\"{{ this.filters.findIndex(f => f === item) }}\\\"\\n             .configurator=\\\"{{ this.configurator }}\\\"\\n            *foreach=\\\"{{ this.filters }}\\\"\\n            .filter-data=\\\"{{ item }}\\n        \\\"></transcode-configurator-filter>\\n    </div>\\n</main>\\n\");\ncustomElements.define(\"transcode-configurator-filter-graph\", FilterGraph);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRmlsdGVyR3JhcGgvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7SUFFTUs7Ozs7Ozs7Ozs7OztFQUFvQkw7O0FBRTFCSyxXQUFXLENBQUNDLFFBQVo7QUFBdUI7QUFBdkIsWUFDRUYsdUVBREYsZUFFRUQsNkNBRkY7QUFlQUksY0FBYyxDQUFDQyxNQUFmLENBQXNCLHFDQUF0QixFQUE2REgsV0FBN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRmlsdGVyR3JhcGgvaW5kZXguanM/Y2QxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltLCBVdGlscywgSWNvbmlmeSB9IGZyb20gXCJAL2NvbXBvbmVudHMvbGliXCI7XG5pbXBvcnQgQ0FSRF9DU1MgZnJvbSBcIi4uL0NhcmRDc3NcIjtcbmltcG9ydCB7IElDT05fU1RBQ0tfQ1NTIH0gZnJvbSBcIkAvY29tcG9uZW50cy9JY29ucy9TdGFjay5jc3NcIjtcbmltcG9ydCBcIi4vRmlsdGVyXCI7XG5cbmNsYXNzIEZpbHRlckdyYXBoIGV4dGVuZHMgU2xpbSB7fVxuXG5GaWx0ZXJHcmFwaC50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7SUNPTl9TVEFDS19DU1N9XG4ke0NBUkRfQ1NTfVxuPG1haW4+XG4gICAgPGgyPkZpbHRlckdyYXBoPC9oMj5cbiAgICA8ZGl2IGNsYXNzPVwiZmlsdGVyc1wiPlxuICAgICAgICA8dHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1maWx0ZXJcbiAgICAgICAgICAgIGRhdGEtaWQ9XCJ7eyB0aGlzLmZpbHRlcnMuZmluZEluZGV4KGYgPT4gZiA9PT0gaXRlbSkgfX1cIlxuICAgICAgICAgICAgIC5jb25maWd1cmF0b3I9XCJ7eyB0aGlzLmNvbmZpZ3VyYXRvciB9fVwiXG4gICAgICAgICAgICAqZm9yZWFjaD1cInt7IHRoaXMuZmlsdGVycyB9fVwiXG4gICAgICAgICAgICAuZmlsdGVyLWRhdGE9XCJ7eyBpdGVtIH19XG4gICAgICAgIFwiPjwvdHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1maWx0ZXI+XG4gICAgPC9kaXY+XG48L21haW4+XG5gO1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwidHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1maWx0ZXItZ3JhcGhcIiwgRmlsdGVyR3JhcGgpOyJdLCJuYW1lcyI6WyJTbGltIiwiVXRpbHMiLCJJY29uaWZ5IiwiQ0FSRF9DU1MiLCJJQ09OX1NUQUNLX0NTUyIsIkZpbHRlckdyYXBoIiwidGVtcGxhdGUiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/FilterGraph/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Format.js":
/*!********************************************************!*\
  !*** ./resources/js/components/Configurator/Format.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _CardCss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CardCss */ \"./resources/js/components/Configurator/CardCss.js\");\n/* harmony import */ var _Helper_File__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/Helper/File */ \"./resources/js/Helper/File.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar Format = /*#__PURE__*/function (_Slim) {\n  _inherits(Format, _Slim);\n\n  var _super = _createSuper(Format);\n\n  function Format() {\n    _classCallCheck(this, Format);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Format, [{\n    key: \"duration\",\n    get: function get() {\n      if (!this.format.duration) {\n        return 'N/A';\n      }\n\n      return new Date(this.format.duration * 1000).toISOString().replace(/^[0-9-]+T/, '').replace(/z$/i, '');\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return _Helper_File__WEBPACK_IMPORTED_MODULE_2__.default.fileSizeH(this.format.size);\n    }\n  }, {\n    key: \"bitRate\",\n    get: function get() {\n      if (!this.format.bit_rate) {\n        return 'N/A';\n      }\n\n      return \"\".concat(Math.round(this.format.bit_rate / 1000), \" kb/s\");\n    }\n  }]);\n\n  return Format;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nFormat.template =\n/*html*/\n\"\\n\".concat(_CardCss__WEBPACK_IMPORTED_MODULE_1__.default, \"\\n<style>\\n    .select-all {\\n        user-select: all;\\n    }\\n    .filename {\\n        font-size: .75em;\\n    }\\n</style>\\n<main>\\n    <h2>Format</h2>\\n    <section>\\n        <div class=\\\"filename select-all\\\">{{ this.format.filename }}</div>\\n        <div>Container: {{ this.format.format_long_name }} / {{ this.format.format_name }}\\n        <div>Duration:&nbsp;<span class=\\\"select-all\\\">{{ this.duration }}</span>, Size: {{ this.size }}, Bitrate: {{ this.bitRate }}</div>\\n    </section>\\n</main>\\n\");\ncustomElements.define('transcode-configurator-format', Format);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRm9ybWF0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztJQUVNRzs7Ozs7Ozs7Ozs7OztTQUVGLGVBQWU7QUFDWCxVQUFJLENBQUMsS0FBS0MsTUFBTCxDQUFZQyxRQUFqQixFQUEyQjtBQUN2QixlQUFPLEtBQVA7QUFDSDs7QUFDRCxhQUFPLElBQUlDLElBQUosQ0FBUyxLQUFLRixNQUFMLENBQVlDLFFBQVosR0FBdUIsSUFBaEMsRUFBc0NFLFdBQXRDLEdBQW9EQyxPQUFwRCxDQUE0RCxXQUE1RCxFQUF5RSxFQUF6RSxFQUE2RUEsT0FBN0UsQ0FBcUYsS0FBckYsRUFBNEYsRUFBNUYsQ0FBUDtBQUNIOzs7U0FFRCxlQUFXO0FBQ1AsYUFBT04sMkRBQUEsQ0FBcUIsS0FBS0UsTUFBTCxDQUFZTSxJQUFqQyxDQUFQO0FBQ0g7OztTQUVELGVBQWM7QUFDVixVQUFJLENBQUMsS0FBS04sTUFBTCxDQUFZTyxRQUFqQixFQUEyQjtBQUN2QixlQUFPLEtBQVA7QUFDSDs7QUFDRCx1QkFBVUMsSUFBSSxDQUFDQyxLQUFMLENBQVcsS0FBS1QsTUFBTCxDQUFZTyxRQUFaLEdBQXVCLElBQWxDLENBQVY7QUFDSDs7OztFQWxCZ0JYOztBQXFCckJHLE1BQU0sQ0FBQ1csUUFBUDtBQUFrQjtBQUFsQixZQUNFYiw2Q0FERjtBQW9CQWMsY0FBYyxDQUFDQyxNQUFmLENBQXNCLCtCQUF0QixFQUF1RGIsTUFBdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvRm9ybWF0LmpzPzI2YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2xpbSB9IGZyb20gJ0AvY29tcG9uZW50cy9saWInO1xuaW1wb3J0IENBUkRfQ1NTIGZyb20gJy4vQ2FyZENzcyc7XG5pbXBvcnQgRmlsZUhlbHBlciBmcm9tICdAL0hlbHBlci9GaWxlJztcblxuY2xhc3MgRm9ybWF0IGV4dGVuZHMgU2xpbSB7XG5cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5mb3JtYXQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAnTi9BJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5mb3JtYXQuZHVyYXRpb24gKiAxMDAwKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL15bMC05LV0rVC8sICcnKS5yZXBsYWNlKC96JC9pLCAnJylcbiAgICB9XG5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEZpbGVIZWxwZXIuZmlsZVNpemVIKHRoaXMuZm9ybWF0LnNpemUpXG4gICAgfVxuXG4gICAgZ2V0IGJpdFJhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5mb3JtYXQuYml0X3JhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnTi9BJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZCh0aGlzLmZvcm1hdC5iaXRfcmF0ZSAvIDEwMDApfSBrYi9zYFxuICAgIH1cbn1cblxuRm9ybWF0LnRlbXBsYXRlID0gLypodG1sKi8gYFxuJHtDQVJEX0NTU31cbjxzdHlsZT5cbiAgICAuc2VsZWN0LWFsbCB7XG4gICAgICAgIHVzZXItc2VsZWN0OiBhbGw7XG4gICAgfVxuICAgIC5maWxlbmFtZSB7XG4gICAgICAgIGZvbnQtc2l6ZTogLjc1ZW07XG4gICAgfVxuPC9zdHlsZT5cbjxtYWluPlxuICAgIDxoMj5Gb3JtYXQ8L2gyPlxuICAgIDxzZWN0aW9uPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZW5hbWUgc2VsZWN0LWFsbFwiPnt7IHRoaXMuZm9ybWF0LmZpbGVuYW1lIH19PC9kaXY+XG4gICAgICAgIDxkaXY+Q29udGFpbmVyOiB7eyB0aGlzLmZvcm1hdC5mb3JtYXRfbG9uZ19uYW1lIH19IC8ge3sgdGhpcy5mb3JtYXQuZm9ybWF0X25hbWUgfX1cbiAgICAgICAgPGRpdj5EdXJhdGlvbjombmJzcDs8c3BhbiBjbGFzcz1cInNlbGVjdC1hbGxcIj57eyB0aGlzLmR1cmF0aW9uIH19PC9zcGFuPiwgU2l6ZToge3sgdGhpcy5zaXplIH19LCBCaXRyYXRlOiB7eyB0aGlzLmJpdFJhdGUgfX08L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG48L21haW4+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RyYW5zY29kZS1jb25maWd1cmF0b3ItZm9ybWF0JywgRm9ybWF0KTsiXSwibmFtZXMiOlsiU2xpbSIsIkNBUkRfQ1NTIiwiRmlsZUhlbHBlciIsIkZvcm1hdCIsImZvcm1hdCIsImR1cmF0aW9uIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicmVwbGFjZSIsImZpbGVTaXplSCIsInNpemUiLCJiaXRfcmF0ZSIsIk1hdGgiLCJyb3VuZCIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Format.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Streams/Audio.js":
/*!***************************************************************!*\
  !*** ./resources/js/components/Configurator/Streams/Audio.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Stream */ \"./resources/js/components/Configurator/Streams/Stream.js\");\n/* harmony import */ var _CardCss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CardCss */ \"./resources/js/components/Configurator/CardCss.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Audio = /*#__PURE__*/function (_Stream) {\n  _inherits(Audio, _Stream);\n\n  var _super = _createSuper(Audio);\n\n  function Audio() {\n    _classCallCheck(this, Audio);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Audio;\n}(_Stream__WEBPACK_IMPORTED_MODULE_0__.Stream);\n\nAudio.prototype.header = 'Audio';\nAudio.template =\n/*html*/\n\"\\n\".concat(_CardCss__WEBPACK_IMPORTED_MODULE_1__.default, \"\\n\").concat(_Stream__WEBPACK_IMPORTED_MODULE_0__.MAINSTART, \"\\n<section class=\\\"toggle\\\">\\n    <div class=\\\"{{ item.shortView && 'visible' }}\\\" @click=\\\"{{ this.toggleView(item) }}\\\" data-toggle=\\\"true\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-chevron-right\\\"></span>\\n        Stream #0:{{ item.index }}\\n        {{ item.codec_name }}\\n        {{ item.channel_layout && item.channel_layout + ',' || '' }}\\n        {{ (item.bit_rate && Math.round(item.bit_rate / 1000) + ' kb/s') || '' }}\\n        {{ (item.tags?.language || '').wrap('(', ')') }}\\n        &nbsp;->&nbsp;\\n        {{ Object.values(AUDIO_CODECS).find(c => c.v === item.transcodeConfig.codec).l }},\\n        Channels: {{ item.transcodeConfig.channels }}\\n    </div>\\n    <div class=\\\"{{ (!item.shortView && 'visible') }}\\\" @click=\\\"{{ this.toggleView(item) }}\\\" data-toggle=\\\"true\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-chevron-down\\\"></span>\\n        Stream #0:{{ item.index }}{{ (item.id?.wrap('[', ']') || '') }}:\\n        {{ (item.tags?.language || '').wrap('(', ')') }}\\n    </div>\\n    <div class=\\\"{{ (!item.shortView && 'visible') }}\\\">\\n        Audio: {{ item.codec_name }}\\n        {{ [item.codec_tag_string, item.codec_tag].filter(i => i).join(' / ')?.wrap('(', ')') }},\\n        {{ item.sample_rate && item.sample_rate + 'Hz,' || '' }}\\n        {{ item.channel_layout && item.channel_layout + ',' || '' }}\\n        {{ item.sample_fmt && item.sample_fmt + ',' || '' }}\\n        {{ (item.bit_rate && Math.round(item.bit_rate / 1000) + ' kb/s') || '' }}\\n    </div>\\n</section>\\n\").concat(_Stream__WEBPACK_IMPORTED_MODULE_0__.MAINEND, \"\\n\");\ncustomElements.define('transcode-configurator-stream-audio', Audio);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvU3RyZWFtcy9BdWRpby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztJQUVNSTs7Ozs7Ozs7Ozs7O0VBQWNKOztBQUVwQkksS0FBSyxDQUFDQyxTQUFOLENBQWdCQyxNQUFoQixHQUF5QixPQUF6QjtBQUVBRixLQUFLLENBQUNHLFFBQU47QUFBaUI7QUFBakIsWUFDRUosNkNBREYsZUFFRUYsOENBRkYscy9DQTZCRUMsNENBN0JGO0FBZ0NBTSxjQUFjLENBQUNDLE1BQWYsQ0FBc0IscUNBQXRCLEVBQTZETCxLQUE3RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9TdHJlYW1zL0F1ZGlvLmpzPzBhOWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTdHJlYW0sIE1BSU5TVEFSVCwgTUFJTkVORH0gZnJvbSBcIi4vU3RyZWFtXCI7XG5pbXBvcnQgQ0FSRF9DU1MgZnJvbSBcIi4uL0NhcmRDc3NcIjtcblxuY2xhc3MgQXVkaW8gZXh0ZW5kcyBTdHJlYW0ge31cblxuQXVkaW8ucHJvdG90eXBlLmhlYWRlciA9ICdBdWRpbydcblxuQXVkaW8udGVtcGxhdGUgPSAvKmh0bWwqL2BcbiR7Q0FSRF9DU1N9XG4ke01BSU5TVEFSVH1cbjxzZWN0aW9uIGNsYXNzPVwidG9nZ2xlXCI+XG4gICAgPGRpdiBjbGFzcz1cInt7IGl0ZW0uc2hvcnRWaWV3ICYmICd2aXNpYmxlJyB9fVwiIEBjbGljaz1cInt7IHRoaXMudG9nZ2xlVmlldyhpdGVtKSB9fVwiIGRhdGEtdG9nZ2xlPVwidHJ1ZVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktY2hldnJvbi1yaWdodFwiPjwvc3Bhbj5cbiAgICAgICAgU3RyZWFtICMwOnt7IGl0ZW0uaW5kZXggfX1cbiAgICAgICAge3sgaXRlbS5jb2RlY19uYW1lIH19XG4gICAgICAgIHt7IGl0ZW0uY2hhbm5lbF9sYXlvdXQgJiYgaXRlbS5jaGFubmVsX2xheW91dCArICcsJyB8fCAnJyB9fVxuICAgICAgICB7eyAoaXRlbS5iaXRfcmF0ZSAmJiBNYXRoLnJvdW5kKGl0ZW0uYml0X3JhdGUgLyAxMDAwKSArICcga2IvcycpIHx8ICcnIH19XG4gICAgICAgIHt7IChpdGVtLnRhZ3M/Lmxhbmd1YWdlIHx8ICcnKS53cmFwKCcoJywgJyknKSB9fVxuICAgICAgICAmbmJzcDstPiZuYnNwO1xuICAgICAgICB7eyBPYmplY3QudmFsdWVzKEFVRElPX0NPREVDUykuZmluZChjID0+IGMudiA9PT0gaXRlbS50cmFuc2NvZGVDb25maWcuY29kZWMpLmwgfX0sXG4gICAgICAgIENoYW5uZWxzOiB7eyBpdGVtLnRyYW5zY29kZUNvbmZpZy5jaGFubmVscyB9fVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ7eyAoIWl0ZW0uc2hvcnRWaWV3ICYmICd2aXNpYmxlJykgfX1cIiBAY2xpY2s9XCJ7eyB0aGlzLnRvZ2dsZVZpZXcoaXRlbSkgfX1cIiBkYXRhLXRvZ2dsZT1cInRydWVcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWNoZXZyb24tZG93blwiPjwvc3Bhbj5cbiAgICAgICAgU3RyZWFtICMwOnt7IGl0ZW0uaW5kZXggfX17eyAoaXRlbS5pZD8ud3JhcCgnWycsICddJykgfHwgJycpIH19OlxuICAgICAgICB7eyAoaXRlbS50YWdzPy5sYW5ndWFnZSB8fCAnJykud3JhcCgnKCcsICcpJykgfX1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwie3sgKCFpdGVtLnNob3J0VmlldyAmJiAndmlzaWJsZScpIH19XCI+XG4gICAgICAgIEF1ZGlvOiB7eyBpdGVtLmNvZGVjX25hbWUgfX1cbiAgICAgICAge3sgW2l0ZW0uY29kZWNfdGFnX3N0cmluZywgaXRlbS5jb2RlY190YWddLmZpbHRlcihpID0+IGkpLmpvaW4oJyAvICcpPy53cmFwKCcoJywgJyknKSB9fSxcbiAgICAgICAge3sgaXRlbS5zYW1wbGVfcmF0ZSAmJiBpdGVtLnNhbXBsZV9yYXRlICsgJ0h6LCcgfHwgJycgfX1cbiAgICAgICAge3sgaXRlbS5jaGFubmVsX2xheW91dCAmJiBpdGVtLmNoYW5uZWxfbGF5b3V0ICsgJywnIHx8ICcnIH19XG4gICAgICAgIHt7IGl0ZW0uc2FtcGxlX2ZtdCAmJiBpdGVtLnNhbXBsZV9mbXQgKyAnLCcgfHwgJycgfX1cbiAgICAgICAge3sgKGl0ZW0uYml0X3JhdGUgJiYgTWF0aC5yb3VuZChpdGVtLmJpdF9yYXRlIC8gMTAwMCkgKyAnIGtiL3MnKSB8fCAnJyB9fVxuICAgIDwvZGl2PlxuPC9zZWN0aW9uPlxuJHtNQUlORU5EfVxuYFxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RyYW5zY29kZS1jb25maWd1cmF0b3Itc3RyZWFtLWF1ZGlvJywgQXVkaW8pOyJdLCJuYW1lcyI6WyJTdHJlYW0iLCJNQUlOU1RBUlQiLCJNQUlORU5EIiwiQ0FSRF9DU1MiLCJBdWRpbyIsInByb3RvdHlwZSIsImhlYWRlciIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Streams/Audio.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Streams/Buttons.js":
/*!*****************************************************************!*\
  !*** ./resources/js/components/Configurator/Streams/Buttons.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iconify/iconify */ \"./node_modules/@iconify/iconify/dist/iconify.min.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_iconify_iconify__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar Buttons = /*#__PURE__*/function (_Slim) {\n  _inherits(Buttons, _Slim);\n\n  var _super = _createSuper(Buttons);\n\n  function Buttons() {\n    _classCallCheck(this, Buttons);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Buttons, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this = this;\n\n      requestAnimationFrame(function () {\n        return _iconify_iconify__WEBPACK_IMPORTED_MODULE_1___default().scan(_this.shadowRoot);\n      });\n    }\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      var _this2 = this;\n\n      this.item.active = !this.item.active;\n      requestAnimationFrame(function () {\n        _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(_this2, 'item');\n        _iconify_iconify__WEBPACK_IMPORTED_MODULE_1___default().scan(_this2.shadowRoot);\n      });\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      document.dispatchEvent(new CustomEvent('stream-configure', {\n        detail: {\n          origin: this,\n          item: this.item\n        }\n      }));\n    }\n  }]);\n\n  return Buttons;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nButtons.template =\n/*html*/\n\"\\n<style>\\n    :host {\\n        flex-grow: 0;\\n    }\\n    main {\\n        display: flex;\\n        align-items: center;\\n        gap: .5rem;\\n    }\\n    button {\\n        font-size: var(--font-size-200);\\n        height: 1em;\\n        aspect-ratio: 1;\\n    }\\n    button:not(:disabled) {\\n        cursor: pointer;\\n    }\\n</style>\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_2__.ICON_STACK_CSS, \"\\n<main>\\n    <button @click=\\\"{{ this.toggle() }}\\\" class=\\\"{{ this.item.active ? 'icon-stack active' : 'icon-stack' }}\\\">\\n        <span class=\\\"iconify active\\\" data-icon=\\\"mdi-checkbox-marked-outline\\\"></span>\\n        <span class=\\\"iconify inactive\\\" data-icon=\\\"mdi-checkbox-blank-outline\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-checkbox-blank-outline\\\"></span>\\n    </button>\\n    <button @click=\\\"{{ this.configure() }}\\\" class=\\\"icon-stack\\\" .disabled=\\\"{{ !this.item.active }}\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-cog-outline\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-cog-outline\\\"></span>\\n    </button>\\n</main>\\n\");\ncustomElements.define('transcode-configurator-stream-buttons', Buttons);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvU3RyZWFtcy9CdXR0b25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7SUFFTUk7Ozs7Ozs7Ozs7Ozs7V0FFRixtQkFBVTtBQUFBOztBQUNOQyxNQUFBQSxxQkFBcUIsQ0FBQztBQUFBLGVBQU1ILDREQUFBLENBQWEsS0FBSSxDQUFDSyxVQUFsQixDQUFOO0FBQUEsT0FBRCxDQUFyQjtBQUNIOzs7V0FFRCxrQkFBUztBQUFBOztBQUNMLFdBQUtDLElBQUwsQ0FBVUMsTUFBVixHQUFtQixDQUFDLEtBQUtELElBQUwsQ0FBVUMsTUFBOUI7QUFDQUosTUFBQUEscUJBQXFCLENBQUMsWUFBTTtBQUN4QkosUUFBQUEsOERBQUEsQ0FBa0IsTUFBbEIsRUFBd0IsTUFBeEI7QUFDQUMsUUFBQUEsNERBQUEsQ0FBYSxNQUFJLENBQUNLLFVBQWxCO0FBQ0gsT0FIb0IsQ0FBckI7QUFJSDs7O1dBRUQscUJBQVk7QUFDUkksTUFBQUEsUUFBUSxDQUFDQyxhQUFULENBQXVCLElBQUlDLFdBQUosQ0FBZ0Isa0JBQWhCLEVBQW9DO0FBQUNDLFFBQUFBLE1BQU0sRUFBRTtBQUNoRUMsVUFBQUEsTUFBTSxFQUFFLElBRHdEO0FBRWhFUCxVQUFBQSxJQUFJLEVBQUUsS0FBS0E7QUFGcUQ7QUFBVCxPQUFwQyxDQUF2QjtBQUlIOzs7O0VBbkJpQlI7O0FBc0J0QkksT0FBTyxDQUFDWSxRQUFSO0FBQW1CO0FBQW5CLHFWQW1CRWIsdUVBbkJGO0FBaUNBYyxjQUFjLENBQUNDLE1BQWYsQ0FBc0IsdUNBQXRCLEVBQStEZCxPQUEvRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9TdHJlYW1zL0J1dHRvbnMuanM/YTgxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltLCBVdGlscyB9IGZyb20gJ0AvY29tcG9uZW50cy9saWInO1xuaW1wb3J0IEljb25pZnkgZnJvbSAnQGljb25pZnkvaWNvbmlmeSdcbmltcG9ydCB7IElDT05fU1RBQ0tfQ1NTIH0gZnJvbSAnQC9jb21wb25lbnRzL0ljb25zL1N0YWNrLmNzcydcblxuY2xhc3MgQnV0dG9ucyBleHRlbmRzIFNsaW0ge1xuXG4gICAgb25BZGRlZCgpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IEljb25pZnkuc2Nhbih0aGlzLnNoYWRvd1Jvb3QpKVxuICAgIH1cblxuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy5pdGVtLmFjdGl2ZSA9ICF0aGlzLml0ZW0uYWN0aXZlXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBVdGlscy5mb3JjZVVwZGF0ZSh0aGlzLCAnaXRlbScpXG4gICAgICAgICAgICBJY29uaWZ5LnNjYW4odGhpcy5zaGFkb3dSb290KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGNvbmZpZ3VyZSgpIHtcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3N0cmVhbS1jb25maWd1cmUnLCB7ZGV0YWlsOiB7XG4gICAgICAgICAgICBvcmlnaW46IHRoaXMsXG4gICAgICAgICAgICBpdGVtOiB0aGlzLml0ZW1cbiAgICAgICAgfX0pKVxuICAgIH1cbn1cblxuQnV0dG9ucy50ZW1wbGF0ZSA9IC8qaHRtbCovYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZmxleC1ncm93OiAwO1xuICAgIH1cbiAgICBtYWluIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgZ2FwOiAuNXJlbTtcbiAgICB9XG4gICAgYnV0dG9uIHtcbiAgICAgICAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUtMjAwKTtcbiAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgIGFzcGVjdC1yYXRpbzogMTtcbiAgICB9XG4gICAgYnV0dG9uOm5vdCg6ZGlzYWJsZWQpIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbjwvc3R5bGU+XG4ke0lDT05fU1RBQ0tfQ1NTfVxuPG1haW4+XG4gICAgPGJ1dHRvbiBAY2xpY2s9XCJ7eyB0aGlzLnRvZ2dsZSgpIH19XCIgY2xhc3M9XCJ7eyB0aGlzLml0ZW0uYWN0aXZlID8gJ2ljb24tc3RhY2sgYWN0aXZlJyA6ICdpY29uLXN0YWNrJyB9fVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgYWN0aXZlXCIgZGF0YS1pY29uPVwibWRpLWNoZWNrYm94LW1hcmtlZC1vdXRsaW5lXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaW5hY3RpdmVcIiBkYXRhLWljb249XCJtZGktY2hlY2tib3gtYmxhbmstb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5IGhvdmVyXCIgZGF0YS1pY29uPVwibWRpLWNoZWNrYm94LWJsYW5rLW91dGxpbmVcIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG4gICAgPGJ1dHRvbiBAY2xpY2s9XCJ7eyB0aGlzLmNvbmZpZ3VyZSgpIH19XCIgY2xhc3M9XCJpY29uLXN0YWNrXCIgLmRpc2FibGVkPVwie3sgIXRoaXMuaXRlbS5hY3RpdmUgfX1cIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWNvZy1vdXRsaW5lXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktY29nLW91dGxpbmVcIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG48L21haW4+XG5gXG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgndHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1zdHJlYW0tYnV0dG9ucycsIEJ1dHRvbnMpOyJdLCJuYW1lcyI6WyJTbGltIiwiVXRpbHMiLCJJY29uaWZ5IiwiSUNPTl9TVEFDS19DU1MiLCJCdXR0b25zIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2NhbiIsInNoYWRvd1Jvb3QiLCJpdGVtIiwiYWN0aXZlIiwiZm9yY2VVcGRhdGUiLCJkb2N1bWVudCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsIm9yaWdpbiIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Streams/Buttons.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Streams/Config/index.js":
/*!**********************************************************************!*\
  !*** ./resources/js/components/Configurator/Streams/Config/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar StreamConfig = /*#__PURE__*/function (_Slim) {\n  _inherits(StreamConfig, _Slim);\n\n  var _super = _createSuper(StreamConfig);\n\n  function StreamConfig() {\n    var _this;\n\n    _classCallCheck(this, StreamConfig);\n\n    _this = _super.call(this);\n    _this.videoCodecs = Object.values(VIDEO_CODECS).sort(function (a, b) {\n      return a.v > b.v;\n    });\n    _this.audioCodecs = Object.values(AUDIO_CODECS).sort(function (a, b) {\n      return a.v > b.v;\n    });\n    _this.subtitleCodecs = Object.values(SUBTITLE_CODECS).sort(function (a, b) {\n      return a.v > b.v;\n    });\n    _this.channelOptions = [2, 6];\n    _this.aspectRatioOptions = [\"Keep\", \"16:9\", \"4:3\"];\n    _this.cleanup = _this.cleanup.bind(_assertThisInitialized(_this));\n    _this.handleQpRange = _this.handleQpRange.bind(_assertThisInitialized(_this));\n    _this.handleCodecChange = _this.handleCodecChange.bind(_assertThisInitialized(_this));\n    _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized(_this));\n    _this.handleChannelsChange = _this.handleChannelsChange.bind(_assertThisInitialized(_this));\n    _this.handleAspectRatioChange = _this.handleAspectRatioChange.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(StreamConfig, [{\n    key: \"toggle\",\n    value: function toggle(item, offset) {\n      var _this2 = this;\n\n      if (this.classList.contains('active')) {\n        this.hide();\n      } else {\n        this.item = item;\n        this.classList.add(item.codec_type);\n        this.style.top = \"calc(\".concat(offset.top, \"px - .4rem)\");\n        this.style.right = \"calc(\".concat(offset.right, \"px + 1rem)\");\n        this.initSettings();\n        requestAnimationFrame(function () {\n          return _this2.show();\n        });\n      }\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      var _this3 = this;\n\n      requestAnimationFrame(function () {\n        _this3.classList.add('active');\n\n        _this3.addEventListener('transitionend', function () {\n          document.addEventListener('click', _this3.handleDocumentClick);\n          document.addEventListener('configurator-hidden', _this3.cleanup, {\n            once: true\n          });\n        }, {\n          once: true\n        });\n\n        requestAnimationFrame(function () {\n          return _this3.classList.add('fade-in');\n        });\n      });\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.item.transcodeConfig = {\n        codec: this.codec\n      };\n\n      if (this.item.codec_type === 'video') {\n        this.item.transcodeConfig.qp = this.qp;\n        this.item.transcodeConfig.aspectRatio = this.aspectRatio;\n      } else {\n        this.item.transcodeConfig.channels = this.channels;\n      }\n\n      document.dispatchEvent(new CustomEvent('stream-config', {\n        detail: {\n          item: this.item\n        }\n      }));\n      this.addEventListener('transitionend', this.cleanup, {\n        once: true\n      });\n      this.classList.add('fade-out');\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      document.removeEventListener('click', this.handleDocumentClick);\n      document.removeEventListener('configurator-hidden', this.cleanup);\n      this.className = '';\n      delete this.item;\n    }\n  }, {\n    key: \"initSettings\",\n    value: function initSettings() {\n      var _this$item$transcodeC, _this$item$transcodeC2, _this$item$transcodeC3, _this$item$transcodeC4, _this$item$transcodeC5;\n\n      var codec = (_this$item$transcodeC = this.item.transcodeConfig) === null || _this$item$transcodeC === void 0 ? void 0 : _this$item$transcodeC.codec;\n      var channels = (_this$item$transcodeC2 = this.item.transcodeConfig) === null || _this$item$transcodeC2 === void 0 ? void 0 : _this$item$transcodeC2.channels;\n      var qp = (_this$item$transcodeC3 = this.item.transcodeConfig) === null || _this$item$transcodeC3 === void 0 ? void 0 : _this$item$transcodeC3.qp;\n      this.aspectRatio = (_this$item$transcodeC4 = (_this$item$transcodeC5 = this.item.transcodeConfig) === null || _this$item$transcodeC5 === void 0 ? void 0 : _this$item$transcodeC5.aspectRatio) !== null && _this$item$transcodeC4 !== void 0 ? _this$item$transcodeC4 : '16:9';\n      this.codecs = this[\"\".concat(this.item.codec_type, \"Codecs\")].sort(function (a, b) {\n        return a.id > b.id;\n      });\n      this.codec = typeof codec !== 'undefined' ? codec : this.codecs.find(function (c) {\n        return c[\"default\"];\n      }).v;\n      this.qp = typeof qp !== 'undefined' ? qp : this.codecs.find(function (c) {\n        return c[\"default\"];\n      }).qp;\n      this.channels = typeof channels !== 'undefined' ? channels : this.codecs.find(function (c) {\n        return c[\"default\"];\n      }).channels;\n      this.qpSlider.value = this.qp;\n      this.copyCodec = this.codecs.find(function (c) {\n        return c.l === 'Copy';\n      }).v;\n      _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(this);\n    }\n  }, {\n    key: \"handleDocumentClick\",\n    value: function handleDocumentClick(e) {\n      if (e.composedPath().indexOf(this) < 0) {\n        this.hide();\n      }\n    }\n  }, {\n    key: \"handleQpRange\",\n    value: function handleQpRange(e) {\n      this.qp = parseInt(this.qpSlider.value);\n    }\n  }, {\n    key: \"handleCodecChange\",\n    value: function handleCodecChange(e) {\n      var _this4 = this;\n\n      this.codec = parseInt(e.currentTarget.value);\n\n      if (this.item.codec_type === 'audio') {\n        this.channels = this.codecs.find(function (c) {\n          return c.v === _this4.codec;\n        }).channels;\n      }\n\n      if (this.item.codec_type === 'video') {\n        this.qp = this.codecs.find(function (c) {\n          return c.v === _this4.codec;\n        }).qp;\n        this.qpSlider.value = this.qp;\n      }\n\n      _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(this);\n    }\n  }, {\n    key: \"handleChannelsChange\",\n    value: function handleChannelsChange(e) {\n      this.channels = parseInt(e.currentTarget.value);\n    }\n  }, {\n    key: \"handleAspectRatioChange\",\n    value: function handleAspectRatioChange(e) {\n      this.aspectRatio = e.currentTarget.value;\n    }\n  }, {\n    key: \"isCodecChecked\",\n    value: function isCodecChecked(codec) {\n      return codec.v === this.codec;\n    }\n  }, {\n    key: \"isCHannelsChecked\",\n    value: function isCHannelsChecked(channels) {\n      return channels === this.channels && this.codec !== this.copyCodec;\n    }\n  }, {\n    key: \"isAspectRatio\",\n    value: function isAspectRatio(ratio) {\n      return this.aspectRatio === ratio || \"Keep\" === ratio;\n    }\n  }]);\n\n  return StreamConfig;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nStreamConfig.template =\n/*html*/\n\"\\n<style>\\n    /* fade */\\n    :host {\\n        display: none;\\n        opacity: 0;\\n        transition: opacity var(--transition-fast) ease-in;\\n        position: absolute;\\n    }\\n    :host(.active) {\\n        display: flex;\\n        align-items: center;\\n    }\\n    :host(.fade-in) {\\n        opacity: 1;\\n    }\\n    :host(.fade-out) {\\n        transition-duration: var(--transition-ultraslow);\\n        opacity: 0;\\n    }\\n    /* common */\\n    main {\\n        background: var(--clr-bg-100);\\n        border: 2px solid var(--clr-bg-200);\\n        border-radius: .5rem;\\n        box-shadow: 0 0 7vw 0 var(--clr-shadow-0);\\n        padding: .5rem;\\n    }\\n    main::before {\\n        position: absolute;\\n        z-index: 0;\\n        top: .7rem;\\n        right: -.4rem;\\n        content: '';\\n        width: .8rem;\\n        aspect-ratio: 1;\\n        background: var(--clr-bg-100);\\n        border: 2px var(--clr-bg-200);\\n        border-style: none solid solid none;\\n        transform: rotate(-45deg);\\n    }\\n    label {\\n        position: relative;\\n        z-index: 1;\\n        display: flex;\\n        justify-content: space-between;\\n        align-items: center;\\n        gap: .5rem;\\n        font-size: .8rem;\\n        padding-block: .25rem;\\n    }\\n    input {\\n        accent-color: var(--clr-enlightened);\\n    }\\n    input:checked {\\n        box-shadow: 0 0 10px 3px var(--clr-enlightened-glow);\\n    }\\n    :host(:not(.video)) #qpslider,\\n    :host(:not(.video)) #aspect-ratio {\\n        display: none;\\n    }\\n    :host(:not(.audio)) #audiochannels {\\n        display: none;\\n    }\\n</style>\\n<main>\\n    <label *foreach=\\\"{{ this.codecs }}\\\">\\n        <span>{{ item.l }}</span>\\n        <input type=\\\"radio\\\" value=\\\"{{ item.v }}\\\" name=\\\"codec\\\" .checked=\\\"{{ this.isCodecChecked(item) }}\\\" @change=\\\"{{ this.handleCodecChange }}\\\">\\n    </label>\\n    <div id=\\\"audiochannels\\\">\\n        <span>Channels</span>\\n        <label *foreach=\\\"{{ this.channelOptions }}\\\">\\n            <span>{{ item }}</span>\\n            <input type=\\\"radio\\\" value=\\\"{{ item }}\\\" .disabled=\\\"{{ this.codec === this.copyCodec }}\\\" name=\\\"channels\\\" .checked=\\\"{{ this.isCHannelsChecked(item) }}\\\" @change=\\\"{{ this.handleChannelsChange }}\\\">\\n        </label>\\n    </div>\\n    <label id=\\\"qpslider\\\">\\n        <span>QP (<span #ref=\\\"qpDisplay\\\">{{ this.qp }}</span>)</span>\\n        <input #ref=\\\"qpSlider\\\" list=\\\"tickmarks\\\" .disabled=\\\"{{ this.codec === this.copyCodec }}\\\" type=\\\"range\\\" min=\\\"18\\\" max=\\\"51\\\" step=\\\"1\\\" value=\\\"{{ this.qp }}\\\" @input=\\\"{{ this.handleQpRange }}\\\">\\n    </label>\\n    <div id=\\\"aspect-ratio\\\">\\n        <span>Aspect Ratio</span>\\n        <label *foreach=\\\"{{ this.aspectRatioOptions }}\\\">\\n            <span>{{ item }}</span>\\n            <input type=\\\"radio\\\" value=\\\"{{ item }}\\\" name=\\\"aspect-ratio\\\" .checked=\\\"{{ this.isAspectRatio(item) }}\\\" @change=\\\"{{ this.handleAspectRatioChange }}\\\">\\n        </label>\\n    </div>\\n</main>\\n\";\ncustomElements.define('transcode-configurator-stream-config', StreamConfig);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvU3RyZWFtcy9Db25maWcvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0lBRU1FOzs7OztBQUVGLDBCQUFjO0FBQUE7O0FBQUE7O0FBQ1Y7QUFDQSxVQUFLQyxXQUFMLEdBQW1CQyxNQUFNLENBQUNDLE1BQVAsQ0FBY0MsWUFBZCxFQUE0QkMsSUFBNUIsQ0FBaUMsVUFBQ0MsQ0FBRCxFQUFHQyxDQUFIO0FBQUEsYUFBU0QsQ0FBQyxDQUFDRSxDQUFGLEdBQU1ELENBQUMsQ0FBQ0MsQ0FBakI7QUFBQSxLQUFqQyxDQUFuQjtBQUNBLFVBQUtDLFdBQUwsR0FBbUJQLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjTyxZQUFkLEVBQTRCTCxJQUE1QixDQUFpQyxVQUFDQyxDQUFELEVBQUdDLENBQUg7QUFBQSxhQUFTRCxDQUFDLENBQUNFLENBQUYsR0FBTUQsQ0FBQyxDQUFDQyxDQUFqQjtBQUFBLEtBQWpDLENBQW5CO0FBQ0EsVUFBS0csY0FBTCxHQUFzQlQsTUFBTSxDQUFDQyxNQUFQLENBQWNTLGVBQWQsRUFBK0JQLElBQS9CLENBQ2xCLFVBQUNDLENBQUQsRUFBSUMsQ0FBSjtBQUFBLGFBQVVELENBQUMsQ0FBQ0UsQ0FBRixHQUFNRCxDQUFDLENBQUNDLENBQWxCO0FBQUEsS0FEa0IsQ0FBdEI7QUFHQSxVQUFLSyxjQUFMLEdBQXNCLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBdEI7QUFDQSxVQUFLQyxrQkFBTCxHQUEwQixDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLEtBQWpCLENBQTFCO0FBQ0EsVUFBS0MsT0FBTCxHQUFlLE1BQUtBLE9BQUwsQ0FBYUMsSUFBYiwrQkFBZjtBQUNBLFVBQUtDLGFBQUwsR0FBcUIsTUFBS0EsYUFBTCxDQUFtQkQsSUFBbkIsK0JBQXJCO0FBQ0EsVUFBS0UsaUJBQUwsR0FBeUIsTUFBS0EsaUJBQUwsQ0FBdUJGLElBQXZC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QUFDLENBQUM7QUFBQSxpQkFBSUEsQ0FBQyxDQUFDM0MsQ0FBRixLQUFRLE1BQUksQ0FBQytCLEtBQWpCO0FBQUEsU0FBbEIsRUFBMENDLEVBQXBEO0FBQ0EsYUFBS1ksUUFBTCxDQUFjQyxLQUFkLEdBQXNCLEtBQUtiLEVBQTNCO0FBQ0g7O0FBQ0R6QyxNQUFBQSw4REFBQSxDQUFrQixJQUFsQjtBQUNIOzs7V0FFRCw4QkFBcUIwRCxDQUFyQixFQUF3QjtBQUNwQixXQUFLZixRQUFMLEdBQWdCa0IsUUFBUSxDQUFDSCxDQUFDLENBQUNJLGFBQUYsQ0FBZ0JSLEtBQWpCLENBQXhCO0FBQ0g7OztXQUVELGlDQUF3QkksQ0FBeEIsRUFBMkI7QUFDdkIsV0FBS2hCLFdBQUwsR0FBbUJnQixDQUFDLENBQUNJLGFBQUYsQ0FBZ0JSLEtBQW5DO0FBQ0g7OztXQUVELHdCQUFlZCxLQUFmLEVBQXNCO0FBQ2xCLGFBQU9BLEtBQUssQ0FBQy9CLENBQU4sS0FBWSxLQUFLK0IsS0FBeEI7QUFDSDs7O1dBRUQsMkJBQWtCRyxRQUFsQixFQUE0QjtBQUN4QixhQUFPQSxRQUFRLEtBQUssS0FBS0EsUUFBbEIsSUFBOEIsS0FBS0gsS0FBTCxLQUFlLEtBQUtlLFNBQXpEO0FBQ0g7OztXQUVELHVCQUFjUSxLQUFkLEVBQXFCO0FBQ2pCLGFBQU8sS0FBS3JCLFdBQUwsS0FBcUJxQixLQUFyQixJQUE4QixXQUFXQSxLQUFoRDtBQUNIOzs7O0VBcEhzQmhFOztBQXVIM0JFLFlBQVksQ0FBQytELFFBQWI7QUFBd0I7QUFBeEI7QUEyRkFDLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixzQ0FBdEIsRUFBOERqRSxZQUE5RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9TdHJlYW1zL0NvbmZpZy9pbmRleC5qcz8wNmQ2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaW0sIFV0aWxzIH0gZnJvbSAnQC9jb21wb25lbnRzL2xpYic7XG5cbmNsYXNzIFN0cmVhbUNvbmZpZyBleHRlbmRzIFNsaW0ge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy52aWRlb0NvZGVjcyA9IE9iamVjdC52YWx1ZXMoVklERU9fQ09ERUNTKS5zb3J0KChhLGIpID0+IGEudiA+IGIudilcbiAgICAgICAgdGhpcy5hdWRpb0NvZGVjcyA9IE9iamVjdC52YWx1ZXMoQVVESU9fQ09ERUNTKS5zb3J0KChhLGIpID0+IGEudiA+IGIudilcbiAgICAgICAgdGhpcy5zdWJ0aXRsZUNvZGVjcyA9IE9iamVjdC52YWx1ZXMoU1VCVElUTEVfQ09ERUNTKS5zb3J0KFxuICAgICAgICAgICAgKGEsIGIpID0+IGEudiA+IGIudlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gWzIsNl1cbiAgICAgICAgdGhpcy5hc3BlY3RSYXRpb09wdGlvbnMgPSBbXCJLZWVwXCIsIFwiMTY6OVwiLCBcIjQ6M1wiXTtcbiAgICAgICAgdGhpcy5jbGVhbnVwID0gdGhpcy5jbGVhbnVwLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5oYW5kbGVRcFJhbmdlID0gdGhpcy5oYW5kbGVRcFJhbmdlLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5oYW5kbGVDb2RlY0NoYW5nZSA9IHRoaXMuaGFuZGxlQ29kZWNDaGFuZ2UuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2sgPSB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2suYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmhhbmRsZUNoYW5uZWxzQ2hhbmdlID0gdGhpcy5oYW5kbGVDaGFubmVsc0NoYW5nZS5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMuaGFuZGxlQXNwZWN0UmF0aW9DaGFuZ2UgPSB0aGlzLmhhbmRsZUFzcGVjdFJhdGlvQ2hhbmdlLmJpbmQodGhpcylcbiAgICB9XG5cbiAgICB0b2dnbGUoaXRlbSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLml0ZW0gPSBpdGVtXG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoaXRlbS5jb2RlY190eXBlKVxuICAgICAgICAgICAgdGhpcy5zdHlsZS50b3AgPSBgY2FsYygke29mZnNldC50b3B9cHggLSAuNHJlbSlgXG4gICAgICAgICAgICB0aGlzLnN0eWxlLnJpZ2h0ID0gYGNhbGMoJHtvZmZzZXQucmlnaHR9cHggKyAxcmVtKWBcbiAgICAgICAgICAgIHRoaXMuaW5pdFNldHRpbmdzKClcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnNob3coKSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbmZpZ3VyYXRvci1oaWRkZW4nLCB0aGlzLmNsZWFudXAsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICAgIH0sIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhZGUtaW4nKSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLml0ZW0udHJhbnNjb2RlQ29uZmlnID0ge2NvZGVjOiB0aGlzLmNvZGVjfVxuICAgICAgICBpZiAodGhpcy5pdGVtLmNvZGVjX3R5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbS50cmFuc2NvZGVDb25maWcucXAgPSB0aGlzLnFwXG4gICAgICAgICAgICB0aGlzLml0ZW0udHJhbnNjb2RlQ29uZmlnLmFzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpb1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pdGVtLnRyYW5zY29kZUNvbmZpZy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHNcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc3RyZWFtLWNvbmZpZycsIHtkZXRhaWw6IHtpdGVtOiB0aGlzLml0ZW19fSkpXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuY2xlYW51cCwge29uY2U6IHRydWV9KVxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhZGUtb3V0JylcbiAgICB9XG5cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlRG9jdW1lbnRDbGljaylcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29uZmlndXJhdG9yLWhpZGRlbicsIHRoaXMuY2xlYW51cClcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnJ1xuICAgICAgICBkZWxldGUgdGhpcy5pdGVtXG4gICAgfVxuXG4gICAgaW5pdFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBjb2RlYyA9IHRoaXMuaXRlbS50cmFuc2NvZGVDb25maWc/LmNvZGVjXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gdGhpcy5pdGVtLnRyYW5zY29kZUNvbmZpZz8uY2hhbm5lbHNcbiAgICAgICAgY29uc3QgcXAgPSB0aGlzLml0ZW0udHJhbnNjb2RlQ29uZmlnPy5xcFxuICAgICAgICB0aGlzLmFzcGVjdFJhdGlvID0gdGhpcy5pdGVtLnRyYW5zY29kZUNvbmZpZz8uYXNwZWN0UmF0aW8gPz8gJzE2OjknXG4gICAgICAgIHRoaXMuY29kZWNzID0gdGhpc1tgJHt0aGlzLml0ZW0uY29kZWNfdHlwZX1Db2RlY3NgXS5zb3J0KChhLGIpID0+IGEuaWQgPiBiLmlkKVxuICAgICAgICB0aGlzLmNvZGVjID0gdHlwZW9mIGNvZGVjICE9PSAndW5kZWZpbmVkJyA/IGNvZGVjIDogdGhpcy5jb2RlY3MuZmluZChjID0+IGMuZGVmYXVsdCkudlxuICAgICAgICB0aGlzLnFwID0gdHlwZW9mIHFwICE9PSAndW5kZWZpbmVkJyA/IHFwIDogdGhpcy5jb2RlY3MuZmluZChjID0+IGMuZGVmYXVsdCkucXBcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IHR5cGVvZiBjaGFubmVscyAhPT0gJ3VuZGVmaW5lZCcgPyBjaGFubmVscyA6IHRoaXMuY29kZWNzLmZpbmQoYyA9PiBjLmRlZmF1bHQpLmNoYW5uZWxzXG4gICAgICAgIHRoaXMucXBTbGlkZXIudmFsdWUgPSB0aGlzLnFwXG4gICAgICAgIHRoaXMuY29weUNvZGVjID0gdGhpcy5jb2RlY3MuZmluZChjID0+IGMubCA9PT0gJ0NvcHknKS52XG4gICAgICAgIFV0aWxzLmZvcmNlVXBkYXRlKHRoaXMpXG4gICAgfVxuXG4gICAgaGFuZGxlRG9jdW1lbnRDbGljayhlKSB7XG4gICAgICAgIGlmKGUuY29tcG9zZWRQYXRoKCkuaW5kZXhPZih0aGlzKSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVRcFJhbmdlKGUpIHtcbiAgICAgICAgdGhpcy5xcCA9IHBhcnNlSW50KHRoaXMucXBTbGlkZXIudmFsdWUpXG4gICAgfVxuXG4gICAgaGFuZGxlQ29kZWNDaGFuZ2UoZSkge1xuICAgICAgICB0aGlzLmNvZGVjID0gcGFyc2VJbnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKVxuICAgICAgICBpZiAodGhpcy5pdGVtLmNvZGVjX3R5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNvZGVjcy5maW5kKGMgPT4gYy52ID09PSB0aGlzLmNvZGVjKS5jaGFubmVsc1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLml0ZW0uY29kZWNfdHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgdGhpcy5xcCA9IHRoaXMuY29kZWNzLmZpbmQoYyA9PiBjLnYgPT09IHRoaXMuY29kZWMpLnFwXG4gICAgICAgICAgICB0aGlzLnFwU2xpZGVyLnZhbHVlID0gdGhpcy5xcFxuICAgICAgICB9XG4gICAgICAgIFV0aWxzLmZvcmNlVXBkYXRlKHRoaXMpXG4gICAgfVxuXG4gICAgaGFuZGxlQ2hhbm5lbHNDaGFuZ2UoZSkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gcGFyc2VJbnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKVxuICAgIH1cblxuICAgIGhhbmRsZUFzcGVjdFJhdGlvQ2hhbmdlKGUpIHtcbiAgICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IGUuY3VycmVudFRhcmdldC52YWx1ZVxuICAgIH1cblxuICAgIGlzQ29kZWNDaGVja2VkKGNvZGVjKSB7XG4gICAgICAgIHJldHVybiBjb2RlYy52ID09PSB0aGlzLmNvZGVjXG4gICAgfVxuXG4gICAgaXNDSGFubmVsc0NoZWNrZWQoY2hhbm5lbHMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWxzID09PSB0aGlzLmNoYW5uZWxzICYmIHRoaXMuY29kZWMgIT09IHRoaXMuY29weUNvZGVjXG4gICAgfVxuXG4gICAgaXNBc3BlY3RSYXRpbyhyYXRpbykge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3BlY3RSYXRpbyA9PT0gcmF0aW8gfHwgXCJLZWVwXCIgPT09IHJhdGlvO1xuICAgIH1cbn1cblxuU3RyZWFtQ29uZmlnLnRlbXBsYXRlID0gLypodG1sKi9gXG48c3R5bGU+XG4gICAgLyogZmFkZSAqL1xuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSB2YXIoLS10cmFuc2l0aW9uLWZhc3QpIGVhc2UtaW47XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB9XG4gICAgOmhvc3QoLmFjdGl2ZSkge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cbiAgICA6aG9zdCguZmFkZS1pbikge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgIH1cbiAgICA6aG9zdCguZmFkZS1vdXQpIHtcbiAgICAgICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogdmFyKC0tdHJhbnNpdGlvbi11bHRyYXNsb3cpO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbiAgICAvKiBjb21tb24gKi9cbiAgICBtYWluIHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tY2xyLWJnLTEwMCk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHZhcigtLWNsci1iZy0yMDApO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAuNXJlbTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDd2dyAwIHZhcigtLWNsci1zaGFkb3ctMCk7XG4gICAgICAgIHBhZGRpbmc6IC41cmVtO1xuICAgIH1cbiAgICBtYWluOjpiZWZvcmUge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIHRvcDogLjdyZW07XG4gICAgICAgIHJpZ2h0OiAtLjRyZW07XG4gICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgICB3aWR0aDogLjhyZW07XG4gICAgICAgIGFzcGVjdC1yYXRpbzogMTtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tY2xyLWJnLTEwMCk7XG4gICAgICAgIGJvcmRlcjogMnB4IHZhcigtLWNsci1iZy0yMDApO1xuICAgICAgICBib3JkZXItc3R5bGU6IG5vbmUgc29saWQgc29saWQgbm9uZTtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTtcbiAgICB9XG4gICAgbGFiZWwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgZ2FwOiAuNXJlbTtcbiAgICAgICAgZm9udC1zaXplOiAuOHJlbTtcbiAgICAgICAgcGFkZGluZy1ibG9jazogLjI1cmVtO1xuICAgIH1cbiAgICBpbnB1dCB7XG4gICAgICAgIGFjY2VudC1jb2xvcjogdmFyKC0tY2xyLWVubGlnaHRlbmVkKTtcbiAgICB9XG4gICAgaW5wdXQ6Y2hlY2tlZCB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IDNweCB2YXIoLS1jbHItZW5saWdodGVuZWQtZ2xvdyk7XG4gICAgfVxuICAgIDpob3N0KDpub3QoLnZpZGVvKSkgI3Fwc2xpZGVyLFxuICAgIDpob3N0KDpub3QoLnZpZGVvKSkgI2FzcGVjdC1yYXRpbyB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICAgIDpob3N0KDpub3QoLmF1ZGlvKSkgI2F1ZGlvY2hhbm5lbHMge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbjwvc3R5bGU+XG48bWFpbj5cbiAgICA8bGFiZWwgKmZvcmVhY2g9XCJ7eyB0aGlzLmNvZGVjcyB9fVwiPlxuICAgICAgICA8c3Bhbj57eyBpdGVtLmwgfX08L3NwYW4+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiB2YWx1ZT1cInt7IGl0ZW0udiB9fVwiIG5hbWU9XCJjb2RlY1wiIC5jaGVja2VkPVwie3sgdGhpcy5pc0NvZGVjQ2hlY2tlZChpdGVtKSB9fVwiIEBjaGFuZ2U9XCJ7eyB0aGlzLmhhbmRsZUNvZGVjQ2hhbmdlIH19XCI+XG4gICAgPC9sYWJlbD5cbiAgICA8ZGl2IGlkPVwiYXVkaW9jaGFubmVsc1wiPlxuICAgICAgICA8c3Bhbj5DaGFubmVsczwvc3Bhbj5cbiAgICAgICAgPGxhYmVsICpmb3JlYWNoPVwie3sgdGhpcy5jaGFubmVsT3B0aW9ucyB9fVwiPlxuICAgICAgICAgICAgPHNwYW4+e3sgaXRlbSB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiB2YWx1ZT1cInt7IGl0ZW0gfX1cIiAuZGlzYWJsZWQ9XCJ7eyB0aGlzLmNvZGVjID09PSB0aGlzLmNvcHlDb2RlYyB9fVwiIG5hbWU9XCJjaGFubmVsc1wiIC5jaGVja2VkPVwie3sgdGhpcy5pc0NIYW5uZWxzQ2hlY2tlZChpdGVtKSB9fVwiIEBjaGFuZ2U9XCJ7eyB0aGlzLmhhbmRsZUNoYW5uZWxzQ2hhbmdlIH19XCI+XG4gICAgICAgIDwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPGxhYmVsIGlkPVwicXBzbGlkZXJcIj5cbiAgICAgICAgPHNwYW4+UVAgKDxzcGFuICNyZWY9XCJxcERpc3BsYXlcIj57eyB0aGlzLnFwIH19PC9zcGFuPik8L3NwYW4+XG4gICAgICAgIDxpbnB1dCAjcmVmPVwicXBTbGlkZXJcIiBsaXN0PVwidGlja21hcmtzXCIgLmRpc2FibGVkPVwie3sgdGhpcy5jb2RlYyA9PT0gdGhpcy5jb3B5Q29kZWMgfX1cIiB0eXBlPVwicmFuZ2VcIiBtaW49XCIxOFwiIG1heD1cIjUxXCIgc3RlcD1cIjFcIiB2YWx1ZT1cInt7IHRoaXMucXAgfX1cIiBAaW5wdXQ9XCJ7eyB0aGlzLmhhbmRsZVFwUmFuZ2UgfX1cIj5cbiAgICA8L2xhYmVsPlxuICAgIDxkaXYgaWQ9XCJhc3BlY3QtcmF0aW9cIj5cbiAgICAgICAgPHNwYW4+QXNwZWN0IFJhdGlvPC9zcGFuPlxuICAgICAgICA8bGFiZWwgKmZvcmVhY2g9XCJ7eyB0aGlzLmFzcGVjdFJhdGlvT3B0aW9ucyB9fVwiPlxuICAgICAgICAgICAgPHNwYW4+e3sgaXRlbSB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiB2YWx1ZT1cInt7IGl0ZW0gfX1cIiBuYW1lPVwiYXNwZWN0LXJhdGlvXCIgLmNoZWNrZWQ9XCJ7eyB0aGlzLmlzQXNwZWN0UmF0aW8oaXRlbSkgfX1cIiBAY2hhbmdlPVwie3sgdGhpcy5oYW5kbGVBc3BlY3RSYXRpb0NoYW5nZSB9fVwiPlxuICAgICAgICA8L2xhYmVsPlxuICAgIDwvZGl2PlxuPC9tYWluPlxuYFxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RyYW5zY29kZS1jb25maWd1cmF0b3Itc3RyZWFtLWNvbmZpZycsIFN0cmVhbUNvbmZpZyk7Il0sIm5hbWVzIjpbIlNsaW0iLCJVdGlscyIsIlN0cmVhbUNvbmZpZyIsInZpZGVvQ29kZWNzIiwiT2JqZWN0IiwidmFsdWVzIiwiVklERU9fQ09ERUNTIiwic29ydCIsImEiLCJiIiwidiIsImF1ZGlvQ29kZWNzIiwiQVVESU9fQ09ERUNTIiwic3VidGl0bGVDb2RlY3MiLCJTVUJUSVRMRV9DT0RFQ1MiLCJjaGFubmVsT3B0aW9ucyIsImFzcGVjdFJhdGlvT3B0aW9ucyIsImNsZWFudXAiLCJiaW5kIiwiaGFuZGxlUXBSYW5nZSIsImhhbmRsZUNvZGVjQ2hhbmdlIiwiaGFuZGxlRG9jdW1lbnRDbGljayIsImhhbmRsZUNoYW5uZWxzQ2hhbmdlIiwiaGFuZGxlQXNwZWN0UmF0aW9DaGFuZ2UiLCJpdGVtIiwib2Zmc2V0IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJoaWRlIiwiYWRkIiwiY29kZWNfdHlwZSIsInN0eWxlIiwidG9wIiwicmlnaHQiLCJpbml0U2V0dGluZ3MiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzaG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRvY3VtZW50Iiwib25jZSIsInRyYW5zY29kZUNvbmZpZyIsImNvZGVjIiwicXAiLCJhc3BlY3RSYXRpbyIsImNoYW5uZWxzIiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsYXNzTmFtZSIsImNvZGVjcyIsImlkIiwiZmluZCIsImMiLCJxcFNsaWRlciIsInZhbHVlIiwiY29weUNvZGVjIiwibCIsImZvcmNlVXBkYXRlIiwiZSIsImNvbXBvc2VkUGF0aCIsImluZGV4T2YiLCJwYXJzZUludCIsImN1cnJlbnRUYXJnZXQiLCJyYXRpbyIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Streams/Config/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Streams/Data.js":
/*!**************************************************************!*\
  !*** ./resources/js/components/Configurator/Streams/Data.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Stream */ \"./resources/js/components/Configurator/Streams/Stream.js\");\n/* harmony import */ var _CardCss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CardCss */ \"./resources/js/components/Configurator/CardCss.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Data = /*#__PURE__*/function (_Stream) {\n  _inherits(Data, _Stream);\n\n  var _super = _createSuper(Data);\n\n  function Data() {\n    _classCallCheck(this, Data);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Data;\n}(_Stream__WEBPACK_IMPORTED_MODULE_0__.Stream);\n\nData.prototype.header = 'Data';\nData.template =\n/*html*/\n\"\\n\".concat(_CardCss__WEBPACK_IMPORTED_MODULE_1__.default, \"\\n\").concat(_Stream__WEBPACK_IMPORTED_MODULE_0__.MAINSTART, \"\\n<section class=\\\"toggle\\\">\\n    <div class=\\\"{{ item.shortView && 'visible' }}\\\" @click=\\\"{{ this.toggleView(item) }}\\\" data-toggle=\\\"true\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-chevron-right\\\"></span>\\n        Stream #0:{{ item.index }}\\n        {{ item.codec_name }}\\n    </div>\\n    <div class=\\\"{{ (!item.shortView && 'visible') }}\\\" @click=\\\"{{ this.toggleView(item) }}\\\" data-toggle=\\\"true\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-chevron-down\\\"></span>\\n        Stream #0:{{ item.index }}{{ (item.id?.wrap('[', ']') || '') }}:\\n        {{ (item.tags?.language || '').wrap('(', ')') }}\\n    </div>\\n    <div class=\\\"{{ (!item.shortView && 'visible') }}\\\">\\n        Data: {{ item.codec_name }}\\n        {{ [item.codec_tag_string, item.codec_tag].filter(i => i).join(' / ')?.wrap('(', ')') }}\\n    </div>\\n</section>\\n\").concat(_Stream__WEBPACK_IMPORTED_MODULE_0__.MAINEND, \"\\n\");\ncustomElements.define('transcode-configurator-stream-data', Data);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvU3RyZWFtcy9EYXRhLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0lBRU1JOzs7Ozs7Ozs7Ozs7RUFBYUo7O0FBRW5CSSxJQUFJLENBQUNDLFNBQUwsQ0FBZUMsTUFBZixHQUF3QixNQUF4QjtBQUVBRixJQUFJLENBQUNHLFFBQUw7QUFBZ0I7QUFBaEIsWUFDRUosNkNBREYsZUFFRUYsOENBRkYsNjFCQW1CRUMsNENBbkJGO0FBc0JBTSxjQUFjLENBQUNDLE1BQWYsQ0FBc0Isb0NBQXRCLEVBQTRETCxJQUE1RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9TdHJlYW1zL0RhdGEuanM/ZTg5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1N0cmVhbSwgTUFJTlNUQVJULCBNQUlORU5EfSBmcm9tIFwiLi9TdHJlYW1cIjtcbmltcG9ydCBDQVJEX0NTUyBmcm9tIFwiLi4vQ2FyZENzc1wiO1xuXG5jbGFzcyBEYXRhIGV4dGVuZHMgU3RyZWFtIHt9XG5cbkRhdGEucHJvdG90eXBlLmhlYWRlciA9ICdEYXRhJ1xuXG5EYXRhLnRlbXBsYXRlID0gLypodG1sKi9gXG4ke0NBUkRfQ1NTfVxuJHtNQUlOU1RBUlR9XG48c2VjdGlvbiBjbGFzcz1cInRvZ2dsZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJ7eyBpdGVtLnNob3J0VmlldyAmJiAndmlzaWJsZScgfX1cIiBAY2xpY2s9XCJ7eyB0aGlzLnRvZ2dsZVZpZXcoaXRlbSkgfX1cIiBkYXRhLXRvZ2dsZT1cInRydWVcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWNoZXZyb24tcmlnaHRcIj48L3NwYW4+XG4gICAgICAgIFN0cmVhbSAjMDp7eyBpdGVtLmluZGV4IH19XG4gICAgICAgIHt7IGl0ZW0uY29kZWNfbmFtZSB9fVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ7eyAoIWl0ZW0uc2hvcnRWaWV3ICYmICd2aXNpYmxlJykgfX1cIiBAY2xpY2s9XCJ7eyB0aGlzLnRvZ2dsZVZpZXcoaXRlbSkgfX1cIiBkYXRhLXRvZ2dsZT1cInRydWVcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWNoZXZyb24tZG93blwiPjwvc3Bhbj5cbiAgICAgICAgU3RyZWFtICMwOnt7IGl0ZW0uaW5kZXggfX17eyAoaXRlbS5pZD8ud3JhcCgnWycsICddJykgfHwgJycpIH19OlxuICAgICAgICB7eyAoaXRlbS50YWdzPy5sYW5ndWFnZSB8fCAnJykud3JhcCgnKCcsICcpJykgfX1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwie3sgKCFpdGVtLnNob3J0VmlldyAmJiAndmlzaWJsZScpIH19XCI+XG4gICAgICAgIERhdGE6IHt7IGl0ZW0uY29kZWNfbmFtZSB9fVxuICAgICAgICB7eyBbaXRlbS5jb2RlY190YWdfc3RyaW5nLCBpdGVtLmNvZGVjX3RhZ10uZmlsdGVyKGkgPT4gaSkuam9pbignIC8gJyk/LndyYXAoJygnLCAnKScpIH19XG4gICAgPC9kaXY+XG48L3NlY3Rpb24+XG4ke01BSU5FTkR9XG5gXG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgndHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1zdHJlYW0tZGF0YScsIERhdGEpOyJdLCJuYW1lcyI6WyJTdHJlYW0iLCJNQUlOU1RBUlQiLCJNQUlORU5EIiwiQ0FSRF9DU1MiLCJEYXRhIiwicHJvdG90eXBlIiwiaGVhZGVyIiwidGVtcGxhdGUiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Streams/Data.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Streams/Stream.js":
/*!****************************************************************!*\
  !*** ./resources/js/components/Configurator/Streams/Stream.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stream\": () => (/* binding */ Stream),\n/* harmony export */   \"MAINSTART\": () => (/* binding */ MAINSTART),\n/* harmony export */   \"MAINEND\": () => (/* binding */ MAINEND)\n/* harmony export */ });\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iconify/iconify */ \"./node_modules/@iconify/iconify/dist/iconify.min.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_iconify_iconify__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Buttons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Buttons */ \"./resources/js/components/Configurator/Streams/Buttons.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar Stream = /*#__PURE__*/function (_Slim) {\n  _inherits(Stream, _Slim);\n\n  var _super = _createSuper(Stream);\n\n  function Stream() {\n    var _this;\n\n    _classCallCheck(this, Stream);\n\n    _this = _super.call(this);\n\n    _this.streams.forEach(function (item) {\n      item.shortView = true;\n    });\n\n    _this[\"short\"] = true;\n    return _this;\n  }\n\n  _createClass(Stream, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      requestAnimationFrame(function () {\n        return _iconify_iconify__WEBPACK_IMPORTED_MODULE_1___default().scan(_this2.shadowRoot);\n      });\n    }\n  }, {\n    key: \"toggleView\",\n    value: function toggleView(item) {\n      item.shortView = !item.shortView;\n      _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(this);\n    }\n  }]);\n\n  return Stream;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nvar MAINSTART =\n/*html*/\n\"\\n<main>\\n    <h2>{{ this.header }}</h2>\\n    <div *foreach=\\\"{{ this.streams }}\\\">\\n        <div class=\\\"stream\\\">\\n\";\nvar MAINEND =\n/*html*/\n\"\\n            <transcode-configurator-stream-buttons .item=\\\"{{ item }}\\\"></transcode-configurator-stream-buttons>\\n        </div>\\n    </div>\\n</main>\\n\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvU3RyZWFtcy9TdHJlYW0uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0lBRU1HOzs7OztBQUVGLG9CQUFjO0FBQUE7O0FBQUE7O0FBQ1Y7O0FBQ0EsVUFBS0MsT0FBTCxDQUFhQyxPQUFiLENBQXFCLFVBQUFDLElBQUksRUFBSTtBQUN6QkEsTUFBQUEsSUFBSSxDQUFDQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0gsS0FGRDs7QUFHQSxxQkFBYSxJQUFiO0FBTFU7QUFNYjs7OztXQUVELG1CQUFVO0FBQUE7O0FBQ05DLE1BQUFBLHFCQUFxQixDQUFDO0FBQUEsZUFBTU4sNERBQUEsQ0FBYSxNQUFJLENBQUNRLFVBQWxCLENBQU47QUFBQSxPQUFELENBQXJCO0FBQ0g7OztXQUVELG9CQUFXSixJQUFYLEVBQWlCO0FBQ2JBLE1BQUFBLElBQUksQ0FBQ0MsU0FBTCxHQUFpQixDQUFDRCxJQUFJLENBQUNDLFNBQXZCO0FBQ0FOLE1BQUFBLDhEQUFBLENBQWtCLElBQWxCO0FBQ0g7Ozs7RUFqQmdCRDs7QUFvQnJCLElBQU1ZLFNBQVM7QUFBRztBQUFILHVIQUFmO0FBT0EsSUFBTUMsT0FBTztBQUFHO0FBQUgsMkpBQWIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvU3RyZWFtcy9TdHJlYW0uanM/NTdiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltLCBVdGlscyB9IGZyb20gJ0AvY29tcG9uZW50cy9saWInO1xuaW1wb3J0IEljb25pZnkgZnJvbSAnQGljb25pZnkvaWNvbmlmeSdcbmltcG9ydCAnLi9CdXR0b25zJ1xuXG5jbGFzcyBTdHJlYW0gZXh0ZW5kcyBTbGltIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuc3RyZWFtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5zaG9ydFZpZXcgPSB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNob3J0ID0gdHJ1ZVxuICAgIH1cblxuICAgIG9uQWRkZWQoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBJY29uaWZ5LnNjYW4odGhpcy5zaGFkb3dSb290KSlcbiAgICB9XG5cbiAgICB0b2dnbGVWaWV3KGl0ZW0pIHtcbiAgICAgICAgaXRlbS5zaG9ydFZpZXcgPSAhaXRlbS5zaG9ydFZpZXdcbiAgICAgICAgVXRpbHMuZm9yY2VVcGRhdGUodGhpcylcbiAgICB9XG59XG5cbmNvbnN0IE1BSU5TVEFSVCA9IC8qaHRtbCovIGBcbjxtYWluPlxuICAgIDxoMj57eyB0aGlzLmhlYWRlciB9fTwvaDI+XG4gICAgPGRpdiAqZm9yZWFjaD1cInt7IHRoaXMuc3RyZWFtcyB9fVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic3RyZWFtXCI+XG5gXG5cbmNvbnN0IE1BSU5FTkQgPSAvKmh0bWwqLyBgXG4gICAgICAgICAgICA8dHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1zdHJlYW0tYnV0dG9ucyAuaXRlbT1cInt7IGl0ZW0gfX1cIj48L3RyYW5zY29kZS1jb25maWd1cmF0b3Itc3RyZWFtLWJ1dHRvbnM+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9tYWluPlxuYFxuXG5leHBvcnQge1N0cmVhbSwgTUFJTlNUQVJULCBNQUlORU5EfSJdLCJuYW1lcyI6WyJTbGltIiwiVXRpbHMiLCJJY29uaWZ5IiwiU3RyZWFtIiwic3RyZWFtcyIsImZvckVhY2giLCJpdGVtIiwic2hvcnRWaWV3IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2NhbiIsInNoYWRvd1Jvb3QiLCJmb3JjZVVwZGF0ZSIsIk1BSU5TVEFSVCIsIk1BSU5FTkQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Streams/Stream.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Streams/Sub.js":
/*!*************************************************************!*\
  !*** ./resources/js/components/Configurator/Streams/Sub.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Stream */ \"./resources/js/components/Configurator/Streams/Stream.js\");\n/* harmony import */ var _CardCss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CardCss */ \"./resources/js/components/Configurator/CardCss.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Sub = /*#__PURE__*/function (_Stream) {\n  _inherits(Sub, _Stream);\n\n  var _super = _createSuper(Sub);\n\n  function Sub() {\n    _classCallCheck(this, Sub);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Sub;\n}(_Stream__WEBPACK_IMPORTED_MODULE_0__.Stream);\n\nSub.prototype.header = 'Subtitle';\nSub.template =\n/*html*/\n\"\\n\".concat(_CardCss__WEBPACK_IMPORTED_MODULE_1__.default, \"\\n\").concat(_Stream__WEBPACK_IMPORTED_MODULE_0__.MAINSTART, \"\\n<section class=\\\"toggle\\\">\\n    <div class=\\\"{{ item.shortView && 'visible' }}\\\" @click=\\\"{{ this.toggleView(item) }}\\\" data-toggle=\\\"true\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-chevron-right\\\"></span>\\n        Stream #0:{{ item.index }}\\n        {{ item.codec_name }}\\n        {{ (item.tags?.language || '').wrap('(', ')') }}\\n        {{ Object.keys(item.disposition).filter(k => item.disposition[k] > 0).join(', ').wrap('(', ')') }}\\n        &nbsp;->&nbsp;\\n        {{ Object.values(SUBTITLE_CODECS).find(c => c.v === item.transcodeConfig.codec).l }}\\n    </div>\\n    <div class=\\\"{{ (!item.shortView && 'visible') }}\\\" @click=\\\"{{ this.toggleView(item) }}\\\" data-toggle=\\\"true\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-chevron-down\\\"></span>\\n        Stream #0:{{ item.index }}{{ (item.id?.wrap('[', ']') || '') }}:\\n        {{ (item.tags?.language || '').wrap('(', ')') }}\\n    </div>\\n    <div class=\\\"{{ (!item.shortView && 'visible') }}\\\">\\n        Subtitle: {{ item.codec_name }}\\n        {{ [item.codec_tag_string, item.codec_tag].filter(i => i).join(' / ')?.wrap('(', ')') }}\\n        {{ Object.keys(item.disposition).filter(k => item.disposition[k] > 0).join(', ').wrap('(', ')') }}\\n    </div>\\n</section>\\n\").concat(_Stream__WEBPACK_IMPORTED_MODULE_0__.MAINEND, \"\\n\");\ncustomElements.define('transcode-configurator-stream-sub', Sub);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvU3RyZWFtcy9TdWIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7SUFFTUk7Ozs7Ozs7Ozs7OztFQUFZSjs7QUFFbEJJLEdBQUcsQ0FBQ0MsU0FBSixDQUFjQyxNQUFkLEdBQXVCLFVBQXZCO0FBRUFGLEdBQUcsQ0FBQ0csUUFBSjtBQUFlO0FBQWYsWUFDRUosNkNBREYsZUFFRUYsOENBRkYseXVDQXdCRUMsNENBeEJGO0FBMkJBTSxjQUFjLENBQUNDLE1BQWYsQ0FBc0IsbUNBQXRCLEVBQTJETCxHQUEzRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9TdHJlYW1zL1N1Yi5qcz8yODA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U3RyZWFtLCBNQUlOU1RBUlQsIE1BSU5FTkR9IGZyb20gXCIuL1N0cmVhbVwiO1xuaW1wb3J0IENBUkRfQ1NTIGZyb20gXCIuLi9DYXJkQ3NzXCI7XG5cbmNsYXNzIFN1YiBleHRlbmRzIFN0cmVhbSB7fVxuXG5TdWIucHJvdG90eXBlLmhlYWRlciA9ICdTdWJ0aXRsZSdcblxuU3ViLnRlbXBsYXRlID0gLypodG1sKi9gXG4ke0NBUkRfQ1NTfVxuJHtNQUlOU1RBUlR9XG48c2VjdGlvbiBjbGFzcz1cInRvZ2dsZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJ7eyBpdGVtLnNob3J0VmlldyAmJiAndmlzaWJsZScgfX1cIiBAY2xpY2s9XCJ7eyB0aGlzLnRvZ2dsZVZpZXcoaXRlbSkgfX1cIiBkYXRhLXRvZ2dsZT1cInRydWVcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWNoZXZyb24tcmlnaHRcIj48L3NwYW4+XG4gICAgICAgIFN0cmVhbSAjMDp7eyBpdGVtLmluZGV4IH19XG4gICAgICAgIHt7IGl0ZW0uY29kZWNfbmFtZSB9fVxuICAgICAgICB7eyAoaXRlbS50YWdzPy5sYW5ndWFnZSB8fCAnJykud3JhcCgnKCcsICcpJykgfX1cbiAgICAgICAge3sgT2JqZWN0LmtleXMoaXRlbS5kaXNwb3NpdGlvbikuZmlsdGVyKGsgPT4gaXRlbS5kaXNwb3NpdGlvbltrXSA+IDApLmpvaW4oJywgJykud3JhcCgnKCcsICcpJykgfX1cbiAgICAgICAgJm5ic3A7LT4mbmJzcDtcbiAgICAgICAge3sgT2JqZWN0LnZhbHVlcyhTVUJUSVRMRV9DT0RFQ1MpLmZpbmQoYyA9PiBjLnYgPT09IGl0ZW0udHJhbnNjb2RlQ29uZmlnLmNvZGVjKS5sIH19XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInt7ICghaXRlbS5zaG9ydFZpZXcgJiYgJ3Zpc2libGUnKSB9fVwiIEBjbGljaz1cInt7IHRoaXMudG9nZ2xlVmlldyhpdGVtKSB9fVwiIGRhdGEtdG9nZ2xlPVwidHJ1ZVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktY2hldnJvbi1kb3duXCI+PC9zcGFuPlxuICAgICAgICBTdHJlYW0gIzA6e3sgaXRlbS5pbmRleCB9fXt7IChpdGVtLmlkPy53cmFwKCdbJywgJ10nKSB8fCAnJykgfX06XG4gICAgICAgIHt7IChpdGVtLnRhZ3M/Lmxhbmd1YWdlIHx8ICcnKS53cmFwKCcoJywgJyknKSB9fVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ7eyAoIWl0ZW0uc2hvcnRWaWV3ICYmICd2aXNpYmxlJykgfX1cIj5cbiAgICAgICAgU3VidGl0bGU6IHt7IGl0ZW0uY29kZWNfbmFtZSB9fVxuICAgICAgICB7eyBbaXRlbS5jb2RlY190YWdfc3RyaW5nLCBpdGVtLmNvZGVjX3RhZ10uZmlsdGVyKGkgPT4gaSkuam9pbignIC8gJyk/LndyYXAoJygnLCAnKScpIH19XG4gICAgICAgIHt7IE9iamVjdC5rZXlzKGl0ZW0uZGlzcG9zaXRpb24pLmZpbHRlcihrID0+IGl0ZW0uZGlzcG9zaXRpb25ba10gPiAwKS5qb2luKCcsICcpLndyYXAoJygnLCAnKScpIH19XG4gICAgPC9kaXY+XG48L3NlY3Rpb24+XG4ke01BSU5FTkR9XG5gXG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgndHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1zdHJlYW0tc3ViJywgU3ViKTsiXSwibmFtZXMiOlsiU3RyZWFtIiwiTUFJTlNUQVJUIiwiTUFJTkVORCIsIkNBUkRfQ1NTIiwiU3ViIiwicHJvdG90eXBlIiwiaGVhZGVyIiwidGVtcGxhdGUiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Streams/Sub.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Streams/Video.js":
/*!***************************************************************!*\
  !*** ./resources/js/components/Configurator/Streams/Video.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VALID_ASPECT_RATIOS\": () => (/* binding */ VALID_ASPECT_RATIOS)\n/* harmony export */ });\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Stream */ \"./resources/js/components/Configurator/Streams/Stream.js\");\n/* harmony import */ var _CardCss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CardCss */ \"./resources/js/components/Configurator/CardCss.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar VALID_ASPECT_RATIOS = [\"4:3\", \"16:9\"];\n\nvar Video = /*#__PURE__*/function (_Stream) {\n  _inherits(Video, _Stream);\n\n  var _super = _createSuper(Video);\n\n  function Video() {\n    _classCallCheck(this, Video);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Video;\n}(_Stream__WEBPACK_IMPORTED_MODULE_1__.Stream);\n\nVideo.prototype.header = 'Video';\nVideo.template =\n/*html*/\n\"\\n\".concat(_CardCss__WEBPACK_IMPORTED_MODULE_2__.default, \"\\n<style>\\n</style>\\n\").concat(_Stream__WEBPACK_IMPORTED_MODULE_1__.MAINSTART, \"\\n<section class=\\\"toggle\\\">\\n    <div class=\\\"{{ (item.shortView && 'visible') }}\\\" @click=\\\"{{ this.toggleView(item) }}\\\" data-toggle=\\\"true\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-chevron-right\\\"></span>\\n        Stream #0:{{ item.index }}\\n        {{ item.codec_name }}\\n        {{ [item.width, item.height].filter(i => i).join('x') }}\\n        &nbsp;->&nbsp;\\n        {{ Object.values(VIDEO_CODECS).find(c => c.v === item.transcodeConfig.codec).l }},\\n        QP: {{ 'undefined' !== typeof item.transcodeConfig.qp ? item.transcodeConfig.qp : 'N/A' }},\\n        DAR: {{ item.transcodeConfig.aspectRatio }}\\n    </div>\\n    <div class=\\\"{{ (!item.shortView && 'visible') }}\\\" @click=\\\"{{ this.toggleView(item) }}\\\" data-toggle=\\\"true\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-chevron-down\\\"></span>\\n        Stream #0:{{ item.index }}{{ (item.id?.wrap('[', ']') || '') }}:\\n    </div>\\n    <div class=\\\"{{ (!item.shortView && 'visible') }}\\\">\\n        Video: {{ item.codec_name }}\\n        {{ item.profile?.wrap('(', ')') || '' }}\\n        {{ [item.codec_tag_string, item.codec_tag].filter(i => i).join(' / ')?.wrap('(', ')') || '' }}\\n        {{ (item.pix_fmt || '') }}{{ [item.color_range, item.color_space, item.field_order].filter(i => i).join(', ')?.wrap('(', ')') }}\\n    </div>\\n    <div class=\\\"{{ (!item.shortView && 'visible') }}\\\">\\n        {{ [item.width, item.height].filter(i => i).join('x') }}\\n        {{ [item.sample_aspect_ratio?.wrap('SAR '), item.display_aspect_ratio?.wrap('DAR ')].filter(i => i).join(' ')?.wrap('[', ']') }}\\n        {{ ( item.avg_frame_rate?.indexOf('/') > -1 && eval(item.avg_frame_rate) || (item.avg_frame_rate || 'N/A') ) }} fps,\\n        {{ ( item.r_frame_rate?.indexOf('/') > -1 && eval(item.r_frame_rate) || (item.r_frame_rate || 'N/A') ) }} tbr,\\n        {{ ( item.time_base?.indexOf('/') > -1 && parseInt(item.time_base.split('/').pop(), 10) / 1000 + 'k' || (item.time_base || 'N/A') ) }} tbn,\\n        {{ ( item.codec_time_base?.indexOf('/') > -1 && item.codec_time_base.split('/').pop() || (item.codec_time_base || 'N/A') ) }} tbc\\n    </div>\\n</section>\\n\").concat(_Stream__WEBPACK_IMPORTED_MODULE_1__.MAINEND, \"\\n\");\ncustomElements.define('transcode-configurator-stream-video', Video);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvU3RyZWFtcy9WaWRlby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBRU8sSUFBTUssbUJBQW1CLEdBQUcsQ0FBQyxLQUFELEVBQVEsTUFBUixDQUE1Qjs7SUFFREM7Ozs7Ozs7Ozs7OztFQUFjTDs7QUFFcEJLLEtBQUssQ0FBQ0MsU0FBTixDQUFnQkMsTUFBaEIsR0FBeUIsT0FBekI7QUFFQUYsS0FBSyxDQUFDRyxRQUFOO0FBQWlCO0FBQWpCLFlBQ0VMLDZDQURGLGtDQUlFRiw4Q0FKRixnbUVBbUNFQyw0Q0FuQ0Y7QUFzQ0FPLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixxQ0FBdEIsRUFBNkRMLEtBQTdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL1N0cmVhbXMvVmlkZW8uanM/NDdmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVdGlscyB9IGZyb20gJ0AvY29tcG9uZW50cy9saWInO1xuaW1wb3J0IHtTdHJlYW0sIE1BSU5TVEFSVCwgTUFJTkVORH0gZnJvbSBcIi4vU3RyZWFtXCI7XG5pbXBvcnQgQ0FSRF9DU1MgZnJvbSBcIi4uL0NhcmRDc3NcIjtcblxuZXhwb3J0IGNvbnN0IFZBTElEX0FTUEVDVF9SQVRJT1MgPSBbXCI0OjNcIiwgXCIxNjo5XCJdO1xuXG5jbGFzcyBWaWRlbyBleHRlbmRzIFN0cmVhbSB7fVxuXG5WaWRlby5wcm90b3R5cGUuaGVhZGVyID0gJ1ZpZGVvJ1xuXG5WaWRlby50ZW1wbGF0ZSA9IC8qaHRtbCovYFxuJHtDQVJEX0NTU31cbjxzdHlsZT5cbjwvc3R5bGU+XG4ke01BSU5TVEFSVH1cbjxzZWN0aW9uIGNsYXNzPVwidG9nZ2xlXCI+XG4gICAgPGRpdiBjbGFzcz1cInt7IChpdGVtLnNob3J0VmlldyAmJiAndmlzaWJsZScpIH19XCIgQGNsaWNrPVwie3sgdGhpcy50b2dnbGVWaWV3KGl0ZW0pIH19XCIgZGF0YS10b2dnbGU9XCJ0cnVlXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1jaGV2cm9uLXJpZ2h0XCI+PC9zcGFuPlxuICAgICAgICBTdHJlYW0gIzA6e3sgaXRlbS5pbmRleCB9fVxuICAgICAgICB7eyBpdGVtLmNvZGVjX25hbWUgfX1cbiAgICAgICAge3sgW2l0ZW0ud2lkdGgsIGl0ZW0uaGVpZ2h0XS5maWx0ZXIoaSA9PiBpKS5qb2luKCd4JykgfX1cbiAgICAgICAgJm5ic3A7LT4mbmJzcDtcbiAgICAgICAge3sgT2JqZWN0LnZhbHVlcyhWSURFT19DT0RFQ1MpLmZpbmQoYyA9PiBjLnYgPT09IGl0ZW0udHJhbnNjb2RlQ29uZmlnLmNvZGVjKS5sIH19LFxuICAgICAgICBRUDoge3sgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBpdGVtLnRyYW5zY29kZUNvbmZpZy5xcCA/IGl0ZW0udHJhbnNjb2RlQ29uZmlnLnFwIDogJ04vQScgfX0sXG4gICAgICAgIERBUjoge3sgaXRlbS50cmFuc2NvZGVDb25maWcuYXNwZWN0UmF0aW8gfX1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwie3sgKCFpdGVtLnNob3J0VmlldyAmJiAndmlzaWJsZScpIH19XCIgQGNsaWNrPVwie3sgdGhpcy50b2dnbGVWaWV3KGl0ZW0pIH19XCIgZGF0YS10b2dnbGU9XCJ0cnVlXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1jaGV2cm9uLWRvd25cIj48L3NwYW4+XG4gICAgICAgIFN0cmVhbSAjMDp7eyBpdGVtLmluZGV4IH19e3sgKGl0ZW0uaWQ/LndyYXAoJ1snLCAnXScpIHx8ICcnKSB9fTpcbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwie3sgKCFpdGVtLnNob3J0VmlldyAmJiAndmlzaWJsZScpIH19XCI+XG4gICAgICAgIFZpZGVvOiB7eyBpdGVtLmNvZGVjX25hbWUgfX1cbiAgICAgICAge3sgaXRlbS5wcm9maWxlPy53cmFwKCcoJywgJyknKSB8fCAnJyB9fVxuICAgICAgICB7eyBbaXRlbS5jb2RlY190YWdfc3RyaW5nLCBpdGVtLmNvZGVjX3RhZ10uZmlsdGVyKGkgPT4gaSkuam9pbignIC8gJyk/LndyYXAoJygnLCAnKScpIHx8ICcnIH19XG4gICAgICAgIHt7IChpdGVtLnBpeF9mbXQgfHwgJycpIH19e3sgW2l0ZW0uY29sb3JfcmFuZ2UsIGl0ZW0uY29sb3Jfc3BhY2UsIGl0ZW0uZmllbGRfb3JkZXJdLmZpbHRlcihpID0+IGkpLmpvaW4oJywgJyk/LndyYXAoJygnLCAnKScpIH19XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInt7ICghaXRlbS5zaG9ydFZpZXcgJiYgJ3Zpc2libGUnKSB9fVwiPlxuICAgICAgICB7eyBbaXRlbS53aWR0aCwgaXRlbS5oZWlnaHRdLmZpbHRlcihpID0+IGkpLmpvaW4oJ3gnKSB9fVxuICAgICAgICB7eyBbaXRlbS5zYW1wbGVfYXNwZWN0X3JhdGlvPy53cmFwKCdTQVIgJyksIGl0ZW0uZGlzcGxheV9hc3BlY3RfcmF0aW8/LndyYXAoJ0RBUiAnKV0uZmlsdGVyKGkgPT4gaSkuam9pbignICcpPy53cmFwKCdbJywgJ10nKSB9fVxuICAgICAgICB7eyAoIGl0ZW0uYXZnX2ZyYW1lX3JhdGU/LmluZGV4T2YoJy8nKSA+IC0xICYmIGV2YWwoaXRlbS5hdmdfZnJhbWVfcmF0ZSkgfHwgKGl0ZW0uYXZnX2ZyYW1lX3JhdGUgfHwgJ04vQScpICkgfX0gZnBzLFxuICAgICAgICB7eyAoIGl0ZW0ucl9mcmFtZV9yYXRlPy5pbmRleE9mKCcvJykgPiAtMSAmJiBldmFsKGl0ZW0ucl9mcmFtZV9yYXRlKSB8fCAoaXRlbS5yX2ZyYW1lX3JhdGUgfHwgJ04vQScpICkgfX0gdGJyLFxuICAgICAgICB7eyAoIGl0ZW0udGltZV9iYXNlPy5pbmRleE9mKCcvJykgPiAtMSAmJiBwYXJzZUludChpdGVtLnRpbWVfYmFzZS5zcGxpdCgnLycpLnBvcCgpLCAxMCkgLyAxMDAwICsgJ2snIHx8IChpdGVtLnRpbWVfYmFzZSB8fCAnTi9BJykgKSB9fSB0Ym4sXG4gICAgICAgIHt7ICggaXRlbS5jb2RlY190aW1lX2Jhc2U/LmluZGV4T2YoJy8nKSA+IC0xICYmIGl0ZW0uY29kZWNfdGltZV9iYXNlLnNwbGl0KCcvJykucG9wKCkgfHwgKGl0ZW0uY29kZWNfdGltZV9iYXNlIHx8ICdOL0EnKSApIH19IHRiY1xuICAgIDwvZGl2PlxuPC9zZWN0aW9uPlxuJHtNQUlORU5EfVxuYFxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RyYW5zY29kZS1jb25maWd1cmF0b3Itc3RyZWFtLXZpZGVvJywgVmlkZW8pOyJdLCJuYW1lcyI6WyJVdGlscyIsIlN0cmVhbSIsIk1BSU5TVEFSVCIsIk1BSU5FTkQiLCJDQVJEX0NTUyIsIlZBTElEX0FTUEVDVF9SQVRJT1MiLCJWaWRlbyIsInByb3RvdHlwZSIsImhlYWRlciIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Streams/Video.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Streams/index.js":
/*!***************************************************************!*\
  !*** ./resources/js/components/Configurator/Streams/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TYPE_AUDIO\": () => (/* binding */ TYPE_AUDIO),\n/* harmony export */   \"TYPE_VIDEO\": () => (/* binding */ TYPE_VIDEO),\n/* harmony export */   \"TYPE_SUB\": () => (/* binding */ TYPE_SUB),\n/* harmony export */   \"TYPE_DATA\": () => (/* binding */ TYPE_DATA)\n/* harmony export */ });\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _Video__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Video */ \"./resources/js/components/Configurator/Streams/Video.js\");\n/* harmony import */ var _Audio__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Audio */ \"./resources/js/components/Configurator/Streams/Audio.js\");\n/* harmony import */ var _Sub__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Sub */ \"./resources/js/components/Configurator/Streams/Sub.js\");\n/* harmony import */ var _Data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Data */ \"./resources/js/components/Configurator/Streams/Data.js\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Config */ \"./resources/js/components/Configurator/Streams/Config/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\nvar TYPE_VIDEO = 'video';\nvar TYPE_AUDIO = 'audio';\nvar TYPE_SUB = 'subtitle';\nvar TYPE_DATA = 'data';\n\n\nvar Streams = /*#__PURE__*/function (_Slim) {\n  _inherits(Streams, _Slim);\n\n  var _super = _createSuper(Streams);\n\n  function Streams() {\n    _classCallCheck(this, Streams);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Streams, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this$video, _this$video2, _this$audio, _this$audio2;\n\n      this.updateHandler = this.handleUpdates.bind(this);\n      ((_this$video = this.video) === null || _this$video === void 0 ? void 0 : _this$video.find(function (v) {\n        return v.active;\n      })) || ((_this$video2 = this.video) === null || _this$video2 === void 0 ? void 0 : _this$video2.forEach(function (v, k) {\n        return v.active = k === 0;\n      }));\n      ((_this$audio = this.audio) === null || _this$audio === void 0 ? void 0 : _this$audio.find(function (a) {\n        return a.active;\n      })) || ((_this$audio2 = this.audio) === null || _this$audio2 === void 0 ? void 0 : _this$audio2.forEach(function (v, k) {\n        return v.active = k === 0;\n      }));\n      document.addEventListener('stream-config', this.updateHandler);\n    }\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved() {\n      document.removeEventListener('stream-config', this.updateHandler);\n    }\n  }, {\n    key: \"handleUpdates\",\n    value: function handleUpdates() {\n      _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(this);\n    }\n  }, {\n    key: \"video\",\n    get: function get() {\n      var _this$items;\n\n      return (_this$items = this.items) === null || _this$items === void 0 ? void 0 : _this$items.filter(function (i) {\n        return i.codec_type === TYPE_VIDEO;\n      }).sort(function (a, b) {\n        return a.index > b.index;\n      });\n    }\n  }, {\n    key: \"audio\",\n    get: function get() {\n      var _this$items2;\n\n      return (_this$items2 = this.items) === null || _this$items2 === void 0 ? void 0 : _this$items2.filter(function (i) {\n        return i.codec_type === TYPE_AUDIO;\n      }).sort(function (a, b) {\n        return a.index > b.index;\n      });\n    }\n  }, {\n    key: \"subs\",\n    get: function get() {\n      var _this$items3;\n\n      return (_this$items3 = this.items) === null || _this$items3 === void 0 ? void 0 : _this$items3.filter(function (i) {\n        return i.codec_type === TYPE_SUB;\n      }).sort(function (a, b) {\n        return a.index > b.index;\n      });\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      var _this$items4;\n\n      return (_this$items4 = this.items) === null || _this$items4 === void 0 ? void 0 : _this$items4.filter(function (i) {\n        return i.codec_type === TYPE_DATA;\n      }).sort(function (a, b) {\n        return a.index > b.index;\n      });\n    }\n  }]);\n\n  return Streams;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nStreams.template =\n/*html*/\n\"\\n<style>\\ndiv {\\n    display: flex;\\n    flex-direction: column;\\n    gap: 1rem;\\n}\\n</style>\\n<div>\\n    <transcode-configurator-stream-video *if=\\\"{{ this.video.length }}\\\" .streams=\\\"{{ this.video }}\\\"></transcode-configurator-stream-video>\\n    <transcode-configurator-stream-audio *if=\\\"{{ this.audio.length }}\\\" .streams=\\\"{{ this.audio }}\\\"></transcode-configurator-stream-audio>\\n    <transcode-configurator-stream-sub *if=\\\"{{ this.subs.length }}\\\" .streams=\\\"{{ this.subs }}\\\"></transcode-configurator-stream-sub>\\n    <transcode-configurator-stream-data *if=\\\"{{ this.data.length }}\\\" .streams=\\\"{{ this.data }}\\\"></transcode-configurator-stream-data>\\n</div>\\n\";\ncustomElements.define('transcode-configurator-streams', Streams);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvU3RyZWFtcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLElBQU1FLFVBQVUsR0FBRyxPQUFuQjtBQUNBLElBQU1DLFVBQVUsR0FBRyxPQUFuQjtBQUNBLElBQU1DLFFBQVEsR0FBRyxVQUFqQjtBQUNBLElBQU1DLFNBQVMsR0FBRyxNQUFsQjtBQUVBOztJQUVNQzs7Ozs7Ozs7Ozs7OztXQUVGLG1CQUFVO0FBQUE7O0FBQ04sV0FBS0MsYUFBTCxHQUFxQixLQUFLQyxhQUFMLENBQW1CQyxJQUFuQixDQUF3QixJQUF4QixDQUFyQjtBQUNBLDJCQUFLQyxLQUFMLDREQUFZQyxJQUFaLENBQWlCLFVBQUFDLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUNDLE1BQU47QUFBQSxPQUFsQix1QkFBbUMsS0FBS0gsS0FBeEMsaURBQW1DLGFBQVlJLE9BQVosQ0FBb0IsVUFBQ0YsQ0FBRCxFQUFJRyxDQUFKO0FBQUEsZUFBVUgsQ0FBQyxDQUFDQyxNQUFGLEdBQVdFLENBQUMsS0FBSyxDQUEzQjtBQUFBLE9BQXBCLENBQW5DO0FBQ0EsMkJBQUtDLEtBQUwsNERBQVlMLElBQVosQ0FBaUIsVUFBQU0sQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ0osTUFBTjtBQUFBLE9BQWxCLHVCQUFtQyxLQUFLRyxLQUF4QyxpREFBbUMsYUFBWUYsT0FBWixDQUFvQixVQUFDRixDQUFELEVBQUlHLENBQUo7QUFBQSxlQUFVSCxDQUFDLENBQUNDLE1BQUYsR0FBV0UsQ0FBQyxLQUFLLENBQTNCO0FBQUEsT0FBcEIsQ0FBbkM7QUFDQUcsTUFBQUEsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQixlQUExQixFQUEyQyxLQUFLWixhQUFoRDtBQUNIOzs7V0FFRCxxQkFBWTtBQUNSVyxNQUFBQSxRQUFRLENBQUNFLG1CQUFULENBQTZCLGVBQTdCLEVBQThDLEtBQUtiLGFBQW5EO0FBQ0g7OztXQUVELHlCQUFnQjtBQUNaTixNQUFBQSw4REFBQSxDQUFrQixJQUFsQjtBQUNIOzs7U0FFRCxlQUFZO0FBQUE7O0FBQ1IsNEJBQU8sS0FBS3FCLEtBQVosZ0RBQU8sWUFBWUMsTUFBWixDQUFtQixVQUFBQyxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDQyxVQUFGLEtBQWlCdkIsVUFBckI7QUFBQSxPQUFwQixFQUFxRHdCLElBQXJELENBQTBELFVBQUNULENBQUQsRUFBSVUsQ0FBSjtBQUFBLGVBQVVWLENBQUMsQ0FBQ1csS0FBRixHQUFVRCxDQUFDLENBQUNDLEtBQXRCO0FBQUEsT0FBMUQsQ0FBUDtBQUNIOzs7U0FFRCxlQUFZO0FBQUE7O0FBQ1IsNkJBQU8sS0FBS04sS0FBWixpREFBTyxhQUFZQyxNQUFaLENBQW1CLFVBQUFDLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUNDLFVBQUYsS0FBaUJ0QixVQUFyQjtBQUFBLE9BQXBCLEVBQXFEdUIsSUFBckQsQ0FBMEQsVUFBQ1QsQ0FBRCxFQUFJVSxDQUFKO0FBQUEsZUFBVVYsQ0FBQyxDQUFDVyxLQUFGLEdBQVVELENBQUMsQ0FBQ0MsS0FBdEI7QUFBQSxPQUExRCxDQUFQO0FBQ0g7OztTQUVELGVBQVc7QUFBQTs7QUFDUCw2QkFBTyxLQUFLTixLQUFaLGlEQUFPLGFBQVlDLE1BQVosQ0FBbUIsVUFBQUMsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ0MsVUFBRixLQUFpQnJCLFFBQXJCO0FBQUEsT0FBcEIsRUFBbURzQixJQUFuRCxDQUF3RCxVQUFDVCxDQUFELEVBQUlVLENBQUo7QUFBQSxlQUFVVixDQUFDLENBQUNXLEtBQUYsR0FBVUQsQ0FBQyxDQUFDQyxLQUF0QjtBQUFBLE9BQXhELENBQVA7QUFDSDs7O1NBRUQsZUFBVztBQUFBOztBQUNQLDZCQUFPLEtBQUtOLEtBQVosaURBQU8sYUFBWUMsTUFBWixDQUFtQixVQUFBQyxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDQyxVQUFGLEtBQWlCcEIsU0FBckI7QUFBQSxPQUFwQixFQUFvRHFCLElBQXBELENBQXlELFVBQUNULENBQUQsRUFBSVUsQ0FBSjtBQUFBLGVBQVVWLENBQUMsQ0FBQ1csS0FBRixHQUFVRCxDQUFDLENBQUNDLEtBQXRCO0FBQUEsT0FBekQsQ0FBUDtBQUNIOzs7O0VBL0JpQjVCOztBQWtDdEJNLE9BQU8sQ0FBQ3VCLFFBQVI7QUFBbUI7QUFBbkI7QUFnQkFDLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixnQ0FBdEIsRUFBd0R6QixPQUF4RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9TdHJlYW1zL2luZGV4LmpzPzU0OTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2xpbSwgVXRpbHMgfSBmcm9tICdAL2NvbXBvbmVudHMvbGliJztcbmltcG9ydCAnLi9WaWRlbydcbmltcG9ydCAnLi9BdWRpbydcbmltcG9ydCAnLi9TdWInXG5pbXBvcnQgJy4vRGF0YSdcbmltcG9ydCAnLi9Db25maWcnXG5cbmNvbnN0IFRZUEVfVklERU8gPSAndmlkZW8nXG5jb25zdCBUWVBFX0FVRElPID0gJ2F1ZGlvJ1xuY29uc3QgVFlQRV9TVUIgPSAnc3VidGl0bGUnXG5jb25zdCBUWVBFX0RBVEEgPSAnZGF0YSdcblxuZXhwb3J0IHsgVFlQRV9BVURJTywgVFlQRV9WSURFTywgVFlQRV9TVUIsIFRZUEVfREFUQSB9O1xuXG5jbGFzcyBTdHJlYW1zIGV4dGVuZHMgU2xpbSB7XG5cbiAgICBvbkFkZGVkKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIgPSB0aGlzLmhhbmRsZVVwZGF0ZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy52aWRlbz8uZmluZCh2ID0+IHYuYWN0aXZlKSB8fCB0aGlzLnZpZGVvPy5mb3JFYWNoKCh2LCBrKSA9PiB2LmFjdGl2ZSA9IGsgPT09IDApXG4gICAgICAgIHRoaXMuYXVkaW8/LmZpbmQoYSA9PiBhLmFjdGl2ZSkgfHwgdGhpcy5hdWRpbz8uZm9yRWFjaCgodiwgaykgPT4gdi5hY3RpdmUgPSBrID09PSAwKVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzdHJlYW0tY29uZmlnJywgdGhpcy51cGRhdGVIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBvblJlbW92ZWQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0cmVhbS1jb25maWcnLCB0aGlzLnVwZGF0ZUhhbmRsZXIpO1xuICAgIH1cblxuICAgIGhhbmRsZVVwZGF0ZXMoKSB7XG4gICAgICAgIFV0aWxzLmZvcmNlVXBkYXRlKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCB2aWRlbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXM/LmZpbHRlcihpID0+IGkuY29kZWNfdHlwZSA9PT0gVFlQRV9WSURFTykuc29ydCgoYSwgYikgPT4gYS5pbmRleCA+IGIuaW5kZXgpXG4gICAgfVxuXG4gICAgZ2V0IGF1ZGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcz8uZmlsdGVyKGkgPT4gaS5jb2RlY190eXBlID09PSBUWVBFX0FVRElPKS5zb3J0KChhLCBiKSA9PiBhLmluZGV4ID4gYi5pbmRleClcbiAgICB9XG5cbiAgICBnZXQgc3VicygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXM/LmZpbHRlcihpID0+IGkuY29kZWNfdHlwZSA9PT0gVFlQRV9TVUIpLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggPiBiLmluZGV4KVxuICAgIH1cblxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcz8uZmlsdGVyKGkgPT4gaS5jb2RlY190eXBlID09PSBUWVBFX0RBVEEpLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggPiBiLmluZGV4KVxuICAgIH1cbn1cblxuU3RyZWFtcy50ZW1wbGF0ZSA9IC8qaHRtbCovYFxuPHN0eWxlPlxuZGl2IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgZ2FwOiAxcmVtO1xufVxuPC9zdHlsZT5cbjxkaXY+XG4gICAgPHRyYW5zY29kZS1jb25maWd1cmF0b3Itc3RyZWFtLXZpZGVvICppZj1cInt7IHRoaXMudmlkZW8ubGVuZ3RoIH19XCIgLnN0cmVhbXM9XCJ7eyB0aGlzLnZpZGVvIH19XCI+PC90cmFuc2NvZGUtY29uZmlndXJhdG9yLXN0cmVhbS12aWRlbz5cbiAgICA8dHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1zdHJlYW0tYXVkaW8gKmlmPVwie3sgdGhpcy5hdWRpby5sZW5ndGggfX1cIiAuc3RyZWFtcz1cInt7IHRoaXMuYXVkaW8gfX1cIj48L3RyYW5zY29kZS1jb25maWd1cmF0b3Itc3RyZWFtLWF1ZGlvPlxuICAgIDx0cmFuc2NvZGUtY29uZmlndXJhdG9yLXN0cmVhbS1zdWIgKmlmPVwie3sgdGhpcy5zdWJzLmxlbmd0aCB9fVwiIC5zdHJlYW1zPVwie3sgdGhpcy5zdWJzIH19XCI+PC90cmFuc2NvZGUtY29uZmlndXJhdG9yLXN0cmVhbS1zdWI+XG4gICAgPHRyYW5zY29kZS1jb25maWd1cmF0b3Itc3RyZWFtLWRhdGEgKmlmPVwie3sgdGhpcy5kYXRhLmxlbmd0aCB9fVwiIC5zdHJlYW1zPVwie3sgdGhpcy5kYXRhIH19XCI+PC90cmFuc2NvZGUtY29uZmlndXJhdG9yLXN0cmVhbS1kYXRhPlxuPC9kaXY+XG5gXG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgndHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1zdHJlYW1zJywgU3RyZWFtcyk7Il0sIm5hbWVzIjpbIlNsaW0iLCJVdGlscyIsIlRZUEVfVklERU8iLCJUWVBFX0FVRElPIiwiVFlQRV9TVUIiLCJUWVBFX0RBVEEiLCJTdHJlYW1zIiwidXBkYXRlSGFuZGxlciIsImhhbmRsZVVwZGF0ZXMiLCJiaW5kIiwidmlkZW8iLCJmaW5kIiwidiIsImFjdGl2ZSIsImZvckVhY2giLCJrIiwiYXVkaW8iLCJhIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZvcmNlVXBkYXRlIiwiaXRlbXMiLCJmaWx0ZXIiLCJpIiwiY29kZWNfdHlwZSIsInNvcnQiLCJiIiwiaW5kZXgiLCJ0ZW1wbGF0ZSIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Streams/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Tools/clipper.js":
/*!***************************************************************!*\
  !*** ./resources/js/components/Configurator/Tools/clipper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clipper\": () => (/* binding */ clipper)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Streams__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Streams */ \"./resources/js/components/Configurator/Streams/index.js\");\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\nvar clipper = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n    var _this$streams$filter;\n\n    var _m, m, d, i, _d$clips$i$timestamps, _d$clips$i, _d$clips$i$timestamps2, _d$clips$i2;\n\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(this.format.format_name === \"mpegts\")) {\n              _context.next = 7;\n              break;\n            }\n\n            _m = document.createElement(\"modal-alert\");\n\n            _m.appendChild(document.createTextNode(\"Clipper does not work with mpegts Files. Remux first.\"));\n\n            document.body.appendChild(_m);\n            _context.next = 6;\n            return _m.alert();\n\n          case 6:\n            return _context.abrupt(\"return\");\n\n          case 7:\n            m = document.createElement(\"modal-window\");\n            m.header = \"Clipper\";\n            m.classList.add(\"no-shadow\");\n            d = document.createElement(\"dialogue-clipper\");\n            d.setClips(this.clips.getTimestamps());\n            d.video = _objectSpread(_objectSpread({}, (_this$streams$filter = this.streams.filter(function (s) {\n              return s.codec_type === _Streams__WEBPACK_IMPORTED_MODULE_1__.TYPE_VIDEO;\n            })) === null || _this$streams$filter === void 0 ? void 0 : _this$streams$filter[0]), {}, {\n              duration: parseFloat(this.format.duration)\n            });\n            d.path = this.item.path;\n            m.appendChild(d);\n            document.body.appendChild(m);\n            _context.prev = 16;\n            _context.next = 19;\n            return m.open();\n\n          case 19:\n            this.clips.clips = [];\n\n            for (i = 0; i < d.clips.length; i++) {\n              this.clips.addClip((_d$clips$i$timestamps = (_d$clips$i = d.clips[i]) === null || _d$clips$i === void 0 ? void 0 : _d$clips$i.timestamps.start) !== null && _d$clips$i$timestamps !== void 0 ? _d$clips$i$timestamps : null, (_d$clips$i$timestamps2 = (_d$clips$i2 = d.clips[i]) === null || _d$clips$i2 === void 0 ? void 0 : _d$clips$i2.timestamps.end) !== null && _d$clips$i$timestamps2 !== void 0 ? _d$clips$i$timestamps2 : null);\n            }\n\n            this.clips.update();\n            _context.next = 26;\n            break;\n\n          case 24:\n            _context.prev = 24;\n            _context.t0 = _context[\"catch\"](16);\n\n          case 26:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[16, 24]]);\n  }));\n\n  return function clipper() {\n    return _ref.apply(this, arguments);\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvY2xpcHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFTyxJQUFNQyxPQUFPO0FBQUEsb0hBQUc7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUNmLEtBQUtDLE1BQUwsQ0FBWUMsV0FBWixLQUE0QixRQURiO0FBQUE7QUFBQTtBQUFBOztBQUVUQyxZQUFBQSxFQUZTLEdBRUxDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixhQUF2QixDQUZLOztBQUdmRixZQUFBQSxFQUFDLENBQUNHLFdBQUYsQ0FDSUYsUUFBUSxDQUFDRyxjQUFULENBQ0ksdURBREosQ0FESjs7QUFLQUgsWUFBQUEsUUFBUSxDQUFDSSxJQUFULENBQWNGLFdBQWQsQ0FBMEJILEVBQTFCO0FBUmU7QUFBQSxtQkFTVEEsRUFBQyxDQUFDTSxLQUFGLEVBVFM7O0FBQUE7QUFBQTs7QUFBQTtBQVliTixZQUFBQSxDQVphLEdBWVRDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixjQUF2QixDQVpTO0FBYW5CRixZQUFBQSxDQUFDLENBQUNPLE1BQUYsR0FBVyxTQUFYO0FBQ0FQLFlBQUFBLENBQUMsQ0FBQ1EsU0FBRixDQUFZQyxHQUFaLENBQWdCLFdBQWhCO0FBQ01DLFlBQUFBLENBZmEsR0FlVFQsUUFBUSxDQUFDQyxhQUFULENBQXVCLGtCQUF2QixDQWZTO0FBZ0JuQlEsWUFBQUEsQ0FBQyxDQUFDQyxRQUFGLENBQVcsS0FBS0MsS0FBTCxDQUFXQyxhQUFYLEVBQVg7QUFDQUgsWUFBQUEsQ0FBQyxDQUFDSSxLQUFGLDJEQUNPLEtBQUtDLE9BQUwsQ0FBYUMsTUFBYixDQUFvQixVQUFDQyxDQUFEO0FBQUEscUJBQU9BLENBQUMsQ0FBQ0MsVUFBRixLQUFpQnRCLGdEQUF4QjtBQUFBLGFBQXBCLENBRFAseURBQ08scUJBQTBELENBQTFELENBRFA7QUFFSXVCLGNBQUFBLFFBQVEsRUFBRUMsVUFBVSxDQUFDLEtBQUt0QixNQUFMLENBQVlxQixRQUFiO0FBRnhCO0FBSUFULFlBQUFBLENBQUMsQ0FBQ1csSUFBRixHQUFTLEtBQUtDLElBQUwsQ0FBVUQsSUFBbkI7QUFDQXJCLFlBQUFBLENBQUMsQ0FBQ0csV0FBRixDQUFjTyxDQUFkO0FBQ0FULFlBQUFBLFFBQVEsQ0FBQ0ksSUFBVCxDQUFjRixXQUFkLENBQTBCSCxDQUExQjtBQXZCbUI7QUFBQTtBQUFBLG1CQXlCVEEsQ0FBQyxDQUFDdUIsSUFBRixFQXpCUzs7QUFBQTtBQTBCZixpQkFBS1gsS0FBTCxDQUFXQSxLQUFYLEdBQW1CLEVBQW5COztBQUNBLGlCQUFTWSxDQUFULEdBQWEsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHZCxDQUFDLENBQUNFLEtBQUYsQ0FBUWEsTUFBNUIsRUFBb0NELENBQUMsRUFBckMsRUFBeUM7QUFDckMsbUJBQUtaLEtBQUwsQ0FBV2MsT0FBWCx3Q0FDSWhCLENBQUMsQ0FBQ0UsS0FBRixDQUFRWSxDQUFSLENBREosK0NBQ0ksV0FBWUcsVUFBWixDQUF1QkMsS0FEM0IseUVBQ29DLElBRHBDLDJDQUVJbEIsQ0FBQyxDQUFDRSxLQUFGLENBQVFZLENBQVIsQ0FGSixnREFFSSxZQUFZRyxVQUFaLENBQXVCRSxHQUYzQiwyRUFFa0MsSUFGbEM7QUFJSDs7QUFDRCxpQkFBS2pCLEtBQUwsQ0FBV2tCLE1BQVg7QUFqQ2U7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBSDs7QUFBQSxrQkFBUGpDLE9BQU87QUFBQTtBQUFBO0FBQUEsR0FBYiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9Ub29scy9jbGlwcGVyLmpzP2E4OTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVFlQRV9WSURFTyB9IGZyb20gXCIuLi9TdHJlYW1zXCI7XG5cbmV4cG9ydCBjb25zdCBjbGlwcGVyID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZvcm1hdC5mb3JtYXRfbmFtZSA9PT0gXCJtcGVndHNcIikge1xuICAgICAgICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1vZGFsLWFsZXJ0XCIpO1xuICAgICAgICBtLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgICAgICAgICAgICAgXCJDbGlwcGVyIGRvZXMgbm90IHdvcmsgd2l0aCBtcGVndHMgRmlsZXMuIFJlbXV4IGZpcnN0LlwiXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobSk7XG4gICAgICAgIGF3YWl0IG0uYWxlcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1vZGFsLXdpbmRvd1wiKTtcbiAgICBtLmhlYWRlciA9IFwiQ2xpcHBlclwiO1xuICAgIG0uY2xhc3NMaXN0LmFkZChcIm5vLXNoYWRvd1wiKTtcbiAgICBjb25zdCBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpYWxvZ3VlLWNsaXBwZXJcIik7XG4gICAgZC5zZXRDbGlwcyh0aGlzLmNsaXBzLmdldFRpbWVzdGFtcHMoKSk7XG4gICAgZC52aWRlbyA9IHtcbiAgICAgICAgLi4udGhpcy5zdHJlYW1zLmZpbHRlcigocykgPT4gcy5jb2RlY190eXBlID09PSBUWVBFX1ZJREVPKT8uWzBdLFxuICAgICAgICBkdXJhdGlvbjogcGFyc2VGbG9hdCh0aGlzLmZvcm1hdC5kdXJhdGlvbiksXG4gICAgfTtcbiAgICBkLnBhdGggPSB0aGlzLml0ZW0ucGF0aDtcbiAgICBtLmFwcGVuZENoaWxkKGQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobSk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbS5vcGVuKCk7XG4gICAgICAgIHRoaXMuY2xpcHMuY2xpcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkLmNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNsaXBzLmFkZENsaXAoXG4gICAgICAgICAgICAgICAgZC5jbGlwc1tpXT8udGltZXN0YW1wcy5zdGFydCA/PyBudWxsLFxuICAgICAgICAgICAgICAgIGQuY2xpcHNbaV0/LnRpbWVzdGFtcHMuZW5kID8/IG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGlwcy51cGRhdGUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge31cbn07XG4iXSwibmFtZXMiOlsiVFlQRV9WSURFTyIsImNsaXBwZXIiLCJmb3JtYXQiLCJmb3JtYXRfbmFtZSIsIm0iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiYm9keSIsImFsZXJ0IiwiaGVhZGVyIiwiY2xhc3NMaXN0IiwiYWRkIiwiZCIsInNldENsaXBzIiwiY2xpcHMiLCJnZXRUaW1lc3RhbXBzIiwidmlkZW8iLCJzdHJlYW1zIiwiZmlsdGVyIiwicyIsImNvZGVjX3R5cGUiLCJkdXJhdGlvbiIsInBhcnNlRmxvYXQiLCJwYXRoIiwiaXRlbSIsIm9wZW4iLCJpIiwibGVuZ3RoIiwiYWRkQ2xpcCIsInRpbWVzdGFtcHMiLCJzdGFydCIsImVuZCIsInVwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Tools/clipper.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Tools/concat.js":
/*!**************************************************************!*\
  !*** ./resources/js/components/Configurator/Tools/concat.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"requestConcat\": () => (/* binding */ requestConcat)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\nvar requestConcat = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(container) {\n    var m, d, _this$item, _this$item$parent, _this$item$parent$vid;\n\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            m = document.createElement(\"modal-dialogue\");\n            d = m.appendChild(document.createElement(\"dialogue-concat\"));\n            _context.prev = 2;\n            m.header = \"Concat\";\n            d.streams = this.streams;\n            d.files = (_this$item = this.item) === null || _this$item === void 0 ? void 0 : (_this$item$parent = _this$item.parent) === null || _this$item$parent === void 0 ? void 0 : (_this$item$parent$vid = _this$item$parent.videoFiles) === null || _this$item$parent$vid === void 0 ? void 0 : _this$item$parent$vid.filter(function (f) {\n              return !f.internal;\n            });\n            document.body.appendChild(m);\n            _context.next = 9;\n            return m.open();\n\n          case 9:\n            console.info(\"Concat video files in %s\", this.item.path, container, d.files, d.streams);\n            _context.next = 12;\n            return _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.post(\"/concat/\".concat(encodeURIComponent(this.item.path)), {\n              container: container,\n              streams: d.streams.map(function (s) {\n                return s.index;\n              }),\n              files: d.files.map(function (f) {\n                return f.name;\n              })\n            });\n\n          case 12:\n            _context.next = 17;\n            break;\n\n          case 14:\n            _context.prev = 14;\n            _context.t0 = _context[\"catch\"](2);\n            console.error(_context.t0);\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[2, 14]]);\n  }));\n\n  return function requestConcat(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvY29uY2F0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVPLElBQU1DLGFBQWE7QUFBQSxvSEFBRyxpQkFBZ0JDLFNBQWhCO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDbkJDLFlBQUFBLENBRG1CLEdBQ2ZDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixnQkFBdkIsQ0FEZTtBQUVuQkMsWUFBQUEsQ0FGbUIsR0FFZkgsQ0FBQyxDQUFDSSxXQUFGLENBQWNILFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixpQkFBdkIsQ0FBZCxDQUZlO0FBQUE7QUFJckJGLFlBQUFBLENBQUMsQ0FBQ0ssTUFBRixHQUFXLFFBQVg7QUFDQUYsWUFBQUEsQ0FBQyxDQUFDRyxPQUFGLEdBQVksS0FBS0EsT0FBakI7QUFDQUgsWUFBQUEsQ0FBQyxDQUFDSSxLQUFGLGlCQUFVLEtBQUtDLElBQWYsb0VBQVUsV0FBV0MsTUFBckIsK0VBQVUsa0JBQW1CQyxVQUE3QiwwREFBVSxzQkFBK0JDLE1BQS9CLENBQXNDLFVBQUNDLENBQUQ7QUFBQSxxQkFBTyxDQUFDQSxDQUFDLENBQUNDLFFBQVY7QUFBQSxhQUF0QyxDQUFWO0FBQ0FaLFlBQUFBLFFBQVEsQ0FBQ2EsSUFBVCxDQUFjVixXQUFkLENBQTBCSixDQUExQjtBQVBxQjtBQUFBLG1CQVFmQSxDQUFDLENBQUNlLElBQUYsRUFSZTs7QUFBQTtBQVNyQkMsWUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQ0ksMEJBREosRUFFSSxLQUFLVCxJQUFMLENBQVVVLElBRmQsRUFHSW5CLFNBSEosRUFJSUksQ0FBQyxDQUFDSSxLQUpOLEVBS0lKLENBQUMsQ0FBQ0csT0FMTjtBQVRxQjtBQUFBLG1CQWdCZlQsNkRBQUEsbUJBQXdCdUIsa0JBQWtCLENBQUMsS0FBS1osSUFBTCxDQUFVVSxJQUFYLENBQTFDLEdBQThEO0FBQ2hFbkIsY0FBQUEsU0FBUyxFQUFUQSxTQURnRTtBQUVoRU8sY0FBQUEsT0FBTyxFQUFFSCxDQUFDLENBQUNHLE9BQUYsQ0FBVWUsR0FBVixDQUFjLFVBQUNDLENBQUQ7QUFBQSx1QkFBT0EsQ0FBQyxDQUFDQyxLQUFUO0FBQUEsZUFBZCxDQUZ1RDtBQUdoRWhCLGNBQUFBLEtBQUssRUFBRUosQ0FBQyxDQUFDSSxLQUFGLENBQVFjLEdBQVIsQ0FBWSxVQUFDVCxDQUFEO0FBQUEsdUJBQU9BLENBQUMsQ0FBQ1ksSUFBVDtBQUFBLGVBQVo7QUFIeUQsYUFBOUQsQ0FoQmU7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQXNCckJSLFlBQUFBLE9BQU8sQ0FBQ1MsS0FBUjs7QUF0QnFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQUg7O0FBQUEsa0JBQWIzQixhQUFhO0FBQUE7QUFBQTtBQUFBLEdBQW5CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL1Rvb2xzL2NvbmNhdC5qcz85ODFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlcXVlc3QgfSBmcm9tIFwiQC9jb21wb25lbnRzL1JlcXVlc3RcIjtcblxuZXhwb3J0IGNvbnN0IHJlcXVlc3RDb25jYXQgPSBhc3luYyBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgY29uc3QgbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtb2RhbC1kaWFsb2d1ZVwiKTtcbiAgICBjb25zdCBkID0gbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGlhbG9ndWUtY29uY2F0XCIpKTtcbiAgICB0cnkge1xuICAgICAgICBtLmhlYWRlciA9IFwiQ29uY2F0XCI7XG4gICAgICAgIGQuc3RyZWFtcyA9IHRoaXMuc3RyZWFtcztcbiAgICAgICAgZC5maWxlcyA9IHRoaXMuaXRlbT8ucGFyZW50Py52aWRlb0ZpbGVzPy5maWx0ZXIoKGYpID0+ICFmLmludGVybmFsKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtKTtcbiAgICAgICAgYXdhaXQgbS5vcGVuKCk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgICAgIFwiQ29uY2F0IHZpZGVvIGZpbGVzIGluICVzXCIsXG4gICAgICAgICAgICB0aGlzLml0ZW0ucGF0aCxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGQuZmlsZXMsXG4gICAgICAgICAgICBkLnN0cmVhbXNcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgUmVxdWVzdC5wb3N0KGAvY29uY2F0LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaXRlbS5wYXRoKX1gLCB7XG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBzdHJlYW1zOiBkLnN0cmVhbXMubWFwKChzKSA9PiBzLmluZGV4KSxcbiAgICAgICAgICAgIGZpbGVzOiBkLmZpbGVzLm1hcCgoZikgPT4gZi5uYW1lKSxcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJSZXF1ZXN0IiwicmVxdWVzdENvbmNhdCIsImNvbnRhaW5lciIsIm0iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJkIiwiYXBwZW5kQ2hpbGQiLCJoZWFkZXIiLCJzdHJlYW1zIiwiZmlsZXMiLCJpdGVtIiwicGFyZW50IiwidmlkZW9GaWxlcyIsImZpbHRlciIsImYiLCJpbnRlcm5hbCIsImJvZHkiLCJvcGVuIiwiY29uc29sZSIsImluZm8iLCJwYXRoIiwicG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsIm1hcCIsInMiLCJpbmRleCIsIm5hbWUiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Tools/concat.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Tools/crop.js":
/*!************************************************************!*\
  !*** ./resources/js/components/Configurator/Tools/crop.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"requestCrop\": () => (/* binding */ requestCrop)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\n/* harmony import */ var _Streams__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Streams */ \"./resources/js/components/Configurator/Streams/index.js\");\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\nvar requestCrop = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(type) {\n    var _this$streams$filter, m, d, filterData;\n\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            m = document.createElement(\"modal-window\");\n            m.header = \"Cropper\";\n            m.classList.add(\"no-shadow\");\n            d = document.createElement(\"dialogue-cropper\");\n            d.video = _objectSpread(_objectSpread({}, (_this$streams$filter = this.streams.filter(function (s) {\n              return s.codec_type === _Streams__WEBPACK_IMPORTED_MODULE_2__.TYPE_VIDEO;\n            })) === null || _this$streams$filter === void 0 ? void 0 : _this$streams$filter[0]), {}, {\n              duration: parseFloat(this.format.duration)\n            });\n            d.crop = this.crop;\n            d.path = this.item.path;\n            d.type = type;\n            m.appendChild(d);\n            document.body.appendChild(m);\n            _context.next = 13;\n            return m.open();\n\n          case 13:\n            console.info(\"Crop video file %s to %dx%d at %d/%d and scale to %d pixel height with an aspect-ratio of %s\", this.item.path, d.crop.cw, d.crop.ch, d.crop.cx, d.crop.cy, d.crop.height, d.crop.aspect);\n            this.crop = d.crop;\n\n            if (!d.startCrop) {\n              _context.next = 20;\n              break;\n            }\n\n            _context.next = 18;\n            return _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.post(\"/crop/\".concat(encodeURIComponent(this.item.path)), d.crop);\n\n          case 18:\n            _context.next = 23;\n            break;\n\n          case 20:\n            filterData = _objectSpread(_objectSpread({}, d.crop), {\n              filterType: 'crop'\n            });\n            this.filterGraph.push(filterData);\n            this.saveSettings();\n\n          case 23:\n            _context.next = 27;\n            break;\n\n          case 25:\n            _context.prev = 25;\n            _context.t0 = _context[\"catch\"](0);\n\n          case 27:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[0, 25]]);\n  }));\n\n  return function requestCrop(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvY3JvcC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFTyxJQUFNRSxXQUFXO0FBQUEsb0hBQUcsaUJBQWdCQyxJQUFoQjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFYkMsWUFBQUEsQ0FGYSxHQUVUQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsY0FBdkIsQ0FGUztBQUduQkYsWUFBQUEsQ0FBQyxDQUFDRyxNQUFGLEdBQVcsU0FBWDtBQUNBSCxZQUFBQSxDQUFDLENBQUNJLFNBQUYsQ0FBWUMsR0FBWixDQUFnQixXQUFoQjtBQUNNQyxZQUFBQSxDQUxhLEdBS1RMLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixrQkFBdkIsQ0FMUztBQU1uQkksWUFBQUEsQ0FBQyxDQUFDQyxLQUFGLDJEQUNPLEtBQUtDLE9BQUwsQ0FBYUMsTUFBYixDQUFvQixVQUFDQyxDQUFEO0FBQUEscUJBQU9BLENBQUMsQ0FBQ0MsVUFBRixLQUFpQmQsZ0RBQXhCO0FBQUEsYUFBcEIsQ0FEUCx5REFDTyxxQkFBMEQsQ0FBMUQsQ0FEUDtBQUVJZSxjQUFBQSxRQUFRLEVBQUVDLFVBQVUsQ0FBQyxLQUFLQyxNQUFMLENBQVlGLFFBQWI7QUFGeEI7QUFJQU4sWUFBQUEsQ0FBQyxDQUFDUyxJQUFGLEdBQVMsS0FBS0EsSUFBZDtBQUNBVCxZQUFBQSxDQUFDLENBQUNVLElBQUYsR0FBUyxLQUFLQyxJQUFMLENBQVVELElBQW5CO0FBQ0FWLFlBQUFBLENBQUMsQ0FBQ1AsSUFBRixHQUFTQSxJQUFUO0FBQ0FDLFlBQUFBLENBQUMsQ0FBQ2tCLFdBQUYsQ0FBY1osQ0FBZDtBQUNBTCxZQUFBQSxRQUFRLENBQUNrQixJQUFULENBQWNELFdBQWQsQ0FBMEJsQixDQUExQjtBQWRtQjtBQUFBLG1CQWViQSxDQUFDLENBQUNvQixJQUFGLEVBZmE7O0FBQUE7QUFnQm5CQyxZQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FDSSw4RkFESixFQUVJLEtBQUtMLElBQUwsQ0FBVUQsSUFGZCxFQUdJVixDQUFDLENBQUNTLElBQUYsQ0FBT1EsRUFIWCxFQUlJakIsQ0FBQyxDQUFDUyxJQUFGLENBQU9TLEVBSlgsRUFLSWxCLENBQUMsQ0FBQ1MsSUFBRixDQUFPVSxFQUxYLEVBTUluQixDQUFDLENBQUNTLElBQUYsQ0FBT1csRUFOWCxFQU9JcEIsQ0FBQyxDQUFDUyxJQUFGLENBQU9ZLE1BUFgsRUFRSXJCLENBQUMsQ0FBQ1MsSUFBRixDQUFPYSxNQVJYO0FBVUEsaUJBQUtiLElBQUwsR0FBWVQsQ0FBQyxDQUFDUyxJQUFkOztBQTFCbUIsaUJBMkJmVCxDQUFDLENBQUN1QixTQTNCYTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQTRCVGpDLDZEQUFBLGlCQUNPbUMsa0JBQWtCLENBQUMsS0FBS2QsSUFBTCxDQUFVRCxJQUFYLENBRHpCLEdBRUZWLENBQUMsQ0FBQ1MsSUFGQSxDQTVCUzs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFpQ1RpQixZQUFBQSxVQWpDUyxtQ0FpQ1ExQixDQUFDLENBQUNTLElBakNWLEdBaUNtQjtBQUFDa0IsY0FBQUEsVUFBVSxFQUFFO0FBQWIsYUFqQ25CO0FBa0NmLGlCQUFLQyxXQUFMLENBQWlCQyxJQUFqQixDQUFzQkgsVUFBdEI7QUFDQSxpQkFBS0ksWUFBTDs7QUFuQ2U7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFIOztBQUFBLGtCQUFYdEMsV0FBVztBQUFBO0FBQUE7QUFBQSxHQUFqQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NvbmZpZ3VyYXRvci9Ub29scy9jcm9wLmpzPzc1MDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvUmVxdWVzdFwiO1xuaW1wb3J0IHsgVFlQRV9WSURFTyB9IGZyb20gXCIuLi9TdHJlYW1zXCI7XG5cbmV4cG9ydCBjb25zdCByZXF1ZXN0Q3JvcCA9IGFzeW5jIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtb2RhbC13aW5kb3dcIik7XG4gICAgICAgIG0uaGVhZGVyID0gXCJDcm9wcGVyXCI7XG4gICAgICAgIG0uY2xhc3NMaXN0LmFkZChcIm5vLXNoYWRvd1wiKTtcbiAgICAgICAgY29uc3QgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaWFsb2d1ZS1jcm9wcGVyXCIpO1xuICAgICAgICBkLnZpZGVvID0ge1xuICAgICAgICAgICAgLi4udGhpcy5zdHJlYW1zLmZpbHRlcigocykgPT4gcy5jb2RlY190eXBlID09PSBUWVBFX1ZJREVPKT8uWzBdLFxuICAgICAgICAgICAgZHVyYXRpb246IHBhcnNlRmxvYXQodGhpcy5mb3JtYXQuZHVyYXRpb24pLFxuICAgICAgICB9O1xuICAgICAgICBkLmNyb3AgPSB0aGlzLmNyb3A7XG4gICAgICAgIGQucGF0aCA9IHRoaXMuaXRlbS5wYXRoO1xuICAgICAgICBkLnR5cGUgPSB0eXBlO1xuICAgICAgICBtLmFwcGVuZENoaWxkKGQpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG0pO1xuICAgICAgICBhd2FpdCBtLm9wZW4oKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICAgICAgXCJDcm9wIHZpZGVvIGZpbGUgJXMgdG8gJWR4JWQgYXQgJWQvJWQgYW5kIHNjYWxlIHRvICVkIHBpeGVsIGhlaWdodCB3aXRoIGFuIGFzcGVjdC1yYXRpbyBvZiAlc1wiLFxuICAgICAgICAgICAgdGhpcy5pdGVtLnBhdGgsXG4gICAgICAgICAgICBkLmNyb3AuY3csXG4gICAgICAgICAgICBkLmNyb3AuY2gsXG4gICAgICAgICAgICBkLmNyb3AuY3gsXG4gICAgICAgICAgICBkLmNyb3AuY3ksXG4gICAgICAgICAgICBkLmNyb3AuaGVpZ2h0LFxuICAgICAgICAgICAgZC5jcm9wLmFzcGVjdFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNyb3AgPSBkLmNyb3A7XG4gICAgICAgIGlmIChkLnN0YXJ0Q3JvcCkge1xuICAgICAgICAgICAgYXdhaXQgUmVxdWVzdC5wb3N0KFxuICAgICAgICAgICAgICAgIGAvY3JvcC8ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLml0ZW0ucGF0aCl9YCxcbiAgICAgICAgICAgICAgICBkLmNyb3BcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJEYXRhID0gey4uLmQuY3JvcCwgLi4ue2ZpbHRlclR5cGU6ICdjcm9wJ319O1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJHcmFwaC5wdXNoKGZpbHRlckRhdGEpO1xuICAgICAgICAgICAgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxufTtcbiJdLCJuYW1lcyI6WyJSZXF1ZXN0IiwiVFlQRV9WSURFTyIsInJlcXVlc3RDcm9wIiwidHlwZSIsIm0iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJoZWFkZXIiLCJjbGFzc0xpc3QiLCJhZGQiLCJkIiwidmlkZW8iLCJzdHJlYW1zIiwiZmlsdGVyIiwicyIsImNvZGVjX3R5cGUiLCJkdXJhdGlvbiIsInBhcnNlRmxvYXQiLCJmb3JtYXQiLCJjcm9wIiwicGF0aCIsIml0ZW0iLCJhcHBlbmRDaGlsZCIsImJvZHkiLCJvcGVuIiwiY29uc29sZSIsImluZm8iLCJjdyIsImNoIiwiY3giLCJjeSIsImhlaWdodCIsImFzcGVjdCIsInN0YXJ0Q3JvcCIsInBvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJmaWx0ZXJEYXRhIiwiZmlsdGVyVHlwZSIsImZpbHRlckdyYXBoIiwicHVzaCIsInNhdmVTZXR0aW5ncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Tools/crop.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Tools/delogo.js":
/*!**************************************************************!*\
  !*** ./resources/js/components/Configurator/Tools/delogo.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"requestDelogo\": () => (/* binding */ requestDelogo)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\n/* harmony import */ var _Streams__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Streams */ \"./resources/js/components/Configurator/Streams/index.js\");\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\nvar requestDelogo = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(type) {\n    var _this$streams$filter, m, d, filterData, idx, _m;\n\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            m = document.createElement(\"modal-window\");\n            m.header = \"Delogo\";\n            m.classList.add(\"no-shadow\");\n            d = document.createElement(\"dialogue-delogo\");\n            d.video = _objectSpread(_objectSpread({}, (_this$streams$filter = this.streams.filter(function (s) {\n              return s.codec_type === _Streams__WEBPACK_IMPORTED_MODULE_2__.TYPE_VIDEO;\n            })) === null || _this$streams$filter === void 0 ? void 0 : _this$streams$filter[0]), {}, {\n              duration: parseFloat(this.format.duration)\n            });\n            d.path = this.item.path;\n            d.type = type;\n            m.appendChild(d);\n            document.body.appendChild(m);\n            _context.next = 12;\n            return m.open();\n\n          case 12:\n            this.delogo = _objectSpread(_objectSpread({}, d.coords), [type]);\n            console.info(\"Delogo video file %s. x: %d, x: %d, w: %d, h: %d, type: %s\", this.item.path, this.delogo.x, this.delogo.y, this.delogo.w, this.delogo.h, type);\n\n            if (!this.startDelogo) {\n              _context.next = 19;\n              break;\n            }\n\n            _context.next = 17;\n            return _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.post(\"/delogo/\".concat(encodeURIComponent(this.item.path)), this.delogo);\n\n          case 17:\n            _context.next = 41;\n            break;\n\n          case 19:\n            filterData = _objectSpread(_objectSpread({}, this.delogo), {\n              filterType: 'delogo'\n            });\n            idx = this.filterGraph.findIndex(function (f) {\n              return f.filterType === 'delogo';\n            });\n\n            if (!(idx > -1)) {\n              _context.next = 39;\n              break;\n            }\n\n            _m = document.createElement(\"modal-confirm\");\n            _m.header = \"Replace existing filter?\";\n            _m.content = \"Delogo filter can only be applied once.\";\n            document.body.appendChild(_m);\n            _context.prev = 26;\n            _context.next = 29;\n            return _m.confirm();\n\n          case 29:\n            this.filterGraph[idx] = filterData;\n            console.log(\"Replace delogo filter confirmed\");\n            _context.next = 37;\n            break;\n\n          case 33:\n            _context.prev = 33;\n            _context.t0 = _context[\"catch\"](26);\n            console.log(\"Replace delogo filter canceled\");\n            return _context.abrupt(\"return\");\n\n          case 37:\n            _context.next = 40;\n            break;\n\n          case 39:\n            this.filterGraph.push(filterData);\n\n          case 40:\n            this.saveSettings();\n\n          case 41:\n            _context.next = 45;\n            break;\n\n          case 43:\n            _context.prev = 43;\n            _context.t1 = _context[\"catch\"](0);\n\n          case 45:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[0, 43], [26, 33]]);\n  }));\n\n  return function requestDelogo(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvZGVsb2dvLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUVPLElBQU1FLGFBQWE7QUFBQSxvSEFBRyxpQkFBZ0JDLElBQWhCO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVmQyxZQUFBQSxDQUZlLEdBRVhDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixjQUF2QixDQUZXO0FBR3JCRixZQUFBQSxDQUFDLENBQUNHLE1BQUYsR0FBVyxRQUFYO0FBQ0FILFlBQUFBLENBQUMsQ0FBQ0ksU0FBRixDQUFZQyxHQUFaLENBQWdCLFdBQWhCO0FBQ01DLFlBQUFBLENBTGUsR0FLWEwsUUFBUSxDQUFDQyxhQUFULENBQXVCLGlCQUF2QixDQUxXO0FBTXJCSSxZQUFBQSxDQUFDLENBQUNDLEtBQUYsMkRBQ08sS0FBS0MsT0FBTCxDQUFhQyxNQUFiLENBQW9CLFVBQUNDLENBQUQ7QUFBQSxxQkFBT0EsQ0FBQyxDQUFDQyxVQUFGLEtBQWlCZCxnREFBeEI7QUFBQSxhQUFwQixDQURQLHlEQUNPLHFCQUEwRCxDQUExRCxDQURQO0FBRUllLGNBQUFBLFFBQVEsRUFBRUMsVUFBVSxDQUFDLEtBQUtDLE1BQUwsQ0FBWUYsUUFBYjtBQUZ4QjtBQUlBTixZQUFBQSxDQUFDLENBQUNTLElBQUYsR0FBUyxLQUFLQyxJQUFMLENBQVVELElBQW5CO0FBQ0FULFlBQUFBLENBQUMsQ0FBQ1AsSUFBRixHQUFTQSxJQUFUO0FBQ0FDLFlBQUFBLENBQUMsQ0FBQ2lCLFdBQUYsQ0FBY1gsQ0FBZDtBQUNBTCxZQUFBQSxRQUFRLENBQUNpQixJQUFULENBQWNELFdBQWQsQ0FBMEJqQixDQUExQjtBQWJxQjtBQUFBLG1CQWNmQSxDQUFDLENBQUNtQixJQUFGLEVBZGU7O0FBQUE7QUFlckIsaUJBQUtDLE1BQUwsbUNBQWtCZCxDQUFDLENBQUNlLE1BQXBCLEdBQStCLENBQUN0QixJQUFELENBQS9CO0FBQ0F1QixZQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FDSSw0REFESixFQUVJLEtBQUtQLElBQUwsQ0FBVUQsSUFGZCxFQUdJLEtBQUtLLE1BQUwsQ0FBWUksQ0FIaEIsRUFJSSxLQUFLSixNQUFMLENBQVlLLENBSmhCLEVBS0ksS0FBS0wsTUFBTCxDQUFZTSxDQUxoQixFQU1JLEtBQUtOLE1BQUwsQ0FBWU8sQ0FOaEIsRUFPSTVCLElBUEo7O0FBaEJxQixpQkF5QmpCLEtBQUs2QixXQXpCWTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQTBCWGhDLDZEQUFBLG1CQUF3QmtDLGtCQUFrQixDQUFDLEtBQUtkLElBQUwsQ0FBVUQsSUFBWCxDQUExQyxHQUE4RCxLQUFLSyxNQUFuRSxDQTFCVzs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUE0QlhXLFlBQUFBLFVBNUJXLG1DQTRCTSxLQUFLWCxNQTVCWCxHQTRCc0I7QUFBQ1ksY0FBQUEsVUFBVSxFQUFFO0FBQWIsYUE1QnRCO0FBNkJYQyxZQUFBQSxHQTdCVyxHQTZCTCxLQUFLQyxXQUFMLENBQWlCQyxTQUFqQixDQUEyQixVQUFBQyxDQUFDO0FBQUEscUJBQUlBLENBQUMsQ0FBQ0osVUFBRixLQUFpQixRQUFyQjtBQUFBLGFBQTVCLENBN0JLOztBQUFBLGtCQThCYkMsR0FBRyxHQUFHLENBQUMsQ0E5Qk07QUFBQTtBQUFBO0FBQUE7O0FBK0JQakMsWUFBQUEsRUEvQk8sR0ErQkhDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixlQUF2QixDQS9CRztBQWdDYkYsWUFBQUEsRUFBQyxDQUFDRyxNQUFGLEdBQVcsMEJBQVg7QUFDQUgsWUFBQUEsRUFBQyxDQUFDcUMsT0FBRixHQUFZLHlDQUFaO0FBQ0FwQyxZQUFBQSxRQUFRLENBQUNpQixJQUFULENBQWNELFdBQWQsQ0FBMEJqQixFQUExQjtBQWxDYTtBQUFBO0FBQUEsbUJBb0NIQSxFQUFDLENBQUNzQyxPQUFGLEVBcENHOztBQUFBO0FBcUNULGlCQUFLSixXQUFMLENBQWlCRCxHQUFqQixJQUF3QkYsVUFBeEI7QUFDQVQsWUFBQUEsT0FBTyxDQUFDaUIsR0FBUixDQUFZLGlDQUFaO0FBdENTO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBd0NUakIsWUFBQUEsT0FBTyxDQUFDaUIsR0FBUixDQUFZLGdDQUFaO0FBeENTOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQTRDYixpQkFBS0wsV0FBTCxDQUFpQk0sSUFBakIsQ0FBc0JULFVBQXRCOztBQTVDYTtBQThDakIsaUJBQUtVLFlBQUw7O0FBOUNpQjtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQUg7O0FBQUEsa0JBQWIzQyxhQUFhO0FBQUE7QUFBQTtBQUFBLEdBQW5CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL1Rvb2xzL2RlbG9nby5qcz83NzM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlcXVlc3QgfSBmcm9tIFwiQC9jb21wb25lbnRzL1JlcXVlc3RcIjtcbmltcG9ydCB7IFRZUEVfVklERU8gfSBmcm9tIFwiLi4vU3RyZWFtc1wiO1xuXG5leHBvcnQgY29uc3QgcmVxdWVzdERlbG9nbyA9IGFzeW5jIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtb2RhbC13aW5kb3dcIik7XG4gICAgICAgIG0uaGVhZGVyID0gXCJEZWxvZ29cIjtcbiAgICAgICAgbS5jbGFzc0xpc3QuYWRkKFwibm8tc2hhZG93XCIpO1xuICAgICAgICBjb25zdCBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpYWxvZ3VlLWRlbG9nb1wiKTtcbiAgICAgICAgZC52aWRlbyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RyZWFtcy5maWx0ZXIoKHMpID0+IHMuY29kZWNfdHlwZSA9PT0gVFlQRV9WSURFTyk/LlswXSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJzZUZsb2F0KHRoaXMuZm9ybWF0LmR1cmF0aW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgZC5wYXRoID0gdGhpcy5pdGVtLnBhdGg7XG4gICAgICAgIGQudHlwZSA9IHR5cGU7XG4gICAgICAgIG0uYXBwZW5kQ2hpbGQoZCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobSk7XG4gICAgICAgIGF3YWl0IG0ub3BlbigpO1xuICAgICAgICB0aGlzLmRlbG9nbyA9IHsuLi5kLmNvb3JkcywgLi4uW3R5cGVdfTtcbiAgICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICAgICAgXCJEZWxvZ28gdmlkZW8gZmlsZSAlcy4geDogJWQsIHg6ICVkLCB3OiAlZCwgaDogJWQsIHR5cGU6ICVzXCIsXG4gICAgICAgICAgICB0aGlzLml0ZW0ucGF0aCxcbiAgICAgICAgICAgIHRoaXMuZGVsb2dvLngsXG4gICAgICAgICAgICB0aGlzLmRlbG9nby55LFxuICAgICAgICAgICAgdGhpcy5kZWxvZ28udyxcbiAgICAgICAgICAgIHRoaXMuZGVsb2dvLmgsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RGVsb2dvKSB7XG4gICAgICAgICAgICBhd2FpdCBSZXF1ZXN0LnBvc3QoYC9kZWxvZ28vJHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5pdGVtLnBhdGgpfWAsIHRoaXMuZGVsb2dvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckRhdGEgPSB7Li4udGhpcy5kZWxvZ28sIC4uLntmaWx0ZXJUeXBlOiAnZGVsb2dvJ319XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZpbHRlckdyYXBoLmZpbmRJbmRleChmID0+IGYuZmlsdGVyVHlwZSA9PT0gJ2RlbG9nbycpO1xuICAgICAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtb2RhbC1jb25maXJtXCIpO1xuICAgICAgICAgICAgICAgIG0uaGVhZGVyID0gXCJSZXBsYWNlIGV4aXN0aW5nIGZpbHRlcj9cIjtcbiAgICAgICAgICAgICAgICBtLmNvbnRlbnQgPSBcIkRlbG9nbyBmaWx0ZXIgY2FuIG9ubHkgYmUgYXBwbGllZCBvbmNlLlwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbS5jb25maXJtKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyR3JhcGhbaWR4XSA9IGZpbHRlckRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVwbGFjZSBkZWxvZ28gZmlsdGVyIGNvbmZpcm1lZFwiKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlcGxhY2UgZGVsb2dvIGZpbHRlciBjYW5jZWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJHcmFwaC5wdXNoKGZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxufTtcbiJdLCJuYW1lcyI6WyJSZXF1ZXN0IiwiVFlQRV9WSURFTyIsInJlcXVlc3REZWxvZ28iLCJ0eXBlIiwibSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhlYWRlciIsImNsYXNzTGlzdCIsImFkZCIsImQiLCJ2aWRlbyIsInN0cmVhbXMiLCJmaWx0ZXIiLCJzIiwiY29kZWNfdHlwZSIsImR1cmF0aW9uIiwicGFyc2VGbG9hdCIsImZvcm1hdCIsInBhdGgiLCJpdGVtIiwiYXBwZW5kQ2hpbGQiLCJib2R5Iiwib3BlbiIsImRlbG9nbyIsImNvb3JkcyIsImNvbnNvbGUiLCJpbmZvIiwieCIsInkiLCJ3IiwiaCIsInN0YXJ0RGVsb2dvIiwicG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsImZpbHRlckRhdGEiLCJmaWx0ZXJUeXBlIiwiaWR4IiwiZmlsdGVyR3JhcGgiLCJmaW5kSW5kZXgiLCJmIiwiY29udGVudCIsImNvbmZpcm0iLCJsb2ciLCJwdXNoIiwic2F2ZVNldHRpbmdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Tools/delogo.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Tools/index.js":
/*!*************************************************************!*\
  !*** ./resources/js/components/Configurator/Tools/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toolProxy\": () => (/* binding */ toolProxy)\n/* harmony export */ });\n/* harmony import */ var _scale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scale.js */ \"./resources/js/components/Configurator/Tools/scale.js\");\n/* harmony import */ var _concat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./concat.js */ \"./resources/js/components/Configurator/Tools/concat.js\");\n/* harmony import */ var _crop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./crop.js */ \"./resources/js/components/Configurator/Tools/crop.js\");\n/* harmony import */ var _remux_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./remux.js */ \"./resources/js/components/Configurator/Tools/remux.js\");\n/* harmony import */ var _clipper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./clipper.js */ \"./resources/js/components/Configurator/Tools/clipper.js\");\n/* harmony import */ var _delogo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./delogo.js */ \"./resources/js/components/Configurator/Tools/delogo.js\");\n/* harmony import */ var _removelogo_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./removelogo.js */ \"./resources/js/components/Configurator/Tools/removelogo.js\");\n/* harmony import */ var _player_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./player.js */ \"./resources/js/components/Configurator/Tools/player.js\");\n\n\n\n\n\n\n\n\nvar toolProxy = function toolProxy(e) {\n  var args = e.target.value.split(\":\");\n\n  switch (args.shift()) {\n    case \"concat\":\n      _concat_js__WEBPACK_IMPORTED_MODULE_1__.requestConcat.apply(this, args);\n      break;\n\n    case \"scale\":\n      _scale_js__WEBPACK_IMPORTED_MODULE_0__.requestScale.apply(this, args);\n      break;\n\n    case \"remux\":\n      _remux_js__WEBPACK_IMPORTED_MODULE_3__.requestRemux.apply(this, args);\n      break;\n\n    case \"crop\":\n      _crop_js__WEBPACK_IMPORTED_MODULE_2__.requestCrop.apply(this, args);\n      break;\n\n    case \"clip\":\n      _clipper_js__WEBPACK_IMPORTED_MODULE_4__.clipper.apply(this, args);\n      break;\n\n    case \"delogo\":\n      _delogo_js__WEBPACK_IMPORTED_MODULE_5__.requestDelogo.apply(this, args);\n      break;\n\n    case \"removelogo\":\n      _removelogo_js__WEBPACK_IMPORTED_MODULE_6__.requestRemovelogo.apply(this, args);\n      break;\n\n    case \"play\":\n      _player_js__WEBPACK_IMPORTED_MODULE_7__.requestPlay.apply(this, args);\n      break;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVPLElBQU1RLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVVDLENBQVYsRUFBYTtBQUNsQyxNQUFNQyxJQUFJLEdBQUdELENBQUMsQ0FBQ0UsTUFBRixDQUFTQyxLQUFULENBQWVDLEtBQWYsQ0FBcUIsR0FBckIsQ0FBYjs7QUFDQSxVQUFRSCxJQUFJLENBQUNJLEtBQUwsRUFBUjtBQUNJLFNBQUssUUFBTDtBQUNJYixNQUFBQSwyREFBQSxDQUFvQixJQUFwQixFQUEwQlMsSUFBMUI7QUFDQTs7QUFDSixTQUFLLE9BQUw7QUFDSVYsTUFBQUEseURBQUEsQ0FBbUIsSUFBbkIsRUFBeUJVLElBQXpCO0FBQ0E7O0FBQ0osU0FBSyxPQUFMO0FBQ0lQLE1BQUFBLHlEQUFBLENBQW1CLElBQW5CLEVBQXlCTyxJQUF6QjtBQUNBOztBQUNKLFNBQUssTUFBTDtBQUNJUixNQUFBQSx1REFBQSxDQUFrQixJQUFsQixFQUF3QlEsSUFBeEI7QUFDQTs7QUFDSixTQUFLLE1BQUw7QUFDSU4sTUFBQUEsc0RBQUEsQ0FBYyxJQUFkLEVBQW9CTSxJQUFwQjtBQUNBOztBQUNKLFNBQUssUUFBTDtBQUNJTCxNQUFBQSwyREFBQSxDQUFvQixJQUFwQixFQUEwQkssSUFBMUI7QUFDQTs7QUFDSixTQUFLLFlBQUw7QUFDSUosTUFBQUEsbUVBQUEsQ0FBd0IsSUFBeEIsRUFBOEJJLElBQTlCO0FBQ0E7O0FBQ0osU0FBSyxNQUFMO0FBQ0lILE1BQUFBLHlEQUFBLENBQWtCLElBQWxCLEVBQXdCRyxJQUF4QjtBQUNBO0FBeEJSO0FBMEJILENBNUJNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL1Rvb2xzL2luZGV4LmpzPzc2MzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVxdWVzdFNjYWxlIH0gZnJvbSBcIi4vc2NhbGUuanNcIjtcbmltcG9ydCB7IHJlcXVlc3RDb25jYXQgfSBmcm9tIFwiLi9jb25jYXQuanNcIjtcbmltcG9ydCB7IHJlcXVlc3RDcm9wIH0gZnJvbSBcIi4vY3JvcC5qc1wiO1xuaW1wb3J0IHsgcmVxdWVzdFJlbXV4IH0gZnJvbSBcIi4vcmVtdXguanNcIjtcbmltcG9ydCB7IGNsaXBwZXIgfSBmcm9tIFwiLi9jbGlwcGVyLmpzXCI7XG5pbXBvcnQgeyByZXF1ZXN0RGVsb2dvIH0gZnJvbSBcIi4vZGVsb2dvLmpzXCI7XG5pbXBvcnQgeyByZXF1ZXN0UmVtb3ZlbG9nbyB9IGZyb20gXCIuL3JlbW92ZWxvZ28uanNcIjtcbmltcG9ydCB7IHJlcXVlc3RQbGF5IH0gZnJvbSBcIi4vcGxheWVyLmpzXCI7XG5cbmV4cG9ydCBjb25zdCB0b29sUHJveHkgPSBmdW5jdGlvbiAoZSkge1xuICAgIGNvbnN0IGFyZ3MgPSBlLnRhcmdldC52YWx1ZS5zcGxpdChcIjpcIik7XG4gICAgc3dpdGNoIChhcmdzLnNoaWZ0KCkpIHtcbiAgICAgICAgY2FzZSBcImNvbmNhdFwiOlxuICAgICAgICAgICAgcmVxdWVzdENvbmNhdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2NhbGVcIjpcbiAgICAgICAgICAgIHJlcXVlc3RTY2FsZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVtdXhcIjpcbiAgICAgICAgICAgIHJlcXVlc3RSZW11eC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3JvcFwiOlxuICAgICAgICAgICAgcmVxdWVzdENyb3AuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNsaXBcIjpcbiAgICAgICAgICAgIGNsaXBwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlbG9nb1wiOlxuICAgICAgICAgICAgcmVxdWVzdERlbG9nby5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVtb3ZlbG9nb1wiOlxuICAgICAgICAgICAgcmVxdWVzdFJlbW92ZWxvZ28uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBsYXlcIjpcbiAgICAgICAgICAgIHJlcXVlc3RQbGF5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJyZXF1ZXN0U2NhbGUiLCJyZXF1ZXN0Q29uY2F0IiwicmVxdWVzdENyb3AiLCJyZXF1ZXN0UmVtdXgiLCJjbGlwcGVyIiwicmVxdWVzdERlbG9nbyIsInJlcXVlc3RSZW1vdmVsb2dvIiwicmVxdWVzdFBsYXkiLCJ0b29sUHJveHkiLCJlIiwiYXJncyIsInRhcmdldCIsInZhbHVlIiwic3BsaXQiLCJzaGlmdCIsImFwcGx5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Tools/index.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Tools/player.js":
/*!**************************************************************!*\
  !*** ./resources/js/components/Configurator/Tools/player.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"requestPlay\": () => (/* binding */ requestPlay)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Dialogues_Player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Dialogues/Player */ \"./resources/js/components/Configurator/Dialogues/Player/index.js\");\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\nvar requestPlay = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n    var m, d;\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            m = document.createElement(\"modal-window\");\n            d = m.appendChild(document.createElement(\"dialogue-player\"));\n            _context.prev = 2;\n            d.path = this.item.path;\n            d.config = this.config;\n            m.dataset.closeButton = \"true\";\n            m.dataset.noFooter = \"true\";\n            m.header = \"Player\";\n            document.body.appendChild(m);\n            _context.next = 11;\n            return m.open();\n\n          case 11:\n            _context.next = 16;\n            break;\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](2);\n            console.error(_context.t0);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[2, 13]]);\n  }));\n\n  return function requestPlay() {\n    return _ref.apply(this, arguments);\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvcGxheWVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVPLElBQU1BLFdBQVc7QUFBQSxvSEFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDakJDLFlBQUFBLENBRGlCLEdBQ2JDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixjQUF2QixDQURhO0FBRWpCQyxZQUFBQSxDQUZpQixHQUViSCxDQUFDLENBQUNJLFdBQUYsQ0FBY0gsUUFBUSxDQUFDQyxhQUFULENBQXVCLGlCQUF2QixDQUFkLENBRmE7QUFBQTtBQUluQkMsWUFBQUEsQ0FBQyxDQUFDRSxJQUFGLEdBQVMsS0FBS0MsSUFBTCxDQUFVRCxJQUFuQjtBQUNBRixZQUFBQSxDQUFDLENBQUNJLE1BQUYsR0FBVyxLQUFLQSxNQUFoQjtBQUNBUCxZQUFBQSxDQUFDLENBQUNRLE9BQUYsQ0FBVUMsV0FBVixHQUF3QixNQUF4QjtBQUNBVCxZQUFBQSxDQUFDLENBQUNRLE9BQUYsQ0FBVUUsUUFBVixHQUFxQixNQUFyQjtBQUNBVixZQUFBQSxDQUFDLENBQUNXLE1BQUYsR0FBVyxRQUFYO0FBQ0FWLFlBQUFBLFFBQVEsQ0FBQ1csSUFBVCxDQUFjUixXQUFkLENBQTBCSixDQUExQjtBQVRtQjtBQUFBLG1CQVViQSxDQUFDLENBQUNhLElBQUYsRUFWYTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBWW5CQyxZQUFBQSxPQUFPLENBQUNDLEtBQVI7O0FBWm1CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQUg7O0FBQUEsa0JBQVhoQixXQUFXO0FBQUE7QUFBQTtBQUFBLEdBQWpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL1Rvb2xzL3BsYXllci5qcz85OTJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4uL0RpYWxvZ3Vlcy9QbGF5ZXJcIjtcblxuZXhwb3J0IGNvbnN0IHJlcXVlc3RQbGF5ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibW9kYWwtd2luZG93XCIpO1xuICAgIGNvbnN0IGQgPSBtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaWFsb2d1ZS1wbGF5ZXJcIikpO1xuICAgIHRyeSB7XG4gICAgICAgIGQucGF0aCA9IHRoaXMuaXRlbS5wYXRoO1xuICAgICAgICBkLmNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBtLmRhdGFzZXQuY2xvc2VCdXR0b24gPSBcInRydWVcIjtcbiAgICAgICAgbS5kYXRhc2V0Lm5vRm9vdGVyID0gXCJ0cnVlXCI7XG4gICAgICAgIG0uaGVhZGVyID0gXCJQbGF5ZXJcIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtKTtcbiAgICAgICAgYXdhaXQgbS5vcGVuKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJyZXF1ZXN0UGxheSIsIm0iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJkIiwiYXBwZW5kQ2hpbGQiLCJwYXRoIiwiaXRlbSIsImNvbmZpZyIsImRhdGFzZXQiLCJjbG9zZUJ1dHRvbiIsIm5vRm9vdGVyIiwiaGVhZGVyIiwiYm9keSIsIm9wZW4iLCJjb25zb2xlIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Tools/player.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Tools/removelogo.js":
/*!******************************************************************!*\
  !*** ./resources/js/components/Configurator/Tools/removelogo.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"requestRemovelogo\": () => (/* binding */ requestRemovelogo)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\n/* harmony import */ var _Streams__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Streams */ \"./resources/js/components/Configurator/Streams/index.js\");\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\nvar requestRemovelogo = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(type) {\n    var _this$streams$filter, m, d, filterData, idx, _m;\n\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            m = document.createElement(\"modal-window\");\n            m.header = \"Removelogo\";\n            m.classList.add(\"no-shadow\");\n            d = document.createElement(\"dialogue-removelogo\");\n            d.video = _objectSpread(_objectSpread({}, (_this$streams$filter = this.streams.filter(function (s) {\n              return s.codec_type === _Streams__WEBPACK_IMPORTED_MODULE_2__.TYPE_VIDEO;\n            })) === null || _this$streams$filter === void 0 ? void 0 : _this$streams$filter[0]), {}, {\n              duration: parseFloat(this.format.duration)\n            });\n            d.path = this.item.path;\n            d.type = type;\n            m.appendChild(d);\n            document.body.appendChild(m);\n            _context.next = 12;\n            return m.open();\n\n          case 12:\n            console.info(\"Removelogo video file %s. Create logomask at timestamp %s, width: %s, height: %s, type: %s\", this.item.path, d.removeLogo.timestamp, d.removeLogo.w, d.removeLogo.h, d.removeLogo.type);\n            this.removeLogo = d.removeLogo;\n\n            if (!this.startRemoveLogo) {\n              _context.next = 19;\n              break;\n            }\n\n            _context.next = 17;\n            return _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.post(\"/removelogo/\".concat(encodeURIComponent(this.item.path)), d.removeLogo);\n\n          case 17:\n            _context.next = 41;\n            break;\n\n          case 19:\n            filterData = _objectSpread(_objectSpread({}, this.removeLogo), {\n              filterType: 'removeLogo'\n            });\n            idx = this.filterGraph.findIndex(function (f) {\n              return f.filterType === 'removeLogo';\n            });\n\n            if (!(idx > -1)) {\n              _context.next = 39;\n              break;\n            }\n\n            _m = document.createElement(\"modal-confirm\");\n            _m.header = \"Replace existing filter?\";\n            _m.content = \"RemoveLogo filter can only be applied once.\";\n            document.body.appendChild(_m);\n            _context.prev = 26;\n            _context.next = 29;\n            return _m.confirm();\n\n          case 29:\n            this.filterGraph[idx] = filterData;\n            console.log(\"Replace removeLogo filter confirmed\");\n            _context.next = 37;\n            break;\n\n          case 33:\n            _context.prev = 33;\n            _context.t0 = _context[\"catch\"](26);\n            console.log(\"Replace removeLogo filter canceled\");\n            return _context.abrupt(\"return\");\n\n          case 37:\n            _context.next = 40;\n            break;\n\n          case 39:\n            this.filterGraph.push(filterData);\n\n          case 40:\n            this.saveSettings();\n\n          case 41:\n            _context.next = 45;\n            break;\n\n          case 43:\n            _context.prev = 43;\n            _context.t1 = _context[\"catch\"](0);\n\n          case 45:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[0, 43], [26, 33]]);\n  }));\n\n  return function requestRemovelogo(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvcmVtb3ZlbG9nby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFTyxJQUFNRSxpQkFBaUI7QUFBQSxvSEFBRyxpQkFBZ0JDLElBQWhCO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVuQkMsWUFBQUEsQ0FGbUIsR0FFZkMsUUFBUSxDQUFDQyxhQUFULENBQXVCLGNBQXZCLENBRmU7QUFHekJGLFlBQUFBLENBQUMsQ0FBQ0csTUFBRixHQUFXLFlBQVg7QUFDQUgsWUFBQUEsQ0FBQyxDQUFDSSxTQUFGLENBQVlDLEdBQVosQ0FBZ0IsV0FBaEI7QUFDTUMsWUFBQUEsQ0FMbUIsR0FLZkwsUUFBUSxDQUFDQyxhQUFULENBQXVCLHFCQUF2QixDQUxlO0FBTXpCSSxZQUFBQSxDQUFDLENBQUNDLEtBQUYsMkRBQ08sS0FBS0MsT0FBTCxDQUFhQyxNQUFiLENBQW9CLFVBQUNDLENBQUQ7QUFBQSxxQkFBT0EsQ0FBQyxDQUFDQyxVQUFGLEtBQWlCZCxnREFBeEI7QUFBQSxhQUFwQixDQURQLHlEQUNPLHFCQUEwRCxDQUExRCxDQURQO0FBRUllLGNBQUFBLFFBQVEsRUFBRUMsVUFBVSxDQUFDLEtBQUtDLE1BQUwsQ0FBWUYsUUFBYjtBQUZ4QjtBQUlBTixZQUFBQSxDQUFDLENBQUNTLElBQUYsR0FBUyxLQUFLQyxJQUFMLENBQVVELElBQW5CO0FBQ0FULFlBQUFBLENBQUMsQ0FBQ1AsSUFBRixHQUFTQSxJQUFUO0FBQ0FDLFlBQUFBLENBQUMsQ0FBQ2lCLFdBQUYsQ0FBY1gsQ0FBZDtBQUNBTCxZQUFBQSxRQUFRLENBQUNpQixJQUFULENBQWNELFdBQWQsQ0FBMEJqQixDQUExQjtBQWJ5QjtBQUFBLG1CQWNuQkEsQ0FBQyxDQUFDbUIsSUFBRixFQWRtQjs7QUFBQTtBQWV6QkMsWUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsNEZBQWIsRUFDSSxLQUFLTCxJQUFMLENBQVVELElBRGQsRUFFSVQsQ0FBQyxDQUFDZ0IsVUFBRixDQUFhQyxTQUZqQixFQUdJakIsQ0FBQyxDQUFDZ0IsVUFBRixDQUFhRSxDQUhqQixFQUlJbEIsQ0FBQyxDQUFDZ0IsVUFBRixDQUFhRyxDQUpqQixFQUtJbkIsQ0FBQyxDQUFDZ0IsVUFBRixDQUFhdkIsSUFMakI7QUFPQSxpQkFBS3VCLFVBQUwsR0FBa0JoQixDQUFDLENBQUNnQixVQUFwQjs7QUF0QnlCLGlCQXVCckIsS0FBS0ksZUF2QmdCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBd0JmOUIsNkRBQUEsdUJBQ2FnQyxrQkFBa0IsQ0FBQyxLQUFLWixJQUFMLENBQVVELElBQVgsQ0FEL0IsR0FFRlQsQ0FBQyxDQUFDZ0IsVUFGQSxDQXhCZTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUE2QmZPLFlBQUFBLFVBN0JlLG1DQTZCRSxLQUFLUCxVQTdCUCxHQTZCc0I7QUFBQ1EsY0FBQUEsVUFBVSxFQUFFO0FBQWIsYUE3QnRCO0FBOEJmQyxZQUFBQSxHQTlCZSxHQThCVCxLQUFLQyxXQUFMLENBQWlCQyxTQUFqQixDQUEyQixVQUFBQyxDQUFDO0FBQUEscUJBQUlBLENBQUMsQ0FBQ0osVUFBRixLQUFpQixZQUFyQjtBQUFBLGFBQTVCLENBOUJTOztBQUFBLGtCQStCakJDLEdBQUcsR0FBRyxDQUFDLENBL0JVO0FBQUE7QUFBQTtBQUFBOztBQWdDWC9CLFlBQUFBLEVBaENXLEdBZ0NQQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsZUFBdkIsQ0FoQ087QUFpQ2pCRixZQUFBQSxFQUFDLENBQUNHLE1BQUYsR0FBVywwQkFBWDtBQUNBSCxZQUFBQSxFQUFDLENBQUNtQyxPQUFGLEdBQVksNkNBQVo7QUFDQWxDLFlBQUFBLFFBQVEsQ0FBQ2lCLElBQVQsQ0FBY0QsV0FBZCxDQUEwQmpCLEVBQTFCO0FBbkNpQjtBQUFBO0FBQUEsbUJBcUNQQSxFQUFDLENBQUNvQyxPQUFGLEVBckNPOztBQUFBO0FBc0NiLGlCQUFLSixXQUFMLENBQWlCRCxHQUFqQixJQUF3QkYsVUFBeEI7QUFDQVQsWUFBQUEsT0FBTyxDQUFDaUIsR0FBUixDQUFZLHFDQUFaO0FBdkNhO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBeUNiakIsWUFBQUEsT0FBTyxDQUFDaUIsR0FBUixDQUFZLG9DQUFaO0FBekNhOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQTZDakIsaUJBQUtMLFdBQUwsQ0FBaUJNLElBQWpCLENBQXNCVCxVQUF0Qjs7QUE3Q2lCO0FBK0NyQixpQkFBS1UsWUFBTDs7QUEvQ3FCO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBSDs7QUFBQSxrQkFBakJ6QyxpQkFBaUI7QUFBQTtBQUFBO0FBQUEsR0FBdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvcmVtb3ZlbG9nby5qcz84OGE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlcXVlc3QgfSBmcm9tIFwiQC9jb21wb25lbnRzL1JlcXVlc3RcIjtcbmltcG9ydCB7IFRZUEVfVklERU8gfSBmcm9tIFwiLi4vU3RyZWFtc1wiO1xuXG5leHBvcnQgY29uc3QgcmVxdWVzdFJlbW92ZWxvZ28gPSBhc3luYyBmdW5jdGlvbiAodHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibW9kYWwtd2luZG93XCIpO1xuICAgICAgICBtLmhlYWRlciA9IFwiUmVtb3ZlbG9nb1wiO1xuICAgICAgICBtLmNsYXNzTGlzdC5hZGQoXCJuby1zaGFkb3dcIik7XG4gICAgICAgIGNvbnN0IGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGlhbG9ndWUtcmVtb3ZlbG9nb1wiKTtcbiAgICAgICAgZC52aWRlbyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RyZWFtcy5maWx0ZXIoKHMpID0+IHMuY29kZWNfdHlwZSA9PT0gVFlQRV9WSURFTyk/LlswXSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJzZUZsb2F0KHRoaXMuZm9ybWF0LmR1cmF0aW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgZC5wYXRoID0gdGhpcy5pdGVtLnBhdGg7XG4gICAgICAgIGQudHlwZSA9IHR5cGU7XG4gICAgICAgIG0uYXBwZW5kQ2hpbGQoZCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobSk7XG4gICAgICAgIGF3YWl0IG0ub3BlbigpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJSZW1vdmVsb2dvIHZpZGVvIGZpbGUgJXMuIENyZWF0ZSBsb2dvbWFzayBhdCB0aW1lc3RhbXAgJXMsIHdpZHRoOiAlcywgaGVpZ2h0OiAlcywgdHlwZTogJXNcIixcbiAgICAgICAgICAgIHRoaXMuaXRlbS5wYXRoLFxuICAgICAgICAgICAgZC5yZW1vdmVMb2dvLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGQucmVtb3ZlTG9nby53LFxuICAgICAgICAgICAgZC5yZW1vdmVMb2dvLmgsXG4gICAgICAgICAgICBkLnJlbW92ZUxvZ28udHlwZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnJlbW92ZUxvZ28gPSBkLnJlbW92ZUxvZ287XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0UmVtb3ZlTG9nbykge1xuICAgICAgICAgICAgYXdhaXQgUmVxdWVzdC5wb3N0KFxuICAgICAgICAgICAgICAgIGAvcmVtb3ZlbG9nby8ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLml0ZW0ucGF0aCl9YCxcbiAgICAgICAgICAgICAgICBkLnJlbW92ZUxvZ29cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJEYXRhID0gey4uLnRoaXMucmVtb3ZlTG9nbywgLi4ue2ZpbHRlclR5cGU6ICdyZW1vdmVMb2dvJ319O1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5maWx0ZXJHcmFwaC5maW5kSW5kZXgoZiA9PiBmLmZpbHRlclR5cGUgPT09ICdyZW1vdmVMb2dvJyk7XG4gICAgICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1vZGFsLWNvbmZpcm1cIik7XG4gICAgICAgICAgICAgICAgbS5oZWFkZXIgPSBcIlJlcGxhY2UgZXhpc3RpbmcgZmlsdGVyP1wiO1xuICAgICAgICAgICAgICAgIG0uY29udGVudCA9IFwiUmVtb3ZlTG9nbyBmaWx0ZXIgY2FuIG9ubHkgYmUgYXBwbGllZCBvbmNlLlwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbS5jb25maXJtKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyR3JhcGhbaWR4XSA9IGZpbHRlckRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVwbGFjZSByZW1vdmVMb2dvIGZpbHRlciBjb25maXJtZWRcIik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZXBsYWNlIHJlbW92ZUxvZ28gZmlsdGVyIGNhbmNlbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckdyYXBoLnB1c2goZmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHt9XG59O1xuIl0sIm5hbWVzIjpbIlJlcXVlc3QiLCJUWVBFX1ZJREVPIiwicmVxdWVzdFJlbW92ZWxvZ28iLCJ0eXBlIiwibSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhlYWRlciIsImNsYXNzTGlzdCIsImFkZCIsImQiLCJ2aWRlbyIsInN0cmVhbXMiLCJmaWx0ZXIiLCJzIiwiY29kZWNfdHlwZSIsImR1cmF0aW9uIiwicGFyc2VGbG9hdCIsImZvcm1hdCIsInBhdGgiLCJpdGVtIiwiYXBwZW5kQ2hpbGQiLCJib2R5Iiwib3BlbiIsImNvbnNvbGUiLCJpbmZvIiwicmVtb3ZlTG9nbyIsInRpbWVzdGFtcCIsInciLCJoIiwic3RhcnRSZW1vdmVMb2dvIiwicG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsImZpbHRlckRhdGEiLCJmaWx0ZXJUeXBlIiwiaWR4IiwiZmlsdGVyR3JhcGgiLCJmaW5kSW5kZXgiLCJmIiwiY29udGVudCIsImNvbmZpcm0iLCJsb2ciLCJwdXNoIiwic2F2ZVNldHRpbmdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Tools/removelogo.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Tools/remux.js":
/*!*************************************************************!*\
  !*** ./resources/js/components/Configurator/Tools/remux.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"requestRemux\": () => (/* binding */ requestRemux)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\nvar requestRemux = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(container) {\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            console.info(\"Remux video file %s\", this.item.path);\n            _context.prev = 1;\n            _context.next = 4;\n            return _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.post(\"/remux/\".concat(encodeURIComponent(this.item.path)), _objectSpread(_objectSpread({}, this.config), {}, {\n              container: container\n            }));\n\n          case 4:\n            _context.next = 9;\n            break;\n\n          case 6:\n            _context.prev = 6;\n            _context.t0 = _context[\"catch\"](1);\n            console.error(_context.t0);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[1, 6]]);\n  }));\n\n  return function requestRemux(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvcmVtdXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRU8sSUFBTUMsWUFBWTtBQUFBLG9IQUFHLGlCQUFnQkMsU0FBaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUN4QkMsWUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEscUJBQWIsRUFBb0MsS0FBS0MsSUFBTCxDQUFVQyxJQUE5QztBQUR3QjtBQUFBO0FBQUEsbUJBR2ROLDZEQUFBLGtCQUF1QlEsa0JBQWtCLENBQUMsS0FBS0gsSUFBTCxDQUFVQyxJQUFYLENBQXpDLG1DQUNDLEtBQUtHLE1BRE47QUFFRlAsY0FBQUEsU0FBUyxFQUFUQTtBQUZFLGVBSGM7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQVFwQkMsWUFBQUEsT0FBTyxDQUFDTyxLQUFSOztBQVJvQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFIOztBQUFBLGtCQUFaVCxZQUFZO0FBQUE7QUFBQTtBQUFBLEdBQWxCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL1Rvb2xzL3JlbXV4LmpzP2ZhMWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvUmVxdWVzdFwiO1xuXG5leHBvcnQgY29uc3QgcmVxdWVzdFJlbXV4ID0gYXN5bmMgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGNvbnNvbGUuaW5mbyhcIlJlbXV4IHZpZGVvIGZpbGUgJXNcIiwgdGhpcy5pdGVtLnBhdGgpO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IFJlcXVlc3QucG9zdChgL3JlbXV4LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaXRlbS5wYXRoKX1gLCB7XG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJSZXF1ZXN0IiwicmVxdWVzdFJlbXV4IiwiY29udGFpbmVyIiwiY29uc29sZSIsImluZm8iLCJpdGVtIiwicGF0aCIsInBvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJjb25maWciLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Tools/remux.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/Tools/scale.js":
/*!*************************************************************!*\
  !*** ./resources/js/components/Configurator/Tools/scale.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"requestScale\": () => (/* binding */ requestScale)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\n/* harmony import */ var _Streams__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Streams */ \"./resources/js/components/Configurator/Streams/index.js\");\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\nvar requestScale = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(type) {\n    var _this$streams$filter;\n\n    var m, d, video;\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            m = document.createElement(\"modal-dialogue\");\n            m.header = \"Scale\";\n            d = m.appendChild(document.createElement(\"dialogue-scale\"));\n            video = (_this$streams$filter = this.streams.filter(function (s) {\n              return s.codec_type === _Streams__WEBPACK_IMPORTED_MODULE_2__.TYPE_VIDEO;\n            })) === null || _this$streams$filter === void 0 ? void 0 : _this$streams$filter[0];\n\n            if (video) {\n              d.setHeight(video.height);\n              d.setAspectRatio(video.display_aspect_ratio);\n            }\n\n            document.body.appendChild(m);\n            _context.prev = 6;\n            _context.next = 9;\n            return m.open();\n\n          case 9:\n            console.info(\"Scale video file %s to %dx%d with an aspect-ratio of %s\", this.item.path, d.scale.width, d.scale.height, d.scale.aspectRatio, type);\n            _context.next = 12;\n            return _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.post(\"/scale/\".concat(encodeURIComponent(this.item.path)), {\n              width: d.scale.width,\n              height: d.scale.height,\n              aspect: d.scale.aspectRatio,\n              type: type\n            });\n\n          case 12:\n            _context.next = 17;\n            break;\n\n          case 14:\n            _context.prev = 14;\n            _context.t0 = _context[\"catch\"](6);\n            console.error(_context.t0);\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[6, 14]]);\n  }));\n\n  return function requestScale(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvVG9vbHMvc2NhbGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBRU8sSUFBTUUsWUFBWTtBQUFBLG9IQUFHLGlCQUFnQkMsSUFBaEI7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ2xCQyxZQUFBQSxDQURrQixHQUNkQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsZ0JBQXZCLENBRGM7QUFFeEJGLFlBQUFBLENBQUMsQ0FBQ0csTUFBRixHQUFXLE9BQVg7QUFDTUMsWUFBQUEsQ0FIa0IsR0FHZEosQ0FBQyxDQUFDSyxXQUFGLENBQWNKLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixnQkFBdkIsQ0FBZCxDQUhjO0FBSWxCSSxZQUFBQSxLQUprQiwyQkFJVixLQUFLQyxPQUFMLENBQWFDLE1BQWIsQ0FBb0IsVUFBQ0MsQ0FBRDtBQUFBLHFCQUFPQSxDQUFDLENBQUNDLFVBQUYsS0FBaUJiLGdEQUF4QjtBQUFBLGFBQXBCLENBSlUseURBSVYscUJBQTBELENBQTFELENBSlU7O0FBS3hCLGdCQUFJUyxLQUFKLEVBQVc7QUFDUEYsY0FBQUEsQ0FBQyxDQUFDTyxTQUFGLENBQVlMLEtBQUssQ0FBQ00sTUFBbEI7QUFDQVIsY0FBQUEsQ0FBQyxDQUFDUyxjQUFGLENBQWlCUCxLQUFLLENBQUNRLG9CQUF2QjtBQUNIOztBQUNEYixZQUFBQSxRQUFRLENBQUNjLElBQVQsQ0FBY1YsV0FBZCxDQUEwQkwsQ0FBMUI7QUFUd0I7QUFBQTtBQUFBLG1CQVdkQSxDQUFDLENBQUNnQixJQUFGLEVBWGM7O0FBQUE7QUFZcEJDLFlBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUNJLHlEQURKLEVBRUksS0FBS0MsSUFBTCxDQUFVQyxJQUZkLEVBR0loQixDQUFDLENBQUNpQixLQUFGLENBQVFDLEtBSFosRUFJSWxCLENBQUMsQ0FBQ2lCLEtBQUYsQ0FBUVQsTUFKWixFQUtJUixDQUFDLENBQUNpQixLQUFGLENBQVFFLFdBTFosRUFNSXhCLElBTko7QUFab0I7QUFBQSxtQkFvQmRILDZEQUFBLGtCQUF1QjZCLGtCQUFrQixDQUFDLEtBQUtOLElBQUwsQ0FBVUMsSUFBWCxDQUF6QyxHQUE2RDtBQUMvREUsY0FBQUEsS0FBSyxFQUFFbEIsQ0FBQyxDQUFDaUIsS0FBRixDQUFRQyxLQURnRDtBQUUvRFYsY0FBQUEsTUFBTSxFQUFFUixDQUFDLENBQUNpQixLQUFGLENBQVFULE1BRitDO0FBRy9EYyxjQUFBQSxNQUFNLEVBQUV0QixDQUFDLENBQUNpQixLQUFGLENBQVFFLFdBSCtDO0FBSS9EeEIsY0FBQUEsSUFBSSxFQUFFQTtBQUp5RCxhQUE3RCxDQXBCYzs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBMkJwQmtCLFlBQUFBLE9BQU8sQ0FBQ1UsS0FBUjs7QUEzQm9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQUg7O0FBQUEsa0JBQVo3QixZQUFZO0FBQUE7QUFBQTtBQUFBLEdBQWxCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL1Rvb2xzL3NjYWxlLmpzP2Y3NTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvUmVxdWVzdFwiO1xuaW1wb3J0IHsgVFlQRV9WSURFTyB9IGZyb20gXCIuLi9TdHJlYW1zXCI7XG5cbmV4cG9ydCBjb25zdCByZXF1ZXN0U2NhbGUgPSBhc3luYyBmdW5jdGlvbiAodHlwZSkge1xuICAgIGNvbnN0IG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibW9kYWwtZGlhbG9ndWVcIik7XG4gICAgbS5oZWFkZXIgPSBcIlNjYWxlXCI7XG4gICAgY29uc3QgZCA9IG0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpYWxvZ3VlLXNjYWxlXCIpKTtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMuc3RyZWFtcy5maWx0ZXIoKHMpID0+IHMuY29kZWNfdHlwZSA9PT0gVFlQRV9WSURFTyk/LlswXTtcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgZC5zZXRIZWlnaHQodmlkZW8uaGVpZ2h0KTtcbiAgICAgICAgZC5zZXRBc3BlY3RSYXRpbyh2aWRlby5kaXNwbGF5X2FzcGVjdF9yYXRpbyk7XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobSk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbS5vcGVuKCk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgICAgIFwiU2NhbGUgdmlkZW8gZmlsZSAlcyB0byAlZHglZCB3aXRoIGFuIGFzcGVjdC1yYXRpbyBvZiAlc1wiLFxuICAgICAgICAgICAgdGhpcy5pdGVtLnBhdGgsXG4gICAgICAgICAgICBkLnNjYWxlLndpZHRoLFxuICAgICAgICAgICAgZC5zY2FsZS5oZWlnaHQsXG4gICAgICAgICAgICBkLnNjYWxlLmFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICApO1xuICAgICAgICBhd2FpdCBSZXF1ZXN0LnBvc3QoYC9zY2FsZS8ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLml0ZW0ucGF0aCl9YCwge1xuICAgICAgICAgICAgd2lkdGg6IGQuc2NhbGUud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGQuc2NhbGUuaGVpZ2h0LFxuICAgICAgICAgICAgYXNwZWN0OiBkLnNjYWxlLmFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJSZXF1ZXN0IiwiVFlQRV9WSURFTyIsInJlcXVlc3RTY2FsZSIsInR5cGUiLCJtIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaGVhZGVyIiwiZCIsImFwcGVuZENoaWxkIiwidmlkZW8iLCJzdHJlYW1zIiwiZmlsdGVyIiwicyIsImNvZGVjX3R5cGUiLCJzZXRIZWlnaHQiLCJoZWlnaHQiLCJzZXRBc3BlY3RSYXRpbyIsImRpc3BsYXlfYXNwZWN0X3JhdGlvIiwiYm9keSIsIm9wZW4iLCJjb25zb2xlIiwiaW5mbyIsIml0ZW0iLCJwYXRoIiwic2NhbGUiLCJ3aWR0aCIsImFzcGVjdFJhdGlvIiwicG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsImFzcGVjdCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/Tools/scale.js\n");

/***/ }),

/***/ "./resources/js/components/Configurator/index.js":
/*!*******************************************************!*\
  !*** ./resources/js/components/Configurator/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\n/* harmony import */ var _components_partials__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/partials */ \"./resources/js/components/partials/index.js\");\n/* harmony import */ var _Streams__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Streams */ \"./resources/js/components/Configurator/Streams/index.js\");\n/* harmony import */ var _Clips__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Clips */ \"./resources/js/components/Configurator/Clips/index.js\");\n/* harmony import */ var _Format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Format */ \"./resources/js/components/Configurator/Format.js\");\n/* harmony import */ var _FilterGraph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FilterGraph */ \"./resources/js/components/Configurator/FilterGraph/index.js\");\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\n/* harmony import */ var _Dialogues_Scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Dialogues/Scale */ \"./resources/js/components/Configurator/Dialogues/Scale.js\");\n/* harmony import */ var _Dialogues_Concat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Dialogues/Concat */ \"./resources/js/components/Configurator/Dialogues/Concat.js\");\n/* harmony import */ var _Dialogues_Clipper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Dialogues/Clipper */ \"./resources/js/components/Configurator/Dialogues/Clipper/index.js\");\n/* harmony import */ var _Dialogues_Cropper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Dialogues/Cropper */ \"./resources/js/components/Configurator/Dialogues/Cropper/index.js\");\n/* harmony import */ var _Dialogues_Delogo__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Dialogues/Delogo */ \"./resources/js/components/Configurator/Dialogues/Delogo/index.js\");\n/* harmony import */ var _Dialogues_RemoveLogo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Dialogues/RemoveLogo */ \"./resources/js/components/Configurator/Dialogues/RemoveLogo/index.js\");\n/* harmony import */ var _Tools__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Tools */ \"./resources/js/components/Configurator/Tools/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar WS_CHANNEL = \"Transcode.Config\";\n\nvar TranscodeConfigurator = /*#__PURE__*/function (_Slim) {\n  _inherits(TranscodeConfigurator, _Slim);\n\n  var _super = _createSuper(TranscodeConfigurator);\n\n  function TranscodeConfigurator() {\n    _classCallCheck(this, TranscodeConfigurator);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(TranscodeConfigurator, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this = this;\n\n      this.canConcat = false;\n      document.addEventListener(\"file-clicked\", this.init.bind(this));\n      requestAnimationFrame(function () {\n        return _components_lib__WEBPACK_IMPORTED_MODULE_0__.Iconify.scan(_this.shadowRoot);\n      });\n      this.remuxContainer = \"MP4\";\n      this.handleConfigureStream = this.handleConfigureStream.bind(this);\n      this.handleConfigureStreamReady = this.handleStreamConfig.bind(this);\n      this.saveSettings = this.saveSettings.bind(this);\n      this.toolProxy = _Tools__WEBPACK_IMPORTED_MODULE_14__.toolProxy.bind(this);\n      this.hide = this.hide.bind(this);\n    }\n  }, {\n    key: \"init\",\n    value: function init(e) {\n      if (!this.item) {\n        if (\"video\" === e.detail.mime.split(\"/\").shift()) {\n          this.item = e.detail;\n          this.out = \"\";\n          this.setCanConcat();\n          this.initWebsocket();\n        }\n      }\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.classList.add(\"active\");\n      this.item.node.iconActive = true;\n      document.dispatchEvent(new CustomEvent(\"configurator-show\", {\n        detail: true\n      }));\n      document.addEventListener(\"stream-configure\", this.handleConfigureStream);\n      console.info(\"Show streams of %s\", this.item.path);\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(e) {\n      var _this2 = this;\n\n      e.stopPropagation(); // prevent document clicks\n\n      this.addEventListener(\"transitionend\", function () {\n        _this2.classList.remove(\"active\", \"fade-out\");\n\n        _this2.format = undefined;\n        _this2.streams = undefined;\n        _this2.item.node.iconActive = false;\n        delete _this2.item;\n        document.dispatchEvent(new CustomEvent(\"configurator-hidden\"));\n      }, {\n        once: true\n      });\n      this.classList.add(\"fade-out\");\n      this.leaveWebsocket();\n      document.removeEventListener(\"stream-configure\", this.handleConfigureStream);\n      document.removeEventListener(\"stream-config\", this.handleConfigureStreamReady);\n      document.dispatchEvent(new CustomEvent(\"configurator-show\", {\n        detail: false\n      }));\n    }\n  }, {\n    key: \"initWebsocket\",\n    value: function initWebsocket() {\n      this.channel = window.Echo.channel(WS_CHANNEL);\n      this.channel.listen(WS_CHANNEL, this.handleConfiguratorEvent.bind(this));\n      this.channel.subscribed(this.requestStreams.bind(this));\n    }\n  }, {\n    key: \"leaveWebsocket\",\n    value: function leaveWebsocket() {\n      this.channel.stopListening(WS_CHANNEL);\n      window.Echo.leave(WS_CHANNEL);\n      delete this.channel;\n    }\n  }, {\n    key: \"requestStreams\",\n    value: function requestStreams() {\n      try {\n        console.info(\"Request streams of %s\", this.item.path);\n        _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.get(\"/streams/\".concat(encodeURIComponent(this.item.path)));\n      } catch (error) {\n        this.leaveWebsocket();\n        this.hide();\n      }\n    }\n  }, {\n    key: \"transcode\",\n    value: function transcode() {\n      var _this3 = this;\n\n      if (!this.clips.valid) {\n        document.dispatchEvent(new CustomEvent(\"toast\", {\n          detail: {\n            message: \"Clip is invalid\",\n            type: \"warning\"\n          }\n        }));\n        return;\n      }\n\n      try {\n        requestAnimationFrame(function () {\n          console.info(\"Transcode %s\", _this3.item.path, _this3.config);\n          _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.post(\"/transcode/\".concat(encodeURIComponent(_this3.item.path)), _this3.config);\n        });\n      } catch (error) {}\n    }\n  }, {\n    key: \"handleConfiguratorEvent\",\n    value: function handleConfiguratorEvent(ws) {\n      var _ws$crop, _ws$removeLogo, _ws$delogo, _ws$filterGraph;\n\n      console.info(ws);\n      this.format = ws.format;\n      this.streams = this.initTranscodeConfig(ws.streams);\n      this.crop = (_ws$crop = ws.crop) !== null && _ws$crop !== void 0 ? _ws$crop : {};\n      this.removeLogo = (_ws$removeLogo = ws.removeLogo) !== null && _ws$removeLogo !== void 0 ? _ws$removeLogo : {};\n      this.delogo = (_ws$delogo = ws.delogo) !== null && _ws$delogo !== void 0 ? _ws$delogo : {};\n      this.filterGraph = (_ws$filterGraph = ws.filterGraph) !== null && _ws$filterGraph !== void 0 ? _ws$filterGraph : [];\n      this.show();\n    }\n  }, {\n    key: \"initTranscodeConfig\",\n    value: function initTranscodeConfig(streams) {\n      var codecsMap = new Map();\n      codecsMap.set('videoCodecs', Object.values(VIDEO_CODECS).sort(function (a, b) {\n        return a.v > b.v;\n      }));\n      codecsMap.set('audioCodecs', Object.values(AUDIO_CODECS).sort(function (a, b) {\n        return a.v > b.v;\n      }));\n      codecsMap.set('subtitleCodecs', Object.values(SUBTITLE_CODECS).sort(function (a, b) {\n        return a.v > b.v;\n      }));\n      streams.forEach(function (stream) {\n        var _stream$transcodeConf, _stream$transcodeConf2, _stream$transcodeConf3, _stream$transcodeConf4, _stream$transcodeConf5;\n\n        var type = stream.codec_type;\n        var codecs = codecsMap.get(\"\".concat(type, \"Codecs\"));\n        var channels = (_stream$transcodeConf = stream.transcodeConfig) === null || _stream$transcodeConf === void 0 ? void 0 : _stream$transcodeConf.channels;\n        var qp = (_stream$transcodeConf2 = stream.transcodeConfig) === null || _stream$transcodeConf2 === void 0 ? void 0 : _stream$transcodeConf2.qp;\n        stream.transcodeConfig = stream.transcodeConfig || {};\n        stream.transcodeConfig.codec = typeof ((_stream$transcodeConf3 = stream.transcodeConfig) === null || _stream$transcodeConf3 === void 0 ? void 0 : _stream$transcodeConf3.codec) !== \"undefined\" ? stream.transcodeConfig.codec : codecs.find(function (c) {\n          return c[\"default\"];\n        }).v;\n\n        switch (type) {\n          case 'video':\n            stream.transcodeConfig.qp = typeof ((_stream$transcodeConf4 = stream.transcodeConfig) === null || _stream$transcodeConf4 === void 0 ? void 0 : _stream$transcodeConf4.qp) !== \"undefined\" ? stream.transcodeConfig.qp : codecs.find(function (c) {\n              return c[\"default\"];\n            }).qp;\n            stream.transcodeConfig.aspectRatio = stream.transcodeConfig.aspectRatio || '16:9';\n            break;\n\n          case 'audio':\n            stream.transcodeConfig.channels = typeof ((_stream$transcodeConf5 = stream.transcodeConfig) === null || _stream$transcodeConf5 === void 0 ? void 0 : _stream$transcodeConf5.channels) !== \"undefined\" ? stream.transcodeConfig.channels : codecs.find(function (c) {\n              return c[\"default\"];\n            }).channels;\n            break;\n\n          case 'subtitle':\n            break;\n        }\n      });\n      return streams;\n    }\n  }, {\n    key: \"setCanConcat\",\n    value: function setCanConcat() {\n      var _this$item,\n          _this$item$parent,\n          _this$item$parent$vid,\n          _this4 = this;\n\n      this.canConcat = ((_this$item = this.item) === null || _this$item === void 0 ? void 0 : (_this$item$parent = _this$item.parent) === null || _this$item$parent === void 0 ? void 0 : (_this$item$parent$vid = _this$item$parent.videoFiles) === null || _this$item$parent$vid === void 0 ? void 0 : _this$item$parent$vid.length) > 1 && !this.item.parent.videoFiles.find(function (i) {\n        return i.name === \"\".concat(_this4.item.parent.channelHash, \"-concat.ts\");\n      });\n    }\n  }, {\n    key: \"handleConfigureStream\",\n    value: function handleConfigureStream(e) {\n      var _this5 = this;\n\n      var offsetOrigin = e.detail.origin.getBoundingClientRect();\n      var offsetMain = this.main.getBoundingClientRect();\n      var offset = {\n        top: offsetOrigin.top - offsetMain.top,\n        right: offsetMain.right - offsetOrigin.left\n      };\n      document.addEventListener(\"stream-config\", this.handleConfigureStreamReady, {\n        once: true\n      });\n\n      if (this.streamConfig.classList.contains(\"active\") && e.detail.item.index !== this.streamConfig.item.index) {\n        this.streamConfig.addEventListener(\"transitionend\", function () {\n          requestAnimationFrame(function () {\n            return _this5.streamConfig.toggle(e.detail.item, offset);\n          });\n        }, {\n          once: true\n        });\n      }\n\n      this.streamConfig.toggle(e.detail.item, offset);\n    }\n  }, {\n    key: \"handleStreamConfig\",\n    value: function handleStreamConfig(e) {\n      console.info(\"Stream configured: \", e.detail.item.transcodeConfig);\n    }\n  }, {\n    key: \"saveSettings\",\n    value: function saveSettings() {\n      _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.post(\"/settings/\".concat(encodeURIComponent(this.item.path)), this.config);\n      _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(this);\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      var clipsData = _toConsumableArray(this.clips.clips);\n\n      if (clipsData[0].from === null) {\n        clipsData[0].from = \"0:0:0.0\";\n      }\n\n      if (clipsData.length === 1 && clipsData[0].to === null) {\n        clipsData[0].to = this.formatNode.duration;\n      }\n\n      var streams = this.streams.filter(function (s) {\n        return s.active;\n      }).map(function (s) {\n        var _s$transcodeConfig;\n\n        return {\n          id: s.index,\n          config: (_s$transcodeConfig = s.transcodeConfig) !== null && _s$transcodeConfig !== void 0 ? _s$transcodeConfig : {}\n        };\n      });\n      return {\n        streams: streams,\n        clips: clipsData,\n        crop: this.crop,\n        removeLogo: this.removeLogo,\n        delogo: this.delogo,\n        filterGraph: this.filterGraph\n      };\n    }\n  }, {\n    key: \"clips\",\n    get: function get() {\n      return this.shadowRoot.querySelector(\"transcode-configurator-clips\");\n    }\n  }]);\n\n  return TranscodeConfigurator;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nvar CSS =\n/*css*/\n\"\\n<style>\\n:host {\\n    position: fixed;\\n    inset: 0;\\n    display: none;\\n    opacity: 1;\\n    transition: opacity var(--transition-slow) linear;\\n}\\n:host(.active) {\\n    display: flex;\\n    align-items: center;\\n}\\n:host(.fade-out) {\\n    opacity: 0;\\n}\\nmain {\\n    position: absolute;\\n    box-shadow: 0 0 10vw 3vw var(--clr-shadow-0);\\n    inset: var(--window-inset);\\n    background-color: var(--clr-bg-0);\\n    border-radius: var(--window-border-radius);\\n    padding: min(30px, var(--rel-gutter-200));\\n}\\nmain h1 {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n    padding: 0;\\n    margin: 0 0 var(--rel-gutter-100) 0;\\n    font-size: 1.75rem;\\n    user-select: none;\\n}\\nmain h1 div {\\n    cursor: pointer;\\n    height: 1em;\\n    width: 1em;\\n}\\nmain > div {\\n    height: calc(100% - 1.75rem * 2);\\n    gap: 1rem;\\n    display: grid;\\n    grid-template-areas: \\\"info\\\" \\\"footer\\\";\\n    grid-template-rows: auto min-content;\\n}\\n.info {\\n    grid-area: info;\\n    display: grid;\\n    grid-template-areas: \\\"data clips\\\" \\\"filterGraph .\\\";\\n    grid-template-rows: repeat(2, min-content);\\n    gap: 1rem;\\n    overflow-y: auto;\\n}\\n@media (max-width: 640px) {\\n    .info {\\n        grid-template-areas: \\\"data\\\" \\\"clips\\\";\\n    }\\n}\\n.info section {\\n    grid-area: data;\\n    display: grid;\\n    gap: 1rem;\\n    grid-auto-rows: min-content;\\n}\\n.info transcode-configurator-clips {\\n    grid-area: clips;\\n}\\nfooter {\\n    grid-area: footer;\\n    display: flex;\\n    justify-content: flex-end;\\n    align-items: center;\\n    gap: .5rem;\\n    padding: 0 1rem;\\n}\\nfooter .icon-stack {\\n    font-size: var(--font-size-200);\\n    aspect-ratio: 1;\\n}\\ncombo-button {\\n    min-width: 190px;\\n}\\n</style>\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_7__.ICON_STACK_CSS, \"\\n\").concat(_components_partials__WEBPACK_IMPORTED_MODULE_2__.COMBO_BUTTON_CSS, \"\\n\");\nvar HEADING =\n/*html*/\n\"\\n<h1>\\n    Transcode\\n    <div @click=\\\"{{ this.hide }}\\\" class=\\\"icon-stack\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-close\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-close\\\"></span>\\n    </div>\\n</h1>\\n\";\nTranscodeConfigurator.template =\n/*html*/\n\"\\n\".concat(CSS, \"\\n<main #ref=\\\"main\\\">\\n    \").concat(HEADING, \"\\n    <div>\\n        <div class=\\\"info\\\">\\n            <section>\\n                <transcode-configurator-format *if=\\\"{{ this.format }}\\\" .format=\\\"{{ this.format }}\\\" #ref=\\\"formatNode\\\"></transcode-configurator-format>\\n                <transcode-configurator-streams *if=\\\"{{ this.streams }}\\\" .items=\\\"{{ this.streams }}\\\"></transcode-configurator-streams>\\n            </section>\\n            <transcode-configurator-clips *if=\\\"{{ this.streams }}\\\" .path=\\\"{{ this.item.path }}\\\"></transcode-configurator-clips>\\n            <transcode-configurator-filter-graph *if=\\\"{{ this.filterGraph.length }}\\\" .filters=\\\"{{ this.filterGraph }}\\\" .configurator=\\\"{{ this }}\\\"></transcode-configurator-filter-graph>\\n        </div>\\n        <footer>\\n            <button @click=\\\"this.saveSettings()\\\" class=\\\"icon-stack\\\" title=\\\"Save Settings\\\">\\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-content-save-outline\\\"></span>\\n                <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-content-save-outline\\\"></span>\\n            </button>\\n            <button @click=\\\"this.toolProxy({target:{value:'play:cpu'}})\\\" class=\\\"icon-stack\\\" title=\\\"Play\\\">\\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-play\\\"></span>\\n                <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-play\\\"></span>\\n            </button>\\n            <combo-button @click=\\\"{{ this.toolProxy }}\\\">\\n                <option *if=\\\"{{ this.canConcat }}\\\" value=\\\"concat:mkv\\\">Concat MKV</option>\\n                <option *if=\\\"{{ this.canConcat }}\\\" value=\\\"concat:mp4\\\">Concat MP4</option>\\n                <option value=\\\"scale:cpu\\\">Scale (CPU)</option>\\n                <option value=\\\"remux:mkv\\\">Remux MKV</option>\\n                <option value=\\\"remux:mp4\\\">Remux MP4</option>\\n                <option value=\\\"remux:ts\\\">Remux TS</option>\\n                <option value=\\\"crop:cpu\\\">Crop (CPU)</option>\\n                <option value=\\\"delogo:cpu\\\">DeLogo (CPU)</option>\\n                <option value=\\\"removelogo:cpu\\\">RemoveLogo (CPU)</option>\\n            </combo-button>\\n            <theme-button @click=\\\"this.toolProxy({target:{value:'clip'}})\\\">Clipper</theme-button>\\n            <theme-button @click=\\\"this.transcode()\\\">Transcode</theme-button>\\n        </footer>\\n    </div>\\n    <transcode-configurator-stream-config #ref=\\\"streamConfig\\\"></transcode-configurator-stream-config>\\n</main>\\n\");\ncustomElements.define('transcode-configurator', TranscodeConfigurator);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Db25maWd1cmF0b3IvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxJQUFNTyxVQUFVLEdBQUcsa0JBQW5COztJQUNNQzs7Ozs7Ozs7Ozs7OztXQUNGLG1CQUFVO0FBQUE7O0FBQ04sV0FBS0MsU0FBTCxHQUFpQixLQUFqQjtBQUNBQyxNQUFBQSxRQUFRLENBQUNDLGdCQUFULENBQTBCLGNBQTFCLEVBQTBDLEtBQUtDLElBQUwsQ0FBVUMsSUFBVixDQUFlLElBQWYsQ0FBMUM7QUFDQUMsTUFBQUEscUJBQXFCLENBQUM7QUFBQSxlQUFNWix5REFBQSxDQUFhLEtBQUksQ0FBQ2MsVUFBbEIsQ0FBTjtBQUFBLE9BQUQsQ0FBckI7QUFDQSxXQUFLQyxjQUFMLEdBQXNCLEtBQXRCO0FBQ0EsV0FBS0MscUJBQUwsR0FBNkIsS0FBS0EscUJBQUwsQ0FBMkJMLElBQTNCLENBQWdDLElBQWhDLENBQTdCO0FBQ0EsV0FBS00sMEJBQUwsR0FBa0MsS0FBS0Msa0JBQUwsQ0FBd0JQLElBQXhCLENBQTZCLElBQTdCLENBQWxDO0FBQ0EsV0FBS1EsWUFBTCxHQUFvQixLQUFLQSxZQUFMLENBQWtCUixJQUFsQixDQUF1QixJQUF2QixDQUFwQjtBQUNBLFdBQUtQLFNBQUwsR0FBaUJBLG1EQUFBLENBQWUsSUFBZixDQUFqQjtBQUNBLFdBQUtnQixJQUFMLEdBQVksS0FBS0EsSUFBTCxDQUFVVCxJQUFWLENBQWUsSUFBZixDQUFaO0FBQ0g7OztXQUVELGNBQUtVLENBQUwsRUFBUTtBQUNKLFVBQUksQ0FBQyxLQUFLQyxJQUFWLEVBQWdCO0FBQ1osWUFBSSxZQUFZRCxDQUFDLENBQUNFLE1BQUYsQ0FBU0MsSUFB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WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ29uZmlndXJhdG9yL2luZGV4LmpzP2M5NWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2xpbSwgVXRpbHMsIEljb25pZnkgfSBmcm9tICdAL2NvbXBvbmVudHMvbGliJztcbmltcG9ydCB7UmVxdWVzdH0gZnJvbSAnQC9jb21wb25lbnRzL1JlcXVlc3QnXG5pbXBvcnQgeyBDT01CT19CVVRUT05fQ1NTIH0gZnJvbSAnQC9jb21wb25lbnRzL3BhcnRpYWxzJztcbmltcG9ydCAnLi9TdHJlYW1zJ1xuaW1wb3J0ICcuL0NsaXBzJ1xuaW1wb3J0ICcuL0Zvcm1hdCdcbmltcG9ydCAnLi9GaWx0ZXJHcmFwaCdcbmltcG9ydCB7IElDT05fU1RBQ0tfQ1NTIH0gZnJvbSAnQC9jb21wb25lbnRzL0ljb25zL1N0YWNrLmNzcyc7XG5pbXBvcnQgXCIuL0RpYWxvZ3Vlcy9TY2FsZVwiO1xuaW1wb3J0IFwiLi9EaWFsb2d1ZXMvQ29uY2F0XCI7XG5pbXBvcnQgXCIuL0RpYWxvZ3Vlcy9DbGlwcGVyXCI7XG5pbXBvcnQgXCIuL0RpYWxvZ3Vlcy9Dcm9wcGVyXCI7XG5pbXBvcnQgXCIuL0RpYWxvZ3Vlcy9EZWxvZ29cIjtcbmltcG9ydCBcIi4vRGlhbG9ndWVzL1JlbW92ZUxvZ29cIjtcbmltcG9ydCB7IHRvb2xQcm94eSB9IGZyb20gXCIuL1Rvb2xzXCI7XG5cbmNvbnN0IFdTX0NIQU5ORUwgPSBcIlRyYW5zY29kZS5Db25maWdcIjtcbmNsYXNzIFRyYW5zY29kZUNvbmZpZ3VyYXRvciBleHRlbmRzIFNsaW0ge1xuICAgIG9uQWRkZWQoKSB7XG4gICAgICAgIHRoaXMuY2FuQ29uY2F0ID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmaWxlLWNsaWNrZWRcIiwgdGhpcy5pbml0LmJpbmQodGhpcykpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gSWNvbmlmeS5zY2FuKHRoaXMuc2hhZG93Um9vdCkpO1xuICAgICAgICB0aGlzLnJlbXV4Q29udGFpbmVyID0gXCJNUDRcIjtcbiAgICAgICAgdGhpcy5oYW5kbGVDb25maWd1cmVTdHJlYW0gPSB0aGlzLmhhbmRsZUNvbmZpZ3VyZVN0cmVhbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUNvbmZpZ3VyZVN0cmVhbVJlYWR5ID0gdGhpcy5oYW5kbGVTdHJlYW1Db25maWcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYXZlU2V0dGluZ3MgPSB0aGlzLnNhdmVTZXR0aW5ncy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvb2xQcm94eSA9IHRvb2xQcm94eS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhpZGUgPSB0aGlzLmhpZGUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbml0KGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLml0ZW0pIHtcbiAgICAgICAgICAgIGlmIChcInZpZGVvXCIgPT09IGUuZGV0YWlsLm1pbWUuc3BsaXQoXCIvXCIpLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW0gPSBlLmRldGFpbDtcbiAgICAgICAgICAgICAgICB0aGlzLm91dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDYW5Db25jYXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRXZWJzb2NrZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICAgICAgdGhpcy5pdGVtLm5vZGUuaWNvbkFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXCJjb25maWd1cmF0b3Itc2hvd1wiLCB7IGRldGFpbDogdHJ1ZSB9KVxuICAgICAgICApO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJzdHJlYW0tY29uZmlndXJlXCIsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNvbmZpZ3VyZVN0cmVhbVxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJTaG93IHN0cmVhbXMgb2YgJXNcIiwgdGhpcy5pdGVtLnBhdGgpO1xuICAgIH1cblxuICAgIGhpZGUoZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBwcmV2ZW50IGRvY3VtZW50IGNsaWNrc1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcInRyYW5zaXRpb25lbmRcIixcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIiwgXCJmYWRlLW91dFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtLm5vZGUuaWNvbkFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLml0ZW07XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJjb25maWd1cmF0b3ItaGlkZGVuXCIpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoXCJmYWRlLW91dFwiKTtcbiAgICAgICAgdGhpcy5sZWF2ZVdlYnNvY2tldCgpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJzdHJlYW0tY29uZmlndXJlXCIsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNvbmZpZ3VyZVN0cmVhbVxuICAgICAgICApO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RyZWFtLWNvbmZpZ1wiLCB0aGlzLmhhbmRsZUNvbmZpZ3VyZVN0cmVhbVJlYWR5KTtcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcImNvbmZpZ3VyYXRvci1zaG93XCIsIHsgZGV0YWlsOiBmYWxzZSB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGluaXRXZWJzb2NrZXQoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IHdpbmRvdy5FY2hvLmNoYW5uZWwoV1NfQ0hBTk5FTCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5saXN0ZW4oXG4gICAgICAgICAgICBXU19DSEFOTkVMLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25maWd1cmF0b3JFdmVudC5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5zdWJzY3JpYmVkKHRoaXMucmVxdWVzdFN0cmVhbXMuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgbGVhdmVXZWJzb2NrZXQoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5zdG9wTGlzdGVuaW5nKFdTX0NIQU5ORUwpO1xuICAgICAgICB3aW5kb3cuRWNoby5sZWF2ZShXU19DSEFOTkVMKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2hhbm5lbDtcbiAgICB9XG5cbiAgICByZXF1ZXN0U3RyZWFtcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlJlcXVlc3Qgc3RyZWFtcyBvZiAlc1wiLCB0aGlzLml0ZW0ucGF0aCk7XG4gICAgICAgICAgICBSZXF1ZXN0LmdldChgL3N0cmVhbXMvJHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5pdGVtLnBhdGgpfWApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sZWF2ZVdlYnNvY2tldCgpO1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cmFuc2NvZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGlwcy52YWxpZCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXCJ0b2FzdFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDbGlwIGlzIGludmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwid2FybmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRyYW5zY29kZSAlc1wiLCB0aGlzLml0ZW0ucGF0aCwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgICAgIFJlcXVlc3QucG9zdChcbiAgICAgICAgICAgICAgICAgICAgYC90cmFuc2NvZGUvJHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5pdGVtLnBhdGgpfWAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9XG5cbiAgICBoYW5kbGVDb25maWd1cmF0b3JFdmVudCh3cykge1xuICAgICAgICBjb25zb2xlLmluZm8od3MpO1xuICAgICAgICB0aGlzLmZvcm1hdCA9IHdzLmZvcm1hdDtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gdGhpcy5pbml0VHJhbnNjb2RlQ29uZmlnKHdzLnN0cmVhbXMpO1xuICAgICAgICB0aGlzLmNyb3AgPSB3cy5jcm9wID8/IHt9O1xuICAgICAgICB0aGlzLnJlbW92ZUxvZ28gPSB3cy5yZW1vdmVMb2dvID8/IHt9O1xuICAgICAgICB0aGlzLmRlbG9nbyA9IHdzLmRlbG9nbyA/PyB7fVxuICAgICAgICB0aGlzLmZpbHRlckdyYXBoID0gd3MuZmlsdGVyR3JhcGggPz8gW107XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cblxuICAgIGluaXRUcmFuc2NvZGVDb25maWcoc3RyZWFtcykge1xuICAgICAgICBjb25zdCBjb2RlY3NNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvZGVjc01hcC5zZXQoJ3ZpZGVvQ29kZWNzJywgT2JqZWN0LnZhbHVlcyhWSURFT19DT0RFQ1MpLnNvcnQoKGEsYikgPT4gYS52ID4gYi52KSk7XG4gICAgICAgIGNvZGVjc01hcC5zZXQoJ2F1ZGlvQ29kZWNzJywgT2JqZWN0LnZhbHVlcyhBVURJT19DT0RFQ1MpLnNvcnQoKGEsYikgPT4gYS52ID4gYi52KSk7XG4gICAgICAgIGNvZGVjc01hcC5zZXQoJ3N1YnRpdGxlQ29kZWNzJywgT2JqZWN0LnZhbHVlcyhTVUJUSVRMRV9DT0RFQ1MpLnNvcnQoKGEsYikgPT4gYS52ID4gYi52KSk7XG4gICAgICAgIHN0cmVhbXMuZm9yRWFjaCgoc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc3RyZWFtLmNvZGVjX3R5cGU7XG4gICAgICAgICAgICBjb25zdCBjb2RlY3MgPSBjb2RlY3NNYXAuZ2V0KGAke3R5cGV9Q29kZWNzYCk7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHN0cmVhbS50cmFuc2NvZGVDb25maWc/LmNoYW5uZWxzXG4gICAgICAgICAgICBjb25zdCBxcCA9IHN0cmVhbS50cmFuc2NvZGVDb25maWc/LnFwXG4gICAgICAgICAgICBzdHJlYW0udHJhbnNjb2RlQ29uZmlnID0gc3RyZWFtLnRyYW5zY29kZUNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgIHN0cmVhbS50cmFuc2NvZGVDb25maWcuY29kZWMgPSB0eXBlb2Ygc3RyZWFtLnRyYW5zY29kZUNvbmZpZz8uY29kZWMgIT09IFwidW5kZWZpbmVkXCIgPyBzdHJlYW0udHJhbnNjb2RlQ29uZmlnLmNvZGVjIDogY29kZWNzLmZpbmQoYyA9PiBjLmRlZmF1bHQpLnZcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnRyYW5zY29kZUNvbmZpZy5xcCA9IHR5cGVvZiBzdHJlYW0udHJhbnNjb2RlQ29uZmlnPy5xcCAhPT0gXCJ1bmRlZmluZWRcIiA/IHN0cmVhbS50cmFuc2NvZGVDb25maWcucXAgOiBjb2RlY3MuZmluZChjID0+IGMuZGVmYXVsdCkucXBcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnRyYW5zY29kZUNvbmZpZy5hc3BlY3RSYXRpbyA9IHN0cmVhbS50cmFuc2NvZGVDb25maWcuYXNwZWN0UmF0aW8gfHwgJzE2OjknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS50cmFuc2NvZGVDb25maWcuY2hhbm5lbHMgPSB0eXBlb2Ygc3RyZWFtLnRyYW5zY29kZUNvbmZpZz8uY2hhbm5lbHMgIT09IFwidW5kZWZpbmVkXCIgPyBzdHJlYW0udHJhbnNjb2RlQ29uZmlnLmNoYW5uZWxzIDogY29kZWNzLmZpbmQoYyA9PiBjLmRlZmF1bHQpLmNoYW5uZWxzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N1YnRpdGxlJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtcztcbiAgICB9XG5cbiAgICBzZXRDYW5Db25jYXQoKSB7XG4gICAgICAgIHRoaXMuY2FuQ29uY2F0ID1cbiAgICAgICAgICAgIHRoaXMuaXRlbT8ucGFyZW50Py52aWRlb0ZpbGVzPy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAhdGhpcy5pdGVtLnBhcmVudC52aWRlb0ZpbGVzLmZpbmQoXG4gICAgICAgICAgICAgICAgKGkpID0+IGkubmFtZSA9PT0gYCR7dGhpcy5pdGVtLnBhcmVudC5jaGFubmVsSGFzaH0tY29uY2F0LnRzYFxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDb25maWd1cmVTdHJlYW0oZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRPcmlnaW4gPSBlLmRldGFpbC5vcmlnaW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldE1haW4gPSB0aGlzLm1haW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHtcbiAgICAgICAgICAgIHRvcDogb2Zmc2V0T3JpZ2luLnRvcCAtIG9mZnNldE1haW4udG9wLFxuICAgICAgICAgICAgcmlnaHQ6IG9mZnNldE1haW4ucmlnaHQgLSBvZmZzZXRPcmlnaW4ubGVmdCxcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInN0cmVhbS1jb25maWdcIiwgdGhpcy5oYW5kbGVDb25maWd1cmVTdHJlYW1SZWFkeSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29uZmlnLmNsYXNzTGlzdC5jb250YWlucyhcImFjdGl2ZVwiKSAmJlxuICAgICAgICAgICAgZS5kZXRhaWwuaXRlbS5pbmRleCAhPT0gdGhpcy5zdHJlYW1Db25maWcuaXRlbS5pbmRleFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29uZmlnLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgXCJ0cmFuc2l0aW9uZW5kXCIsXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29uZmlnLnRvZ2dsZShlLmRldGFpbC5pdGVtLCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbUNvbmZpZy50b2dnbGUoZS5kZXRhaWwuaXRlbSwgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBoYW5kbGVTdHJlYW1Db25maWcoZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJTdHJlYW0gY29uZmlndXJlZDogXCIsIGUuZGV0YWlsLml0ZW0udHJhbnNjb2RlQ29uZmlnKTtcbiAgICB9XG5cbiAgICBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIFJlcXVlc3QucG9zdChcbiAgICAgICAgICAgIGAvc2V0dGluZ3MvJHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5pdGVtLnBhdGgpfWAsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1xuICAgICAgICApO1xuICAgICAgICBVdGlscy5mb3JjZVVwZGF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICBjb25zdCBjbGlwc0RhdGEgPSBbLi4udGhpcy5jbGlwcy5jbGlwc107XG4gICAgICAgIGlmIChjbGlwc0RhdGFbMF0uZnJvbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY2xpcHNEYXRhWzBdLmZyb20gPSBcIjA6MDowLjBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpcHNEYXRhLmxlbmd0aCA9PT0gMSAmJiBjbGlwc0RhdGFbMF0udG8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsaXBzRGF0YVswXS50byA9IHRoaXMuZm9ybWF0Tm9kZS5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW1zID0gdGhpcy5zdHJlYW1zXG4gICAgICAgICAgICAuZmlsdGVyKChzKSA9PiBzLmFjdGl2ZSlcbiAgICAgICAgICAgIC5tYXAoKHMpID0+ICh7IGlkOiBzLmluZGV4LCBjb25maWc6IHMudHJhbnNjb2RlQ29uZmlnID8/IHt9IH0pKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RyZWFtcyxcbiAgICAgICAgICAgIGNsaXBzOiBjbGlwc0RhdGEsXG4gICAgICAgICAgICBjcm9wOiB0aGlzLmNyb3AsXG4gICAgICAgICAgICByZW1vdmVMb2dvOiB0aGlzLnJlbW92ZUxvZ28sXG4gICAgICAgICAgICBkZWxvZ286IHRoaXMuZGVsb2dvLFxuICAgICAgICAgICAgZmlsdGVyR3JhcGg6IHRoaXMuZmlsdGVyR3JhcGhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBnZXQgY2xpcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInRyYW5zY29kZS1jb25maWd1cmF0b3ItY2xpcHNcIik7XG4gICAgfVxufVxuXG5jb25zdCBDU1MgPSAvKmNzcyovIGBcbjxzdHlsZT5cbjpob3N0IHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgaW5zZXQ6IDA7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgdmFyKC0tdHJhbnNpdGlvbi1zbG93KSBsaW5lYXI7XG59XG46aG9zdCguYWN0aXZlKSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuOmhvc3QoLmZhZGUtb3V0KSB7XG4gICAgb3BhY2l0eTogMDtcbn1cbm1haW4ge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3gtc2hhZG93OiAwIDAgMTB2dyAzdncgdmFyKC0tY2xyLXNoYWRvdy0wKTtcbiAgICBpbnNldDogdmFyKC0td2luZG93LWluc2V0KTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jbHItYmctMCk7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0td2luZG93LWJvcmRlci1yYWRpdXMpO1xuICAgIHBhZGRpbmc6IG1pbigzMHB4LCB2YXIoLS1yZWwtZ3V0dGVyLTIwMCkpO1xufVxubWFpbiBoMSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBwYWRkaW5nOiAwO1xuICAgIG1hcmdpbjogMCAwIHZhcigtLXJlbC1ndXR0ZXItMTAwKSAwO1xuICAgIGZvbnQtc2l6ZTogMS43NXJlbTtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cbm1haW4gaDEgZGl2IHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgaGVpZ2h0OiAxZW07XG4gICAgd2lkdGg6IDFlbTtcbn1cbm1haW4gPiBkaXYge1xuICAgIGhlaWdodDogY2FsYygxMDAlIC0gMS43NXJlbSAqIDIpO1xuICAgIGdhcDogMXJlbTtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtYXJlYXM6IFwiaW5mb1wiIFwiZm9vdGVyXCI7XG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiBhdXRvIG1pbi1jb250ZW50O1xufVxuLmluZm8ge1xuICAgIGdyaWQtYXJlYTogaW5mbztcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtYXJlYXM6IFwiZGF0YSBjbGlwc1wiIFwiZmlsdGVyR3JhcGggLlwiO1xuICAgIGdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KDIsIG1pbi1jb250ZW50KTtcbiAgICBnYXA6IDFyZW07XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbn1cbkBtZWRpYSAobWF4LXdpZHRoOiA2NDBweCkge1xuICAgIC5pbmZvIHtcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1hcmVhczogXCJkYXRhXCIgXCJjbGlwc1wiO1xuICAgIH1cbn1cbi5pbmZvIHNlY3Rpb24ge1xuICAgIGdyaWQtYXJlYTogZGF0YTtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdhcDogMXJlbTtcbiAgICBncmlkLWF1dG8tcm93czogbWluLWNvbnRlbnQ7XG59XG4uaW5mbyB0cmFuc2NvZGUtY29uZmlndXJhdG9yLWNsaXBzIHtcbiAgICBncmlkLWFyZWE6IGNsaXBzO1xufVxuZm9vdGVyIHtcbiAgICBncmlkLWFyZWE6IGZvb3RlcjtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IC41cmVtO1xuICAgIHBhZGRpbmc6IDAgMXJlbTtcbn1cbmZvb3RlciAuaWNvbi1zdGFjayB7XG4gICAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUtMjAwKTtcbiAgICBhc3BlY3QtcmF0aW86IDE7XG59XG5jb21iby1idXR0b24ge1xuICAgIG1pbi13aWR0aDogMTkwcHg7XG59XG48L3N0eWxlPlxuJHtJQ09OX1NUQUNLX0NTU31cbiR7Q09NQk9fQlVUVE9OX0NTU31cbmA7XG5cbmNvbnN0IEhFQURJTkcgPSAvKmh0bWwqLyBgXG48aDE+XG4gICAgVHJhbnNjb2RlXG4gICAgPGRpdiBAY2xpY2s9XCJ7eyB0aGlzLmhpZGUgfX1cIiBjbGFzcz1cImljb24tc3RhY2tcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWNsb3NlXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktY2xvc2VcIj48L3NwYW4+XG4gICAgPC9kaXY+XG48L2gxPlxuYDtcblxuVHJhbnNjb2RlQ29uZmlndXJhdG9yLnRlbXBsYXRlID0gLypodG1sKi8gYFxuJHtDU1N9XG48bWFpbiAjcmVmPVwibWFpblwiPlxuICAgICR7SEVBRElOR31cbiAgICA8ZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuICAgICAgICAgICAgPHNlY3Rpb24+XG4gICAgICAgICAgICAgICAgPHRyYW5zY29kZS1jb25maWd1cmF0b3ItZm9ybWF0ICppZj1cInt7IHRoaXMuZm9ybWF0IH19XCIgLmZvcm1hdD1cInt7IHRoaXMuZm9ybWF0IH19XCIgI3JlZj1cImZvcm1hdE5vZGVcIj48L3RyYW5zY29kZS1jb25maWd1cmF0b3ItZm9ybWF0PlxuICAgICAgICAgICAgICAgIDx0cmFuc2NvZGUtY29uZmlndXJhdG9yLXN0cmVhbXMgKmlmPVwie3sgdGhpcy5zdHJlYW1zIH19XCIgLml0ZW1zPVwie3sgdGhpcy5zdHJlYW1zIH19XCI+PC90cmFuc2NvZGUtY29uZmlndXJhdG9yLXN0cmVhbXM+XG4gICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICA8dHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1jbGlwcyAqaWY9XCJ7eyB0aGlzLnN0cmVhbXMgfX1cIiAucGF0aD1cInt7IHRoaXMuaXRlbS5wYXRoIH19XCI+PC90cmFuc2NvZGUtY29uZmlndXJhdG9yLWNsaXBzPlxuICAgICAgICAgICAgPHRyYW5zY29kZS1jb25maWd1cmF0b3ItZmlsdGVyLWdyYXBoICppZj1cInt7IHRoaXMuZmlsdGVyR3JhcGgubGVuZ3RoIH19XCIgLmZpbHRlcnM9XCJ7eyB0aGlzLmZpbHRlckdyYXBoIH19XCIgLmNvbmZpZ3VyYXRvcj1cInt7IHRoaXMgfX1cIj48L3RyYW5zY29kZS1jb25maWd1cmF0b3ItZmlsdGVyLWdyYXBoPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGZvb3Rlcj5cbiAgICAgICAgICAgIDxidXR0b24gQGNsaWNrPVwidGhpcy5zYXZlU2V0dGluZ3MoKVwiIGNsYXNzPVwiaWNvbi1zdGFja1wiIHRpdGxlPVwiU2F2ZSBTZXR0aW5nc1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1jb250ZW50LXNhdmUtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktY29udGVudC1zYXZlLW91dGxpbmVcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gQGNsaWNrPVwidGhpcy50b29sUHJveHkoe3RhcmdldDp7dmFsdWU6J3BsYXk6Y3B1J319KVwiIGNsYXNzPVwiaWNvbi1zdGFja1wiIHRpdGxlPVwiUGxheVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1wbGF5XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeSBob3ZlclwiIGRhdGEtaWNvbj1cIm1kaS1wbGF5XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8Y29tYm8tYnV0dG9uIEBjbGljaz1cInt7IHRoaXMudG9vbFByb3h5IH19XCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiAqaWY9XCJ7eyB0aGlzLmNhbkNvbmNhdCB9fVwiIHZhbHVlPVwiY29uY2F0Om1rdlwiPkNvbmNhdCBNS1Y8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uICppZj1cInt7IHRoaXMuY2FuQ29uY2F0IH19XCIgdmFsdWU9XCJjb25jYXQ6bXA0XCI+Q29uY2F0IE1QNDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzY2FsZTpjcHVcIj5TY2FsZSAoQ1BVKTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZW11eDpta3ZcIj5SZW11eCBNS1Y8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmVtdXg6bXA0XCI+UmVtdXggTVA0PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJlbXV4OnRzXCI+UmVtdXggVFM8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY3JvcDpjcHVcIj5Dcm9wIChDUFUpPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImRlbG9nbzpjcHVcIj5EZUxvZ28gKENQVSk8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmVtb3ZlbG9nbzpjcHVcIj5SZW1vdmVMb2dvIChDUFUpPC9vcHRpb24+XG4gICAgICAgICAgICA8L2NvbWJvLWJ1dHRvbj5cbiAgICAgICAgICAgIDx0aGVtZS1idXR0b24gQGNsaWNrPVwidGhpcy50b29sUHJveHkoe3RhcmdldDp7dmFsdWU6J2NsaXAnfX0pXCI+Q2xpcHBlcjwvdGhlbWUtYnV0dG9uPlxuICAgICAgICAgICAgPHRoZW1lLWJ1dHRvbiBAY2xpY2s9XCJ0aGlzLnRyYW5zY29kZSgpXCI+VHJhbnNjb2RlPC90aGVtZS1idXR0b24+XG4gICAgICAgIDwvZm9vdGVyPlxuICAgIDwvZGl2PlxuICAgIDx0cmFuc2NvZGUtY29uZmlndXJhdG9yLXN0cmVhbS1jb25maWcgI3JlZj1cInN0cmVhbUNvbmZpZ1wiPjwvdHJhbnNjb2RlLWNvbmZpZ3VyYXRvci1zdHJlYW0tY29uZmlnPlxuPC9tYWluPlxuYDtcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCd0cmFuc2NvZGUtY29uZmlndXJhdG9yJywgVHJhbnNjb2RlQ29uZmlndXJhdG9yKTsiXSwibmFtZXMiOlsiU2xpbSIsIlV0aWxzIiwiSWNvbmlmeSIsIlJlcXVlc3QiLCJDT01CT19CVVRUT05fQ1NTIiwiSUNPTl9TVEFDS19DU1MiLCJ0b29sUHJveHkiLCJXU19DSEFOTkVMIiwiVHJhbnNjb2RlQ29uZmlndXJhdG9yIiwiY2FuQ29uY2F0IiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdCIsImJpbmQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzY2FuIiwic2hhZG93Um9vdCIsInJlbXV4Q29udGFpbmVyIiwiaGFuZGxlQ29uZmlndXJlU3RyZWFtIiwiaGFuZGxlQ29uZmlndXJlU3RyZWFtUmVhZHkiLCJoYW5kbGVTdHJlYW1Db25maWciLCJzYXZlU2V0dGluZ3MiLCJoaWRlIiwiZSIsIml0ZW0iLCJkZXRhaWwiLCJtaW1lIiwic3BsaXQiLCJzaGlmdCIsIm91dCIsInNldENhbkNvbmNhdCIsImluaXRXZWJzb2NrZXQiLCJjbGFzc0xpc3QiLCJhZGQiLCJub2RlIiwiaWNvbkFjdGl2ZSIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImNvbnNvbGUiLCJpbmZvIiwicGF0aCIsInN0b3BQcm9wYWdhdGlvbiIsInJlbW92ZSIsImZvcm1hdCIsInVuZGVmaW5lZCIsInN0cmVhbXMiLCJvbmNlIiwibGVhdmVXZWJzb2NrZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2hhbm5lbCIsIndpbmRvdyIsIkVjaG8iLCJsaXN0ZW4iLCJoYW5kbGVDb25maWd1cmF0b3JFdmVudCIsInN1YnNjcmliZWQiLCJyZXF1ZXN0U3RyZWFtcyIsInN0b3BMaXN0ZW5pbmciLCJsZWF2ZSIsImdldCIsImVuY29kZVVSSUNvbXBvbmVudCIsImVycm9yIiwiY2xpcHMiLCJ2YWxpZCIsIm1lc3NhZ2UiLCJ0eXBlIiwiY29uZmlnIiwicG9zdCIsIndzIiwiaW5pdFRyYW5zY29kZUNvbmZpZyIsImNyb3AiLCJyZW1vdmVMb2dvIiwiZGVsb2dvIiwiZmlsdGVyR3JhcGgiLCJzaG93IiwiY29kZWNzTWFwIiwiTWFwIiwic2V0IiwiT2JqZWN0IiwidmFsdWVzIiwiVklERU9fQ09ERUNTIiwic29ydCIsImEiLCJiIiwidiIsIkFVRElPX0NPREVDUyIsIlNVQlRJVExFX0NPREVDUyIsImZvckVhY2giLCJzdHJlYW0iLCJjb2RlY190eXBlIiwiY29kZWNzIiwiY2hhbm5lbHMiLCJ0cmFuc2NvZGVDb25maWciLCJxcCIsImNvZGVjIiwiZmluZCIsImMiLCJhc3BlY3RSYXRpbyIsInBhcmVudCIsInZpZGVvRmlsZXMiLCJsZW5ndGgiLCJpIiwibmFtZSIsImNoYW5uZWxIYXNoIiwib2Zmc2V0T3JpZ2luIiwib3JpZ2luIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib2Zmc2V0TWFpbiIsIm1haW4iLCJvZmZzZXQiLCJ0b3AiLCJyaWdodCIsImxlZnQiLCJzdHJlYW1Db25maWciLCJjb250YWlucyIsImluZGV4IiwidG9nZ2xlIiwiZm9yY2VVcGRhdGUiLCJjbGlwc0RhdGEiLCJmcm9tIiwidG8iLCJmb3JtYXROb2RlIiwiZHVyYXRpb24iLCJmaWx0ZXIiLCJzIiwiYWN0aXZlIiwibWFwIiwiaWQiLCJxdWVyeVNlbGVjdG9yIiwiQ1NTIiwiSEVBRElORyIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Configurator/index.js\n");

/***/ }),

/***/ "./resources/js/components/FilePicker/FilePickerBase.js":
/*!**************************************************************!*\
  !*** ./resources/js/components/FilePicker/FilePickerBase.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FilePickerBase\": () => (/* binding */ FilePickerBase),\n/* harmony export */   \"TYPE_FILE\": () => (/* binding */ TYPE_FILE),\n/* harmony export */   \"TYPE_DIRECTORY\": () => (/* binding */ TYPE_DIRECTORY)\n/* harmony export */ });\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar TYPE_DIRECTORY = 'd';\nvar TYPE_FILE = 'f';\n\nvar FilePickerBase = /*#__PURE__*/function (_Slim) {\n  _inherits(FilePickerBase, _Slim);\n\n  var _super = _createSuper(FilePickerBase);\n\n  function FilePickerBase() {\n    var _this;\n\n    _classCallCheck(this, FilePickerBase);\n\n    _this = _super.call(this);\n    _this.items = [];\n    _this.wsUrl = [_this.wsBaseUrl];\n    _this.wsChannel = \"\".concat(_this.wsEvent, \".\").concat(_this.channelHash);\n    _this.requestItems = _this.requestItems.bind(_assertThisInitialized(_this));\n    _this.onWsEvent = _this.onWsEvent.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(FilePickerBase, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      this.addEventListener('child-deleted', this.requestItems);\n    }\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved() {\n      this.leaveWebsocket();\n      this.removeEventListener('child-deleted', this.requestItems);\n    }\n  }, {\n    key: \"initWebsocket\",\n    value: function initWebsocket() {\n      this.channel = window.Echo.channel(this.wsChannel);\n      this.channel.listen(this.wsEvent, this.onWsEvent);\n      this.channel.subscribed(this.requestItems.bind(this));\n    }\n  }, {\n    key: \"leaveWebsocket\",\n    value: function leaveWebsocket() {\n      if (this.channel) {\n        this.channel.stopListening(this.wsEvent);\n        window.Echo.leave(this.wsChannel);\n      }\n    }\n  }, {\n    key: \"onWsEvent\",\n    value: function onWsEvent(e) {\n      var _this2 = this;\n\n      this.items = e.items;\n\n      if (!e.externalUpdate) {\n        _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.loading = false;\n        console.info('Received %d items in %s', this.items.length, this.path);\n      }\n\n      requestAnimationFrame(function () {\n        _this2.shadowRoot.querySelectorAll('filepicker-item').forEach(function (i) {\n          return i.update();\n        });\n      });\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick() {}\n  }, {\n    key: \"requestItems\",\n    value: function requestItems() {\n      try {\n        this.classList.add(this.loadingClass);\n        console.info('Request items in %s', this.path);\n        _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.loading = true;\n        _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.get(this.wsUrl.join(''));\n      } catch (error) {\n        _components_Request__WEBPACK_IMPORTED_MODULE_1__.Request.loading = false;\n      } finally {\n        this.classList.remove(this.loadingClass);\n      }\n    }\n  }, {\n    key: \"iconActive\",\n    set: function set(value) {\n      this.shadowRoot.querySelector('.icon-stack').classList.toggle('active', value);\n    }\n  }]);\n\n  return FilePickerBase;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nFilePickerBase.prototype.wsBaseUrl = '/file-picker/';\nFilePickerBase.prototype.wsEvent = 'FilePicker';\nFilePickerBase.prototype.loadingClass = 'loading';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9GaWxlUGlja2VyL0ZpbGVQaWNrZXJCYXNlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQSxJQUFNRyxjQUFjLEdBQUcsR0FBdkI7QUFDQSxJQUFNQyxTQUFTLEdBQUcsR0FBbEI7O0lBQ01DOzs7OztBQUVGLDRCQUFjO0FBQUE7O0FBQUE7O0FBQ1Y7QUFDQSxVQUFLQyxLQUFMLEdBQWEsRUFBYjtBQUNBLFVBQUtDLEtBQUwsR0FBYSxDQUFDLE1BQUtDLFNBQU4sQ0FBYjtBQUNBLFVBQUtDLFNBQUwsYUFBb0IsTUFBS0MsT0FBekIsY0FBb0MsTUFBS0MsV0FBekM7QUFDQSxVQUFLQyxZQUFMLEdBQW9CLE1BQUtBLFlBQUwsQ0FBa0JDLElBQWxCLCtCQUFwQjtBQUNBLFVBQUtDLFNBQUwsR0FBaUIsTUFBS0EsU0FBTCxDQUFlRCxJQUFmLCtCQUFqQjtBQU5VO0FBT2I7Ozs7V0FFRCxtQkFBVTtBQUNOLFdBQUtFLGdCQUFMLENBQXNCLGVBQXRCLEVBQXVDLEtBQUtILFlBQTVDO0FBQ0g7OztXQUVELHFCQUFZO0FBQ1IsV0FBS0ksY0FBTDtBQUNBLFdBQUtDLG1CQUFMLENBQXlCLGVBQXpCLEVBQTBDLEtBQUtMLFlBQS9DO0FBQ0g7OztXQUVELHlCQUFnQjtBQUNaLFdBQUtNLE9BQUwsR0FBZUMsTUFBTSxDQUFDQyxJQUFQLENBQVlGLE9BQVosQ0FBb0IsS0FBS1QsU0FBekIsQ0FBZjtBQUNBLFdBQUtTLE9BQUwsQ0FBYUcsTUFBYixDQUFvQixLQUFLWCxPQUF6QixFQUFrQyxLQUFLSSxTQUF2QztBQUNBLFdBQUtJLE9BQUwsQ0FBYUksVUFBYixDQUF3QixLQUFLVixZQUFMLENBQWtCQyxJQUFsQixDQUF1QixJQUF2QixDQUF4QjtBQUNIOzs7V0FFRCwwQkFBaUI7QUFDYixVQUFJLEtBQUtLLE9BQVQsRUFBa0I7QUFDZCxhQUFLQSxPQUFMLENBQWFLLGFBQWIsQ0FBMkIsS0FBS2IsT0FBaEM7QUFDQVMsUUFBQUEsTUFBTSxDQUFDQyxJQUFQLENBQVlJLEtBQVosQ0FBa0IsS0FBS2YsU0FBdkI7QUFDSDtBQUNKOzs7V0FFRCxtQkFBVWdCLENBQVYsRUFBYTtBQUFBOztBQUNULFdBQUtuQixLQUFMLEdBQWFtQixDQUFDLENBQUNuQixLQUFmOztBQUNBLFVBQUksQ0FBQ21CLENBQUMsQ0FBQ0MsY0FBUCxFQUF1QjtBQUNuQnhCLFFBQUFBLGdFQUFBLEdBQWtCLEtBQWxCO0FBQ0EwQixRQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSx5QkFBYixFQUF3QyxLQUFLdkIsS0FBTCxDQUFXd0IsTUFBbkQsRUFBMkQsS0FBS0MsSUFBaEU7QUFDSDs7QUFDREMsTUFBQUEscUJBQXFCLENBQUMsWUFBTTtBQUN4QixjQUFJLENBQUNDLFVBQUwsQ0FBZ0JDLGdCQUFoQixDQUFpQyxpQkFBakMsRUFBb0RDLE9BQXBELENBQTRELFVBQUFDLENBQUM7QUFBQSxpQkFBSUEsQ0FBQyxDQUFDQyxNQUFGLEVBQUo7QUFBQSxTQUE3RDtBQUNILE9BRm9CLENBQXJCO0FBR0g7OztXQUVELHVCQUFjLENBQ2I7OztXQUVELHdCQUFlO0FBQ1gsVUFBSTtBQUNBLGFBQUtDLFNBQUwsQ0FBZUMsR0FBZixDQUFtQixLQUFLQyxZQUF4QjtBQUNBWixRQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSxxQkFBYixFQUFvQyxLQUFLRSxJQUF6QztBQUNBN0IsUUFBQUEsZ0VBQUEsR0FBa0IsSUFBbEI7QUFDQUEsUUFBQUEsNERBQUEsQ0FBWSxLQUFLSyxLQUFMLENBQVdtQyxJQUFYLENBQWdCLEVBQWhCLENBQVo7QUFDSCxPQUxELENBS0UsT0FBT0MsS0FBUCxFQUFjO0FBQ1p6QyxRQUFBQSxnRUFBQSxHQUFrQixLQUFsQjtBQUNILE9BUEQsU0FPVTtBQUNOLGFBQUtvQyxTQUFMLENBQWVNLE1BQWYsQ0FBc0IsS0FBS0osWUFBM0I7QUFDSDtBQUNKOzs7U0FFRCxhQUFlSyxLQUFmLEVBQXNCO0FBQ2xCLFdBQUtaLFVBQUwsQ0FBZ0JhLGFBQWhCLENBQThCLGFBQTlCLEVBQTZDUixTQUE3QyxDQUF1RFMsTUFBdkQsQ0FBOEQsUUFBOUQsRUFBd0VGLEtBQXhFO0FBQ0g7Ozs7RUE5RHdCN0M7O0FBaUU3QkssY0FBYyxDQUFDMkMsU0FBZixDQUF5QnhDLFNBQXpCLEdBQXFDLGVBQXJDO0FBQ0FILGNBQWMsQ0FBQzJDLFNBQWYsQ0FBeUJ0QyxPQUF6QixHQUFtQyxZQUFuQztBQUNBTCxjQUFjLENBQUMyQyxTQUFmLENBQXlCUixZQUF6QixHQUF3QyxTQUF4QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0ZpbGVQaWNrZXIvRmlsZVBpY2tlckJhc2UuanM/YzVkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltLCBVdGlscyB9IGZyb20gJ0AvY29tcG9uZW50cy9saWInO1xuaW1wb3J0IHtSZXF1ZXN0fSBmcm9tICdAL2NvbXBvbmVudHMvUmVxdWVzdCdcblxuY29uc3QgVFlQRV9ESVJFQ1RPUlkgPSAnZCdcbmNvbnN0IFRZUEVfRklMRSA9ICdmJ1xuY2xhc3MgRmlsZVBpY2tlckJhc2UgZXh0ZW5kcyBTbGltIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXVxuICAgICAgICB0aGlzLndzVXJsID0gW3RoaXMud3NCYXNlVXJsXVxuICAgICAgICB0aGlzLndzQ2hhbm5lbCA9IGAke3RoaXMud3NFdmVudH0uJHt0aGlzLmNoYW5uZWxIYXNofWBcbiAgICAgICAgdGhpcy5yZXF1ZXN0SXRlbXMgPSB0aGlzLnJlcXVlc3RJdGVtcy5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMub25Xc0V2ZW50ID0gdGhpcy5vbldzRXZlbnQuYmluZCh0aGlzKVxuICAgIH1cblxuICAgIG9uQWRkZWQoKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2hpbGQtZGVsZXRlZCcsIHRoaXMucmVxdWVzdEl0ZW1zKVxuICAgIH1cblxuICAgIG9uUmVtb3ZlZCgpIHtcbiAgICAgICAgdGhpcy5sZWF2ZVdlYnNvY2tldCgpXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hpbGQtZGVsZXRlZCcsIHRoaXMucmVxdWVzdEl0ZW1zKVxuICAgIH1cblxuICAgIGluaXRXZWJzb2NrZXQoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IHdpbmRvdy5FY2hvLmNoYW5uZWwodGhpcy53c0NoYW5uZWwpXG4gICAgICAgIHRoaXMuY2hhbm5lbC5saXN0ZW4odGhpcy53c0V2ZW50LCB0aGlzLm9uV3NFdmVudCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5zdWJzY3JpYmVkKHRoaXMucmVxdWVzdEl0ZW1zLmJpbmQodGhpcykpXG4gICAgfVxuXG4gICAgbGVhdmVXZWJzb2NrZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWwpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5zdG9wTGlzdGVuaW5nKHRoaXMud3NFdmVudClcbiAgICAgICAgICAgIHdpbmRvdy5FY2hvLmxlYXZlKHRoaXMud3NDaGFubmVsKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Xc0V2ZW50KGUpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGUuaXRlbXNcbiAgICAgICAgaWYgKCFlLmV4dGVybmFsVXBkYXRlKSB7XG4gICAgICAgICAgICBSZXF1ZXN0LmxvYWRpbmcgPSBmYWxzZVxuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdSZWNlaXZlZCAlZCBpdGVtcyBpbiAlcycsIHRoaXMuaXRlbXMubGVuZ3RoLCB0aGlzLnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdmaWxlcGlja2VyLWl0ZW0nKS5mb3JFYWNoKGkgPT4gaS51cGRhdGUoKSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBoYW5kbGVDbGljaygpIHtcbiAgICB9XG5cbiAgICByZXF1ZXN0SXRlbXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQodGhpcy5sb2FkaW5nQ2xhc3MpXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ1JlcXVlc3QgaXRlbXMgaW4gJXMnLCB0aGlzLnBhdGgpXG4gICAgICAgICAgICBSZXF1ZXN0LmxvYWRpbmcgPSB0cnVlXG4gICAgICAgICAgICBSZXF1ZXN0LmdldCh0aGlzLndzVXJsLmpvaW4oJycpKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgUmVxdWVzdC5sb2FkaW5nID0gZmFsc2VcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmxvYWRpbmdDbGFzcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBpY29uQWN0aXZlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuaWNvbi1zdGFjaycpLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScsIHZhbHVlKVxuICAgIH1cbn1cblxuRmlsZVBpY2tlckJhc2UucHJvdG90eXBlLndzQmFzZVVybCA9ICcvZmlsZS1waWNrZXIvJ1xuRmlsZVBpY2tlckJhc2UucHJvdG90eXBlLndzRXZlbnQgPSAnRmlsZVBpY2tlcidcbkZpbGVQaWNrZXJCYXNlLnByb3RvdHlwZS5sb2FkaW5nQ2xhc3MgPSAnbG9hZGluZydcblxuZXhwb3J0IHsgRmlsZVBpY2tlckJhc2UsIFRZUEVfRklMRSwgVFlQRV9ESVJFQ1RPUlkgfSJdLCJuYW1lcyI6WyJTbGltIiwiVXRpbHMiLCJSZXF1ZXN0IiwiVFlQRV9ESVJFQ1RPUlkiLCJUWVBFX0ZJTEUiLCJGaWxlUGlja2VyQmFzZSIsIml0ZW1zIiwid3NVcmwiLCJ3c0Jhc2VVcmwiLCJ3c0NoYW5uZWwiLCJ3c0V2ZW50IiwiY2hhbm5lbEhhc2giLCJyZXF1ZXN0SXRlbXMiLCJiaW5kIiwib25Xc0V2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImxlYXZlV2Vic29ja2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNoYW5uZWwiLCJ3aW5kb3ciLCJFY2hvIiwibGlzdGVuIiwic3Vic2NyaWJlZCIsInN0b3BMaXN0ZW5pbmciLCJsZWF2ZSIsImUiLCJleHRlcm5hbFVwZGF0ZSIsImxvYWRpbmciLCJjb25zb2xlIiwiaW5mbyIsImxlbmd0aCIsInBhdGgiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzaGFkb3dSb290IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJpIiwidXBkYXRlIiwiY2xhc3NMaXN0IiwiYWRkIiwibG9hZGluZ0NsYXNzIiwiZ2V0Iiwiam9pbiIsImVycm9yIiwicmVtb3ZlIiwidmFsdWUiLCJxdWVyeVNlbGVjdG9yIiwidG9nZ2xlIiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/FilePicker/FilePickerBase.js\n");

/***/ }),

/***/ "./resources/js/components/FilePicker/FilePickerItem.js":
/*!**************************************************************!*\
  !*** ./resources/js/components/FilePicker/FilePickerItem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _FilePickerBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FilePickerBase */ \"./resources/js/components/FilePicker/FilePickerBase.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iconify/iconify */ \"./node_modules/@iconify/iconify/dist/iconify.min.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_iconify_iconify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\nvar FilePickerItem = /*#__PURE__*/function (_FilePickerBase) {\n  _inherits(FilePickerItem, _FilePickerBase);\n\n  var _super = _createSuper(FilePickerItem);\n\n  function FilePickerItem() {\n    var _this;\n\n    _classCallCheck(this, FilePickerItem);\n\n    _this = _super.call(this);\n\n    _this.wsUrl.push(encodeURIComponent(_this.path));\n\n    _this.isDirectory = _this.type === _FilePickerBase__WEBPACK_IMPORTED_MODULE_1__.TYPE_DIRECTORY;\n    _this.isFile = _this.type === _FilePickerBase__WEBPACK_IMPORTED_MODULE_1__.TYPE_FILE;\n    _this[\"delete\"] = _this[\"delete\"].bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(FilePickerItem, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(FilePickerItem.prototype), \"onAdded\", this).call(this);\n\n      requestAnimationFrame(function () {\n        return _this2.update();\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.title = this.buildTitle();\n      _iconify_iconify__WEBPACK_IMPORTED_MODULE_2___default().scan(this.shadowRoot);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick() {\n      if (_FilePickerBase__WEBPACK_IMPORTED_MODULE_1__.TYPE_DIRECTORY === this.type) {\n        this.dirClicked();\n      }\n\n      if (_FilePickerBase__WEBPACK_IMPORTED_MODULE_1__.TYPE_FILE === this.type) {\n        this.fileClicked();\n      }\n    }\n  }, {\n    key: \"dirClicked\",\n    value: function dirClicked() {\n      if (!this.items.length) {\n        this.iconActive = true;\n        this.initWebsocket();\n      } else {\n        this.items = [];\n        this.iconActive = false;\n        this.leaveWebsocket();\n      }\n    }\n  }, {\n    key: \"fileClicked\",\n    value: function fileClicked() {\n      var detail = {\n        node: this,\n        path: this.path,\n        channel: this.channelHash,\n        mime: this.mime,\n        size: this.size,\n        type: this.type\n      };\n      var parent = this.getRootNode().host;\n\n      if (parent) {\n        detail.parent = {\n          node: parent,\n          path: parent.path,\n          videoFiles: parent.videoFiles,\n          channelHash: parent.channelHash\n        };\n      }\n\n      this.iconActive = true;\n      document.dispatchEvent(new CustomEvent(\"file-clicked\", {\n        detail: detail\n      }));\n    }\n  }, {\n    key: \"buildTitle\",\n    value: function buildTitle() {\n      var result = this.path.trim();\n\n      if (this.mime) {\n        result += \" - \".concat(this.mime);\n      }\n\n      if (this.size) {\n        result += \" - \".concat(this.size);\n      }\n\n      if (this.lastModified) {\n        result += \" - \".concat(this.getLocalDate());\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getLocalDate\",\n    value: function getLocalDate() {\n      var d = new Date(this.lastModified * 1000);\n      var date = d.toLocaleDateString(d.getTimezoneOffset(), {\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\"\n      });\n      var time = d.toLocaleTimeString(d.getTimezoneOffset());\n      return \"\".concat(date, \" \").concat(time);\n    }\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n        var m;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                m = document.createElement(\"modal-confirm\");\n                m.header = \"Delete\";\n                m.content = \"Delete file \".concat(this.path, \"?\");\n                document.body.appendChild(m);\n                _context.prev = 4;\n                _context.next = 7;\n                return m.confirm();\n\n              case 7:\n                _context.next = 9;\n                return _components_Request__WEBPACK_IMPORTED_MODULE_4__.Request.delete(\"/file-picker/\".concat(encodeURIComponent(this.path)));\n\n              case 9:\n                this.getRootNode().host.dispatchEvent(new CustomEvent(\"child-deleted\"));\n                _context.next = 14;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](4);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 12]]);\n      }));\n\n      function _delete() {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n  }, {\n    key: \"icon\",\n    get: function get() {\n      if (this.isDirectory) {\n        return \"mdi-folder\";\n      }\n\n      switch (this.fileType) {\n        case \"video\":\n          return \"mdi-filmstrip\";\n\n        case \"text\":\n          return \"mdi-note-text-outline\";\n\n        case \"image\":\n          return \"mdi-file-image-outline\";\n\n        default:\n          return \"mdi-file\";\n      }\n    }\n  }, {\n    key: \"title\",\n    get: function get() {\n      return this.buildTitle();\n    }\n  }, {\n    key: \"fileType\",\n    get: function get() {\n      var mime = this.mime.split(\"/\").shift().toLowerCase();\n\n      switch (mime) {\n        case \"video\":\n        case \"text\":\n        case \"image\":\n          return mime;\n\n        default:\n          return \"unknown\";\n      }\n    }\n  }, {\n    key: \"hasFiles\",\n    get: function get() {\n      return this.isDirectory && this.items.filter(function (i) {\n        return i.type === _FilePickerBase__WEBPACK_IMPORTED_MODULE_1__.TYPE_FILE;\n      }).length > 0;\n    }\n  }, {\n    key: \"videoFiles\",\n    get: function get() {\n      if (this.hasFiles) {\n        return this.items.filter(function (i) {\n          return i.type === _FilePickerBase__WEBPACK_IMPORTED_MODULE_1__.TYPE_FILE && \"video\" === i.mime.split(\"/\").shift().toLowerCase();\n        });\n      }\n\n      return [];\n    }\n  }]);\n\n  return FilePickerItem;\n}(_FilePickerBase__WEBPACK_IMPORTED_MODULE_1__.FilePickerBase);\n\nvar CSS =\n/*css*/\n\"\\n<style>\\n    :host {\\n        display: block;\\n    }\\n    :host(.\".concat(_FilePickerBase__WEBPACK_IMPORTED_MODULE_1__.FilePickerBase.prototype.loadingClass, \") {\\n        animation: pulse 1s infinite;\\n    }\\n    span {\\n        display: inline-block;\\n        cursor: pointer;\\n        padding: calc(var(--gutter-base) / 4) calc(var(--gutter-base) / 2);\\n    }\\n    :host(:hover) span {\\n        background-color: var(--clr-bg-100);\\n    }\\n    :host(:hover) .icon-stack:not(:disabled):not(.active):not(button) svg.hover {\\n        opacity: 1;\\n    }\\n    filepicker-item {\\n        margin-left: var(--gutter-base);\\n    }\\n    @keyframes pulse {\\n        0% {\\n            opacity: 1;\\n        }\\n        50% {\\n            opacity: .5;\\n        }\\n        100% {\\n            opacity: 1;\\n        }\\n    }\\n    .item {\\n        display: flex;\\n        align-items: center;\\n        justify-content: space-between;\\n    }\\n    .label {\\n        margin-right: auto;\\n    }\\n    .icon-stack {\\n        width: 1em;\\n        height: 1em;\\n        display: inline-block;\\n    }\\n    .file.internal button.delete {\\n        font-size: 1rem;\\n        display: revert;\\n    }\\n    .dummy-button {\\n        width: 1rem;\\n    }\\n    .info {\\n        font-size: .85em;\\n    }\\n</style>\\n\").concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_3__.ICON_STACK_CSS, \"\\n\");\nvar ICON_TEMPLATE =\n/*html*/\n\"\\n<div class=\\\"icon-stack\\\">\\n    <span class=\\\"iconify inactive\\\" data-icon=\\\"{{ this.icon }}\\\"></span>\\n    <span class=\\\"iconify active\\\" data-icon=\\\"{{ this.icon }}\\\"></span>\\n    <span class=\\\"iconify hover\\\" data-icon=\\\"{{ this.icon }}\\\"></span>\\n</div>\\n\";\n/** preserve whitespaces! */\n\nvar ITEM_TEMPLATE =\n/*html*/\n\"\\n<filepicker-item\\n    *foreach=\\\"{{ this.items }}\\\"\\n    .type=\\\"{{ item.type }}\\\"\\n    .path=\\\"{{ item.path }}\\\"\\n    .channel-hash=\\\"{{ item.channel }}\\\"\\n    .mime=\\\"{{ item.mime }}\\\"\\n    .size=\\\"{{ item.size }}\\\"\\n    .last-modified=\\\"{{ item.lastModified }}\\\"\\n    .internal=\\\"{{ item.internal }}\\\"\\n    .name=\\\"{{ item.name }}\\\"\\n>\\n        {{ item.name }}\\n</filepicker-item>\\n\";\nFilePickerItem.template =\n/*html*/\n\"\\n\".concat(CSS, \"\\n<div class=\\\"{{ (this.isFile ? 'file' : 'dir') + (this.internal ? ' internal' : '') }}\\\">\\n    <div class=\\\"item\\\">\\n        \").concat(ICON_TEMPLATE, \"\\n        <span @click=\\\"this.handleClick()\\\" title=\\\"{{ this.title }}\\\" class=\\\"label\\\">\\n            <slot></slot>\\n        </span>\\n        <span *if=\\\"{{ this.type === 'f' }}\\\" class=\\\"info\\\">{{ this.size }}</span>\\n        <span *if=\\\"{{ this.type === 'f' }}\\\" class=\\\"info\\\">{{ this.getLocalDate() }}</span>\\n        <button *if=\\\"{{ this.internal }}\\\" class=\\\"icon-stack delete\\\" @click=\\\"{{ this.delete }}\\\">\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-trash-can-outline\\\"></span>\\n            <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-trash-can-outline\\\"></span>\\n        </button>\\n        <div class=\\\"dummy-button\\\" *if=\\\"{{ !this.internal }}\\\"></div>\\n    </div>\\n    \").concat(ITEM_TEMPLATE, \"\\n</div>\\n\");\ncustomElements.define(\"filepicker-item\", FilePickerItem);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ITEM_TEMPLATE);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9GaWxlUGlja2VyL0ZpbGVQaWNrZXJJdGVtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7SUFFTU07Ozs7O0FBQ0YsNEJBQWM7QUFBQTs7QUFBQTs7QUFDVjs7QUFDQSxVQUFLQyxLQUFMLENBQVdDLElBQVgsQ0FBZ0JDLGtCQUFrQixDQUFDLE1BQUtDLElBQU4sQ0FBbEM7O0FBQ0EsVUFBS0MsV0FBTCxHQUFtQixNQUFLQyxJQUFMLEtBQWNYLDJEQUFqQztBQUNBLFVBQUtZLE1BQUwsR0FBYyxNQUFLRCxJQUFMLEtBQWNWLHNEQUE1QjtBQUNBLHNCQUFjLGdCQUFZWSxJQUFaLCtCQUFkO0FBTFU7QUFNYjs7OztXQUVELG1CQUFVO0FBQUE7O0FBQ047O0FBQ0FDLE1BQUFBLHFCQUFxQixDQUFDO0FBQUEsZUFBTSxNQUFJLENBQUNDLE1BQUwsRUFBTjtBQUFBLE9BQUQsQ0FBckI7QUFDSDs7O1dBRUQsa0JBQVM7QUFDTCxXQUFLQyxLQUFMLEdBQWEsS0FBS0MsVUFBTCxFQUFiO0FBQ0FmLE1BQUFBLDREQUFBLENBQWEsS0FBS2lCLFVBQWxCO0FBQ0g7OztXQUVELHVCQUFjO0FBQ1YsVUFBSW5CLDJEQUFjLEtBQUssS0FBS1csSUFBNUIsRUFBa0M7QUFDOUIsYUFBS1MsVUFBTDtBQUNIOztBQUNELFVBQUluQixzREFBUyxLQUFLLEtBQUtVLElBQXZCLEVBQTZCO0FBQ3pCLGFBQUtVLFdBQUw7QUFDSDtBQUNKOzs7V0FFRCxzQkFBYTtBQUNULFVBQUksQ0FBQyxLQUFLQyxLQUFMLENBQVdDLE1BQWhCLEVBQXdCO0FBQ3BCLGFBQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxhQUFLQyxhQUFMO0FBQ0gsT0FIRCxNQUdPO0FBQ0gsYUFBS0gsS0FBTCxHQUFhLEVBQWI7QUFDQSxhQUFLRSxVQUFMLEdBQWtCLEtBQWxCO0FB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LEVBQVA7QUFDSDs7OztFQXRKd0JqRTs7QUF5SjdCLElBQU1xRSxHQUFHO0FBQUc7QUFBSCw2RUFLSXJFLGtGQUxKLDZtQ0F5RFBJLHVFQXpETyxPQUFUO0FBNERBLElBQU1vRSxhQUFhO0FBQUc7QUFBSCx1UUFBbkI7QUFRQTs7QUFDQSxJQUFNQyxhQUFhO0FBQUc7QUFBSCxxWUFBbkI7QUFnQkFuRSxjQUFjLENBQUNvRSxRQUFmO0FBQTBCO0FBQTFCLFlBQ0VMLEdBREYsNElBSVVHLGFBSlYsbXNCQWdCTUMsYUFoQk47QUFvQkFFLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixpQkFBdEIsRUFBeUN0RSxjQUF6QztBQUVBLGlFQUFlbUUsYUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0ZpbGVQaWNrZXIvRmlsZVBpY2tlckl0ZW0uanM/ZjYxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGaWxlUGlja2VyQmFzZSwgVFlQRV9ESVJFQ1RPUlksIFRZUEVfRklMRSB9IGZyb20gJy4vRmlsZVBpY2tlckJhc2UnXG5pbXBvcnQgSWNvbmlmeSBmcm9tICdAaWNvbmlmeS9pY29uaWZ5J1xuaW1wb3J0IHsgSUNPTl9TVEFDS19DU1MgfSBmcm9tICdAL2NvbXBvbmVudHMvSWNvbnMvU3RhY2suY3NzJ1xuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvUmVxdWVzdFwiO1xuXG5jbGFzcyBGaWxlUGlja2VySXRlbSBleHRlbmRzIEZpbGVQaWNrZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53c1VybC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnBhdGgpKTtcbiAgICAgICAgdGhpcy5pc0RpcmVjdG9yeSA9IHRoaXMudHlwZSA9PT0gVFlQRV9ESVJFQ1RPUlk7XG4gICAgICAgIHRoaXMuaXNGaWxlID0gdGhpcy50eXBlID09PSBUWVBFX0ZJTEU7XG4gICAgICAgIHRoaXMuZGVsZXRlID0gdGhpcy5kZWxldGUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBvbkFkZGVkKCkge1xuICAgICAgICBzdXBlci5vbkFkZGVkKCk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnVwZGF0ZSgpKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmJ1aWxkVGl0bGUoKTtcbiAgICAgICAgSWNvbmlmeS5zY2FuKHRoaXMuc2hhZG93Um9vdCk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIGlmIChUWVBFX0RJUkVDVE9SWSA9PT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmRpckNsaWNrZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVFlQRV9GSUxFID09PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZUNsaWNrZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpckNsaWNrZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbkFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmluaXRXZWJzb2NrZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaWNvbkFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sZWF2ZVdlYnNvY2tldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlsZUNsaWNrZWQoKSB7XG4gICAgICAgIGNvbnN0IGRldGFpbCA9IHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzLmNoYW5uZWxIYXNoLFxuICAgICAgICAgICAgbWltZTogdGhpcy5taW1lLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFJvb3ROb2RlKCkuaG9zdDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgZGV0YWlsLnBhcmVudCA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiBwYXJlbnQsXG4gICAgICAgICAgICAgICAgcGF0aDogcGFyZW50LnBhdGgsXG4gICAgICAgICAgICAgICAgdmlkZW9GaWxlczogcGFyZW50LnZpZGVvRmlsZXMsXG4gICAgICAgICAgICAgICAgY2hhbm5lbEhhc2g6IHBhcmVudC5jaGFubmVsSGFzaCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pY29uQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJmaWxlLWNsaWNrZWRcIiwgeyBkZXRhaWwgfSkpO1xuICAgIH1cblxuICAgIGJ1aWxkVGl0bGUoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhdGgudHJpbSgpO1xuICAgICAgICBpZiAodGhpcy5taW1lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYCAtICR7dGhpcy5taW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGAgLSAke3RoaXMuc2l6ZX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGAgLSAke3RoaXMuZ2V0TG9jYWxEYXRlKCl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldExvY2FsRGF0ZSgpIHtcbiAgICAgICAgbGV0IGQgPSBuZXcgRGF0ZSh0aGlzLmxhc3RNb2RpZmllZCAqIDEwMDApO1xuICAgICAgICBsZXQgZGF0ZSA9IGQudG9Mb2NhbGVEYXRlU3RyaW5nKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSwge1xuICAgICAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICAgICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpbWUgPSBkLnRvTG9jYWxlVGltZVN0cmluZyhkLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgICAgICByZXR1cm4gYCR7ZGF0ZX0gJHt0aW1lfWA7XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlKCkge1xuICAgICAgICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1vZGFsLWNvbmZpcm1cIik7XG4gICAgICAgIG0uaGVhZGVyID0gXCJEZWxldGVcIjtcbiAgICAgICAgbS5jb250ZW50ID0gYERlbGV0ZSBmaWxlICR7dGhpcy5wYXRofT9gO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbS5jb25maXJtKCk7XG4gICAgICAgICAgICBhd2FpdCBSZXF1ZXN0LmRlbGV0ZShcbiAgICAgICAgICAgICAgICBgL2ZpbGUtcGlja2VyLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMucGF0aCl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0Um9vdE5vZGUoKS5ob3N0LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFwiY2hpbGQtZGVsZXRlZFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfVxuXG4gICAgZ2V0IGljb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJtZGktZm9sZGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLmZpbGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtZGktZmlsbXN0cmlwXCI7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIm1kaS1ub3RlLXRleHQtb3V0bGluZVwiO1xuICAgICAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibWRpLWZpbGUtaW1hZ2Utb3V0bGluZVwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtZGktZmlsZVwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFRpdGxlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGZpbGVUeXBlKCkge1xuICAgICAgICBsZXQgbWltZSA9IHRoaXMubWltZS5zcGxpdChcIi9cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKG1pbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtaW1lO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaGFzRmlsZXMoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzRGlyZWN0b3J5ICYmXG4gICAgICAgICAgICB0aGlzLml0ZW1zLmZpbHRlcigoaSkgPT4gaS50eXBlID09PSBUWVBFX0ZJTEUpLmxlbmd0aCA+IDBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXQgdmlkZW9GaWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRmlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihcbiAgICAgICAgICAgICAgICAoaSkgPT5cbiAgICAgICAgICAgICAgICAgICAgaS50eXBlID09PSBUWVBFX0ZJTEUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJ2aWRlb1wiID09PSBpLm1pbWUuc3BsaXQoXCIvXCIpLnNoaWZ0KCkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG5jb25zdCBDU1MgPSAvKmNzcyovIGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIH1cbiAgICA6aG9zdCguJHtGaWxlUGlja2VyQmFzZS5wcm90b3R5cGUubG9hZGluZ0NsYXNzfSkge1xuICAgICAgICBhbmltYXRpb246IHB1bHNlIDFzIGluZmluaXRlO1xuICAgIH1cbiAgICBzcGFuIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHBhZGRpbmc6IGNhbGModmFyKC0tZ3V0dGVyLWJhc2UpIC8gNCkgY2FsYyh2YXIoLS1ndXR0ZXItYmFzZSkgLyAyKTtcbiAgICB9XG4gICAgOmhvc3QoOmhvdmVyKSBzcGFuIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY2xyLWJnLTEwMCk7XG4gICAgfVxuICAgIDpob3N0KDpob3ZlcikgLmljb24tc3RhY2s6bm90KDpkaXNhYmxlZCk6bm90KC5hY3RpdmUpOm5vdChidXR0b24pIHN2Zy5ob3ZlciB7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuICAgIGZpbGVwaWNrZXItaXRlbSB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1ndXR0ZXItYmFzZSk7XG4gICAgfVxuICAgIEBrZXlmcmFtZXMgcHVsc2Uge1xuICAgICAgICAwJSB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB9XG4gICAgICAgIDUwJSB7XG4gICAgICAgICAgICBvcGFjaXR5OiAuNTtcbiAgICAgICAgfVxuICAgICAgICAxMDAlIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLml0ZW0ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgfVxuICAgIC5sYWJlbCB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogYXV0bztcbiAgICB9XG4gICAgLmljb24tc3RhY2sge1xuICAgICAgICB3aWR0aDogMWVtO1xuICAgICAgICBoZWlnaHQ6IDFlbTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIH1cbiAgICAuZmlsZS5pbnRlcm5hbCBidXR0b24uZGVsZXRlIHtcbiAgICAgICAgZm9udC1zaXplOiAxcmVtO1xuICAgICAgICBkaXNwbGF5OiByZXZlcnQ7XG4gICAgfVxuICAgIC5kdW1teS1idXR0b24ge1xuICAgICAgICB3aWR0aDogMXJlbTtcbiAgICB9XG4gICAgLmluZm8ge1xuICAgICAgICBmb250LXNpemU6IC44NWVtO1xuICAgIH1cbjwvc3R5bGU+XG4ke0lDT05fU1RBQ0tfQ1NTfVxuYDtcblxuY29uc3QgSUNPTl9URU1QTEFURSA9IC8qaHRtbCovIGBcbjxkaXYgY2xhc3M9XCJpY29uLXN0YWNrXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5IGluYWN0aXZlXCIgZGF0YS1pY29uPVwie3sgdGhpcy5pY29uIH19XCI+PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeSBhY3RpdmVcIiBkYXRhLWljb249XCJ7eyB0aGlzLmljb24gfX1cIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5IGhvdmVyXCIgZGF0YS1pY29uPVwie3sgdGhpcy5pY29uIH19XCI+PC9zcGFuPlxuPC9kaXY+XG5gO1xuXG4vKiogcHJlc2VydmUgd2hpdGVzcGFjZXMhICovXG5jb25zdCBJVEVNX1RFTVBMQVRFID0gLypodG1sKi8gYFxuPGZpbGVwaWNrZXItaXRlbVxuICAgICpmb3JlYWNoPVwie3sgdGhpcy5pdGVtcyB9fVwiXG4gICAgLnR5cGU9XCJ7eyBpdGVtLnR5cGUgfX1cIlxuICAgIC5wYXRoPVwie3sgaXRlbS5wYXRoIH19XCJcbiAgICAuY2hhbm5lbC1oYXNoPVwie3sgaXRlbS5jaGFubmVsIH19XCJcbiAgICAubWltZT1cInt7IGl0ZW0ubWltZSB9fVwiXG4gICAgLnNpemU9XCJ7eyBpdGVtLnNpemUgfX1cIlxuICAgIC5sYXN0LW1vZGlmaWVkPVwie3sgaXRlbS5sYXN0TW9kaWZpZWQgfX1cIlxuICAgIC5pbnRlcm5hbD1cInt7IGl0ZW0uaW50ZXJuYWwgfX1cIlxuICAgIC5uYW1lPVwie3sgaXRlbS5uYW1lIH19XCJcbj5cbiAgICAgICAge3sgaXRlbS5uYW1lIH19XG48L2ZpbGVwaWNrZXItaXRlbT5cbmA7XG5cbkZpbGVQaWNrZXJJdGVtLnRlbXBsYXRlID0gLypodG1sKi8gYFxuJHtDU1N9XG48ZGl2IGNsYXNzPVwie3sgKHRoaXMuaXNGaWxlID8gJ2ZpbGUnIDogJ2RpcicpICsgKHRoaXMuaW50ZXJuYWwgPyAnIGludGVybmFsJyA6ICcnKSB9fVwiPlxuICAgIDxkaXYgY2xhc3M9XCJpdGVtXCI+XG4gICAgICAgICR7SUNPTl9URU1QTEFURX1cbiAgICAgICAgPHNwYW4gQGNsaWNrPVwidGhpcy5oYW5kbGVDbGljaygpXCIgdGl0bGU9XCJ7eyB0aGlzLnRpdGxlIH19XCIgY2xhc3M9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuICppZj1cInt7IHRoaXMudHlwZSA9PT0gJ2YnIH19XCIgY2xhc3M9XCJpbmZvXCI+e3sgdGhpcy5zaXplIH19PC9zcGFuPlxuICAgICAgICA8c3BhbiAqaWY9XCJ7eyB0aGlzLnR5cGUgPT09ICdmJyB9fVwiIGNsYXNzPVwiaW5mb1wiPnt7IHRoaXMuZ2V0TG9jYWxEYXRlKCkgfX08L3NwYW4+XG4gICAgICAgIDxidXR0b24gKmlmPVwie3sgdGhpcy5pbnRlcm5hbCB9fVwiIGNsYXNzPVwiaWNvbi1zdGFjayBkZWxldGVcIiBAY2xpY2s9XCJ7eyB0aGlzLmRlbGV0ZSB9fVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLXRyYXNoLWNhbi1vdXRsaW5lXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5IGhvdmVyXCIgZGF0YS1pY29uPVwibWRpLXRyYXNoLWNhbi1vdXRsaW5lXCI+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImR1bW15LWJ1dHRvblwiICppZj1cInt7ICF0aGlzLmludGVybmFsIH19XCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgJHtJVEVNX1RFTVBMQVRFfVxuPC9kaXY+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJmaWxlcGlja2VyLWl0ZW1cIiwgRmlsZVBpY2tlckl0ZW0pO1xuXG5leHBvcnQgZGVmYXVsdCBJVEVNX1RFTVBMQVRFOyJdLCJuYW1lcyI6WyJGaWxlUGlja2VyQmFzZSIsIlRZUEVfRElSRUNUT1JZIiwiVFlQRV9GSUxFIiwiSWNvbmlmeSIsIklDT05fU1RBQ0tfQ1NTIiwiUmVxdWVzdCIsIkZpbGVQaWNrZXJJdGVtIiwid3NVcmwiLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicGF0aCIsImlzRGlyZWN0b3J5IiwidHlwZSIsImlzRmlsZSIsImJpbmQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ1cGRhdGUiLCJ0aXRsZSIsImJ1aWxkVGl0bGUiLCJzY2FuIiwic2hhZG93Um9vdCIsImRpckNsaWNrZWQiLCJmaWxlQ2xpY2tlZCIsIml0ZW1zIiwibGVuZ3RoIiwiaWNvbkFjdGl2ZSIsImluaXRXZWJzb2NrZXQiLCJsZWF2ZVdlYnNvY2tldCIsImRldGFpbCIsIm5vZGUiLCJjaGFubmVsIiwiY2hhbm5lbEhhc2giLCJtaW1lIiwic2l6ZSIsInBhcmVudCIsImdldFJvb3ROb2RlIiwiaG9zdCIsInZpZGVvRmlsZXMiLCJkb2N1bWVudCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsInJlc3VsdCIsInRyaW0iLCJsYXN0TW9kaWZpZWQiLCJnZXRMb2NhbERhdGUiLCJkIiwiRGF0ZSIsImRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJnZXRUaW1lem9uZU9mZnNldCIsInllYXIiLCJtb250aCIsImRheSIsInRpbWUiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJtIiwiY3JlYXRlRWxlbWVudCIsImhlYWRlciIsImNvbnRlbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjb25maXJtIiwiZmlsZVR5cGUiLCJzcGxpdCIsInNoaWZ0IiwidG9Mb3dlckNhc2UiLCJmaWx0ZXIiLCJpIiwiaGFzRmlsZXMiLCJDU1MiLCJwcm90b3R5cGUiLCJsb2FkaW5nQ2xhc3MiLCJJQ09OX1RFTVBMQVRFIiwiSVRFTV9URU1QTEFURSIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/FilePicker/FilePickerItem.js\n");

/***/ }),

/***/ "./resources/js/components/FilePicker/index.js":
/*!*****************************************************!*\
  !*** ./resources/js/components/FilePicker/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _FilePickerBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FilePickerBase */ \"./resources/js/components/FilePicker/FilePickerBase.js\");\n/* harmony import */ var _FilePickerItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FilePickerItem */ \"./resources/js/components/FilePicker/FilePickerItem.js\");\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iconify/iconify */ \"./node_modules/@iconify/iconify/dist/iconify.min.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_iconify_iconify__WEBPACK_IMPORTED_MODULE_3__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\nvar FilePicker = /*#__PURE__*/function (_FilePickerBase) {\n  _inherits(FilePicker, _FilePickerBase);\n\n  var _super = _createSuper(FilePicker);\n\n  function FilePicker() {\n    _classCallCheck(this, FilePicker);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(FilePicker, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this = this;\n\n      _get(_getPrototypeOf(FilePicker.prototype), \"onAdded\", this).call(this);\n\n      this.path = \"root\";\n      this.initWebsocket();\n      this.reload = this.reload.bind(this);\n      requestAnimationFrame(function () {\n        return _iconify_iconify__WEBPACK_IMPORTED_MODULE_3___default().scan(_this.shadowRoot);\n      });\n    }\n  }, {\n    key: \"reload\",\n    value: function reload(e) {\n      this.items = [];\n      this.requestItems();\n    }\n  }]);\n\n  return FilePicker;\n}(_FilePickerBase__WEBPACK_IMPORTED_MODULE_0__.FilePickerBase);\n\nFilePicker.template =\n/*html*/\n\"\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_2__.ICON_STACK_CSS, \"\\n<style>\\n    :host {\\n        display: grid;\\n        grid-template-rows: min-content 1fr;\\n    }\\n.toolbar {\\n    display: grid;\\n    grid-auto-flow: column;\\n    justify-content: end;\\n    grid-column-gap: .25rem;\\n}\\n.toolbar .tool-button {\\n    width: 1.25em;\\n    height: 1.25em;\\n    font-size: 1.25rem;\\n    cursor: pointer;\\n    border: 1px solid var(--clr-bg-100);\\n    background: var(--clr-bg-150);\\n    display: grid;\\n    place-items: center;\\n    border-radius: .125rem;\\n}\\nmain {\\n    overflow: auto;\\n    padding: 0 1rem;\\n}\\n</style>\\n<div class=\\\"toolbar\\\">\\n    <div class=\\\"tool-button\\\" @click=\\\"{{ this.reload }}\\\">\\n        <div class=\\\"icon-stack\\\">\\n            <span class=\\\"iconify inactive\\\" data-icon=\\\"mdi-reload\\\"></span>\\n            <span class=\\\"iconify active\\\" data-icon=\\\"mdi-reload\\\"></span>\\n            <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-reload\\\"></span>\\n        </div>\\n    </div>\\n</div>\\n<main>\\n    <div>\\n        \").concat(_FilePickerItem__WEBPACK_IMPORTED_MODULE_1__.default, \"\\n    </div>\\n</main>\\n\");\ncustomElements.define(\"filepicker-root\", FilePicker);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9GaWxlUGlja2VyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7SUFFTUk7Ozs7Ozs7Ozs7Ozs7V0FDRixtQkFBVTtBQUFBOztBQUNOOztBQUNBLFdBQUtDLElBQUwsR0FBWSxNQUFaO0FBQ0EsV0FBS0MsYUFBTDtBQUNBLFdBQUtDLE1BQUwsR0FBYyxLQUFLQSxNQUFMLENBQVlDLElBQVosQ0FBaUIsSUFBakIsQ0FBZDtBQUNBQyxNQUFBQSxxQkFBcUIsQ0FBQztBQUFBLGVBQU1QLDREQUFBLENBQWEsS0FBSSxDQUFDUyxVQUFsQixDQUFOO0FBQUEsT0FBRCxDQUFyQjtBQUNIOzs7V0FFRCxnQkFBT0MsQ0FBUCxFQUFVO0FBQ04sV0FBS0MsS0FBTCxHQUFhLEVBQWI7QUFDQSxXQUFLQyxZQUFMO0FBQ0g7Ozs7RUFab0JkOztBQWV6QkksVUFBVSxDQUFDVyxRQUFYO0FBQXNCO0FBQXRCLFlBQ0VkLHVFQURGLDA5QkF3Q1VFLG9EQXhDVjtBQTRDQWEsY0FBYyxDQUFDQyxNQUFmLENBQXNCLGlCQUF0QixFQUF5Q2IsVUFBekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9GaWxlUGlja2VyL2luZGV4LmpzP2VlZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRmlsZVBpY2tlckJhc2UgfSBmcm9tIFwiLi9GaWxlUGlja2VyQmFzZVwiO1xuaW1wb3J0IFwiLi9GaWxlUGlja2VySXRlbVwiO1xuaW1wb3J0IHsgSUNPTl9TVEFDS19DU1MgfSBmcm9tIFwiQC9jb21wb25lbnRzL0ljb25zL1N0YWNrLmNzc1wiO1xuaW1wb3J0IEljb25pZnkgZnJvbSBcIkBpY29uaWZ5L2ljb25pZnlcIjtcblxuaW1wb3J0IElURU1fVEVNUExBVEUgZnJvbSBcIi4vRmlsZVBpY2tlckl0ZW1cIjtcblxuY2xhc3MgRmlsZVBpY2tlciBleHRlbmRzIEZpbGVQaWNrZXJCYXNlIHtcbiAgICBvbkFkZGVkKCkge1xuICAgICAgICBzdXBlci5vbkFkZGVkKCk7XG4gICAgICAgIHRoaXMucGF0aCA9IFwicm9vdFwiO1xuICAgICAgICB0aGlzLmluaXRXZWJzb2NrZXQoKTtcbiAgICAgICAgdGhpcy5yZWxvYWQgPSB0aGlzLnJlbG9hZC5iaW5kKHRoaXMpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gSWNvbmlmeS5zY2FuKHRoaXMuc2hhZG93Um9vdCkpO1xuICAgIH1cblxuICAgIHJlbG9hZChlKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SXRlbXMoKTtcbiAgICB9XG59XG5cbkZpbGVQaWNrZXIudGVtcGxhdGUgPSAvKmh0bWwqLyBgXG4ke0lDT05fU1RBQ0tfQ1NTfVxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogZ3JpZDtcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiBtaW4tY29udGVudCAxZnI7XG4gICAgfVxuLnRvb2xiYXIge1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC1hdXRvLWZsb3c6IGNvbHVtbjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGVuZDtcbiAgICBncmlkLWNvbHVtbi1nYXA6IC4yNXJlbTtcbn1cbi50b29sYmFyIC50b29sLWJ1dHRvbiB7XG4gICAgd2lkdGg6IDEuMjVlbTtcbiAgICBoZWlnaHQ6IDEuMjVlbTtcbiAgICBmb250LXNpemU6IDEuMjVyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWNsci1iZy0xMDApO1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWNsci1iZy0xNTApO1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgcGxhY2UtaXRlbXM6IGNlbnRlcjtcbiAgICBib3JkZXItcmFkaXVzOiAuMTI1cmVtO1xufVxubWFpbiB7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgcGFkZGluZzogMCAxcmVtO1xufVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJ0b29sYmFyXCI+XG4gICAgPGRpdiBjbGFzcz1cInRvb2wtYnV0dG9uXCIgQGNsaWNrPVwie3sgdGhpcy5yZWxvYWQgfX1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImljb24tc3RhY2tcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeSBpbmFjdGl2ZVwiIGRhdGEtaWNvbj1cIm1kaS1yZWxvYWRcIj48L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgYWN0aXZlXCIgZGF0YS1pY29uPVwibWRpLXJlbG9hZFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeSBob3ZlclwiIGRhdGEtaWNvbj1cIm1kaS1yZWxvYWRcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG48bWFpbj5cbiAgICA8ZGl2PlxuICAgICAgICAke0lURU1fVEVNUExBVEV9XG4gICAgPC9kaXY+XG48L21haW4+XG5gO1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwiZmlsZXBpY2tlci1yb290XCIsIEZpbGVQaWNrZXIpO1xuIl0sIm5hbWVzIjpbIkZpbGVQaWNrZXJCYXNlIiwiSUNPTl9TVEFDS19DU1MiLCJJY29uaWZ5IiwiSVRFTV9URU1QTEFURSIsIkZpbGVQaWNrZXIiLCJwYXRoIiwiaW5pdFdlYnNvY2tldCIsInJlbG9hZCIsImJpbmQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzY2FuIiwic2hhZG93Um9vdCIsImUiLCJpdGVtcyIsInJlcXVlc3RJdGVtcyIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/FilePicker/index.js\n");

/***/ }),

/***/ "./resources/js/components/Icons/Stack.css.js":
/*!****************************************************!*\
  !*** ./resources/js/components/Icons/Stack.css.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ICON_STACK_CSS\": () => (/* binding */ ICON_STACK_CSS)\n/* harmony export */ });\nvar ICON_STACK_CSS =\n/*css*/\n\"\\n<style>\\n.icon-stack {\\n    position: relative;\\n    width: 1em;\\n    height: 1em;\\n}\\nbutton.icon-stack {\\n    border: unset;\\n    background: unset;\\n}\\n.icon-stack svg {\\n    position: absolute;\\n    inset: 0;\\n    opacity: 1;\\n}\\n.icon-stack svg {\\n    transition: opacity var(--transition-medium) ease-out, color var(--transition-medium) ease-out;\\n}\\n.icon-stack svg {\\n    color: var(--clr-text-0);\\n}\\n.icon-stack:disabled svg {\\n    color: var(--clr-disabled);\\n}\\n.icon-stack:disabled svg.hover {\\n    opacity: 0;\\n}\\n.icon-stack:not(:disabled) svg.hover,\\n.icon-stack:not(:disabled) svg.active,\\n.icon-stack:not(:disabled).active svg.inactive {\\n    opacity: 0;\\n}\\n.icon-stack:not(:disabled) svg.hover,\\n.icon-stack:not(:disabled) svg.active {\\n    color: var(--active-icon-clr);\\n    filter: var(--active-icon-glow);\\n}\\n.icon-stack:not(:disabled):hover svg.hover,\\n.icon-stack:not(:disabled).active svg.active {\\n    opacity: 1;\\n}\\n.icon-stack:not(:disabled).active:hover svg.hover {\\n    opacity: 0;\\n}\\n</style>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9JY29ucy9TdGFjay5jc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLElBQU1BLGNBQWM7QUFBRztBQUFILDBnQ0FBcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9JY29ucy9TdGFjay5jc3MuanM/YmVkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgSUNPTl9TVEFDS19DU1MgPSAvKmNzcyovIGBcbjxzdHlsZT5cbi5pY29uLXN0YWNrIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgd2lkdGg6IDFlbTtcbiAgICBoZWlnaHQ6IDFlbTtcbn1cbmJ1dHRvbi5pY29uLXN0YWNrIHtcbiAgICBib3JkZXI6IHVuc2V0O1xuICAgIGJhY2tncm91bmQ6IHVuc2V0O1xufVxuLmljb24tc3RhY2sgc3ZnIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgaW5zZXQ6IDA7XG4gICAgb3BhY2l0eTogMTtcbn1cbi5pY29uLXN0YWNrIHN2ZyB7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSB2YXIoLS10cmFuc2l0aW9uLW1lZGl1bSkgZWFzZS1vdXQsIGNvbG9yIHZhcigtLXRyYW5zaXRpb24tbWVkaXVtKSBlYXNlLW91dDtcbn1cbi5pY29uLXN0YWNrIHN2ZyB7XG4gICAgY29sb3I6IHZhcigtLWNsci10ZXh0LTApO1xufVxuLmljb24tc3RhY2s6ZGlzYWJsZWQgc3ZnIHtcbiAgICBjb2xvcjogdmFyKC0tY2xyLWRpc2FibGVkKTtcbn1cbi5pY29uLXN0YWNrOmRpc2FibGVkIHN2Zy5ob3ZlciB7XG4gICAgb3BhY2l0eTogMDtcbn1cbi5pY29uLXN0YWNrOm5vdCg6ZGlzYWJsZWQpIHN2Zy5ob3Zlcixcbi5pY29uLXN0YWNrOm5vdCg6ZGlzYWJsZWQpIHN2Zy5hY3RpdmUsXG4uaWNvbi1zdGFjazpub3QoOmRpc2FibGVkKS5hY3RpdmUgc3ZnLmluYWN0aXZlIHtcbiAgICBvcGFjaXR5OiAwO1xufVxuLmljb24tc3RhY2s6bm90KDpkaXNhYmxlZCkgc3ZnLmhvdmVyLFxuLmljb24tc3RhY2s6bm90KDpkaXNhYmxlZCkgc3ZnLmFjdGl2ZSB7XG4gICAgY29sb3I6IHZhcigtLWFjdGl2ZS1pY29uLWNscik7XG4gICAgZmlsdGVyOiB2YXIoLS1hY3RpdmUtaWNvbi1nbG93KTtcbn1cbi5pY29uLXN0YWNrOm5vdCg6ZGlzYWJsZWQpOmhvdmVyIHN2Zy5ob3Zlcixcbi5pY29uLXN0YWNrOm5vdCg6ZGlzYWJsZWQpLmFjdGl2ZSBzdmcuYWN0aXZlIHtcbiAgICBvcGFjaXR5OiAxO1xufVxuLmljb24tc3RhY2s6bm90KDpkaXNhYmxlZCkuYWN0aXZlOmhvdmVyIHN2Zy5ob3ZlciB7XG4gICAgb3BhY2l0eTogMDtcbn1cbjwvc3R5bGU+XG5gO1xuIl0sIm5hbWVzIjpbIklDT05fU1RBQ0tfQ1NTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Icons/Stack.css.js\n");

/***/ }),

/***/ "./resources/js/components/Request/Loading.js":
/*!****************************************************!*\
  !*** ./resources/js/components/Request/Loading.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iconify/iconify */ \"./node_modules/@iconify/iconify/dist/iconify.min.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_iconify_iconify__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Loading = /*#__PURE__*/function (_Slim) {\n  _inherits(Loading, _Slim);\n\n  var _super = _createSuper(Loading);\n\n  function Loading() {\n    _classCallCheck(this, Loading);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Loading, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this = this;\n\n      document.addEventListener('loading', function (e) {\n        return _this.classList.toggle('active', !!e.detail);\n      });\n      requestAnimationFrame(function () {\n        return _iconify_iconify__WEBPACK_IMPORTED_MODULE_1___default().scan(_this.shadowRoot);\n      });\n    }\n  }]);\n\n  return Loading;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nLoading.template =\n/*html*/\n\"\\n<style>\\n    :host {\\n        position: fixed;\\n        inset: 0;\\n        background-color: transparent;\\n        transition: var(--loading-transition);\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n    }\\n    :host(.active) {\\n        background-color: var(--clr-bg-0-translucent);\\n    }\\n    :host(:not(.active)) {\\n        display: none;\\n    }\\n    @keyframes spin {\\n        from {\\n            transform: rotate(0deg);\\n        }\\n        to {\\n            transform: rotate(360deg);\\n        }\\n    }\\n    @keyframes pulse {\\n        from {\\n            opacity: .25;\\n        }\\n        to {\\n            opacity: 1;\\n        }\\n    }\\n    main {\\n        animation: spin 1s infinite cubic-bezier(.45,.05,.55,.95);\\n        font-size: 5rem;\\n        position: relative;\\n        width: 1em;\\n        height: 1em;\\n    }\\n    svg {\\n        animation: pulse 500ms infinite alternate linear;\\n        color: var(--clr-disabled);\\n        position: absolute;\\n        inset: 0;\\n    }\\n    svg.glow {\\n        color: var(--active-icon-clr);\\n        filter: var(--active-icon-glow);\\n    }\\n</style>\\n<main>\\n    <span class=\\\"iconify\\\" data-icon=\\\"mdi-circle-outline\\\"></span>\\n    <span class=\\\"iconify glow\\\" data-icon=\\\"mdi-loading\\\"></span>\\n</main>\\n\";\ncustomElements.define('transcoder-loading', Loading);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9SZXF1ZXN0L0xvYWRpbmcuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztJQUVNRTs7Ozs7Ozs7Ozs7OztXQUVGLG1CQUFVO0FBQUE7O0FBQ05DLE1BQUFBLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsU0FBMUIsRUFBcUMsVUFBQUMsQ0FBQztBQUFBLGVBQUksS0FBSSxDQUFDQyxTQUFMLENBQWVDLE1BQWYsQ0FBc0IsUUFBdEIsRUFBZ0MsQ0FBQyxDQUFDRixDQUFDLENBQUNHLE1BQXBDLENBQUo7QUFBQSxPQUF0QztBQUNBQyxNQUFBQSxxQkFBcUIsQ0FBQztBQUFBLGVBQU1SLDREQUFBLENBQWEsS0FBSSxDQUFDVSxVQUFsQixDQUFOO0FBQUEsT0FBRCxDQUFyQjtBQUNIOzs7O0VBTGlCWDs7QUFRdEJFLE9BQU8sQ0FBQ1UsUUFBUjtBQUFtQjtBQUFuQjtBQXlEQUMsY0FBYyxDQUFDQyxNQUFmLENBQXNCLG9CQUF0QixFQUE0Q1osT0FBNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9SZXF1ZXN0L0xvYWRpbmcuanM/NjA1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltIH0gZnJvbSAnQC9jb21wb25lbnRzL2xpYic7XG5pbXBvcnQgSWNvbmlmeSBmcm9tICdAaWNvbmlmeS9pY29uaWZ5J1xuXG5jbGFzcyBMb2FkaW5nIGV4dGVuZHMgU2xpbSB7XG5cbiAgICBvbkFkZGVkKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkaW5nJywgZSA9PiB0aGlzLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScsICEhZS5kZXRhaWwpKVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gSWNvbmlmeS5zY2FuKHRoaXMuc2hhZG93Um9vdCkpXG4gICAgfVxufVxuXG5Mb2FkaW5nLnRlbXBsYXRlID0gLypodG1sKi9gXG48c3R5bGU+XG4gICAgOmhvc3Qge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIGluc2V0OiAwO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgdHJhbnNpdGlvbjogdmFyKC0tbG9hZGluZy10cmFuc2l0aW9uKTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuICAgIDpob3N0KC5hY3RpdmUpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY2xyLWJnLTAtdHJhbnNsdWNlbnQpO1xuICAgIH1cbiAgICA6aG9zdCg6bm90KC5hY3RpdmUpKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICAgIEBrZXlmcmFtZXMgc3BpbiB7XG4gICAgICAgIGZyb20ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gICAgICAgIH1cbiAgICAgICAgdG8ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBAa2V5ZnJhbWVzIHB1bHNlIHtcbiAgICAgICAgZnJvbSB7XG4gICAgICAgICAgICBvcGFjaXR5OiAuMjU7XG4gICAgICAgIH1cbiAgICAgICAgdG8ge1xuICAgICAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYWluIHtcbiAgICAgICAgYW5pbWF0aW9uOiBzcGluIDFzIGluZmluaXRlIGN1YmljLWJlemllciguNDUsLjA1LC41NSwuOTUpO1xuICAgICAgICBmb250LXNpemU6IDVyZW07XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDFlbTtcbiAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgfVxuICAgIHN2ZyB7XG4gICAgICAgIGFuaW1hdGlvbjogcHVsc2UgNTAwbXMgaW5maW5pdGUgYWx0ZXJuYXRlIGxpbmVhcjtcbiAgICAgICAgY29sb3I6IHZhcigtLWNsci1kaXNhYmxlZCk7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgaW5zZXQ6IDA7XG4gICAgfVxuICAgIHN2Zy5nbG93IHtcbiAgICAgICAgY29sb3I6IHZhcigtLWFjdGl2ZS1pY29uLWNscik7XG4gICAgICAgIGZpbHRlcjogdmFyKC0tYWN0aXZlLWljb24tZ2xvdyk7XG4gICAgfVxuPC9zdHlsZT5cbjxtYWluPlxuICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1jaXJjbGUtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgZ2xvd1wiIGRhdGEtaWNvbj1cIm1kaS1sb2FkaW5nXCI+PC9zcGFuPlxuPC9tYWluPlxuYFxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RyYW5zY29kZXItbG9hZGluZycsIExvYWRpbmcpOyJdLCJuYW1lcyI6WyJTbGltIiwiSWNvbmlmeSIsIkxvYWRpbmciLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwiZGV0YWlsIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2NhbiIsInNoYWRvd1Jvb3QiLCJ0ZW1wbGF0ZSIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Request/Loading.js\n");

/***/ }),

/***/ "./resources/js/components/Request/index.js":
/*!**************************************************!*\
  !*** ./resources/js/components/Request/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Request\": () => (/* binding */ Request)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Loading_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loading.js */ \"./resources/js/components/Request/Loading.js\");\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar LoadEvent = new CustomEvent('loading', {\n  detail: true\n});\nvar LoadReadyEvent = new CustomEvent('loading', {\n  detail: false\n});\nvar CSRF_TOKEN = document.head.querySelector(\"[name~=csrf-token][content]\").content;\nvar requests = 0;\nvar BASE_HEADERS = {\n  \"Content-Type\": \"application/json\",\n  \"X-CSRF-Token\": CSRF_TOKEN,\n  Accept: \"application/json\"\n};\n\nvar Request = /*#__PURE__*/function () {\n  function Request() {\n    _classCallCheck(this, Request);\n  }\n\n  _createClass(Request, null, [{\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(url) {\n        var indicate,\n            response,\n            error,\n            _args = arguments;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                indicate = _args.length > 1 && _args[1] !== undefined ? _args[1] : true;\n                _context.prev = 1;\n                if (indicate) this.loading = true;\n                _context.next = 5;\n                return fetch(url);\n\n              case 5:\n                response = _context.sent;\n\n                if (!(response.status !== 200)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 9;\n                return response.json();\n\n              case 9:\n                error = _context.sent;\n                throw new Error(error.message);\n\n              case 11:\n                return _context.abrupt(\"return\", response);\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](1);\n                Request.error = _context.t0;\n\n              case 17:\n                _context.prev = 17;\n                if (indicate) this.loading = false;\n                return _context.finish(17);\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 14, 17, 20]]);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"post\",\n    value: function () {\n      var _post = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee2(url, body) {\n        var response, error;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                this.loading = true;\n                _context2.next = 4;\n                return fetch(url, {\n                  method: \"post\",\n                  body: JSON.stringify(body),\n                  headers: BASE_HEADERS\n                });\n\n              case 4:\n                response = _context2.sent;\n\n                if (!(response.status !== 200)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                _context2.next = 8;\n                return response.json();\n\n              case 8:\n                error = _context2.sent;\n                throw new Error(error.message);\n\n              case 10:\n                return _context2.abrupt(\"return\", response);\n\n              case 13:\n                _context2.prev = 13;\n                _context2.t0 = _context2[\"catch\"](0);\n                Request.error = _context2.t0;\n\n              case 16:\n                _context2.prev = 16;\n                this.loading = false;\n                return _context2.finish(16);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 13, 16, 19]]);\n      }));\n\n      function post(_x2, _x3) {\n        return _post.apply(this, arguments);\n      }\n\n      return post;\n    }()\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee3(url) {\n        var response, error;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                this.loading = true;\n                _context3.next = 4;\n                return fetch(url, {\n                  method: \"delete\",\n                  headers: BASE_HEADERS\n                });\n\n              case 4:\n                response = _context3.sent;\n\n                if (!(response.status !== 200)) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                _context3.next = 8;\n                return response.json();\n\n              case 8:\n                error = _context3.sent;\n                throw new Error(error.message);\n\n              case 10:\n                _context3.next = 15;\n                break;\n\n              case 12:\n                _context3.prev = 12;\n                _context3.t0 = _context3[\"catch\"](0);\n                Request.error = _context3.t0;\n\n              case 15:\n                _context3.prev = 15;\n                this.loading = false;\n                return _context3.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 12, 15, 18]]);\n      }));\n\n      function _delete(_x4) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n  }, {\n    key: \"loading\",\n    set: function set(value) {\n      if (value) {\n        requests++;\n\n        if (requests === 1) {\n          document.dispatchEvent(LoadEvent);\n        }\n      } else {\n        requests--;\n\n        if (requests <= 0) {\n          requests = 0;\n          document.dispatchEvent(LoadReadyEvent);\n        }\n      }\n    }\n  }, {\n    key: \"error\",\n    set: function set(error) {\n      console.error(error);\n      document.dispatchEvent(new CustomEvent(\"toast\", {\n        detail: {\n          message: error,\n          type: \"error\"\n        }\n      }));\n      throw error;\n    }\n  }]);\n\n  return Request;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9SZXF1ZXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBLElBQU1BLFNBQVMsR0FBRyxJQUFJQyxXQUFKLENBQWdCLFNBQWhCLEVBQTJCO0FBQUNDLEVBQUFBLE1BQU0sRUFBRTtBQUFULENBQTNCLENBQWxCO0FBQ0EsSUFBTUMsY0FBYyxHQUFHLElBQUlGLFdBQUosQ0FBZ0IsU0FBaEIsRUFBMkI7QUFBQ0MsRUFBQUEsTUFBTSxFQUFFO0FBQVQsQ0FBM0IsQ0FBdkI7QUFDQSxJQUFNRSxVQUFVLEdBQUdDLFFBQVEsQ0FBQ0MsSUFBVCxDQUFjQyxhQUFkLENBQTRCLDZCQUE1QixFQUEyREMsT0FBOUU7QUFFQSxJQUFJQyxRQUFRLEdBQUcsQ0FBZjtBQUVBLElBQU1DLFlBQVksR0FBRztBQUNqQixrQkFBZ0Isa0JBREM7QUFFakIsa0JBQWdCTixVQUZDO0FBR2pCTyxFQUFBQSxNQUFNLEVBQUU7QUFIUyxDQUFyQjs7SUFNTUM7Ozs7Ozs7O3dIQUNGLGlCQUFpQkMsR0FBakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXNCQyxnQkFBQUEsUUFBdEIsMkRBQWlDLElBQWpDO0FBQUE7QUFFUSxvQkFBSUEsUUFBSixFQUFjLEtBQUtDLE9BQUwsR0FBZSxJQUFmO0FBRnRCO0FBQUEsdUJBRzZCQyxLQUFLLENBQUNILEdBQUQsQ0FIbEM7O0FBQUE7QUFHWUksZ0JBQUFBLFFBSFo7O0FBQUEsc0JBSVlBLFFBQVEsQ0FBQ0MsTUFBVCxLQUFvQixHQUpoQztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLHVCQUs4QkQsUUFBUSxDQUFDRSxJQUFULEVBTDlCOztBQUFBO0FBS2dCQyxnQkFBQUEsS0FMaEI7QUFBQSxzQkFNa0IsSUFBSUMsS0FBSixDQUFVRCxLQUFLLENBQUNFLE9BQWhCLENBTmxCOztBQUFBO0FBQUEsaURBUWVMLFFBUmY7O0FBQUE7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QUksRUFBRTtBQUZGO0FBRGEsT0FBekIsQ0FESjtBQVFBLFlBQU1YLEtBQU47QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL1JlcXVlc3QvaW5kZXguanM/OTA4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vTG9hZGluZy5qcydcblxuY29uc3QgTG9hZEV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdsb2FkaW5nJywge2RldGFpbDogdHJ1ZX0pXG5jb25zdCBMb2FkUmVhZHlFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnbG9hZGluZycsIHtkZXRhaWw6IGZhbHNlfSlcbmNvbnN0IENTUkZfVE9LRU4gPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXCJbbmFtZX49Y3NyZi10b2tlbl1bY29udGVudF1cIikuY29udGVudDtcblxubGV0IHJlcXVlc3RzID0gMFxuXG5jb25zdCBCQVNFX0hFQURFUlMgPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgXCJYLUNTUkYtVG9rZW5cIjogQ1NSRl9UT0tFTixcbiAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxufTtcblxuY2xhc3MgUmVxdWVzdCB7XG4gICAgc3RhdGljIGFzeW5jIGdldCh1cmwsIGluZGljYXRlID0gdHJ1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGluZGljYXRlKSB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBSZXF1ZXN0LmVycm9yID0gZXJyb3I7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoaW5kaWNhdGUpIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIHBvc3QodXJsLCBib2R5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBCQVNFX0hFQURFUlMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBSZXF1ZXN0LmVycm9yID0gZXJyb3I7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBkZWxldGUodXJsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImRlbGV0ZVwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IEJBU0VfSEVBREVSUyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIFJlcXVlc3QuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHNldCBsb2FkaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVxdWVzdHMrKztcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0cyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoTG9hZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RzLS07XG4gICAgICAgICAgICBpZiAocmVxdWVzdHMgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RzID0gMDtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KExvYWRSZWFkeUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBzZXQgZXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXCJ0b2FzdFwiLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUmVxdWVzdCB9Il0sIm5hbWVzIjpbIkxvYWRFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiTG9hZFJlYWR5RXZlbnQiLCJDU1JGX1RPS0VOIiwiZG9jdW1lbnQiLCJoZWFkIiwicXVlcnlTZWxlY3RvciIsImNvbnRlbnQiLCJyZXF1ZXN0cyIsIkJBU0VfSEVBREVSUyIsIkFjY2VwdCIsIlJlcXVlc3QiLCJ1cmwiLCJpbmRpY2F0ZSIsImxvYWRpbmciLCJmZXRjaCIsInJlc3BvbnNlIiwic3RhdHVzIiwianNvbiIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiYm9keSIsIm1ldGhvZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwidmFsdWUiLCJkaXNwYXRjaEV2ZW50IiwiY29uc29sZSIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Request/index.js\n");

/***/ }),

/***/ "./resources/js/components/Statusbar/Current.js":
/*!******************************************************!*\
  !*** ./resources/js/components/Statusbar/Current.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Items__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Items */ \"./resources/js/components/Statusbar/Items.js\");\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar ProgressCurrent = /*#__PURE__*/function (_ProgressItem) {\n  _inherits(ProgressCurrent, _ProgressItem);\n\n  var _super = _createSuper(ProgressCurrent);\n\n  function ProgressCurrent() {\n    var _this;\n\n    _classCallCheck(this, ProgressCurrent);\n\n    _this = _super.call(this);\n    _this.requestKill = _this.requestKill.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(ProgressCurrent, [{\n    key: \"width\",\n    get: function get() {\n      return \"width: \".concat(this.item.percentage, \"%;\");\n    }\n  }, {\n    key: \"requestKill\",\n    value: function () {\n      var _requestKill = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                console.info(\"Kill of all ffmpeg processes requested\");\n                _components_Request__WEBPACK_IMPORTED_MODULE_2__.Request.post(\"/kill\");\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function requestKill() {\n        return _requestKill.apply(this, arguments);\n      }\n\n      return requestKill;\n    }()\n  }]);\n\n  return ProgressCurrent;\n}(_Items__WEBPACK_IMPORTED_MODULE_1__.ProgressItem);\n\nProgressCurrent.template =\n/*html*/\n\"\\n\".concat(_Items__WEBPACK_IMPORTED_MODULE_1__.PROGRESS_ITEM_CSS, \"\\n<style>\\n    .path {\\n        position: relative;\\n        width: 100%;\\n    }\\n    .path span:last-of-type {\\n        text-indent: .25rem;\\n        position: absolute;\\n        inset: 0;\\n        background: var(--clr-enlightened);\\n        box-shadow: 0 0 5px 5px inset var(--clr-enlightened-glow);\\n        color: var(--clr-text-200-inverse);\\n        overflow-x: hidden;\\n        border-radius: .2rem;\\n    }\\n</style>\\n<header>Current</header>\\n<div>\\n    <div class=\\\"icon-stack\\\" @click=\\\"{{ this.requestKill }}\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-skull-crossbones-outline\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-skull-crossbones-outline\\\"></span>\\n    </div>\\n    <div @click=\\\"{{ this.showCommand(this.item) }}\\\" class=\\\"path show\\\">\\n        <span>{{ this.item.type.ucfirst() }}: {{ this.item.path }}</span>\\n        <span style=\\\"{{ this.width }}\\\">{{ this.item.type.ucfirst() }}: {{ this.item.path }}</span>\\n    </div>\\n    <div>{{ this.item.percentage }}%</div>\\n</div>\\n\");\ncustomElements.define(\"status-progress-current\", ProgressCurrent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9TdGF0dXNiYXIvQ3VycmVudC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztJQUVNRzs7Ozs7QUFDRiw2QkFBYztBQUFBOztBQUFBOztBQUNWO0FBQ0EsVUFBS0MsV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCQyxJQUFqQiwrQkFBbkI7QUFGVTtBQUdiOzs7O1NBQ0QsZUFBWTtBQUNSLDhCQUFpQixLQUFLQyxJQUFMLENBQVVDLFVBQTNCO0FBQ0g7Ozs7Z0lBRUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNJQyxnQkFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsd0NBQWI7QUFDQVAsZ0JBQUFBLDZEQUFBLENBQWEsT0FBYjs7QUFGSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7RUFUMEJEOztBQWU5QkUsZUFBZSxDQUFDUSxRQUFoQjtBQUEyQjtBQUEzQixZQUNFWCxxREFERjtBQWdDQVksY0FBYyxDQUFDQyxNQUFmLENBQXNCLHlCQUF0QixFQUFpRFYsZUFBakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9TdGF0dXNiYXIvQ3VycmVudC5qcz9jZThlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBST0dSRVNTX0lURU1fQ1NTLCBQcm9ncmVzc0l0ZW0gfSBmcm9tIFwiLi9JdGVtc1wiO1xuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvUmVxdWVzdFwiO1xuXG5jbGFzcyBQcm9ncmVzc0N1cnJlbnQgZXh0ZW5kcyBQcm9ncmVzc0l0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlcXVlc3RLaWxsID0gdGhpcy5yZXF1ZXN0S2lsbC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBgd2lkdGg6ICR7dGhpcy5pdGVtLnBlcmNlbnRhZ2V9JTtgO1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3RLaWxsKCkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJLaWxsIG9mIGFsbCBmZm1wZWcgcHJvY2Vzc2VzIHJlcXVlc3RlZFwiKTtcbiAgICAgICAgUmVxdWVzdC5wb3N0KFwiL2tpbGxcIik7XG4gICAgfVxufVxuXG5Qcm9ncmVzc0N1cnJlbnQudGVtcGxhdGUgPSAvKmh0bWwqLyBgXG4ke1BST0dSRVNTX0lURU1fQ1NTfVxuPHN0eWxlPlxuICAgIC5wYXRoIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG4gICAgLnBhdGggc3BhbjpsYXN0LW9mLXR5cGUge1xuICAgICAgICB0ZXh0LWluZGVudDogLjI1cmVtO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGluc2V0OiAwO1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItZW5saWdodGVuZWQpO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgNXB4IDVweCBpbnNldCB2YXIoLS1jbHItZW5saWdodGVuZWQtZ2xvdyk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1jbHItdGV4dC0yMDAtaW52ZXJzZSk7XG4gICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogLjJyZW07XG4gICAgfVxuPC9zdHlsZT5cbjxoZWFkZXI+Q3VycmVudDwvaGVhZGVyPlxuPGRpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWNvbi1zdGFja1wiIEBjbGljaz1cInt7IHRoaXMucmVxdWVzdEtpbGwgfX1cIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLXNrdWxsLWNyb3NzYm9uZXMtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5IGhvdmVyXCIgZGF0YS1pY29uPVwibWRpLXNrdWxsLWNyb3NzYm9uZXMtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IEBjbGljaz1cInt7IHRoaXMuc2hvd0NvbW1hbmQodGhpcy5pdGVtKSB9fVwiIGNsYXNzPVwicGF0aCBzaG93XCI+XG4gICAgICAgIDxzcGFuPnt7IHRoaXMuaXRlbS50eXBlLnVjZmlyc3QoKSB9fToge3sgdGhpcy5pdGVtLnBhdGggfX08L3NwYW4+XG4gICAgICAgIDxzcGFuIHN0eWxlPVwie3sgdGhpcy53aWR0aCB9fVwiPnt7IHRoaXMuaXRlbS50eXBlLnVjZmlyc3QoKSB9fToge3sgdGhpcy5pdGVtLnBhdGggfX08L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdj57eyB0aGlzLml0ZW0ucGVyY2VudGFnZSB9fSU8L2Rpdj5cbjwvZGl2PlxuYDtcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwic3RhdHVzLXByb2dyZXNzLWN1cnJlbnRcIiwgUHJvZ3Jlc3NDdXJyZW50KTtcbiJdLCJuYW1lcyI6WyJQUk9HUkVTU19JVEVNX0NTUyIsIlByb2dyZXNzSXRlbSIsIlJlcXVlc3QiLCJQcm9ncmVzc0N1cnJlbnQiLCJyZXF1ZXN0S2lsbCIsImJpbmQiLCJpdGVtIiwicGVyY2VudGFnZSIsImNvbnNvbGUiLCJpbmZvIiwicG9zdCIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Statusbar/Current.js\n");

/***/ }),

/***/ "./resources/js/components/Statusbar/Done.js":
/*!***************************************************!*\
  !*** ./resources/js/components/Statusbar/Done.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Items__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Items */ \"./resources/js/components/Statusbar/Items.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar ProgressDone = /*#__PURE__*/function (_ProgressItem) {\n  _inherits(ProgressDone, _ProgressItem);\n\n  var _super = _createSuper(ProgressDone);\n\n  function ProgressDone() {\n    _classCallCheck(this, ProgressDone);\n\n    return _super.apply(this, arguments);\n  }\n\n  return ProgressDone;\n}(_Items__WEBPACK_IMPORTED_MODULE_0__.ProgressItem);\n\nProgressDone.template =\n/*html*/\n\"\\n\".concat(_Items__WEBPACK_IMPORTED_MODULE_0__.PROGRESS_ITEM_CSS, \"\\n<header>Done</header>\\n<div *foreach=\\\"{{ this.items }}\\\">\\n    <div @click=\\\"{{ this.delete(item) }}\\\" style=\\\"cursor: pointer\\\" class=\\\"icon-stack\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-close\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-close\\\"></span>\\n    </div>\\n    <div @click=\\\"{{ this.showCommand(item) }}\\\" class=\\\"path show\\\">{{ item.type.ucfirst() }}: {{ item.path }}</div>\\n    <div>{{ item.percentage }}%</div>\\n</div>\\n\");\ncustomElements.define(\"status-progress-done\", ProgressDone);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9TdGF0dXNiYXIvRG9uZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztJQUVNRTs7Ozs7Ozs7Ozs7O0VBQXFCRDs7QUFFM0JDLFlBQVksQ0FBQ0MsUUFBYjtBQUF3QjtBQUF4QixZQUNFSCxxREFERjtBQWFBSSxjQUFjLENBQUNDLE1BQWYsQ0FBc0Isc0JBQXRCLEVBQThDSCxZQUE5QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL1N0YXR1c2Jhci9Eb25lLmpzP2M0NzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUFJPR1JFU1NfSVRFTV9DU1MsIFByb2dyZXNzSXRlbSB9IGZyb20gXCIuL0l0ZW1zXCI7XG5cbmNsYXNzIFByb2dyZXNzRG9uZSBleHRlbmRzIFByb2dyZXNzSXRlbSB7fVxuXG5Qcm9ncmVzc0RvbmUudGVtcGxhdGUgPSAvKmh0bWwqLyBgXG4ke1BST0dSRVNTX0lURU1fQ1NTfVxuPGhlYWRlcj5Eb25lPC9oZWFkZXI+XG48ZGl2ICpmb3JlYWNoPVwie3sgdGhpcy5pdGVtcyB9fVwiPlxuICAgIDxkaXYgQGNsaWNrPVwie3sgdGhpcy5kZWxldGUoaXRlbSkgfX1cIiBzdHlsZT1cImN1cnNvcjogcG9pbnRlclwiIGNsYXNzPVwiaWNvbi1zdGFja1wiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktY2xvc2VcIj48L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeSBob3ZlclwiIGRhdGEtaWNvbj1cIm1kaS1jbG9zZVwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IEBjbGljaz1cInt7IHRoaXMuc2hvd0NvbW1hbmQoaXRlbSkgfX1cIiBjbGFzcz1cInBhdGggc2hvd1wiPnt7IGl0ZW0udHlwZS51Y2ZpcnN0KCkgfX06IHt7IGl0ZW0ucGF0aCB9fTwvZGl2PlxuICAgIDxkaXY+e3sgaXRlbS5wZXJjZW50YWdlIH19JTwvZGl2PlxuPC9kaXY+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJzdGF0dXMtcHJvZ3Jlc3MtZG9uZVwiLCBQcm9ncmVzc0RvbmUpO1xuIl0sIm5hbWVzIjpbIlBST0dSRVNTX0lURU1fQ1NTIiwiUHJvZ3Jlc3NJdGVtIiwiUHJvZ3Jlc3NEb25lIiwidGVtcGxhdGUiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Statusbar/Done.js\n");

/***/ }),

/***/ "./resources/js/components/Statusbar/Failed.js":
/*!*****************************************************!*\
  !*** ./resources/js/components/Statusbar/Failed.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Items__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Items */ \"./resources/js/components/Statusbar/Items.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar ProgressFailed = /*#__PURE__*/function (_ProgressItem) {\n  _inherits(ProgressFailed, _ProgressItem);\n\n  var _super = _createSuper(ProgressFailed);\n\n  function ProgressFailed() {\n    _classCallCheck(this, ProgressFailed);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ProgressFailed, [{\n    key: \"showException\",\n    value: function showException(item) {\n      console.error(item);\n      document.dispatchEvent(new CustomEvent(\"show-textcontent\", {\n        detail: {\n          content: item.exception\n        }\n      }));\n    }\n  }]);\n\n  return ProgressFailed;\n}(_Items__WEBPACK_IMPORTED_MODULE_0__.ProgressItem);\n\nProgressFailed.template =\n/*html*/\n\"\\n\".concat(_Items__WEBPACK_IMPORTED_MODULE_0__.PROGRESS_ITEM_CSS, \"\\n<header>Failed</header>\\n<div *foreach=\\\"{{ this.items }}\\\">\\n    <div @click=\\\"{{ this.delete(item) }}\\\" style=\\\"cursor: pointer\\\" class=\\\"icon-stack\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-close\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-close\\\"></span>\\n    </div>\\n    <div @click=\\\"{{ this.showException(item) }}\\\" class=\\\"path show\\\">{{ item.type.ucfirst() }}: {{ item.path }}</div>\\n    <div>{{ item.percentage }}%</div>\\n</div>\\n\");\ncustomElements.define(\"status-progress-failed\", ProgressFailed);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9TdGF0dXNiYXIvRmFpbGVkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztJQUVNRTs7Ozs7Ozs7Ozs7OztXQUNGLHVCQUFjQyxJQUFkLEVBQW9CO0FBQ2hCQyxNQUFBQSxPQUFPLENBQUNDLEtBQVIsQ0FBY0YsSUFBZDtBQUNBRyxNQUFBQSxRQUFRLENBQUNDLGFBQVQsQ0FDSSxJQUFJQyxXQUFKLENBQWdCLGtCQUFoQixFQUFvQztBQUNoQ0MsUUFBQUEsTUFBTSxFQUFFO0FBQUVDLFVBQUFBLE9BQU8sRUFBRVAsSUFBSSxDQUFDUTtBQUFoQjtBQUR3QixPQUFwQyxDQURKO0FBS0g7Ozs7RUFSd0JWOztBQVc3QkMsY0FBYyxDQUFDVSxRQUFmO0FBQTBCO0FBQTFCLFlBQ0VaLHFEQURGO0FBYUFhLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQix3QkFBdEIsRUFBZ0RaLGNBQWhEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvU3RhdHVzYmFyL0ZhaWxlZC5qcz9hZjA0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBST0dSRVNTX0lURU1fQ1NTLCBQcm9ncmVzc0l0ZW0gfSBmcm9tIFwiLi9JdGVtc1wiO1xuXG5jbGFzcyBQcm9ncmVzc0ZhaWxlZCBleHRlbmRzIFByb2dyZXNzSXRlbSB7XG4gICAgc2hvd0V4Y2VwdGlvbihpdGVtKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoaXRlbSk7XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXCJzaG93LXRleHRjb250ZW50XCIsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHsgY29udGVudDogaXRlbS5leGNlcHRpb24gfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5Qcm9ncmVzc0ZhaWxlZC50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7UFJPR1JFU1NfSVRFTV9DU1N9XG48aGVhZGVyPkZhaWxlZDwvaGVhZGVyPlxuPGRpdiAqZm9yZWFjaD1cInt7IHRoaXMuaXRlbXMgfX1cIj5cbiAgICA8ZGl2IEBjbGljaz1cInt7IHRoaXMuZGVsZXRlKGl0ZW0pIH19XCIgc3R5bGU9XCJjdXJzb3I6IHBvaW50ZXJcIiBjbGFzcz1cImljb24tc3RhY2tcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWNsb3NlXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktY2xvc2VcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBAY2xpY2s9XCJ7eyB0aGlzLnNob3dFeGNlcHRpb24oaXRlbSkgfX1cIiBjbGFzcz1cInBhdGggc2hvd1wiPnt7IGl0ZW0udHlwZS51Y2ZpcnN0KCkgfX06IHt7IGl0ZW0ucGF0aCB9fTwvZGl2PlxuICAgIDxkaXY+e3sgaXRlbS5wZXJjZW50YWdlIH19JTwvZGl2PlxuPC9kaXY+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJzdGF0dXMtcHJvZ3Jlc3MtZmFpbGVkXCIsIFByb2dyZXNzRmFpbGVkKTtcbiJdLCJuYW1lcyI6WyJQUk9HUkVTU19JVEVNX0NTUyIsIlByb2dyZXNzSXRlbSIsIlByb2dyZXNzRmFpbGVkIiwiaXRlbSIsImNvbnNvbGUiLCJlcnJvciIsImRvY3VtZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiY29udGVudCIsImV4Y2VwdGlvbiIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Statusbar/Failed.js\n");

/***/ }),

/***/ "./resources/js/components/Statusbar/Items.js":
/*!****************************************************!*\
  !*** ./resources/js/components/Statusbar/Items.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PROGRESS_ITEM_CSS\": () => (/* binding */ PROGRESS_ITEM_CSS),\n/* harmony export */   \"ProgressItem\": () => (/* binding */ ProgressItem)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iconify/iconify */ \"./node_modules/@iconify/iconify/dist/iconify.min.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_iconify_iconify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar CSRF_TOKEN = document.head.querySelector(\"[name~=csrf-token][content]\").content;\n\nvar ProgressItem = /*#__PURE__*/function (_Slim) {\n  _inherits(ProgressItem, _Slim);\n\n  var _super = _createSuper(ProgressItem);\n\n  function ProgressItem() {\n    _classCallCheck(this, ProgressItem);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ProgressItem, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this = this;\n\n      requestAnimationFrame(function () {\n        return _iconify_iconify__WEBPACK_IMPORTED_MODULE_2___default().scan(_this.shadowRoot);\n      });\n    }\n  }, {\n    key: \"showCommand\",\n    value: function showCommand(item) {\n      document.dispatchEvent(new CustomEvent(\"show-textcontent\", {\n        detail: {\n          content: item.command\n        }\n      }));\n    }\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(item) {\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                try {\n                  _components_Request__WEBPACK_IMPORTED_MODULE_4__.Request.delete(\"/progress/\".concat(item.id));\n                } catch (error) {}\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function _delete(_x) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n  }]);\n\n  return ProgressItem;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_1__.Slim);\n\nvar PROGRESS_ITEM_CSS =\n/*css*/\n\"\\n<style>\\n:host > div {\\n    display: flex;\\n    justify-content: space-between;\\n    gap: .5em;\\n}\\nheader {\\n    font-weight: bold;\\n    user-select: none;\\n}\\ndiv > div:last-child {\\n    text-align: right;\\n    margin-left: auto;\\n    width: 4em;\\n}\\ndiv.path {\\n    white-space: nowrap;\\n    overflow-x: hidden;\\n    text-overflow: ellipsis;\\n}\\ndiv.path.show {\\n    cursor: pointer;\\n}\\ndiv.icon-stack {\\n    width: 1em;\\n}\\n</style>\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_3__.ICON_STACK_CSS, \"\\n\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9TdGF0dXNiYXIvSXRlbXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBTUksVUFBVSxHQUFHQyxRQUFRLENBQUNDLElBQVQsQ0FBY0MsYUFBZCxDQUE0Qiw2QkFBNUIsRUFBMkRDLE9BQTlFOztJQUVNQzs7Ozs7Ozs7Ozs7OztXQUNGLG1CQUFVO0FBQUE7O0FBQ05DLE1BQUFBLHFCQUFxQixDQUFDO0FBQUEsZUFBTVQsNERBQUEsQ0FBYSxLQUFJLENBQUNXLFVBQWxCLENBQU47QUFBQSxPQUFELENBQXJCO0FBQ0g7OztXQUVELHFCQUFZQyxJQUFaLEVBQWtCO0FBQ2RSLE1BQUFBLFFBQVEsQ0FBQ1MsYUFBVCxDQUNJLElBQUlDLFdBQUosQ0FBZ0Isa0JBQWhCLEVBQW9DO0FBQ2hDQyxRQUFBQSxNQUFNLEVBQUU7QUFBRVIsVUFBQUEsT0FBTyxFQUFFSyxJQUFJLENBQUNJO0FBQWhCO0FBRHdCLE9BQXBDLENBREo7QUFLSDs7Ozs0SEFFRCxpQkFBYUosSUFBYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0ksb0JBQUk7QUFDQVYsa0JBQUFBLCtEQUFBLHFCQUE0QlUsSUFBSSxDQUFDSyxFQUFqQztBQUNILGlCQUZELENBRUUsT0FBT0MsS0FBUCxFQUFjLENBQUU7O0FBSHRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7OztFQWJ1Qm5COztBQW9CM0IsSUFBTW9CLGlCQUFpQjtBQUFHO0FBQUgsbWNBNEJyQmxCLHVFQTVCcUIsT0FBdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9TdGF0dXNiYXIvSXRlbXMuanM/YzgzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltIH0gZnJvbSAnQC9jb21wb25lbnRzL2xpYic7XG5pbXBvcnQgSWNvbmlmeSBmcm9tICdAaWNvbmlmeS9pY29uaWZ5J1xuaW1wb3J0IHsgSUNPTl9TVEFDS19DU1MgfSBmcm9tICdAL2NvbXBvbmVudHMvSWNvbnMvU3RhY2suY3NzJztcbmltcG9ydCB7UmVxdWVzdH0gZnJvbSAnQC9jb21wb25lbnRzL1JlcXVlc3QnXG5cbmNvbnN0IENTUkZfVE9LRU4gPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXCJbbmFtZX49Y3NyZi10b2tlbl1bY29udGVudF1cIikuY29udGVudDtcblxuY2xhc3MgUHJvZ3Jlc3NJdGVtIGV4dGVuZHMgU2xpbSB7XG4gICAgb25BZGRlZCgpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IEljb25pZnkuc2Nhbih0aGlzLnNoYWRvd1Jvb3QpKTtcbiAgICB9XG5cbiAgICBzaG93Q29tbWFuZChpdGVtKSB7XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXCJzaG93LXRleHRjb250ZW50XCIsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHsgY29udGVudDogaXRlbS5jb21tYW5kIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZShpdGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZXF1ZXN0LmRlbGV0ZShgL3Byb2dyZXNzLyR7aXRlbS5pZH1gKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfVxufVxuXG5jb25zdCBQUk9HUkVTU19JVEVNX0NTUyA9IC8qY3NzKi8gYFxuPHN0eWxlPlxuOmhvc3QgPiBkaXYge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGdhcDogLjVlbTtcbn1cbmhlYWRlciB7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG59XG5kaXYgPiBkaXY6bGFzdC1jaGlsZCB7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgd2lkdGg6IDRlbTtcbn1cbmRpdi5wYXRoIHtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbn1cbmRpdi5wYXRoLnNob3cge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn1cbmRpdi5pY29uLXN0YWNrIHtcbiAgICB3aWR0aDogMWVtO1xufVxuPC9zdHlsZT5cbiR7SUNPTl9TVEFDS19DU1N9XG5gO1xuXG5leHBvcnQgeyBQUk9HUkVTU19JVEVNX0NTUywgUHJvZ3Jlc3NJdGVtIH0iXSwibmFtZXMiOlsiU2xpbSIsIkljb25pZnkiLCJJQ09OX1NUQUNLX0NTUyIsIlJlcXVlc3QiLCJDU1JGX1RPS0VOIiwiZG9jdW1lbnQiLCJoZWFkIiwicXVlcnlTZWxlY3RvciIsImNvbnRlbnQiLCJQcm9ncmVzc0l0ZW0iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzY2FuIiwic2hhZG93Um9vdCIsIml0ZW0iLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJjb21tYW5kIiwiaWQiLCJlcnJvciIsIlBST0dSRVNTX0lURU1fQ1NTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Statusbar/Items.js\n");

/***/ }),

/***/ "./resources/js/components/Statusbar/Pending.js":
/*!******************************************************!*\
  !*** ./resources/js/components/Statusbar/Pending.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Items__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Items */ \"./resources/js/components/Statusbar/Items.js\");\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar ProgressPending = /*#__PURE__*/function (_ProgressItem) {\n  _inherits(ProgressPending, _ProgressItem);\n\n  var _super = _createSuper(ProgressPending);\n\n  function ProgressPending() {\n    _classCallCheck(this, ProgressPending);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ProgressPending, [{\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(item) {\n        var m;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                m = document.createElement(\"modal-confirm\");\n                m.header = \"Cancel\";\n                m.content = \"Cancel \".concat(item.type.ucfirst(), \" \").concat(item.path, \"?\");\n                document.body.appendChild(m);\n                _context.prev = 4;\n                _context.next = 7;\n                return m.confirm();\n\n              case 7:\n                console.info(\"Request cancel of queue %s\", item.id);\n                _components_Request__WEBPACK_IMPORTED_MODULE_2__.Request.post(\"/queue/cancel/\".concat(item.id));\n                _context.next = 13;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](4);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[4, 11]]);\n      }));\n\n      function cancel(_x) {\n        return _cancel.apply(this, arguments);\n      }\n\n      return cancel;\n    }()\n  }]);\n\n  return ProgressPending;\n}(_Items__WEBPACK_IMPORTED_MODULE_1__.ProgressItem);\n\nProgressPending.template =\n/*html*/\n\"\\n\".concat(_Items__WEBPACK_IMPORTED_MODULE_1__.PROGRESS_ITEM_CSS, \"\\n<header>Pending</header>\\n<div *foreach=\\\"{{ this.items }}\\\">\\n    <div @click=\\\"{{ this.cancel(item) }}\\\" style=\\\"cursor: pointer\\\" class=\\\"icon-stack\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-trash-can-outline\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-trash-can-outline\\\"></span>\\n    </div>\\n    <div class=\\\"path\\\">{{ item.type.ucfirst() }}: {{ item.path }}</div>\\n    <div>{{ item.percentage }}%</div>\\n</div>\\n\");\ncustomElements.define(\"status-progress-pending\", ProgressPending);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9TdGF0dXNiYXIvUGVuZGluZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztJQUVNRzs7Ozs7Ozs7Ozs7Ozs7MkhBTUYsaUJBQWFDLElBQWI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ1VDLGdCQUFBQSxDQURWLEdBQ2NDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixlQUF2QixDQURkO0FBRUlGLGdCQUFBQSxDQUFDLENBQUNHLE1BQUYsR0FBVyxRQUFYO0FBQ0FILGdCQUFBQSxDQUFDLENBQUNJLE9BQUYsb0JBQXNCTCxJQUFJLENBQUNNLElBQUwsQ0FBVUMsT0FBVixFQUF0QixjQUE2Q1AsSUFBSSxDQUFDUSxJQUFsRDtBQUNBTixnQkFBQUEsUUFBUSxDQUFDTyxJQUFULENBQWNDLFdBQWQsQ0FBMEJULENBQTFCO0FBSko7QUFBQTtBQUFBLHVCQU1jQSxDQUFDLENBQUNVLE9BQUYsRUFOZDs7QUFBQTtBQU9RQyxnQkFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsNEJBQWIsRUFBMkNiLElBQUksQ0FBQ2MsRUFBaEQ7QUFDQWhCLGdCQUFBQSw2REFBQSx5QkFBOEJFLElBQUksQ0FBQ2MsRUFBbkM7QUFSUjtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7RUFOMEJqQjs7QUFtQjlCRSxlQUFlLENBQUNpQixRQUFoQjtBQUEyQjtBQUEzQixZQUNFcEIscURBREY7QUFhQXFCLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQix5QkFBdEIsRUFBaURuQixlQUFqRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL1N0YXR1c2Jhci9QZW5kaW5nLmpzP2YyYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUFJPR1JFU1NfSVRFTV9DU1MsIFByb2dyZXNzSXRlbSB9IGZyb20gXCIuL0l0ZW1zXCI7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSBcIkAvY29tcG9uZW50cy9SZXF1ZXN0XCI7XG5cbmNsYXNzIFByb2dyZXNzUGVuZGluZyBleHRlbmRzIFByb2dyZXNzSXRlbSB7XG4gICAgY2FuY2VsKGl0ZW0pIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiUmVxdWVzdCBjYW5jZWwgb2YgcXVldWUgJXNcIiwgaXRlbS5pZCk7XG4gICAgICAgIFJlcXVlc3QucG9zdChgL3F1ZXVlL2NhbmNlbC8ke2l0ZW0uaWR9YCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtb2RhbC1jb25maXJtXCIpO1xuICAgICAgICBtLmhlYWRlciA9IFwiQ2FuY2VsXCI7XG4gICAgICAgIG0uY29udGVudCA9IGBDYW5jZWwgJHtpdGVtLnR5cGUudWNmaXJzdCgpfSAke2l0ZW0ucGF0aH0/YDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IG0uY29uZmlybSgpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiUmVxdWVzdCBjYW5jZWwgb2YgcXVldWUgJXNcIiwgaXRlbS5pZCk7XG4gICAgICAgICAgICBSZXF1ZXN0LnBvc3QoYC9xdWV1ZS9jYW5jZWwvJHtpdGVtLmlkfWApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9XG59XG5cblByb2dyZXNzUGVuZGluZy50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7UFJPR1JFU1NfSVRFTV9DU1N9XG48aGVhZGVyPlBlbmRpbmc8L2hlYWRlcj5cbjxkaXYgKmZvcmVhY2g9XCJ7eyB0aGlzLml0ZW1zIH19XCI+XG4gICAgPGRpdiBAY2xpY2s9XCJ7eyB0aGlzLmNhbmNlbChpdGVtKSB9fVwiIHN0eWxlPVwiY3Vyc29yOiBwb2ludGVyXCIgY2xhc3M9XCJpY29uLXN0YWNrXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS10cmFzaC1jYW4tb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5IGhvdmVyXCIgZGF0YS1pY29uPVwibWRpLXRyYXNoLWNhbi1vdXRsaW5lXCI+PC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwYXRoXCI+e3sgaXRlbS50eXBlLnVjZmlyc3QoKSB9fToge3sgaXRlbS5wYXRoIH19PC9kaXY+XG4gICAgPGRpdj57eyBpdGVtLnBlcmNlbnRhZ2UgfX0lPC9kaXY+XG48L2Rpdj5cbmA7XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcInN0YXR1cy1wcm9ncmVzcy1wZW5kaW5nXCIsIFByb2dyZXNzUGVuZGluZyk7XG4iXSwibmFtZXMiOlsiUFJPR1JFU1NfSVRFTV9DU1MiLCJQcm9ncmVzc0l0ZW0iLCJSZXF1ZXN0IiwiUHJvZ3Jlc3NQZW5kaW5nIiwiaXRlbSIsIm0iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJoZWFkZXIiLCJjb250ZW50IiwidHlwZSIsInVjZmlyc3QiLCJwYXRoIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY29uZmlybSIsImNvbnNvbGUiLCJpbmZvIiwiaWQiLCJwb3N0IiwidGVtcGxhdGUiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Statusbar/Pending.js\n");

/***/ }),

/***/ "./resources/js/components/Statusbar/index.js":
/*!****************************************************!*\
  !*** ./resources/js/components/Statusbar/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iconify/iconify */ \"./node_modules/@iconify/iconify/dist/iconify.min.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_iconify_iconify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\n/* harmony import */ var _Done__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Done */ \"./resources/js/components/Statusbar/Done.js\");\n/* harmony import */ var _Failed__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Failed */ \"./resources/js/components/Statusbar/Failed.js\");\n/* harmony import */ var _Current__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Current */ \"./resources/js/components/Statusbar/Current.js\");\n/* harmony import */ var _Pending__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Pending */ \"./resources/js/components/Statusbar/Pending.js\");\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\nvar STATE_RUNNING = \"running\";\nvar STATE_PENDING = \"pending\";\nvar STATE_DONE = \"done\";\nvar STATE_FAILED = \"failed\";\nvar WS_CHANNEL_FFMPEG_OUT = \"FFMpegOut\";\nvar runtimeInterval = false;\nvar currentRuntime = 0;\n\nvar Statusbar = /*#__PURE__*/function (_Slim) {\n  _inherits(Statusbar, _Slim);\n\n  var _super = _createSuper(Statusbar);\n\n  function Statusbar() {\n    var _this;\n\n    _classCallCheck(this, Statusbar);\n\n    _this = _super.call(this);\n    _this.running = false;\n    _this.runtime = \"00:00:00\";\n    _this.out = \"\";\n    _this.rate = \"\";\n    _this.remaining = \"\";\n    _this.percentage = 0;\n    _this.dataset.hasItems = false;\n    return _this;\n  }\n\n  _createClass(Statusbar, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      requestAnimationFrame(function () {\n        return _iconify_iconify__WEBPACK_IMPORTED_MODULE_2___default().scan(_this2.shadowRoot);\n      });\n      this.channel = window.Echo.channel(\"FFMpegProgress\");\n      this.channel.subscribed(this.requestProgress.bind(this));\n      this.channel.listen(\"FFMpegProgress\", this.handleProgressEvent.bind(this));\n      this.channelOut = window.Echo.channel(\"\".concat(WS_CHANNEL_FFMPEG_OUT));\n      this.channelOut.listen(WS_CHANNEL_FFMPEG_OUT, this.handleOutEvent.bind(this));\n      document.addEventListener(\"click\", function (e) {\n        var p = e.composedPath();\n\n        if (!_this2.sectionDetail.classList.contains(\"hidden\") && p.indexOf(_this2.sectionDetail) < 0) {\n          _this2.toggleDetail();\n        } else if (p.indexOf(_this2.buttonDetail) > -1) {\n          _this2.toggleDetail();\n        }\n      });\n    }\n  }, {\n    key: \"handleOutEvent\",\n    value: function handleOutEvent(ws) {\n      this.out = ws.out;\n    }\n  }, {\n    key: \"toggleDetail\",\n    value: function toggleDetail() {\n      var detail = this.sectionDetail.classList.contains(\"hidden\");\n      this.classList.toggle(\"detail\", detail);\n      this.iconShort.classList.toggle(\"hidden\", detail);\n      this.iconDetail.classList.toggle(\"hidden\", !detail);\n      this.sectionDetail.classList.toggle(\"hidden\", !detail);\n      this.requestProgress();\n    }\n  }, {\n    key: \"requestProgress\",\n    value: function requestProgress() {\n      try {\n        _components_Request__WEBPACK_IMPORTED_MODULE_3__.Request.get(\"/progress\", false);\n      } catch (error) {}\n    }\n  }, {\n    key: \"handleProgressEvent\",\n    value: function handleProgressEvent(_ref) {\n      var queue = _ref.queue;\n      this.dataset.hasItems = (queue.length > 0).toString();\n      var current = queue.filter(function (q) {\n        return q.state === STATE_RUNNING;\n      });\n      var pending = queue.filter(function (q) {\n        return q.state === STATE_PENDING;\n      });\n      var failed = queue.filter(function (q) {\n        return q.state === STATE_FAILED;\n      });\n      var done = queue.filter(function (q) {\n        return q.state === STATE_DONE;\n      });\n      this.percentage = current.length ? current[0].percentage : 0;\n      this.rate = current.length ? current[0].rate : 0;\n      this.remaining = current.length ? current[0].remaining : 0;\n      this.classList.toggle(\"running\", current.length > 0);\n      this.handleTimer(current);\n      this.sectionDetail.querySelectorAll(\"*\").forEach(function (n) {\n        return n.remove();\n      });\n\n      if (pending.length) {\n        var node = this.sectionDetail.appendChild(document.createElement(\"status-progress-pending\"));\n        node.items = pending;\n      }\n\n      if (current.length) {\n        var _node = this.sectionDetail.appendChild(document.createElement(\"status-progress-current\"));\n\n        _node.item = current[0];\n      }\n\n      if (failed.length) {\n        var _node2 = this.sectionDetail.appendChild(document.createElement(\"status-progress-failed\"));\n\n        _node2.items = failed;\n      }\n\n      if (done.length) {\n        var _node3 = this.sectionDetail.appendChild(document.createElement(\"status-progress-done\"));\n\n        _node3.items = done;\n      }\n    }\n  }, {\n    key: \"handleTimer\",\n    value: function handleTimer(current) {\n      var _this3 = this;\n\n      if (current.length && !runtimeInterval) {\n        currentRuntime = new Date(current[0].updated_at).getTime() - new Date(current[0].created_at).getTime();\n        runtimeInterval = setInterval(function () {\n          _this3.runtime = new Date(currentRuntime).toISOString().split(\"T\").pop().split(\".\").shift();\n          currentRuntime += 1000;\n        }, 1000);\n      } else if (!current.length) {\n        clearInterval(runtimeInterval);\n        runtimeInterval = false;\n      }\n    }\n  }, {\n    key: \"requestKill\",\n    value: function () {\n      var _requestKill = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                console.info(\"Kill of all ffmpeg processes requested\");\n                _components_Request__WEBPACK_IMPORTED_MODULE_3__.Request.post(\"/kill\");\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function requestKill() {\n        return _requestKill.apply(this, arguments);\n      }\n\n      return requestKill;\n    }()\n  }]);\n\n  return Statusbar;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_1__.Slim);\n\nStatusbar.template =\n/*html*/\n\"\\n<style>\\n:host {\\n    position: relative;\\n    box-shadow: 0 0 7vw 0 var(--clr-shadow-0);\\n    z-index: 0;\\n}\\nmain {\\n    padding: .5em;\\n    font-size: max(10px, .85rem);\\n    background: var(--clr-bg-150);\\n    border: 2px var(--clr-bg-200);\\n    display: flex;\\n    gap: .5rem;\\n    justify-content: space-between;\\n    position: relative;\\n    z-index: 1;\\n}\\ndiv {\\n    cursor: pointer;\\n}\\ndiv.hidden {\\n    display: none;\\n}\\nsection:first-of-type {\\n    flex-grow: 1;\\n}\\nsection {\\n    padding: 0 .5rem;\\n    border: 1px solid;\\n    border-color: var(--clr-bg-0) var(--clr-bg-0) var(--clr-bg-200) var(--clr-bg-200);\\n    background-color: var(--clr-bg-140);\\n    --duration: var(--transition-medium);\\n    transform-origin: bottom right;\\n    transition: transform var(--duration) ease-in-out,\\n                max-width var(--duration) ease-in-out,\\n                max-height var(--duration) ease-in-out;\\n}\\nsection.detail {\\n    background: var(--clr-bg-150);\\n    border: 2px var(--clr-bg-200);\\n    box-shadow: 0 0 7vw 0 var(--clr-shadow-0);\\n    border-top-left-radius: .5rem;\\n    padding: .5rem;\\n    display: flex;\\n    flex-direction: column;\\n    gap: .5em;\\n    position: absolute;\\n    right: 0;\\n    max-width: 90vw;\\n    transform: translateY(-100%) scaleY(1);\\n    transform-origin: top;\\n    top: 0;\\n    z-index: 0;\\n}\\nsection.hidden {\\n    transform: translateY(0) scaleY(0);\\n}\\n.ffmpeg-out {\\n    color: var(--clr-text-disabled);\\n    display: flex;\\n    justify-content: space-between;\\n}\\n.ffmpeg-out .icon-stack {\\n    display: none;\\n}\\n:host(.running) .ffmpeg-out {\\n    color: var(--clr-text-0);\\n}\\n:host(.running) .ffmpeg-out .icon-stack {\\n    display: revert;\\n}\\n.runtime {\\n    position: relative;\\n}\\n.runtime span:last-of-type {\\n    position: absolute;\\n    inset: 0 0 1px;\\n    background: var(--clr-enlightened);\\n    box-shadow: 0 0 5px 5px inset var(--clr-enlightened-glow);\\n    color: var(--clr-text-200-inverse);\\n    overflow: hidden;\\n    border-radius: .2rem;\\n    text-indent: .5rem;\\n    max-width: 100%;\\n}\\n</style>\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_8__.ICON_STACK_CSS, \"\\n<main>\\n    <section class=\\\"ffmpeg-out\\\">\\n        <span>{{ this.out }}</span>\\n        <div class=\\\"icon-stack\\\" @click=\\\"{{ this.requestKill }}\\\">\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-skull-crossbones-outline\\\"></span>\\n            <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-skull-crossbones-outline\\\"></span>\\n        </div>\\n    </section>\\n    <section #ref=\\\"sectionRuntime\\\" class=\\\"runtime\\\">\\n        <span>{{ this.runtime }}</span>\\n        <span style=\\\"{{ 'width:' + this.percentage + '%' }}\\\">{{ this.runtime }}</span>\\n    </section>\\n    <section #ref=\\\"sectionShort\\\">{{ this.percentage }}%</section>\\n    <section #ref=\\\"buttonDetail\\\">\\n        <div #ref=\\\"iconShort\\\">\\n            <div class=\\\"icon-stack\\\">\\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-plus-box-outline\\\"></span>\\n                <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-plus-box-outline\\\"></span>\\n            </div>\\n        </div>\\n        <div #ref=\\\"iconDetail\\\" class=\\\"hidden\\\">\\n            <div class=\\\"icon-stack\\\">\\n                <span class=\\\"iconify\\\" data-icon=\\\"mdi-minus-box-outline\\\"></span>\\n                <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-minus-box-outline\\\"></span>\\n            </div>\\n        </div>\\n    </section>\\n</main>\\n<section #ref=\\\"sectionDetail\\\" class=\\\"detail hidden\\\"></section>\\n\");\ncustomElements.define(\"status-bar\", Statusbar);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9TdGF0dXNiYXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxJQUFNSSxhQUFhLEdBQUcsU0FBdEI7QUFDQSxJQUFNQyxhQUFhLEdBQUcsU0FBdEI7QUFDQSxJQUFNQyxVQUFVLEdBQUcsTUFBbkI7QUFDQSxJQUFNQyxZQUFZLEdBQUcsUUFBckI7QUFDQSxJQUFNQyxxQkFBcUIsR0FBRyxXQUE5QjtBQUNBLElBQUlDLGVBQWUsR0FBRyxLQUF0QjtBQUNBLElBQUlDLGNBQWMsR0FBRyxDQUFyQjs7SUFFTUM7Ozs7O0FBQ0YsdUJBQWM7QUFBQTs7QUFBQTs7QUFDVjtBQUNBLFVBQUtDLE9BQUwsR0FBZSxLQUFmO0FBQ0EsVUFBS0MsT0FBTCxHQUFlLFVBQWY7QUFDQSxVQUFLQyxHQUFMLEdBQVcsRUFBWDtBQUNBLFVBQUtDLElBQUwsR0FBWSxFQUFaO0FBQ0EsVUFBS0MsU0FBTCxHQUFpQixFQUFqQjtBQUNBLFVBQUtDLFVBQUwsR0FBa0IsQ0FBbEI7QUFDQSxVQUFLQyxPQUFMLENBQWFDLFFBQWIsR0FBd0IsS0FBeEI7QUFSVTtBQVNiOzs7O1dBRUQsbUJBQVU7QUFBQTs7QUFDTkMsTUFBQUEscUJBQXFCLENBQUM7QUFBQSxlQUFNbkIsNERBQUEsQ0FBYSxNQUFJLENBQUNxQixVQUFsQixDQUFOO0FBQUEsT0FBRCxDQUFyQjtBQUNBLFdBQUtDLE9BQUwsR0FBZUMsTUFBTSxDQUFDQyxJQUFQLENBQVlGLE9BQVosQ0FBb0IsZ0JBQXBCLENBQWY7QUFDQSxXQUFLQSxPQUFMLENBQWFHLFVBQWIsQ0FBd0IsS0FBS0MsZUFBTCxDQUFxQkMsSUFBckIsQ0FBMEIsSUFBMUIsQ0FBeEI7QUFDQSxXQUFLTCxPQUFMLENBQWFNLE1BQWIsQ0FDSSxnQkFESixFQUVJLEtBQUtDLG1C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QUEsQ0FBYSxPQUFiOztBQUZKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7OztFQXJIb0JGOztBQTJIeEJXLFNBQVMsQ0FBQ3lFLFFBQVY7QUFBcUI7QUFBckIsMmlFQXVGRWpGLHVFQXZGRjtBQXVIQWtGLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixZQUF0QixFQUFvQzNFLFNBQXBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvU3RhdHVzYmFyL2luZGV4LmpzP2Q1NzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2xpbSB9IGZyb20gXCJAL2NvbXBvbmVudHMvbGliXCI7XG5pbXBvcnQgSWNvbmlmeSBmcm9tIFwiQGljb25pZnkvaWNvbmlmeVwiO1xuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvUmVxdWVzdFwiO1xuaW1wb3J0IFwiLi9Eb25lXCI7XG5pbXBvcnQgXCIuL0ZhaWxlZFwiO1xuaW1wb3J0IFwiLi9DdXJyZW50XCI7XG5pbXBvcnQgXCIuL1BlbmRpbmdcIjtcbmltcG9ydCB7IElDT05fU1RBQ0tfQ1NTIH0gZnJvbSBcIkAvY29tcG9uZW50cy9JY29ucy9TdGFjay5jc3NcIjtcblxuY29uc3QgU1RBVEVfUlVOTklORyA9IFwicnVubmluZ1wiO1xuY29uc3QgU1RBVEVfUEVORElORyA9IFwicGVuZGluZ1wiO1xuY29uc3QgU1RBVEVfRE9ORSA9IFwiZG9uZVwiO1xuY29uc3QgU1RBVEVfRkFJTEVEID0gXCJmYWlsZWRcIjtcbmNvbnN0IFdTX0NIQU5ORUxfRkZNUEVHX09VVCA9IFwiRkZNcGVnT3V0XCI7XG5sZXQgcnVudGltZUludGVydmFsID0gZmFsc2U7XG5sZXQgY3VycmVudFJ1bnRpbWUgPSAwO1xuXG5jbGFzcyBTdGF0dXNiYXIgZXh0ZW5kcyBTbGltIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnVudGltZSA9IFwiMDA6MDA6MDBcIjtcbiAgICAgICAgdGhpcy5vdXQgPSBcIlwiO1xuICAgICAgICB0aGlzLnJhdGUgPSBcIlwiO1xuICAgICAgICB0aGlzLnJlbWFpbmluZyA9IFwiXCI7XG4gICAgICAgIHRoaXMucGVyY2VudGFnZSA9IDA7XG4gICAgICAgIHRoaXMuZGF0YXNldC5oYXNJdGVtcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIG9uQWRkZWQoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBJY29uaWZ5LnNjYW4odGhpcy5zaGFkb3dSb290KSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IHdpbmRvdy5FY2hvLmNoYW5uZWwoXCJGRk1wZWdQcm9ncmVzc1wiKTtcbiAgICAgICAgdGhpcy5jaGFubmVsLnN1YnNjcmliZWQodGhpcy5yZXF1ZXN0UHJvZ3Jlc3MuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5saXN0ZW4oXG4gICAgICAgICAgICBcIkZGTXBlZ1Byb2dyZXNzXCIsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVByb2dyZXNzRXZlbnQuYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNoYW5uZWxPdXQgPSB3aW5kb3cuRWNoby5jaGFubmVsKGAke1dTX0NIQU5ORUxfRkZNUEVHX09VVH1gKTtcbiAgICAgICAgdGhpcy5jaGFubmVsT3V0Lmxpc3RlbihcbiAgICAgICAgICAgIFdTX0NIQU5ORUxfRkZNUEVHX09VVCxcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlT3V0RXZlbnQuYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0aGlzLnNlY3Rpb25EZXRhaWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpICYmXG4gICAgICAgICAgICAgICAgcC5pbmRleE9mKHRoaXMuc2VjdGlvbkRldGFpbCkgPCAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZURldGFpbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwLmluZGV4T2YodGhpcy5idXR0b25EZXRhaWwpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZURldGFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVPdXRFdmVudCh3cykge1xuICAgICAgICB0aGlzLm91dCA9IHdzLm91dDtcbiAgICB9XG5cbiAgICB0b2dnbGVEZXRhaWwoKSB7XG4gICAgICAgIGNvbnN0IGRldGFpbCA9IHRoaXMuc2VjdGlvbkRldGFpbC5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnRvZ2dsZShcImRldGFpbFwiLCBkZXRhaWwpO1xuICAgICAgICB0aGlzLmljb25TaG9ydC5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsIGRldGFpbCk7XG4gICAgICAgIHRoaXMuaWNvbkRldGFpbC5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICFkZXRhaWwpO1xuICAgICAgICB0aGlzLnNlY3Rpb25EZXRhaWwuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCAhZGV0YWlsKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UHJvZ3Jlc3MoKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0UHJvZ3Jlc3MoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZXF1ZXN0LmdldChcIi9wcm9ncmVzc1wiLCBmYWxzZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIH1cblxuICAgIGhhbmRsZVByb2dyZXNzRXZlbnQoeyBxdWV1ZSB9KSB7XG4gICAgICAgIHRoaXMuZGF0YXNldC5oYXNJdGVtcyA9IChxdWV1ZS5sZW5ndGggPiAwKS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY3VycmVudCA9IHF1ZXVlLmZpbHRlcigocSkgPT4gcS5zdGF0ZSA9PT0gU1RBVEVfUlVOTklORyk7XG4gICAgICAgIGxldCBwZW5kaW5nID0gcXVldWUuZmlsdGVyKChxKSA9PiBxLnN0YXRlID09PSBTVEFURV9QRU5ESU5HKTtcbiAgICAgICAgbGV0IGZhaWxlZCA9IHF1ZXVlLmZpbHRlcigocSkgPT4gcS5zdGF0ZSA9PT0gU1RBVEVfRkFJTEVEKTtcbiAgICAgICAgbGV0IGRvbmUgPSBxdWV1ZS5maWx0ZXIoKHEpID0+IHEuc3RhdGUgPT09IFNUQVRFX0RPTkUpO1xuICAgICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBjdXJyZW50Lmxlbmd0aCA/IGN1cnJlbnRbMF0ucGVyY2VudGFnZSA6IDA7XG4gICAgICAgIHRoaXMucmF0ZSA9IGN1cnJlbnQubGVuZ3RoID8gY3VycmVudFswXS5yYXRlIDogMDtcbiAgICAgICAgdGhpcy5yZW1haW5pbmcgPSBjdXJyZW50Lmxlbmd0aCA/IGN1cnJlbnRbMF0ucmVtYWluaW5nIDogMDtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QudG9nZ2xlKFwicnVubmluZ1wiLCBjdXJyZW50Lmxlbmd0aCA+IDApO1xuICAgICAgICB0aGlzLmhhbmRsZVRpbWVyKGN1cnJlbnQpO1xuXG4gICAgICAgIHRoaXMuc2VjdGlvbkRldGFpbC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKS5mb3JFYWNoKChuKSA9PiBuLnJlbW92ZSgpKTtcblxuICAgICAgICBpZiAocGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5zZWN0aW9uRGV0YWlsLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdGF0dXMtcHJvZ3Jlc3MtcGVuZGluZ1wiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuaXRlbXMgPSBwZW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnNlY3Rpb25EZXRhaWwuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0YXR1cy1wcm9ncmVzcy1jdXJyZW50XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5pdGVtID0gY3VycmVudFswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFpbGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnNlY3Rpb25EZXRhaWwuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0YXR1cy1wcm9ncmVzcy1mYWlsZWRcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLml0ZW1zID0gZmFpbGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb25lLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnNlY3Rpb25EZXRhaWwuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0YXR1cy1wcm9ncmVzcy1kb25lXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5pdGVtcyA9IGRvbmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUaW1lcihjdXJyZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCAmJiAhcnVudGltZUludGVydmFsKSB7XG4gICAgICAgICAgICBjdXJyZW50UnVudGltZSA9XG4gICAgICAgICAgICAgICAgbmV3IERhdGUoY3VycmVudFswXS51cGRhdGVkX2F0KS5nZXRUaW1lKCkgLVxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGN1cnJlbnRbMF0uY3JlYXRlZF9hdCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgcnVudGltZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucnVudGltZSA9IG5ldyBEYXRlKGN1cnJlbnRSdW50aW1lKVxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoXCJUXCIpXG4gICAgICAgICAgICAgICAgICAgIC5wb3AoKVxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoXCIuXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSdW50aW1lICs9IDEwMDA7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSBlbHNlIGlmICghY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVudGltZUludGVydmFsKTtcbiAgICAgICAgICAgIHJ1bnRpbWVJbnRlcnZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdEtpbGwoKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIktpbGwgb2YgYWxsIGZmbXBlZyBwcm9jZXNzZXMgcmVxdWVzdGVkXCIpO1xuICAgICAgICBSZXF1ZXN0LnBvc3QoXCIva2lsbFwiKTtcbiAgICB9XG59XG5cblN0YXR1c2Jhci50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbjxzdHlsZT5cbjpob3N0IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgYm94LXNoYWRvdzogMCAwIDd2dyAwIHZhcigtLWNsci1zaGFkb3ctMCk7XG4gICAgei1pbmRleDogMDtcbn1cbm1haW4ge1xuICAgIHBhZGRpbmc6IC41ZW07XG4gICAgZm9udC1zaXplOiBtYXgoMTBweCwgLjg1cmVtKTtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMTUwKTtcbiAgICBib3JkZXI6IDJweCB2YXIoLS1jbHItYmctMjAwKTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogLjVyZW07XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB6LWluZGV4OiAxO1xufVxuZGl2IHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG59XG5kaXYuaGlkZGVuIHtcbiAgICBkaXNwbGF5OiBub25lO1xufVxuc2VjdGlvbjpmaXJzdC1vZi10eXBlIHtcbiAgICBmbGV4LWdyb3c6IDE7XG59XG5zZWN0aW9uIHtcbiAgICBwYWRkaW5nOiAwIC41cmVtO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkO1xuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY2xyLWJnLTApIHZhcigtLWNsci1iZy0wKSB2YXIoLS1jbHItYmctMjAwKSB2YXIoLS1jbHItYmctMjAwKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jbHItYmctMTQwKTtcbiAgICAtLWR1cmF0aW9uOiB2YXIoLS10cmFuc2l0aW9uLW1lZGl1bSk7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogYm90dG9tIHJpZ2h0O1xuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSB2YXIoLS1kdXJhdGlvbikgZWFzZS1pbi1vdXQsXG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoIHZhcigtLWR1cmF0aW9uKSBlYXNlLWluLW91dCxcbiAgICAgICAgICAgICAgICBtYXgtaGVpZ2h0IHZhcigtLWR1cmF0aW9uKSBlYXNlLWluLW91dDtcbn1cbnNlY3Rpb24uZGV0YWlsIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMTUwKTtcbiAgICBib3JkZXI6IDJweCB2YXIoLS1jbHItYmctMjAwKTtcbiAgICBib3gtc2hhZG93OiAwIDAgN3Z3IDAgdmFyKC0tY2xyLXNoYWRvdy0wKTtcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAuNXJlbTtcbiAgICBwYWRkaW5nOiAuNXJlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgZ2FwOiAuNWVtO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMDtcbiAgICBtYXgtd2lkdGg6IDkwdnc7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDAlKSBzY2FsZVkoMSk7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogdG9wO1xuICAgIHRvcDogMDtcbiAgICB6LWluZGV4OiAwO1xufVxuc2VjdGlvbi5oaWRkZW4ge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKSBzY2FsZVkoMCk7XG59XG4uZmZtcGVnLW91dCB7XG4gICAgY29sb3I6IHZhcigtLWNsci10ZXh0LWRpc2FibGVkKTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcbn1cbi5mZm1wZWctb3V0IC5pY29uLXN0YWNrIHtcbiAgICBkaXNwbGF5OiBub25lO1xufVxuOmhvc3QoLnJ1bm5pbmcpIC5mZm1wZWctb3V0IHtcbiAgICBjb2xvcjogdmFyKC0tY2xyLXRleHQtMCk7XG59XG46aG9zdCgucnVubmluZykgLmZmbXBlZy1vdXQgLmljb24tc3RhY2sge1xuICAgIGRpc3BsYXk6IHJldmVydDtcbn1cbi5ydW50aW1lIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG4ucnVudGltZSBzcGFuOmxhc3Qtb2YtdHlwZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGluc2V0OiAwIDAgMXB4O1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWNsci1lbmxpZ2h0ZW5lZCk7XG4gICAgYm94LXNoYWRvdzogMCAwIDVweCA1cHggaW5zZXQgdmFyKC0tY2xyLWVubGlnaHRlbmVkLWdsb3cpO1xuICAgIGNvbG9yOiB2YXIoLS1jbHItdGV4dC0yMDAtaW52ZXJzZSk7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3JkZXItcmFkaXVzOiAuMnJlbTtcbiAgICB0ZXh0LWluZGVudDogLjVyZW07XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xufVxuPC9zdHlsZT5cbiR7SUNPTl9TVEFDS19DU1N9XG48bWFpbj5cbiAgICA8c2VjdGlvbiBjbGFzcz1cImZmbXBlZy1vdXRcIj5cbiAgICAgICAgPHNwYW4+e3sgdGhpcy5vdXQgfX08L3NwYW4+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpY29uLXN0YWNrXCIgQGNsaWNrPVwie3sgdGhpcy5yZXF1ZXN0S2lsbCB9fVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLXNrdWxsLWNyb3NzYm9uZXMtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeSBob3ZlclwiIGRhdGEtaWNvbj1cIm1kaS1za3VsbC1jcm9zc2JvbmVzLW91dGxpbmVcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvc2VjdGlvbj5cbiAgICA8c2VjdGlvbiAjcmVmPVwic2VjdGlvblJ1bnRpbWVcIiBjbGFzcz1cInJ1bnRpbWVcIj5cbiAgICAgICAgPHNwYW4+e3sgdGhpcy5ydW50aW1lIH19PC9zcGFuPlxuICAgICAgICA8c3BhbiBzdHlsZT1cInt7ICd3aWR0aDonICsgdGhpcy5wZXJjZW50YWdlICsgJyUnIH19XCI+e3sgdGhpcy5ydW50aW1lIH19PC9zcGFuPlxuICAgIDwvc2VjdGlvbj5cbiAgICA8c2VjdGlvbiAjcmVmPVwic2VjdGlvblNob3J0XCI+e3sgdGhpcy5wZXJjZW50YWdlIH19JTwvc2VjdGlvbj5cbiAgICA8c2VjdGlvbiAjcmVmPVwiYnV0dG9uRGV0YWlsXCI+XG4gICAgICAgIDxkaXYgI3JlZj1cImljb25TaG9ydFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImljb24tc3RhY2tcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktcGx1cy1ib3gtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktcGx1cy1ib3gtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiAjcmVmPVwiaWNvbkRldGFpbFwiIGNsYXNzPVwiaGlkZGVuXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWNvbi1zdGFja1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1taW51cy1ib3gtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktbWludXMtYm94LW91dGxpbmVcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuPC9tYWluPlxuPHNlY3Rpb24gI3JlZj1cInNlY3Rpb25EZXRhaWxcIiBjbGFzcz1cImRldGFpbCBoaWRkZW5cIj48L3NlY3Rpb24+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJzdGF0dXMtYmFyXCIsIFN0YXR1c2Jhcik7XG4iXSwibmFtZXMiOlsiU2xpbSIsIkljb25pZnkiLCJSZXF1ZXN0IiwiSUNPTl9TVEFDS19DU1MiLCJTVEFURV9SVU5OSU5HIiwiU1RBVEVfUEVORElORyIsIlNUQVRFX0RPTkUiLCJTVEFURV9GQUlMRUQiLCJXU19DSEFOTkVMX0ZGTVBFR19PVVQiLCJydW50aW1lSW50ZXJ2YWwiLCJjdXJyZW50UnVudGltZSIsIlN0YXR1c2JhciIsInJ1bm5pbmciLCJydW50aW1lIiwib3V0IiwicmF0ZSIsInJlbWFpbmluZyIsInBlcmNlbnRhZ2UiLCJkYXRhc2V0IiwiaGFzSXRlbXMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzY2FuIiwic2hhZG93Um9vdCIsImNoYW5uZWwiLCJ3aW5kb3ciLCJFY2hvIiwic3Vic2NyaWJlZCIsInJlcXVlc3RQcm9ncmVzcyIsImJpbmQiLCJsaXN0ZW4iLCJoYW5kbGVQcm9ncmVzc0V2ZW50IiwiY2hhbm5lbE91dCIsImhhbmRsZU91dEV2ZW50IiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInAiLCJjb21wb3NlZFBhdGgiLCJzZWN0aW9uRGV0YWlsIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJpbmRleE9mIiwidG9nZ2xlRGV0YWlsIiwiYnV0dG9uRGV0YWlsIiwid3MiLCJkZXRhaWwiLCJ0b2dnbGUiLCJpY29uU2hvcnQiLCJpY29uRGV0YWlsIiwiZ2V0IiwiZXJyb3IiLCJxdWV1ZSIsImxlbmd0aCIsInRvU3RyaW5nIiwiY3VycmVudCIsImZpbHRlciIsInEiLCJzdGF0ZSIsInBlbmRpbmciLCJmYWlsZWQiLCJkb25lIiwiaGFuZGxlVGltZXIiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsIm4iLCJyZW1vdmUiLCJub2RlIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiaXRlbXMiLCJpdGVtIiwiRGF0ZSIsInVwZGF0ZWRfYXQiLCJnZXRUaW1lIiwiY3JlYXRlZF9hdCIsInNldEludGVydmFsIiwidG9JU09TdHJpbmciLCJzcGxpdCIsInBvcCIsInNoaWZ0IiwiY2xlYXJJbnRlcnZhbCIsImNvbnNvbGUiLCJpbmZvIiwicG9zdCIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Statusbar/index.js\n");

/***/ }),

/***/ "./resources/js/components/TextViewer/index.js":
/*!*****************************************************!*\
  !*** ./resources/js/components/TextViewer/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\n/* harmony import */ var _components_Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Request */ \"./resources/js/components/Request/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar WS_CHANNEL = 'TextViewer';\n\nvar TextViewer = /*#__PURE__*/function (_Slim) {\n  _inherits(TextViewer, _Slim);\n\n  var _super = _createSuper(TextViewer);\n\n  function TextViewer() {\n    _classCallCheck(this, TextViewer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(TextViewer, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this = this;\n\n      document.addEventListener('file-clicked', this.init.bind(this));\n      document.addEventListener('show-textcontent', this.showTextContent.bind(this));\n      requestAnimationFrame(function () {\n        return Iconify.scan(_this.shadowRoot);\n      });\n    }\n  }, {\n    key: \"init\",\n    value: function init(e) {\n      if (!this.item) {\n        if (this.isValid(e.detail)) {\n          this.item = e.detail;\n          this.initWebsocket();\n        }\n      }\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid(item) {\n      return 'text' === item.mime.split('/').shift() || 'json' === item.mime.split('/').pop();\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.classList.add('active');\n      document.dispatchEvent(new CustomEvent('textviewer-show', {\n        detail: true\n      }));\n      console.info('Show contents of %s', this.item.path);\n    }\n  }, {\n    key: \"showTextContent\",\n    value: function showTextContent(e) {\n      this.origin = 'textcontent';\n      this.content = e.detail.content;\n      this.classList.add('active');\n      document.dispatchEvent(new CustomEvent('textviewer-show', {\n        detail: true\n      }));\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this2 = this;\n\n      this.addEventListener('transitionend', function () {\n        _this2.classList.remove('active', 'fade-out');\n      });\n      this.classList.add('fade-out');\n\n      if (this.origin === 'file') {\n        this.item.node.iconActive = false;\n        delete this.item;\n        this.leaveWebsocket();\n      }\n\n      this.origin = undefined;\n      document.dispatchEvent(new CustomEvent('textviewer-show', {\n        detail: false\n      }));\n    }\n  }, {\n    key: \"initWebsocket\",\n    value: function initWebsocket() {\n      this.channel = window.Echo.channel(WS_CHANNEL);\n      this.channel.listen(WS_CHANNEL, this.handleTextViewerEvent.bind(this));\n      this.channel.subscribed(this.requestContent.bind(this));\n    }\n  }, {\n    key: \"leaveWebsocket\",\n    value: function leaveWebsocket() {\n      this.channel.stopListening(WS_CHANNEL);\n      window.Echo.leave(WS_CHANNEL);\n      delete this.channel;\n    }\n  }, {\n    key: \"requestContent\",\n    value: function requestContent() {\n      console.info('Attempt to fetch content of %s', this.item.path);\n\n      try {\n        this.origin = 'file';\n        _components_Request__WEBPACK_IMPORTED_MODULE_2__.Request.loading = true;\n        _components_Request__WEBPACK_IMPORTED_MODULE_2__.Request.get(\"/textviewer/\".concat(encodeURIComponent(this.item.path)));\n      } catch (error) {\n        this.leaveWebsocket();\n        this.hide();\n      }\n    }\n  }, {\n    key: \"handleTextViewerEvent\",\n    value: function handleTextViewerEvent(ws) {\n      console.info(ws);\n      this.content = ws.content;\n      this.show();\n      _components_Request__WEBPACK_IMPORTED_MODULE_2__.Request.loading = false;\n    }\n  }]);\n\n  return TextViewer;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nvar CSS =\n/*html*/\n\"\\n<style>\\n:host {\\n    position: fixed;\\n    inset: 0;\\n    display: none;\\n    opacity: 1;\\n    transition: opacity var(--transition-slow) linear;\\n}\\n:host(.active) {\\n    display: flex;\\n    align-items: center;\\n}\\n:host(.fade-out) {\\n    opacity: 0;\\n}\\nmain {\\n    position: absolute;\\n    box-shadow: 0 0 10vw 3vw var(--clr-shadow-0);\\n    inset: var(--rel-gutter-500);\\n    background-color: var(--clr-bg-0);\\n    border-radius: var(--rel-gutter-100);\\n    padding: var(--rel-gutter-200);\\n}\\nmain h1 {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n    padding: 0;\\n    margin: 0 0 var(--rel-gutter-100) 0;\\n    font-size: 1.75rem;\\n    user-select: none;\\n}\\nmain h1 div {\\n    cursor: pointer;\\n}\\npre {\\n    white-space: pre-wrap;\\n    background: var(--clr-bg-100);\\n    padding: .5rem;\\n    border-radius: .5rem;\\n    overflow-y: auto;\\n    height: calc(100% - 1.75rem - var(--rel-gutter-200) * 2);\\n}\\n</style>\\n\".concat(_components_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_1__.ICON_STACK_CSS, \"\\n\");\nvar HEADING =\n/*html*/\n\"\\n<h1>\\n    Textviewer\\n    <div @click=\\\"this.hide()\\\" class=\\\"icon-stack\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-close\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-close\\\"></span>\\n    </div>\\n</h1>\\n\";\nTextViewer.template =\n/*html*/\n\"\\n\".concat(CSS, \"\\n<main>\\n    \").concat(HEADING, \"\\n<pre>\\n{{ this.content }}\\n</pre>\\n</main>\\n\");\ncustomElements.define('text-viewer', TextViewer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9UZXh0Vmlld2VyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBRUEsSUFBTUcsVUFBVSxHQUFHLFlBQW5COztJQUVNQzs7Ozs7Ozs7Ozs7OztXQUVGLG1CQUFVO0FBQUE7O0FBQ05DLE1BQUFBLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsY0FBMUIsRUFBMEMsS0FBS0MsSUFBTCxDQUFVQyxJQUFWLENBQWUsSUFBZixDQUExQztBQUNBSCxNQUFBQSxRQUFRLENBQUNDLGdCQUFULENBQTBCLGtCQUExQixFQUE4QyxLQUFLRyxlQUFMLENBQXFCRCxJQUFyQixDQUEwQixJQUExQixDQUE5QztBQUNBRSxNQUFBQSxxQkFBcUIsQ0FBQztBQUFBLGVBQU1DLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLEtBQUksQ0FBQ0MsVUFBbEIsQ0FBTjtBQUFBLE9BQUQsQ0FBckI7QUFDSDs7O1dBRUQsY0FBS0MsQ0FBTCxFQUFRO0FBQ0osVUFBSSxDQUFDLEtBQUtDLElBQVYsRUFBZ0I7QUFDWixZQUFJLEtBQUtDLE9BQUwsQ0FBYUYsQ0FBQyxDQUFDRyxNQUFmLENBQUosRUFBNEI7QUFDeEIsZUFBS0YsSUFBTCxHQUFZRCxDQUFDLENBQUNHLE1BQWQ7QUFDQSxlQUFLQyxhQUFMO0FBQ0g7QUFDSjtBQUNKOzs7V0FFRCxpQkFBUUgsSUFBUixFQUFjO0FBQ1YsYUFBTyxXQUFXQSxJQUFJLENBQUNJLElBQUwsQ0FBVUMsS0FBVixDQUFnQixHQUFoQixFQUFxQkMsS0FBckIsRUFBWCxJQUNILFdBQVdOLElBQUksQ0FBQ0ksSUFBTCxDQUFVQyxLQUFWLENBQWdCLEdBQWhCLEVBQXFCRSxHQUFyQixFQURmO0FBRUg7OztXQUVELGdCQUFPO0FBQ0gsV0FBS0MsU0FBTCxDQUFlQyxHQUFmLENBQW1CLFFBQW5CO0FBQ0FuQixNQUFBQSxRQUFRLENBQUNvQixhQUFULENBQXVCLElB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LFFBQVg7QUFBc0I7QUFBdEIsWUFDRUYsR0FERiwyQkFHTUMsT0FITjtBQVVBRSxjQUFjLENBQUNDLE1BQWYsQ0FBc0IsYUFBdEIsRUFBcUNyRCxVQUFyQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL1RleHRWaWV3ZXIvaW5kZXguanM/ODhjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltIH0gZnJvbSAnQC9jb21wb25lbnRzL2xpYic7XG5pbXBvcnQgeyBJQ09OX1NUQUNLX0NTUyB9IGZyb20gJ0AvY29tcG9uZW50cy9JY29ucy9TdGFjay5jc3MnO1xuaW1wb3J0IHtSZXF1ZXN0fSBmcm9tICdAL2NvbXBvbmVudHMvUmVxdWVzdCdcblxuY29uc3QgV1NfQ0hBTk5FTCA9ICdUZXh0Vmlld2VyJ1xuXG5jbGFzcyBUZXh0Vmlld2VyIGV4dGVuZHMgU2xpbSB7XG5cbiAgICBvbkFkZGVkKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmaWxlLWNsaWNrZWQnLCB0aGlzLmluaXQuYmluZCh0aGlzKSlcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2hvdy10ZXh0Y29udGVudCcsIHRoaXMuc2hvd1RleHRDb250ZW50LmJpbmQodGhpcykpXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBJY29uaWZ5LnNjYW4odGhpcy5zaGFkb3dSb290KSlcbiAgICB9XG5cbiAgICBpbml0KGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLml0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoZS5kZXRhaWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtID0gZS5kZXRhaWxcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRXZWJzb2NrZXQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNWYWxpZChpdGVtKSB7XG4gICAgICAgIHJldHVybiAndGV4dCcgPT09IGl0ZW0ubWltZS5zcGxpdCgnLycpLnNoaWZ0KCkgfHxcbiAgICAgICAgICAgICdqc29uJyA9PT0gaXRlbS5taW1lLnNwbGl0KCcvJykucG9wKClcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd0ZXh0dmlld2VyLXNob3cnLCB7ZGV0YWlsOiB0cnVlfSkpXG4gICAgICAgIGNvbnNvbGUuaW5mbygnU2hvdyBjb250ZW50cyBvZiAlcycsIHRoaXMuaXRlbS5wYXRoKVxuICAgIH1cblxuICAgIHNob3dUZXh0Q29udGVudChlKSB7XG4gICAgICAgIHRoaXMub3JpZ2luID0gJ3RleHRjb250ZW50J1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBlLmRldGFpbC5jb250ZW50XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJylcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3RleHR2aWV3ZXItc2hvdycsIHtkZXRhaWw6IHRydWV9KSlcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScsICdmYWRlLW91dCcpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFkZS1vdXQnKVxuICAgICAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdmaWxlJykge1xuICAgICAgICAgICAgdGhpcy5pdGVtLm5vZGUuaWNvbkFjdGl2ZSA9IGZhbHNlXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pdGVtXG4gICAgICAgICAgICB0aGlzLmxlYXZlV2Vic29ja2V0KClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9yaWdpbiA9IHVuZGVmaW5lZFxuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndGV4dHZpZXdlci1zaG93Jywge2RldGFpbDogZmFsc2V9KSlcbiAgICB9XG5cbiAgICBpbml0V2Vic29ja2V0KCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSB3aW5kb3cuRWNoby5jaGFubmVsKFdTX0NIQU5ORUwpXG4gICAgICAgIHRoaXMuY2hhbm5lbC5saXN0ZW4oV1NfQ0hBTk5FTCwgdGhpcy5oYW5kbGVUZXh0Vmlld2VyRXZlbnQuYmluZCh0aGlzKSlcbiAgICAgICAgdGhpcy5jaGFubmVsLnN1YnNjcmliZWQodGhpcy5yZXF1ZXN0Q29udGVudC5iaW5kKHRoaXMpKVxuICAgIH1cblxuICAgIGxlYXZlV2Vic29ja2V0KCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwuc3RvcExpc3RlbmluZyhXU19DSEFOTkVMKVxuICAgICAgICB3aW5kb3cuRWNoby5sZWF2ZShXU19DSEFOTkVMKVxuICAgICAgICBkZWxldGUgdGhpcy5jaGFubmVsXG4gICAgfVxuXG4gICAgcmVxdWVzdENvbnRlbnQoKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnQXR0ZW1wdCB0byBmZXRjaCBjb250ZW50IG9mICVzJywgdGhpcy5pdGVtLnBhdGgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9ICdmaWxlJ1xuICAgICAgICAgICAgUmVxdWVzdC5sb2FkaW5nID0gdHJ1ZVxuICAgICAgICAgICAgUmVxdWVzdC5nZXQoYC90ZXh0dmlld2VyLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaXRlbS5wYXRoKX1gKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sZWF2ZVdlYnNvY2tldCgpXG4gICAgICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlVGV4dFZpZXdlckV2ZW50KHdzKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyh3cylcbiAgICAgICAgdGhpcy5jb250ZW50ID0gd3MuY29udGVudFxuICAgICAgICB0aGlzLnNob3coKVxuICAgICAgICBSZXF1ZXN0LmxvYWRpbmcgPSBmYWxzZVxuICAgIH1cbn1cblxuY29uc3QgQ1NTID0gLypodG1sKi9gXG48c3R5bGU+XG46aG9zdCB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGluc2V0OiAwO1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IHZhcigtLXRyYW5zaXRpb24tc2xvdykgbGluZWFyO1xufVxuOmhvc3QoLmFjdGl2ZSkge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbjpob3N0KC5mYWRlLW91dCkge1xuICAgIG9wYWNpdHk6IDA7XG59XG5tYWluIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm94LXNoYWRvdzogMCAwIDEwdncgM3Z3IHZhcigtLWNsci1zaGFkb3ctMCk7XG4gICAgaW5zZXQ6IHZhcigtLXJlbC1ndXR0ZXItNTAwKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jbHItYmctMCk7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tcmVsLWd1dHRlci0xMDApO1xuICAgIHBhZGRpbmc6IHZhcigtLXJlbC1ndXR0ZXItMjAwKTtcbn1cbm1haW4gaDEge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDAgMCB2YXIoLS1yZWwtZ3V0dGVyLTEwMCkgMDtcbiAgICBmb250LXNpemU6IDEuNzVyZW07XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG59XG5tYWluIGgxIGRpdiB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxucHJlIHtcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tY2xyLWJnLTEwMCk7XG4gICAgcGFkZGluZzogLjVyZW07XG4gICAgYm9yZGVyLXJhZGl1czogLjVyZW07XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDEuNzVyZW0gLSB2YXIoLS1yZWwtZ3V0dGVyLTIwMCkgKiAyKTtcbn1cbjwvc3R5bGU+XG4ke0lDT05fU1RBQ0tfQ1NTfVxuYFxuXG5jb25zdCBIRUFESU5HID0gLypodG1sKi9gXG48aDE+XG4gICAgVGV4dHZpZXdlclxuICAgIDxkaXYgQGNsaWNrPVwidGhpcy5oaWRlKClcIiBjbGFzcz1cImljb24tc3RhY2tcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWNsb3NlXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktY2xvc2VcIj48L3NwYW4+XG4gICAgPC9kaXY+XG48L2gxPlxuYFxuXG5UZXh0Vmlld2VyLnRlbXBsYXRlID0gLypodG1sKi9gXG4ke0NTU31cbjxtYWluPlxuICAgICR7SEVBRElOR31cbjxwcmU+XG57eyB0aGlzLmNvbnRlbnQgfX1cbjwvcHJlPlxuPC9tYWluPlxuYFxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RleHQtdmlld2VyJywgVGV4dFZpZXdlcik7Il0sIm5hbWVzIjpbIlNsaW0iLCJJQ09OX1NUQUNLX0NTUyIsIlJlcXVlc3QiLCJXU19DSEFOTkVMIiwiVGV4dFZpZXdlciIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImluaXQiLCJiaW5kIiwic2hvd1RleHRDb250ZW50IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiSWNvbmlmeSIsInNjYW4iLCJzaGFkb3dSb290IiwiZSIsIml0ZW0iLCJpc1ZhbGlkIiwiZGV0YWlsIiwiaW5pdFdlYnNvY2tldCIsIm1pbWUiLCJzcGxpdCIsInNoaWZ0IiwicG9wIiwiY2xhc3NMaXN0IiwiYWRkIiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiY29uc29sZSIsImluZm8iLCJwYXRoIiwib3JpZ2luIiwiY29udGVudCIsInJlbW92ZSIsIm5vZGUiLCJpY29uQWN0aXZlIiwibGVhdmVXZWJzb2NrZXQiLCJ1bmRlZmluZWQiLCJjaGFubmVsIiwid2luZG93IiwiRWNobyIsImxpc3RlbiIsImhhbmRsZVRleHRWaWV3ZXJFdmVudCIsInN1YnNjcmliZWQiLCJyZXF1ZXN0Q29udGVudCIsInN0b3BMaXN0ZW5pbmciLCJsZWF2ZSIsImxvYWRpbmciLCJnZXQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJlcnJvciIsImhpZGUiLCJ3cyIsInNob3ciLCJDU1MiLCJIRUFESU5HIiwidGVtcGxhdGUiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/TextViewer/index.js\n");

/***/ }),

/***/ "./resources/js/components/Toast/index.js":
/*!************************************************!*\
  !*** ./resources/js/components/Toast/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iconify/iconify */ \"./node_modules/@iconify/iconify/dist/iconify.min.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_iconify_iconify__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar STATES = ['success', 'info', 'warning', 'error'];\nvar DEFAULT_STATE = 'info';\n\nvar Toast = /*#__PURE__*/function (_Slim) {\n  _inherits(Toast, _Slim);\n\n  var _super = _createSuper(Toast);\n\n  function Toast() {\n    var _this;\n\n    _classCallCheck(this, Toast);\n\n    _this = _super.call(this);\n    _this.items = [];\n    document.addEventListener('toast', _this.show.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(Toast, [{\n    key: \"show\",\n    value: function show(e) {\n      var _this2 = this;\n\n      e.detail.type = STATES.indexOf(e.detail.type) > -1 ? e.detail.type : DEFAULT_STATE;\n      e.detail.id = \"\".concat(performance.now(), \"-\").concat(this.items.length);\n      this.items.unshift(e.detail);\n      _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(this, 'items');\n      requestAnimationFrame(function () {\n        return _iconify_iconify__WEBPACK_IMPORTED_MODULE_1___default().scan(_this2.shadowRoot);\n      });\n      this.animateIn();\n    }\n  }, {\n    key: \"animateIn\",\n    value: function animateIn() {\n      var _this3 = this;\n\n      var node = this.shadowRoot.querySelector('main > div');\n      this.items[0].height = node.offsetHeight;\n      requestAnimationFrame(function () {\n        node.dataset.transitionIn = 'before';\n        requestAnimationFrame(function () {\n          node.style.height = \"\".concat(_this3.items[0].height, \"px\");\n          node.dataset.transition = 'in';\n          node.addEventListener('transitionend', function () {\n            delete node.dataset.transition;\n            node.style.height = '';\n          }, {\n            once: true\n          });\n          requestAnimationFrame(function () {\n            return delete node.dataset.transitionIn;\n          });\n        });\n      });\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(item) {\n      var _this4 = this;\n\n      var idx = this.items.findIndex(function (i) {\n        return item.id === i.id;\n      });\n\n      if (idx > -1) {\n        var node = this.shadowRoot.querySelectorAll('main > div')[idx];\n        node.style.height = \"\".concat(item.height, \"px\");\n        requestAnimationFrame(function () {\n          node.dataset.transition = 'out';\n          requestAnimationFrame(function () {\n            node.addEventListener('transitionend', function () {\n              _this4.items.splice(idx, 1);\n\n              node.style.height = '';\n              delete node.dataset.transition;\n              delete node.dataset.transitionOut;\n              _components_lib__WEBPACK_IMPORTED_MODULE_0__.Utils.forceUpdate(_this4, 'items');\n            }, {\n              once: true\n            });\n            node.dataset.transitionOut = 'before';\n          });\n        });\n      }\n    }\n  }]);\n\n  return Toast;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nToast.template =\n/*html*/\n\"\\n<style>\\n:host {\\n    position: fixed;\\n    right: 2rem;\\n    top: 2rem;\\n    display: block;\\n    overflow-y: hidden;\\n}\\nmain {\\n    display: flex;\\n    flex-direction: column;\\n    gap: .5rem;\\n}\\nmain > div {\\n    width: 25rem;\\n    font-size: var(--font-size-50);\\n    color: hsla(0, 0%, 100%, .8);\\n    border-radius: .5rem;\\n    position: relative;\\n    transform-origin: center top;\\n    transform: scaleY(1);\\n    opacity: 1;\\n    max-height: 10rem;\\n    overflow: hidden;\\n}\\nmain > div:hover {\\n    max-height: 100rem;\\n}\\nmain > div[data-transition=\\\"in\\\"],\\nmain > div[data-transition=\\\"out\\\"] {\\n    transition: all var(--transition-medium) linear;\\n}\\nmain > div[data-transition-in=\\\"before\\\"],\\nmain > div[data-transition-out=\\\"before\\\"] {\\n    opacity: 0;\\n    transform: scaleY(.01);\\n    height: 0 !important;\\n}\\nmain > div {\\n    background: hsla(var(--hue-alert), var(--sat-alert), var(--lit-alert), var(--clr-base-alpha));\\n    cursor: pointer;\\n}\\nmain > div.success {\\n    --hue-alert: var(--hue-success);\\n}\\nmain > div.info {\\n    --hue-alert: var(--hue-info);\\n}\\nmain > div.warning {\\n    --hue-alert: var(--hue-warning);\\n}\\nmain > div.error {\\n    --hue-alert: var(--hue-error);\\n}\\nsvg {\\n    display: none;\\n    margin: .1rem .5rem 0 0;\\n    flex-shrink: 0;\\n}\\ndiv.success svg[data-icon=\\\"mdi-thumb-up-outline\\\"],\\ndiv.info svg[data-icon=\\\"mdi-alert-box-outline\\\"],\\ndiv.warning svg[data-icon=\\\"mdi-alert-outline\\\"],\\ndiv.error svg[data-icon=\\\"mdi-alert-circle-outline\\\"] {\\n    display: block;\\n}\\nsection {\\n    display: flex;\\n    align-items: flex-start;\\n    padding: .5rem;\\n}\\nsvg[data-icon=\\\"mdi-close\\\"] {\\n    display: block;\\n}\\n</style>\\n<main #ref=\\\"main\\\">\\n    <div *foreach=\\\"{{ this.items }}\\\" class=\\\"{{ item.type }}\\\" @click=\\\"{{ this.hide(item) }}\\\">\\n        <section>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-thumb-up-outline\\\"></span>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-alert-box-outline\\\"></span>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-alert-outline\\\"></span>\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-alert-circle-outline\\\"></span>\\n            {{ item.message }}\\n        </section>\\n    </div>\\n</main>\\n\";\ncustomElements.define('transcoder-toast', Toast);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Ub2FzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQSxJQUFNRyxNQUFNLEdBQUcsQ0FBQyxTQUFELEVBQVksTUFBWixFQUFvQixTQUFwQixFQUErQixPQUEvQixDQUFmO0FBQ0EsSUFBTUMsYUFBYSxHQUFHLE1BQXRCOztJQUVNQzs7Ozs7QUFFRixtQkFBYztBQUFBOztBQUFBOztBQUNWO0FBQ0EsVUFBS0MsS0FBTCxHQUFhLEVBQWI7QUFDQUMsSUFBQUEsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQixPQUExQixFQUFtQyxNQUFLQyxJQUFMLENBQVVDLElBQVYsK0JBQW5DO0FBSFU7QUFJYjs7OztXQUVELGNBQUtDLENBQUwsRUFBUTtBQUFBOztBQUNKQSxNQUFBQSxDQUFDLENBQUNDLE1BQUYsQ0FBU0MsSUFBVCxHQUFnQlYsTUFBTSxDQUFDVyxPQUFQLENBQWVILENBQUMsQ0FBQ0MsTUFBRixDQUFTQyxJQUF4QixJQUFnQyxDQUFDLENBQWpDLEdBQXFDRixDQUFDLENBQUNDLE1BQUYsQ0FBU0MsSUFBOUMsR0FBcURULGFBQXJFO0FBQ0FPLE1BQUFBLENBQUMsQ0FBQ0MsTUFBRixDQUFTRyxFQUFULGFBQWlCQyxXQUFXLENBQUNDLEdBQVosRUFBakIsY0FBc0MsS0FBS1gsS0FBTCxDQUFXWSxNQUFqRDtBQUNBLFdBQUtaLEtBQUwsQ0FBV2EsT0FBWCxDQUFtQlIsQ0FBQyxDQUFDQyxNQUFyQjtBQUNBWCxNQUFBQSw4REFBQSxDQUFrQixJQUFsQixFQUF3QixPQUF4QjtBQUVBb0IsTUFBQUEscUJBQXFCLENBQUM7QUFBQSxlQUFNbkIsNERBQUEsQ0FBYSxNQUFJLENBQUNxQixVQUFsQixDQUFOO0FBQUEsT0FBRCxDQUFyQjtBQUNBLFdBQUtDLFNBQUw7QUFDSDs7O1dBRUQscUJBQVk7QUFBQTs7QUFDUixVQUFJQyxJQUFJLEdBQUcsS0FBS0YsVUFBTCxDQUFnQkcsYUFBaEIsQ0FBOEIsWUFBOUIsQ0FBWDtBQUNBLFdBQUtwQixLQUFMLENBQVcsQ0FBWCxFQUFjcUIsTUFBZCxHQUF1QkYsSUFBSSxDQUFDRyxZQUE1QjtBQUNBUCxNQUFBQSxxQkFBcUIsQ0FBQyxZQUFNO0FBQ3hCSSxRQUFBQSxJQUFJLENBQUNJLE9BQUwsQ0FBYUMsWUFBYixHQUE0QixRQUE1QjtBQUNBVCxRQUFBQSxxQkFBcUIsQ0FBQyxZQUFNO0FBQ3hCSSxVQUFBQSxJQUFJLENBQUNNLEtBQUwsQ0FBV0osTUFBWCxhQUF1QixNQUFJLENBQUNyQixLQUFMLENBQVcsQ0FBWCxFQUFjcUIsTUFBckM7QUFDQUYsVUFBQUEsSUFBSSxDQUFDSSxPQUFMLENBQWFHLFVBQWIsR0FBMEIsSUFBMUI7QUFDQVAsVUFBQUEsSUFBSSxDQUFDakIsZ0JBQUwsQ0FBc0IsZUFBdEIsRUFBdUMsWUFBTTtBQUN6QyxtQkFBT2lCLElBQUksQ0FBQ0ksT0FBTCxDQUFhRyxVQUFwQjtBQUNBUCxZQUFBQSxJQUFJLENBQUNNLEtBQUwsQ0FBV0osTUFBWCxHQUFvQixFQUFwQjtBQUNILFdBSEQsRUFHRztBQUFDTSxZQUFBQSxJQUFJLEVBQUU7QUFBUCxXQUhIO0FBSUFaLFVBQUFBLHFCQUFxQixDQUFDO0FBQUEsbUJBQU0sT0FBT0ksSUFBSSxDQUFDSSxPQUFMLENBQWFDLFlBQTFCO0FBQUEsV0FBRCxDQUFyQjtBQUNILFNBUm9CLENBQXJCO0FBU0gsT0FYb0IsQ0FBckI7QUFZSDs7O1dBRUQsY0FBS0ksSUFBTCxFQUFXO0FBQUE7O0FBQ1AsVUFBSUMsR0FBRyxHQUFHLEtBQUs3QixLQUFMLENBQVc4QixTQUFYLENBQXFCLFVBQUFDLENBQUM7QUFBQSxlQUFJSCxJQUFJLENBQUNuQixFQUFMLEtBQVlzQixDQUFDLENBQUN0QixFQUFsQjtBQUFBLE9BQXRCLENBQVY7O0FBQ0EsVUFBSW9CLEdBQUcsR0FBRyxDQUFDLENBQVgsRUFBYztBQUNWLFlBQUlWLElBQUksR0FBRyxLQUFLRixVQUFMLENBQWdCZSxnQkFBaEIsQ0FBaUMsWUFBakMsRUFBK0NILEdBQS9DLENBQVg7QUFDQVYsUUFBQUEsSUFBSSxDQUFDTSxLQUFMLENBQVdKLE1BQVgsYUFBdUJPLElBQUksQ0FBQ1AsTUFBNUI7QUFDQU4sUUFBQUEscUJBQXFCLENBQUMsWUFBTTtBQUN4QkksVUFBQUEsSUFBSSxDQUFDSSxPQUFMLENBQWFHLFVBQWIsR0FBMEIsS0FBMUI7QUFDQVgsVUFBQUEscUJBQXFCLENBQUMsWUFBTTtBQUN4QkksWUFBQUEsSUFBSSxDQUFDakIsZ0JBQUwsQ0FBc0IsZUFBdEIsRUFBdUMsWUFBTTtBQUN6QyxvQkFBSSxDQUFDRixLQUFMLENBQVdpQyxNQUFYLENBQWtCSixHQUFsQixFQUF1QixDQUF2Qjs7QUFDQVYsY0FBQUEsSUFBSSxDQUFDTSxLQUFMLENBQVdKLE1BQVgsR0FBb0IsRUFBcEI7QUFDQSxxQkFBT0YsSUFBSSxDQUFDSSxPQUFMLENBQWFHLFVBQXBCO0FBQ0EscUJBQU9QLElBQUksQ0FBQ0ksT0FBTCxDQUFhVyxhQUFwQjtBQUNBdkMsY0FBQUEsOERBQUEsQ0FBa0IsTUFBbEIsRUFBd0IsT0FBeEI7QUFDSCxhQU5ELEVBTUc7QUFBQ2dDLGNBQUFBLElBQUksRUFBRTtBQUFQLGFBTkg7QUFPQVIsWUFBQUEsSUFBSSxDQUFDSSxPQUFMLENBQWFXLGFBQWIsR0FBNkIsUUFBN0I7QUFDSCxXQVRvQixDQUFyQjtBQVVILFNBWm9CLENBQXJCO0FBYUg7QUFDSjs7OztFQXREZXhDOztBQXlEcEJLLEtBQUssQ0FBQ29DLFFBQU47QUFBaUI7QUFBakI7QUF3RkFDLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixrQkFBdEIsRUFBMEN0QyxLQUExQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL1RvYXN0L2luZGV4LmpzPzliMWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2xpbSwgVXRpbHMgfSBmcm9tICdAL2NvbXBvbmVudHMvbGliJztcbmltcG9ydCBJY29uaWZ5IGZyb20gJ0BpY29uaWZ5L2ljb25pZnknXG5cbmNvbnN0IFNUQVRFUyA9IFsnc3VjY2VzcycsICdpbmZvJywgJ3dhcm5pbmcnLCAnZXJyb3InXVxuY29uc3QgREVGQVVMVF9TVEFURSA9ICdpbmZvJ1xuXG5jbGFzcyBUb2FzdCBleHRlbmRzIFNsaW0ge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvYXN0JywgdGhpcy5zaG93LmJpbmQodGhpcykpXG4gICAgfVxuXG4gICAgc2hvdyhlKSB7XG4gICAgICAgIGUuZGV0YWlsLnR5cGUgPSBTVEFURVMuaW5kZXhPZihlLmRldGFpbC50eXBlKSA+IC0xID8gZS5kZXRhaWwudHlwZSA6IERFRkFVTFRfU1RBVEVcbiAgICAgICAgZS5kZXRhaWwuaWQgPSBgJHtwZXJmb3JtYW5jZS5ub3coKX0tJHt0aGlzLml0ZW1zLmxlbmd0aH1gXG4gICAgICAgIHRoaXMuaXRlbXMudW5zaGlmdChlLmRldGFpbClcbiAgICAgICAgVXRpbHMuZm9yY2VVcGRhdGUodGhpcywgJ2l0ZW1zJylcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gSWNvbmlmeS5zY2FuKHRoaXMuc2hhZG93Um9vdCkpXG4gICAgICAgIHRoaXMuYW5pbWF0ZUluKClcbiAgICB9XG5cbiAgICBhbmltYXRlSW4oKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ21haW4gPiBkaXYnKVxuICAgICAgICB0aGlzLml0ZW1zWzBdLmhlaWdodCA9IG5vZGUub2Zmc2V0SGVpZ2h0XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBub2RlLmRhdGFzZXQudHJhbnNpdGlvbkluID0gJ2JlZm9yZSdcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLml0ZW1zWzBdLmhlaWdodH1weGBcbiAgICAgICAgICAgICAgICBub2RlLmRhdGFzZXQudHJhbnNpdGlvbiA9ICdpbidcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLmRhdGFzZXQudHJhbnNpdGlvblxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9ICcnXG4gICAgICAgICAgICAgICAgfSwge29uY2U6IHRydWV9KVxuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBkZWxldGUgbm9kZS5kYXRhc2V0LnRyYW5zaXRpb25JbilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgaGlkZShpdGVtKSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLml0ZW1zLmZpbmRJbmRleChpID0+IGl0ZW0uaWQgPT09IGkuaWQpXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnbWFpbiA+IGRpdicpW2lkeF07XG4gICAgICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGAke2l0ZW0uaGVpZ2h0fXB4YFxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGFzZXQudHJhbnNpdGlvbiA9ICdvdXQnXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaWR4LCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuZGF0YXNldC50cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5kYXRhc2V0LnRyYW5zaXRpb25PdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmZvcmNlVXBkYXRlKHRoaXMsICdpdGVtcycpXG4gICAgICAgICAgICAgICAgICAgIH0sIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhc2V0LnRyYW5zaXRpb25PdXQgPSAnYmVmb3JlJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5Ub2FzdC50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbjxzdHlsZT5cbjpob3N0IHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgcmlnaHQ6IDJyZW07XG4gICAgdG9wOiAycmVtO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcbn1cbm1haW4ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBnYXA6IC41cmVtO1xufVxubWFpbiA+IGRpdiB7XG4gICAgd2lkdGg6IDI1cmVtO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tZm9udC1zaXplLTUwKTtcbiAgICBjb2xvcjogaHNsYSgwLCAwJSwgMTAwJSwgLjgpO1xuICAgIGJvcmRlci1yYWRpdXM6IC41cmVtO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgdG9wO1xuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpO1xuICAgIG9wYWNpdHk6IDE7XG4gICAgbWF4LWhlaWdodDogMTByZW07XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cbm1haW4gPiBkaXY6aG92ZXIge1xuICAgIG1heC1oZWlnaHQ6IDEwMHJlbTtcbn1cbm1haW4gPiBkaXZbZGF0YS10cmFuc2l0aW9uPVwiaW5cIl0sXG5tYWluID4gZGl2W2RhdGEtdHJhbnNpdGlvbj1cIm91dFwiXSB7XG4gICAgdHJhbnNpdGlvbjogYWxsIHZhcigtLXRyYW5zaXRpb24tbWVkaXVtKSBsaW5lYXI7XG59XG5tYWluID4gZGl2W2RhdGEtdHJhbnNpdGlvbi1pbj1cImJlZm9yZVwiXSxcbm1haW4gPiBkaXZbZGF0YS10cmFuc2l0aW9uLW91dD1cImJlZm9yZVwiXSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSguMDEpO1xuICAgIGhlaWdodDogMCAhaW1wb3J0YW50O1xufVxubWFpbiA+IGRpdiB7XG4gICAgYmFja2dyb3VuZDogaHNsYSh2YXIoLS1odWUtYWxlcnQpLCB2YXIoLS1zYXQtYWxlcnQpLCB2YXIoLS1saXQtYWxlcnQpLCB2YXIoLS1jbHItYmFzZS1hbHBoYSkpO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn1cbm1haW4gPiBkaXYuc3VjY2VzcyB7XG4gICAgLS1odWUtYWxlcnQ6IHZhcigtLWh1ZS1zdWNjZXNzKTtcbn1cbm1haW4gPiBkaXYuaW5mbyB7XG4gICAgLS1odWUtYWxlcnQ6IHZhcigtLWh1ZS1pbmZvKTtcbn1cbm1haW4gPiBkaXYud2FybmluZyB7XG4gICAgLS1odWUtYWxlcnQ6IHZhcigtLWh1ZS13YXJuaW5nKTtcbn1cbm1haW4gPiBkaXYuZXJyb3Ige1xuICAgIC0taHVlLWFsZXJ0OiB2YXIoLS1odWUtZXJyb3IpO1xufVxuc3ZnIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICAgIG1hcmdpbjogLjFyZW0gLjVyZW0gMCAwO1xuICAgIGZsZXgtc2hyaW5rOiAwO1xufVxuZGl2LnN1Y2Nlc3Mgc3ZnW2RhdGEtaWNvbj1cIm1kaS10aHVtYi11cC1vdXRsaW5lXCJdLFxuZGl2LmluZm8gc3ZnW2RhdGEtaWNvbj1cIm1kaS1hbGVydC1ib3gtb3V0bGluZVwiXSxcbmRpdi53YXJuaW5nIHN2Z1tkYXRhLWljb249XCJtZGktYWxlcnQtb3V0bGluZVwiXSxcbmRpdi5lcnJvciBzdmdbZGF0YS1pY29uPVwibWRpLWFsZXJ0LWNpcmNsZS1vdXRsaW5lXCJdIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbn1cbnNlY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgcGFkZGluZzogLjVyZW07XG59XG5zdmdbZGF0YS1pY29uPVwibWRpLWNsb3NlXCJdIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbn1cbjwvc3R5bGU+XG48bWFpbiAjcmVmPVwibWFpblwiPlxuICAgIDxkaXYgKmZvcmVhY2g9XCJ7eyB0aGlzLml0ZW1zIH19XCIgY2xhc3M9XCJ7eyBpdGVtLnR5cGUgfX1cIiBAY2xpY2s9XCJ7eyB0aGlzLmhpZGUoaXRlbSkgfX1cIj5cbiAgICAgICAgPHNlY3Rpb24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktdGh1bWItdXAtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1hbGVydC1ib3gtb3V0bGluZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cIm1kaS1hbGVydC1vdXRsaW5lXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLWFsZXJ0LWNpcmNsZS1vdXRsaW5lXCI+PC9zcGFuPlxuICAgICAgICAgICAge3sgaXRlbS5tZXNzYWdlIH19XG4gICAgICAgIDwvc2VjdGlvbj5cbiAgICA8L2Rpdj5cbjwvbWFpbj5cbmA7XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgndHJhbnNjb2Rlci10b2FzdCcsIFRvYXN0KTsiXSwibmFtZXMiOlsiU2xpbSIsIlV0aWxzIiwiSWNvbmlmeSIsIlNUQVRFUyIsIkRFRkFVTFRfU1RBVEUiLCJUb2FzdCIsIml0ZW1zIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwic2hvdyIsImJpbmQiLCJlIiwiZGV0YWlsIiwidHlwZSIsImluZGV4T2YiLCJpZCIsInBlcmZvcm1hbmNlIiwibm93IiwibGVuZ3RoIiwidW5zaGlmdCIsImZvcmNlVXBkYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2NhbiIsInNoYWRvd1Jvb3QiLCJhbmltYXRlSW4iLCJub2RlIiwicXVlcnlTZWxlY3RvciIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsImRhdGFzZXQiLCJ0cmFuc2l0aW9uSW4iLCJzdHlsZSIsInRyYW5zaXRpb24iLCJvbmNlIiwiaXRlbSIsImlkeCIsImZpbmRJbmRleCIsImkiLCJxdWVyeVNlbGVjdG9yQWxsIiwic3BsaWNlIiwidHJhbnNpdGlvbk91dCIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Toast/index.js\n");

/***/ }),

/***/ "./resources/js/components/Transcoder.js":
/*!***********************************************!*\
  !*** ./resources/js/components/Transcoder.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _FilePicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FilePicker */ \"./resources/js/components/FilePicker/index.js\");\n/* harmony import */ var _Configurator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Configurator */ \"./resources/js/components/Configurator/index.js\");\n/* harmony import */ var _TextViewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TextViewer */ \"./resources/js/components/TextViewer/index.js\");\n/* harmony import */ var _Request__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Request */ \"./resources/js/components/Request/index.js\");\n/* harmony import */ var _Toast__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Toast */ \"./resources/js/components/Toast/index.js\");\n/* harmony import */ var _Statusbar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Statusbar */ \"./resources/js/components/Statusbar/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\nvar Transcoder = /*#__PURE__*/function (_Slim) {\n  _inherits(Transcoder, _Slim);\n\n  var _super = _createSuper(Transcoder);\n\n  function Transcoder() {\n    var _this;\n\n    _classCallCheck(this, Transcoder);\n\n    _this = _super.call(this);\n    _this.backgroundRequests = 0;\n    return _this;\n  }\n\n  _createClass(Transcoder, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var backgroundHandler = this.toggleBackground.bind(this);\n      this.filePicker.channelHash = this.dataset.channel;\n      document.addEventListener(\"loading\", backgroundHandler);\n      document.addEventListener(\"configurator-show\", backgroundHandler);\n      document.addEventListener(\"textviewer-show\", backgroundHandler);\n      document.addEventListener(\"modal-show\", backgroundHandler);\n    }\n  }, {\n    key: \"toggleBackground\",\n    value: function toggleBackground(e) {\n      if (e.detail) {\n        this.classList.add(\"background\");\n        document.body.style.overflow = \"hidden\";\n        this.backgroundRequests++;\n      } else {\n        this.backgroundRequests--;\n      }\n\n      if (!this.backgroundRequests) {\n        document.body.style.overflow = \"\";\n        this.classList.remove(\"background\");\n      }\n    }\n  }, {\n    key: \"selectChange\",\n    value: function selectChange(e) {\n      console.log(\"Change: \", e.target.value);\n    }\n  }, {\n    key: \"selectClick\",\n    value: function selectClick(e) {\n      console.log(\"Action: \", e.target.value);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode() {\n      return this;\n    }\n  }]);\n\n  return Transcoder;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nTranscoder.template =\n/*html*/\n\"\\n<style>\\n    :host {\\n        height: 100%;\\n        display: grid;\\n        grid-template-rows: 5rem calc(100vh - 7rem) var(--statusbar-height);\\n        grid-template-areas: \\\"header\\\" \\\"filepicker\\\" \\\"status\\\";\\n    }\\n    :host(.background) h1,\\n    :host(.background) main {\\n        filter: blur(3px);\\n    }\\n    main, h1 {\\n        filter: blur(0);\\n        transition: var(--loading-transition);\\n    }\\n    h1 {\\n        user-select: none;\\n        grid-area: header;\\n    }\\n    main {\\n        padding: .2rem;\\n        grid-area: filepicker;\\n        overflow: hidden;\\n        align-self: stretch;\\n    }\\n    filepicker-root {\\n        height: 100%;\\n    }\\n    status-bar {\\n        grid-area: status;\\n    }\\n</style>\\n<h1>PVR Toolbox</h1>\\n<main>\\n    <filepicker-root #ref=\\\"filePicker\\\"></filepicker-root>\\n</main>\\n<transcode-configurator #ref=\\\"configurator\\\"></transcode-configurator>\\n<text-viewer></text-viewer>\\n<status-bar></status-bar>\\n<transcoder-toast></transcoder-toast>\\n<transcoder-loading></transcoder-loading>\\n\";\ncustomElements.define(\"ffmpeg-transcoder\", Transcoder);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9UcmFuc2NvZGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUVNQzs7Ozs7QUFDRix3QkFBYztBQUFBOztBQUFBOztBQUNWO0FBQ0EsVUFBS0Msa0JBQUwsR0FBMEIsQ0FBMUI7QUFGVTtBQUdiOzs7O1dBRUQsbUJBQVU7QUFDTixVQUFJQyxpQkFBaUIsR0FBRyxLQUFLQyxnQkFBTCxDQUFzQkMsSUFBdEIsQ0FBMkIsSUFBM0IsQ0FBeEI7QUFDQSxXQUFLQyxVQUFMLENBQWdCQyxXQUFoQixHQUE4QixLQUFLQyxPQUFMLENBQWFDLE9BQTNDO0FBQ0FDLE1BQUFBLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsU0FBMUIsRUFBcUNSLGlCQUFyQztBQUNBTyxNQUFBQSxRQUFRLENBQUNDLGdCQUFULENBQTBCLG1CQUExQixFQUErQ1IsaUJBQS9DO0FBQ0FPLE1BQUFBLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsaUJBQTFCLEVBQTZDUixpQkFBN0M7QUFDQU8sTUFBQUEsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQixZQUExQixFQUF3Q1IsaUJBQXhDO0FBQ0g7OztXQUVELDBCQUFpQlMsQ0FBakIsRUFBb0I7QUFDaEIsVUFBSUEsQ0FBQyxDQUFDQyxNQUFOLEVBQWM7QUFDVixhQUFLQyxTQUFMLENBQWVDLEdBQWYsQ0FBbUIsWUFBbkI7QUFDQUwsUUFBQUEsUUFBUSxDQUFDTSxJQUFULENBQWNDLEtBQWQsQ0FBb0JDLFFBQXBCLEdBQStCLFFBQS9CO0FBQ0EsYUFBS2hCLGtCQUFMO0FBQ0gsT0FKRCxNQUlPO0FBQ0gsYUFBS0Esa0JBQUw7QUFDSDs7QUFDRCxVQUFJLENBQUMsS0FBS0Esa0JBQVYsRUFBOEI7QUFDMUJRLFFBQUFBLFFBQVEsQ0FBQ00sSUFBVCxDQUFjQyxLQUFkLENBQW9CQyxRQUFwQixHQUErQixFQUEvQjtBQUNBLGFBQUtKLFNBQUwsQ0FBZUssTUFBZixDQUFzQixZQUF0QjtBQUNIO0FBQ0o7OztXQUVELHNCQUFhUCxDQUFiLEVBQWdCO0FBQ1pRLE1BQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLFVBQVosRUFBd0JULENBQUMsQ0FBQ1UsTUFBRixDQUFTQyxLQUFqQztBQUNIOzs7V0FDRCxxQkFBWVgsQ0FBWixFQUFlO0FBQ1hRLE1BQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLFVBQVosRUFBd0JULENBQUMsQ0FBQ1UsTUFBRixDQUFTQyxLQUFqQztBQUNIOzs7V0FDRCxtQkFBVTtBQUNOLGFBQU8sSUFBUDtBQUNIOzs7O0VBckNvQnZCOztBQXdDekJDLFVBQVUsQ0FBQ3VCLFFBQVg7QUFBc0I7QUFBdEI7QUE0Q0FDLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixtQkFBdEIsRUFBMkN6QixVQUEzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL1RyYW5zY29kZXIuanM/OTUyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltIH0gZnJvbSBcIkAvY29tcG9uZW50cy9saWJcIjtcbmltcG9ydCBcIi4vRmlsZVBpY2tlclwiO1xuaW1wb3J0IFwiLi9Db25maWd1cmF0b3JcIjtcbmltcG9ydCBcIi4vVGV4dFZpZXdlclwiO1xuaW1wb3J0IFwiLi9SZXF1ZXN0XCI7XG5pbXBvcnQgXCIuL1RvYXN0XCI7XG5pbXBvcnQgXCIuL1N0YXR1c2JhclwiO1xuXG5jbGFzcyBUcmFuc2NvZGVyIGV4dGVuZHMgU2xpbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZFJlcXVlc3RzID0gMDtcbiAgICB9XG5cbiAgICBvbkFkZGVkKCkge1xuICAgICAgICBsZXQgYmFja2dyb3VuZEhhbmRsZXIgPSB0aGlzLnRvZ2dsZUJhY2tncm91bmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5maWxlUGlja2VyLmNoYW5uZWxIYXNoID0gdGhpcy5kYXRhc2V0LmNoYW5uZWw7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkaW5nXCIsIGJhY2tncm91bmRIYW5kbGVyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbmZpZ3VyYXRvci1zaG93XCIsIGJhY2tncm91bmRIYW5kbGVyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRleHR2aWV3ZXItc2hvd1wiLCBiYWNrZ3JvdW5kSGFuZGxlcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb2RhbC1zaG93XCIsIGJhY2tncm91bmRIYW5kbGVyKTtcbiAgICB9XG5cbiAgICB0b2dnbGVCYWNrZ3JvdW5kKGUpIHtcbiAgICAgICAgaWYgKGUuZGV0YWlsKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoXCJiYWNrZ3JvdW5kXCIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRSZXF1ZXN0cysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kUmVxdWVzdHMtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYmFja2dyb3VuZFJlcXVlc3RzKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcImJhY2tncm91bmRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RDaGFuZ2UoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNoYW5nZTogXCIsIGUudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG4gICAgc2VsZWN0Q2xpY2soZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFjdGlvbjogXCIsIGUudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG4gICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5UcmFuc2NvZGVyLnRlbXBsYXRlID0gLypodG1sKi8gYFxuPHN0eWxlPlxuICAgIDpob3N0IHtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgICBncmlkLXRlbXBsYXRlLXJvd3M6IDVyZW0gY2FsYygxMDB2aCAtIDdyZW0pIHZhcigtLXN0YXR1c2Jhci1oZWlnaHQpO1xuICAgICAgICBncmlkLXRlbXBsYXRlLWFyZWFzOiBcImhlYWRlclwiIFwiZmlsZXBpY2tlclwiIFwic3RhdHVzXCI7XG4gICAgfVxuICAgIDpob3N0KC5iYWNrZ3JvdW5kKSBoMSxcbiAgICA6aG9zdCguYmFja2dyb3VuZCkgbWFpbiB7XG4gICAgICAgIGZpbHRlcjogYmx1cigzcHgpO1xuICAgIH1cbiAgICBtYWluLCBoMSB7XG4gICAgICAgIGZpbHRlcjogYmx1cigwKTtcbiAgICAgICAgdHJhbnNpdGlvbjogdmFyKC0tbG9hZGluZy10cmFuc2l0aW9uKTtcbiAgICB9XG4gICAgaDEge1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgZ3JpZC1hcmVhOiBoZWFkZXI7XG4gICAgfVxuICAgIG1haW4ge1xuICAgICAgICBwYWRkaW5nOiAuMnJlbTtcbiAgICAgICAgZ3JpZC1hcmVhOiBmaWxlcGlja2VyO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgIH1cbiAgICBmaWxlcGlja2VyLXJvb3Qge1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuICAgIHN0YXR1cy1iYXIge1xuICAgICAgICBncmlkLWFyZWE6IHN0YXR1cztcbiAgICB9XG48L3N0eWxlPlxuPGgxPlBWUiBUb29sYm94PC9oMT5cbjxtYWluPlxuICAgIDxmaWxlcGlja2VyLXJvb3QgI3JlZj1cImZpbGVQaWNrZXJcIj48L2ZpbGVwaWNrZXItcm9vdD5cbjwvbWFpbj5cbjx0cmFuc2NvZGUtY29uZmlndXJhdG9yICNyZWY9XCJjb25maWd1cmF0b3JcIj48L3RyYW5zY29kZS1jb25maWd1cmF0b3I+XG48dGV4dC12aWV3ZXI+PC90ZXh0LXZpZXdlcj5cbjxzdGF0dXMtYmFyPjwvc3RhdHVzLWJhcj5cbjx0cmFuc2NvZGVyLXRvYXN0PjwvdHJhbnNjb2Rlci10b2FzdD5cbjx0cmFuc2NvZGVyLWxvYWRpbmc+PC90cmFuc2NvZGVyLWxvYWRpbmc+XG5gO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJmZm1wZWctdHJhbnNjb2RlclwiLCBUcmFuc2NvZGVyKTtcbiJdLCJuYW1lcyI6WyJTbGltIiwiVHJhbnNjb2RlciIsImJhY2tncm91bmRSZXF1ZXN0cyIsImJhY2tncm91bmRIYW5kbGVyIiwidG9nZ2xlQmFja2dyb3VuZCIsImJpbmQiLCJmaWxlUGlja2VyIiwiY2hhbm5lbEhhc2giLCJkYXRhc2V0IiwiY2hhbm5lbCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJkZXRhaWwiLCJjbGFzc0xpc3QiLCJhZGQiLCJib2R5Iiwic3R5bGUiLCJvdmVyZmxvdyIsInJlbW92ZSIsImNvbnNvbGUiLCJsb2ciLCJ0YXJnZXQiLCJ2YWx1ZSIsInRlbXBsYXRlIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Transcoder.js\n");

/***/ }),

/***/ "./resources/js/components/lib/index.js":
/*!**********************************************!*\
  !*** ./resources/js/components/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Slim\": () => (/* reexport safe */ slim_js__WEBPACK_IMPORTED_MODULE_0__.Slim),\n/* harmony export */   \"Utils\": () => (/* reexport safe */ slim_js__WEBPACK_IMPORTED_MODULE_0__.Utils),\n/* harmony export */   \"Iconify\": () => (/* reexport default from dynamic */ _iconify_iconify__WEBPACK_IMPORTED_MODULE_2___default.a)\n/* harmony export */ });\n/* harmony import */ var slim_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slim-js */ \"./node_modules/slim-js/dist/index.js\");\n/* harmony import */ var _node_modules_slim_js_dist_directives_all__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/slim-js/dist/directives/all */ \"./node_modules/slim-js/dist/directives/all.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iconify/iconify */ \"./node_modules/@iconify/iconify/dist/iconify.min.js\");\n/* harmony import */ var _iconify_iconify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_iconify_iconify__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL2xpYi9pbmRleC5qcz8wZmEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaW0sIFV0aWxzIH0gZnJvbSAnc2xpbS1qcyc7XG5pbXBvcnQgJy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zbGltLWpzL2Rpc3QvZGlyZWN0aXZlcy9hbGwnXG5pbXBvcnQgSWNvbmlmeSBmcm9tICdAaWNvbmlmeS9pY29uaWZ5J1xuXG5leHBvcnQgeyBTbGltLCBVdGlscywgSWNvbmlmeSB9Il0sIm5hbWVzIjpbIlNsaW0iLCJVdGlscyIsIkljb25pZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/lib/index.js\n");

/***/ }),

/***/ "./resources/js/components/partials/buttons/ComboButton.js":
/*!*****************************************************************!*\
  !*** ./resources/js/components/partials/buttons/ComboButton.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboButton\": () => (/* binding */ ComboButton)\n/* harmony export */ });\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _ComboButton_DropdownCSS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComboButton/DropdownCSS */ \"./resources/js/components/partials/buttons/ComboButton/DropdownCSS.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar ComboButton = /*#__PURE__*/function (_Slim) {\n  _inherits(ComboButton, _Slim);\n\n  var _super = _createSuper(ComboButton);\n\n  function ComboButton() {\n    var _this;\n\n    _classCallCheck(this, ComboButton);\n\n    _this = _super.call(this);\n    _this.click = _this.click.bind(_assertThisInitialized(_this));\n    _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));\n    _this.setValue = _this.setValue.bind(_assertThisInitialized(_this));\n    _this.options = _this.querySelectorAll(\"option\");\n    _this.selectedIndex = 0;\n    _this.value = _this.options[0].value;\n    _this.label = _this.options[0].textContent;\n    return _this;\n  }\n\n  _createClass(ComboButton, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this2 = this;\n\n      requestAnimationFrame(function () {\n        _components_lib__WEBPACK_IMPORTED_MODULE_0__.Iconify.scan(_this2.shadowRoot);\n        requestAnimationFrame(function () {\n          _this2.shadowRoot.querySelector(\"svg\").setAttribute(\"part\", \"icon\");\n\n          _this2.shadowRoot.querySelector(\"svg.hover\").setAttribute(\"part\", \"icon icon-hover\");\n        });\n      });\n    }\n    /**\n     * @param {ClickEvent} e\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle(e) {\n      var _this3 = this;\n\n      var path = e.composedPath();\n\n      if (path.indexOf(this.wrapper) > -1 || path.indexOf(this) > -1) {\n        e.stopPropagation();\n      }\n\n      if (this.wrapper) {\n        if (e.target.tagName === \"OPTION\" && path.indexOf(this.wrapper) > -1) {\n          this.setValue(e);\n        }\n\n        this.wrapper.remove();\n        this.noScroll.remove();\n        delete this.wrapper;\n        delete this.noScroll;\n        document.removeEventListener(\"click\", this.toggle, {\n          once: true\n        });\n      } else {\n        this.noScroll = document.body.appendChild(document.createElement('div'));\n        this.noScroll.style.position = 'fixed';\n        this.noScroll.style.inset = 0;\n        this.wrapper = document.createElement(\"div\");\n        this.options.forEach(function (o) {\n          _this3.wrapper.appendChild(o.cloneNode(true));\n        });\n        document.body.appendChild(this.wrapper);\n        document.addEventListener(\"click\", this.toggle, {\n          once: true\n        });\n        this.wrapper.classList.add(\"combo-button-dropdown\");\n        this.applyWrapperPosition();\n      }\n    }\n  }, {\n    key: \"applyWrapperPosition\",\n    value: function applyWrapperPosition() {\n      var styles = getComputedStyle(this.dropdown);\n      var dim = this.button.getBoundingClientRect();\n      this.wrapper.style.left = \"\".concat(dim.right, \"px\");\n      this.wrapper.style.top = \"\".concat(dim.bottom + document.scrollingElement.scrollTop, \"px\");\n      this.wrapper.style.minWidth = \"calc(\".concat(dim.width, \"px - \").concat(styles.getPropertyValue(\"border-left-width\"), \" - \").concat(styles.getPropertyValue(\"border-right-width\"), \")\");\n      this.wrapper.style.display = \"revert\";\n      var wrapperDim = this.wrapper.getBoundingClientRect();\n\n      if (wrapperDim.bottom > window.innerHeight) {\n        this.wrapper.style.top = \"\".concat(dim.top - wrapperDim.height + document.scrollingElement.scrollTop, \"px\");\n      }\n\n      this.wrapper.style.transform = \"translate(-100%)\";\n    }\n    /**\n     * @param {ClickEvent} e\n     */\n\n  }, {\n    key: \"setValue\",\n    value: function setValue(e) {\n      this.value = e.target.value;\n      this.label = e.target.textContent;\n      this.selectedIndex = Array.from(this.options).indexOf(e.explicitOriginalTarget);\n      this.dispatchEvent(new CustomEvent(\"change\"));\n    }\n  }]);\n\n  return ComboButton;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nComboButton.template =\n/*html*/\n\"\\n<style>\\n    :host {\\n        display: inline-block;\\n    }\\n    button {\\n        display: flex;\\n        width: 100%;\\n        justify-content: space-between;\\n    }\\n    button:hover svg:not(.hover),\\n    button svg.hover {\\n        display: none;\\n    }\\n    button:hover svg.hover {\\n        display: revert;\\n    }\\n    .label {\\n        display: inline-block;\\n    }\\n    .toggle {\\n        display: flex;\\n        align-items: center;\\n        padding-inline-start: inherit;\\n        margin-left: 1ch;\\n        cursor: pointer;\\n    }\\n    .dropdown {\\n        display: none;\\n        position: absolute;\\n        background: white;\\n    }\\n    ::slotted(*) {\\n        display: none;\\n    }\\n</style>\\n<button #ref=\\\"button\\\" part=\\\"button\\\">\\n    <span class=\\\"label\\\" part=\\\"label\\\">{{ this.label }}</span>\\n    <div class=\\\"toggle\\\" @click=\\\"this.toggle\\\" part=\\\"toggle\\\">\\n        <span class=\\\"iconify\\\" data-icon=\\\"mdi-menu-down-outline\\\"></span>\\n        <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-menu-down-outline\\\"></span>\\n    </div>\\n</button>\\n<slot></slot>\\n<div class=\\\"dropdown\\\" #ref=\\\"dropdown\\\" part=\\\"dropdown\\\">\\n    <option part=\\\"option\\\" #ref=\\\"dummyOption\\\"/>\\n    <option part=\\\"option-hover\\\" #ref=\\\"dummyOptionHover\\\"/>\\n</div>\\n\";\nvar dropDownStyle = document.createElement(\"style\");\ndropDownStyle.appendChild(document.createTextNode(_ComboButton_DropdownCSS__WEBPACK_IMPORTED_MODULE_1__.default));\ndocument.querySelector(\":root head\").appendChild(dropDownStyle);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9idXR0b25zL0NvbWJvQnV0dG9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztJQUVNRzs7Ozs7QUFDRix5QkFBYztBQUFBOztBQUFBOztBQUNWO0FBQ0EsVUFBS0MsS0FBTCxHQUFhLE1BQUtBLEtBQUwsQ0FBV0MsSUFBWCwrQkFBYjtBQUNBLFVBQUtDLE1BQUwsR0FBYyxNQUFLQSxNQUFMLENBQVlELElBQVosK0JBQWQ7QUFDQSxVQUFLRSxRQUFMLEdBQWdCLE1BQUtBLFFBQUwsQ0FBY0YsSUFBZCwrQkFBaEI7QUFDQSxVQUFLRyxPQUFMLEdBQWUsTUFBS0MsZ0JBQUwsQ0FBc0IsUUFBdEIsQ0FBZjtBQUNBLFVBQUtDLGFBQUwsR0FBcUIsQ0FBckI7QUFDQSxVQUFLQyxLQUFMLEdBQWEsTUFBS0gsT0FBTCxDQUFhLENBQWIsRUFBZ0JHLEtBQTdCO0FBQ0EsVUFBS0MsS0FBTCxHQUFhLE1BQUtKLE9BQUwsQ0FBYSxDQUFiLEVBQWdCSyxXQUE3QjtBQVJVO0FBU2I7Ozs7V0FFRCxtQkFBVTtBQUFBOztBQUNOQyxNQUFBQSxxQkFBcUIsQ0FBQyxZQUFNO0FBQ3hCYixRQUFBQSx5REFBQSxDQUFhLE1BQUksQ0FBQ2UsVUFBbEI7QUFDQUYsUUFBQUEscUJBQXFCLENBQUMsWUFBTTtBQUN4QixnQkFBSSxDQUFDRSxVQUFMLENBQ0tDLGFBREwsQ0FDbUIsS0FEbkIsRUFFS0MsWUFGTCxDQUVrQixNQUZsQixFQUUwQixNQUYxQjs7QUFHQSxnQkFBSSxDQUFDRixVQUFMLENBQ0tDLGFBREwsQ0FDbUIsV0FEbkIsRUFFS0MsWUFGTCxDQUVrQixNQUZsQixFQUUwQixpQkFGMUI7QUFHSCxTQVBvQixDQUFyQjtBQVFILE9BVm9CLENBQXJCO0FBV0g7QUFFRDtBQUNKO0FBQ0E7Ozs7V0FDSSxnQkFBT0MsQ0FBUCxFQUFVO0FBQUE7O0FBQ04sVUFBTUMsSUFB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LE9BQUwsQ0FBYVksS0FBYixDQUFtQmtCLEdBQW5CLGFBQ0lMLEdBQUcsQ0FBQ0ssR0FBSixHQUFVUSxVQUFVLENBQUNHLE1BQXJCLEdBQThCbkMsUUFBUSxDQUFDMEIsZ0JBQVQsQ0FBMEJDLFNBRDVEO0FBR0g7O0FBQ0QsV0FBS2pDLE9BQUwsQ0FBYVksS0FBYixDQUFtQjhCLFNBQW5CLEdBQStCLGtCQUEvQjtBQUNIO0FBRUQ7QUFDSjtBQUNBOzs7O1dBQ0ksa0JBQVM5QyxDQUFULEVBQVk7QUFDUixXQUFLUixLQUFMLEdBQWFRLENBQUMsQ0FBQ00sTUFBRixDQUFTZCxLQUF0QjtBQUNBLFdBQUtDLEtBQUwsR0FBYU8sQ0FBQyxDQUFDTSxNQUFGLENBQVNaLFdBQXRCO0FBQ0EsV0FBS0gsYUFBTCxHQUFxQndELEtBQUssQ0FBQ0MsSUFBTixDQUFXLEtBQUszRCxPQUFoQixFQUF5QmMsT0FBekIsQ0FDakJILENBQUMsQ0FBQ2lELHNCQURlLENBQXJCO0FBR0EsV0FBS0MsYUFBTCxDQUFtQixJQUFJQyxXQUFKLENBQWdCLFFBQWhCLENBQW5CO0FBQ0g7Ozs7RUE3RnFCdEU7O0FBZ0cxQkcsV0FBVyxDQUFDb0UsUUFBWjtBQUF1QjtBQUF2QjtBQW1EQSxJQUFNQyxhQUFhLEdBQUczQyxRQUFRLENBQUNLLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBdEI7QUFDQXNDLGFBQWEsQ0FBQ3ZDLFdBQWQsQ0FBMEJKLFFBQVEsQ0FBQzRDLGNBQVQsQ0FBd0J2RSw2REFBeEIsQ0FBMUI7QUFDQTJCLFFBQVEsQ0FBQ1osYUFBVCxDQUF1QixZQUF2QixFQUFxQ2dCLFdBQXJDLENBQWlEdUMsYUFBakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9idXR0b25zL0NvbWJvQnV0dG9uLmpzPzA0NmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2xpbSwgSWNvbmlmeSB9IGZyb20gXCJAL2NvbXBvbmVudHMvbGliXCI7XG5pbXBvcnQgQ09NQk9fQlVUVE9OX0RST1BET1dOX0NTUyBmcm9tICcuL0NvbWJvQnV0dG9uL0Ryb3Bkb3duQ1NTJztcblxuY2xhc3MgQ29tYm9CdXR0b24gZXh0ZW5kcyBTbGltIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jbGljayA9IHRoaXMuY2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b2dnbGUgPSB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJvcHRpb25cIik7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wdGlvbnNbMF0udmFsdWU7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLm9wdGlvbnNbMF0udGV4dENvbnRlbnQ7XG4gICAgfVxuXG4gICAgb25BZGRlZCgpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIEljb25pZnkuc2Nhbih0aGlzLnNoYWRvd1Jvb3QpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3RcbiAgICAgICAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldEF0dHJpYnV0ZShcInBhcnRcIiwgXCJpY29uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdFxuICAgICAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvcihcInN2Zy5ob3ZlclwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0QXR0cmlidXRlKFwicGFydFwiLCBcImljb24gaWNvbi1ob3ZlclwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NsaWNrRXZlbnR9IGVcbiAgICAgKi9cbiAgICB0b2dnbGUoZSkge1xuICAgICAgICBjb25zdCBwYXRoID0gZS5jb21wb3NlZFBhdGgoKVxuICAgICAgICBpZiAocGF0aC5pbmRleE9mKHRoaXMud3JhcHBlcikgPiAtMSB8fCBwYXRoLmluZGV4T2YodGhpcykgPiAtMSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53cmFwcGVyKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZS50YXJnZXQudGFnTmFtZSA9PT0gXCJPUFRJT05cIiAmJlxuICAgICAgICAgICAgICAgIHBhdGguaW5kZXhPZih0aGlzLndyYXBwZXIpID4gLTFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLm5vU2Nyb2xsLnJlbW92ZSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMud3JhcHBlcjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vU2Nyb2xsO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMudG9nZ2xlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vU2Nyb2xsID0gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICAgICAgICAgIHRoaXMubm9TY3JvbGwuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgICAgICAgICB0aGlzLm5vU2Nyb2xsLnN0eWxlLmluc2V0ID0gMFxuICAgICAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKG8uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMudG9nZ2xlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmFkZChcImNvbWJvLWJ1dHRvbi1kcm9wZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlXcmFwcGVyUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFwcGx5V3JhcHBlclBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZHJvcGRvd24pO1xuICAgICAgICBjb25zdCBkaW0gPSB0aGlzLmJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBgJHtkaW0ucmlnaHR9cHhgO1xuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gYCR7XG4gICAgICAgICAgICBkaW0uYm90dG9tICsgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgfXB4YDtcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLm1pbldpZHRoID0gYGNhbGMoJHtcbiAgICAgICAgICAgIGRpbS53aWR0aFxuICAgICAgICB9cHggLSAke3N0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKFxuICAgICAgICAgICAgXCJib3JkZXItbGVmdC13aWR0aFwiXG4gICAgICAgICl9IC0gJHtzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci1yaWdodC13aWR0aFwiKX0pYDtcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSBcInJldmVydFwiO1xuICAgICAgICBjb25zdCB3cmFwcGVyRGltID0gdGhpcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAod3JhcHBlckRpbS5ib3R0b20gPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSBgJHtcbiAgICAgICAgICAgICAgICBkaW0udG9wIC0gd3JhcHBlckRpbS5oZWlnaHQgKyBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgfXB4YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoLTEwMCUpXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDbGlja0V2ZW50fSBlXG4gICAgICovXG4gICAgc2V0VmFsdWUoZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgIHRoaXMubGFiZWwgPSBlLnRhcmdldC50ZXh0Q29udGVudDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnMpLmluZGV4T2YoXG4gICAgICAgICAgICBlLmV4cGxpY2l0T3JpZ2luYWxUYXJnZXRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNoYW5nZVwiKSk7XG4gICAgfVxufVxuXG5Db21ib0J1dHRvbi50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbjxzdHlsZT5cbiAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB9XG4gICAgYnV0dG9uIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICB9XG4gICAgYnV0dG9uOmhvdmVyIHN2Zzpub3QoLmhvdmVyKSxcbiAgICBidXR0b24gc3ZnLmhvdmVyIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgYnV0dG9uOmhvdmVyIHN2Zy5ob3ZlciB7XG4gICAgICAgIGRpc3BsYXk6IHJldmVydDtcbiAgICB9XG4gICAgLmxhYmVsIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIH1cbiAgICAudG9nZ2xlIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgcGFkZGluZy1pbmxpbmUtc3RhcnQ6IGluaGVyaXQ7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAxY2g7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG4gICAgLmRyb3Bkb3duIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICB9XG4gICAgOjpzbG90dGVkKCopIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG48L3N0eWxlPlxuPGJ1dHRvbiAjcmVmPVwiYnV0dG9uXCIgcGFydD1cImJ1dHRvblwiPlxuICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIiBwYXJ0PVwibGFiZWxcIj57eyB0aGlzLmxhYmVsIH19PC9zcGFuPlxuICAgIDxkaXYgY2xhc3M9XCJ0b2dnbGVcIiBAY2xpY2s9XCJ0aGlzLnRvZ2dsZVwiIHBhcnQ9XCJ0b2dnbGVcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwibWRpLW1lbnUtZG93bi1vdXRsaW5lXCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktbWVudS1kb3duLW91dGxpbmVcIj48L3NwYW4+XG4gICAgPC9kaXY+XG48L2J1dHRvbj5cbjxzbG90Pjwvc2xvdD5cbjxkaXYgY2xhc3M9XCJkcm9wZG93blwiICNyZWY9XCJkcm9wZG93blwiIHBhcnQ9XCJkcm9wZG93blwiPlxuICAgIDxvcHRpb24gcGFydD1cIm9wdGlvblwiICNyZWY9XCJkdW1teU9wdGlvblwiLz5cbiAgICA8b3B0aW9uIHBhcnQ9XCJvcHRpb24taG92ZXJcIiAjcmVmPVwiZHVtbXlPcHRpb25Ib3ZlclwiLz5cbjwvZGl2PlxuYDtcblxuXG5jb25zdCBkcm9wRG93blN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuZHJvcERvd25TdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShDT01CT19CVVRUT05fRFJPUERPV05fQ1NTKSk7XG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOnJvb3QgaGVhZFwiKS5hcHBlbmRDaGlsZChkcm9wRG93blN0eWxlKTtcblxuZXhwb3J0IHsgQ29tYm9CdXR0b24gfTtcbiJdLCJuYW1lcyI6WyJTbGltIiwiSWNvbmlmeSIsIkNPTUJPX0JVVFRPTl9EUk9QRE9XTl9DU1MiLCJDb21ib0J1dHRvbiIsImNsaWNrIiwiYmluZCIsInRvZ2dsZSIsInNldFZhbHVlIiwib3B0aW9ucyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzZWxlY3RlZEluZGV4IiwidmFsdWUiLCJsYWJlbCIsInRleHRDb250ZW50IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2NhbiIsInNoYWRvd1Jvb3QiLCJxdWVyeVNlbGVjdG9yIiwic2V0QXR0cmlidXRlIiwiZSIsInBhdGgiLCJjb21wb3NlZFBhdGgiLCJpbmRleE9mIiwid3JhcHBlciIsInN0b3BQcm9wYWdhdGlvbiIsInRhcmdldCIsInRhZ05hbWUiLCJyZW1vdmUiLCJub1Njcm9sbCIsImRvY3VtZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsImluc2V0IiwiZm9yRWFjaCIsIm8iLCJjbG9uZU5vZGUiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xhc3NMaXN0IiwiYWRkIiwiYXBwbHlXcmFwcGVyUG9zaXRpb24iLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwiZHJvcGRvd24iLCJkaW0iLCJidXR0b24iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJzY3JvbGxpbmdFbGVtZW50Iiwic2Nyb2xsVG9wIiwibWluV2lkdGgiLCJ3aWR0aCIsImdldFByb3BlcnR5VmFsdWUiLCJkaXNwbGF5Iiwid3JhcHBlckRpbSIsIndpbmRvdyIsImlubmVySGVpZ2h0IiwiaGVpZ2h0IiwidHJhbnNmb3JtIiwiQXJyYXkiLCJmcm9tIiwiZXhwbGljaXRPcmlnaW5hbFRhcmdldCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsInRlbXBsYXRlIiwiZHJvcERvd25TdHlsZSIsImNyZWF0ZVRleHROb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/partials/buttons/ComboButton.js\n");

/***/ }),

/***/ "./resources/js/components/partials/buttons/ComboButton/CSS.js":
/*!*********************************************************************!*\
  !*** ./resources/js/components/partials/buttons/ComboButton/CSS.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*html*/\"\\n<style>\\ncombo-button::part(button) {\\n    font-size: 1rem;\\n    color: var(--clr-text-100);\\n    background: var(--clr-bg-100);\\n    border: 2px  solid var(--clr-bg-200);\\n    transition-property: text-shadow, box-shadow, border-color, background-color, color;\\n    transition-timing-function: ease-out;\\n    transition-duration: var(--transition-medium);\\n    padding: 0;\\n}\\ncombo-button:hover::part(button) {\\n    color: var(--clr-enlightened);\\n    background: var(--clr-bg-200);\\n    border-color: var(--clr-enlightened);\\n    text-shadow: 0 0 5px var(--clr-enlightened-glow), 0 0 10px var(--clr-enlightened-glow);\\n    box-shadow: 0 0 20px 0 var(--clr-enlightened-glow), 0 0 10px 0 inset var(--clr-enlightened-glow);\\n}\\ncombo-button::part(icon-hover) {\\n    color: var(--active-icon-clr);\\n    filter: var(--active-icon-glow);\\n}\\ncombo-button::part(label) {\\n    padding: .5rem;\\n}\\ncombo-button::part(toggle) {\\n    position: relative;\\n    padding: .5rem;\\n}\\ncombo-button::part(toggle)::before {\\n    content: '';\\n    position: absolute;\\n    left: -2px;\\n    top: 0;\\n    bottom: 0;\\n    width: 2px;\\n    background: var(--clr-bg-200);\\n}\\ncombo-button:hover::part(toggle)::before {\\n    background: var(--clr-bg-200);\\n    box-shadow: 0 0 20px 0 var(--clr-enlightened-glow), 0 0 10px 0 inset var(--clr-enlightened-glow);\\n}\\ncombo-button option {\\n    display: none;\\n}\\n</style>\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9idXR0b25zL0NvbWJvQnV0dG9uL0NTUy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9idXR0b25zL0NvbWJvQnV0dG9uL0NTUy5qcz8zNzBjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC8qaHRtbCovIGBcbjxzdHlsZT5cbmNvbWJvLWJ1dHRvbjo6cGFydChidXR0b24pIHtcbiAgICBmb250LXNpemU6IDFyZW07XG4gICAgY29sb3I6IHZhcigtLWNsci10ZXh0LTEwMCk7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tY2xyLWJnLTEwMCk7XG4gICAgYm9yZGVyOiAycHggIHNvbGlkIHZhcigtLWNsci1iZy0yMDApO1xuICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHRleHQtc2hhZG93LCBib3gtc2hhZG93LCBib3JkZXItY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGNvbG9yO1xuICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiB2YXIoLS10cmFuc2l0aW9uLW1lZGl1bSk7XG4gICAgcGFkZGluZzogMDtcbn1cbmNvbWJvLWJ1dHRvbjpob3Zlcjo6cGFydChidXR0b24pIHtcbiAgICBjb2xvcjogdmFyKC0tY2xyLWVubGlnaHRlbmVkKTtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMjAwKTtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNsci1lbmxpZ2h0ZW5lZCk7XG4gICAgdGV4dC1zaGFkb3c6IDAgMCA1cHggdmFyKC0tY2xyLWVubGlnaHRlbmVkLWdsb3cpLCAwIDAgMTBweCB2YXIoLS1jbHItZW5saWdodGVuZWQtZ2xvdyk7XG4gICAgYm94LXNoYWRvdzogMCAwIDIwcHggMCB2YXIoLS1jbHItZW5saWdodGVuZWQtZ2xvdyksIDAgMCAxMHB4IDAgaW5zZXQgdmFyKC0tY2xyLWVubGlnaHRlbmVkLWdsb3cpO1xufVxuY29tYm8tYnV0dG9uOjpwYXJ0KGljb24taG92ZXIpIHtcbiAgICBjb2xvcjogdmFyKC0tYWN0aXZlLWljb24tY2xyKTtcbiAgICBmaWx0ZXI6IHZhcigtLWFjdGl2ZS1pY29uLWdsb3cpO1xufVxuY29tYm8tYnV0dG9uOjpwYXJ0KGxhYmVsKSB7XG4gICAgcGFkZGluZzogLjVyZW07XG59XG5jb21iby1idXR0b246OnBhcnQodG9nZ2xlKSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHBhZGRpbmc6IC41cmVtO1xufVxuY29tYm8tYnV0dG9uOjpwYXJ0KHRvZ2dsZSk6OmJlZm9yZSB7XG4gICAgY29udGVudDogJyc7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6IC0ycHg7XG4gICAgdG9wOiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICB3aWR0aDogMnB4O1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWNsci1iZy0yMDApO1xufVxuY29tYm8tYnV0dG9uOmhvdmVyOjpwYXJ0KHRvZ2dsZSk6OmJlZm9yZSB7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tY2xyLWJnLTIwMCk7XG4gICAgYm94LXNoYWRvdzogMCAwIDIwcHggMCB2YXIoLS1jbHItZW5saWdodGVuZWQtZ2xvdyksIDAgMCAxMHB4IDAgaW5zZXQgdmFyKC0tY2xyLWVubGlnaHRlbmVkLWdsb3cpO1xufVxuY29tYm8tYnV0dG9uIG9wdGlvbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbjwvc3R5bGU+XG5gIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/partials/buttons/ComboButton/CSS.js\n");

/***/ }),

/***/ "./resources/js/components/partials/buttons/ComboButton/DropdownCSS.js":
/*!*****************************************************************************!*\
  !*** ./resources/js/components/partials/buttons/ComboButton/DropdownCSS.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*html*/\"\\n.combo-button-dropdown {\\n    color: var(--clr-text-100);\\n    background: var(--clr-bg-100);\\n    border: 2px  solid var(--clr-bg-200);\\n    position: absolute;\\n}\\n.combo-button-dropdown option {\\n    padding-inline: .5rem;\\n    text-align: right;\\n}\\n.combo-button-dropdown option:hover {\\n    background: var(--clr-bg-200);\\n    text-shadow: 0 0 5px var(--clr-enlightened-glow), 0 0 10px var(--clr-enlightened-glow);\\n    color: var(--clr-enlightened);\\n}\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9idXR0b25zL0NvbWJvQnV0dG9uL0Ryb3Bkb3duQ1NTLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3BhcnRpYWxzL2J1dHRvbnMvQ29tYm9CdXR0b24vRHJvcGRvd25DU1MuanM/ZTllOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvKmh0bWwqLyBgXG4uY29tYm8tYnV0dG9uLWRyb3Bkb3duIHtcbiAgICBjb2xvcjogdmFyKC0tY2xyLXRleHQtMTAwKTtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMTAwKTtcbiAgICBib3JkZXI6IDJweCAgc29saWQgdmFyKC0tY2xyLWJnLTIwMCk7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xufVxuLmNvbWJvLWJ1dHRvbi1kcm9wZG93biBvcHRpb24ge1xuICAgIHBhZGRpbmctaW5saW5lOiAuNXJlbTtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbn1cbi5jb21iby1idXR0b24tZHJvcGRvd24gb3B0aW9uOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMjAwKTtcbiAgICB0ZXh0LXNoYWRvdzogMCAwIDVweCB2YXIoLS1jbHItZW5saWdodGVuZWQtZ2xvdyksIDAgMCAxMHB4IHZhcigtLWNsci1lbmxpZ2h0ZW5lZC1nbG93KTtcbiAgICBjb2xvcjogdmFyKC0tY2xyLWVubGlnaHRlbmVkKTtcbn1cbmAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/partials/buttons/ComboButton/DropdownCSS.js\n");

/***/ }),

/***/ "./resources/js/components/partials/buttons/ThemedButton/index.js":
/*!************************************************************************!*\
  !*** ./resources/js/components/partials/buttons/ThemedButton/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemeButton\": () => (/* binding */ ThemeButton)\n/* harmony export */ });\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar ThemeButton = /*#__PURE__*/function (_Slim) {\n  _inherits(ThemeButton, _Slim);\n\n  var _super = _createSuper(ThemeButton);\n\n  function ThemeButton() {\n    _classCallCheck(this, ThemeButton);\n\n    return _super.call(this);\n  }\n\n  _createClass(ThemeButton, [{\n    key: \"onAdded\",\n    value: function onAdded() {\n      var _this = this;\n\n      requestAnimationFrame(function () {\n        _this.disabled = _this.hasAttribute(\"disabled\") || _this.deferredDisable;\n        delete _this.deferredDisable;\n      });\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      var _this2 = this;\n\n      requestAnimationFrame(function () {\n        _this2.button.focus();\n      });\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      var _this3 = this;\n\n      requestAnimationFrame(function () {\n        _this3.button.blur();\n      });\n    }\n  }, {\n    key: \"matches\",\n    value: function matches(selector) {\n      if (selector === \":focus\") {\n        return this.button.matches(\":focus\");\n      }\n\n      return _get(_getPrototypeOf(ThemeButton.prototype), \"matches\", this).call(this, selector);\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this.button.disabled;\n    },\n    set: function set(value) {\n      if (this.button) {\n        this.button.disabled = !!value;\n      } else {\n        this.deferredDisable = true;\n      }\n    }\n  }]);\n\n  return ThemeButton;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_0__.Slim);\n\nThemeButton.template =\n/*html*/\n\"\\n<style>\\nbutton {\\n    background: var(--clr-bg-100);\\n    color: var(--clr-text-100);\\n    font-size: 1rem;\\n    padding: .5rem;\\n    border: 2px solid var(--clr-bg-200);\\n    transition-property: text-shadow, box-shadow, border-color, background-color;\\n    transition-timing-function: ease-out;\\n    transition-duration: var(--transition-medium);\\n}\\nbutton:focus {\\n    border-color: var(--clr-enlightened);\\n    color: var(--clr-enlightened);\\n    background:var(--clr-bg-200);\\n}\\nbutton:focus-visible {\\n    outline: none;\\n}\\nbutton:hover {\\n    background:var(--clr-bg-200);\\n    color: var(--clr-enlightened);\\n    text-shadow: 0 0 5px var(--clr-enlightened-glow), 0 0 10px var(--clr-enlightened-glow);\\n    border-color: var(--clr-enlightened);\\n    box-shadow: 0 0 20px 0 var(--clr-enlightened-glow), 0 0 10px 0 inset var(--clr-enlightened-glow);\\n}\\nbutton:disabled {\\n    color: var(--clr-text-100);\\n    background-color: var(--clr-disabled);\\n    border-color: var(--clr-bg-150);\\n    text-shadow: none;\\n    box-shadow: none;\\n}\\n</style>\\n<button part=\\\"button\\\" #ref=\\\"button\\\">\\n    <slot></slot>\\n</button>\\n\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9idXR0b25zL1RoZW1lZEJ1dHRvbi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0lBRU1FOzs7OztBQUNGLHlCQUFjO0FBQUE7O0FBQUE7QUFFYjs7OztXQUNELG1CQUFVO0FBQUE7O0FBQ05DLE1BQUFBLHFCQUFxQixDQUFDLFlBQU07QUFDeEIsYUFBSSxDQUFDQyxRQUFMLEdBQ0ksS0FBSSxDQUFDQyxZQUFMLENBQWtCLFVBQWxCLEtBQWlDLEtBQUksQ0FBQ0MsZUFEMUM7QUFFQSxlQUFPLEtBQUksQ0FBQ0EsZUFBWjtBQUNILE9BSm9CLENBQXJCO0FBS0g7OztXQUNELGlCQUFRO0FBQUE7O0FBQ0pILE1BQUFBLHFCQUFxQixDQUFDLFlBQU07QUFDeEIsY0FBSSxDQUFDSSxNQUFMLENBQVlDLEtBQVo7QUFDSCxPQUZvQixDQUFyQjtBQUdIOzs7V0FDRCxnQkFBTztBQUFBOztBQUNITCxNQUFBQSxxQkFBcUIsQ0FBQyxZQUFNO0FBQ3hCLGNBQUksQ0FBQ0ksTUFBTCxDQUFZRSxJQUFaO0FBQ0gsT0FGb0IsQ0FBckI7QUFHSDs7O1dBQ0QsaUJBQVFDLFFBQVIsRUFBa0I7QUFDZCxVQUFJQSxRQUFRLEtBQUssUUFBakIsRUFBMkI7QUFDdkIsZUFBTyxLQUFLSCxNQUFMLENBQVlJLE9BQVosQ0FBb0IsUUFBcEIsQ0FBUDtBQUNIOztBQUNELHNGQUFxQkQsUUFBckI7QUFDSDs7O1NBUUQsZUFBZTtBQUNYLGFBQU8sS0FBS0gsTUFBTCxDQUFZSCxRQUFuQjtBQUNIO1NBVEQsYUFBYVEsS0FBYixFQUFvQjtBQUNoQixVQUFJLEtBQUtMLE1BQVQsRUFBaUI7QUFDYixhQUFLQSxNQUFMLENBQVlILFFBQVosR0FBdUIsQ0FBQyxDQUFDUSxLQUF6QjtBQUNILE9BRkQsTUFFTztBQUNILGFBQUtOLGVBQUwsR0FBdUIsSUFBdkI7QUFDSDtBQUNKOzs7O0VBakNxQk47O0FBdUMxQkUsV0FBVyxDQUFDVyxRQUFaO0FBQXVCO0FBQXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvcGFydGlhbHMvYnV0dG9ucy9UaGVtZWRCdXR0b24vaW5kZXguanM/MWI5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltLCBJY29uaWZ5IH0gZnJvbSBcIkAvY29tcG9uZW50cy9saWJcIjtcblxuY2xhc3MgVGhlbWVCdXR0b24gZXh0ZW5kcyBTbGltIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgb25BZGRlZCgpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgIHRoaXMuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgfHwgdGhpcy5kZWZlcnJlZERpc2FibGU7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kZWZlcnJlZERpc2FibGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb2N1cygpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBibHVyKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idXR0b24uYmx1cigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF0Y2hlcyhzZWxlY3Rvcikge1xuICAgICAgICBpZiAoc2VsZWN0b3IgPT09IFwiOmZvY3VzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1dHRvbi5tYXRjaGVzKFwiOmZvY3VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5idXR0b24uZGlzYWJsZWQgPSAhIXZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZERpc2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnV0dG9uLmRpc2FibGVkO1xuICAgIH1cbn1cblxuVGhlbWVCdXR0b24udGVtcGxhdGUgPSAvKmh0bWwqLyBgXG48c3R5bGU+XG5idXR0b24ge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWNsci1iZy0xMDApO1xuICAgIGNvbG9yOiB2YXIoLS1jbHItdGV4dC0xMDApO1xuICAgIGZvbnQtc2l6ZTogMXJlbTtcbiAgICBwYWRkaW5nOiAuNXJlbTtcbiAgICBib3JkZXI6IDJweCBzb2xpZCB2YXIoLS1jbHItYmctMjAwKTtcbiAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiB0ZXh0LXNoYWRvdywgYm94LXNoYWRvdywgYm9yZGVyLWNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yO1xuICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiB2YXIoLS10cmFuc2l0aW9uLW1lZGl1bSk7XG59XG5idXR0b246Zm9jdXMge1xuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY2xyLWVubGlnaHRlbmVkKTtcbiAgICBjb2xvcjogdmFyKC0tY2xyLWVubGlnaHRlbmVkKTtcbiAgICBiYWNrZ3JvdW5kOnZhcigtLWNsci1iZy0yMDApO1xufVxuYnV0dG9uOmZvY3VzLXZpc2libGUge1xuICAgIG91dGxpbmU6IG5vbmU7XG59XG5idXR0b246aG92ZXIge1xuICAgIGJhY2tncm91bmQ6dmFyKC0tY2xyLWJnLTIwMCk7XG4gICAgY29sb3I6IHZhcigtLWNsci1lbmxpZ2h0ZW5lZCk7XG4gICAgdGV4dC1zaGFkb3c6IDAgMCA1cHggdmFyKC0tY2xyLWVubGlnaHRlbmVkLWdsb3cpLCAwIDAgMTBweCB2YXIoLS1jbHItZW5saWdodGVuZWQtZ2xvdyk7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jbHItZW5saWdodGVuZWQpO1xuICAgIGJveC1zaGFkb3c6IDAgMCAyMHB4IDAgdmFyKC0tY2xyLWVubGlnaHRlbmVkLWdsb3cpLCAwIDAgMTBweCAwIGluc2V0IHZhcigtLWNsci1lbmxpZ2h0ZW5lZC1nbG93KTtcbn1cbmJ1dHRvbjpkaXNhYmxlZCB7XG4gICAgY29sb3I6IHZhcigtLWNsci10ZXh0LTEwMCk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY2xyLWRpc2FibGVkKTtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNsci1iZy0xNTApO1xuICAgIHRleHQtc2hhZG93OiBub25lO1xuICAgIGJveC1zaGFkb3c6IG5vbmU7XG59XG48L3N0eWxlPlxuPGJ1dHRvbiBwYXJ0PVwiYnV0dG9uXCIgI3JlZj1cImJ1dHRvblwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbjwvYnV0dG9uPlxuYDtcblxuZXhwb3J0IHsgVGhlbWVCdXR0b24gfTtcbiJdLCJuYW1lcyI6WyJTbGltIiwiSWNvbmlmeSIsIlRoZW1lQnV0dG9uIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZGlzYWJsZWQiLCJoYXNBdHRyaWJ1dGUiLCJkZWZlcnJlZERpc2FibGUiLCJidXR0b24iLCJmb2N1cyIsImJsdXIiLCJzZWxlY3RvciIsIm1hdGNoZXMiLCJ2YWx1ZSIsInRlbXBsYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/partials/buttons/ThemedButton/index.js\n");

/***/ }),

/***/ "./resources/js/components/partials/index.js":
/*!***************************************************!*\
  !*** ./resources/js/components/partials/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"COMBO_BUTTON_CSS\": () => (/* reexport safe */ _buttons_ComboButton_CSS__WEBPACK_IMPORTED_MODULE_1__.default)\n/* harmony export */ });\n/* harmony import */ var _buttons_ComboButton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buttons/ComboButton */ \"./resources/js/components/partials/buttons/ComboButton.js\");\n/* harmony import */ var _buttons_ComboButton_CSS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buttons/ComboButton/CSS */ \"./resources/js/components/partials/buttons/ComboButton/CSS.js\");\n/* harmony import */ var _buttons_ThemedButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buttons/ThemedButton */ \"./resources/js/components/partials/buttons/ThemedButton/index.js\");\n/* harmony import */ var _modals_Alert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modals/Alert */ \"./resources/js/components/partials/modals/Alert/index.js\");\n/* harmony import */ var _modals_Confirm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modals/Confirm */ \"./resources/js/components/partials/modals/Confirm/index.js\");\n/* harmony import */ var _modals_Dialogue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modals/Dialogue */ \"./resources/js/components/partials/modals/Dialogue/index.js\");\n/* harmony import */ var _modals_Window__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modals/Window */ \"./resources/js/components/partials/modals/Window/index.js\");\n\n\n\n\n\n\n\ncustomElements.define(\"theme-button\", _buttons_ThemedButton__WEBPACK_IMPORTED_MODULE_2__.ThemeButton);\ncustomElements.define(\"combo-button\", _buttons_ComboButton__WEBPACK_IMPORTED_MODULE_0__.ComboButton);\ncustomElements.define(\"modal-alert\", _modals_Alert__WEBPACK_IMPORTED_MODULE_3__.Alert);\ncustomElements.define(\"modal-confirm\", _modals_Confirm__WEBPACK_IMPORTED_MODULE_4__.Confirm);\ncustomElements.define(\"modal-dialogue\", _modals_Dialogue__WEBPACK_IMPORTED_MODULE_5__.Dialogue);\ncustomElements.define(\"modal-window\", _modals_Window__WEBPACK_IMPORTED_MODULE_6__.Window);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUFPLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixjQUF0QixFQUFzQ04sOERBQXRDO0FBQ0FLLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixjQUF0QixFQUFzQ1IsNkRBQXRDO0FBQ0FPLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixhQUF0QixFQUFxQ0wsZ0RBQXJDO0FBQ0FJLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixlQUF0QixFQUF1Q0osb0RBQXZDO0FBQ0FHLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixnQkFBdEIsRUFBd0NILHNEQUF4QztBQUNBRSxjQUFjLENBQUNDLE1BQWYsQ0FBc0IsY0FBdEIsRUFBc0NGLGtEQUF0QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3BhcnRpYWxzL2luZGV4LmpzP2I1OGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tYm9CdXR0b24gfSBmcm9tIFwiLi9idXR0b25zL0NvbWJvQnV0dG9uXCI7XG5pbXBvcnQgQ09NQk9fQlVUVE9OX0NTUyBmcm9tICcuL2J1dHRvbnMvQ29tYm9CdXR0b24vQ1NTJ1xuaW1wb3J0IHsgVGhlbWVCdXR0b24gfSBmcm9tIFwiLi9idXR0b25zL1RoZW1lZEJ1dHRvblwiO1xuaW1wb3J0IHsgQWxlcnQgfSBmcm9tIFwiLi9tb2RhbHMvQWxlcnRcIjtcbmltcG9ydCB7IENvbmZpcm0gfSBmcm9tIFwiLi9tb2RhbHMvQ29uZmlybVwiO1xuaW1wb3J0IHsgRGlhbG9ndWUgfSBmcm9tIFwiLi9tb2RhbHMvRGlhbG9ndWVcIjtcbmltcG9ydCB7IFdpbmRvdyB9IGZyb20gXCIuL21vZGFscy9XaW5kb3dcIjtcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwidGhlbWUtYnV0dG9uXCIsIFRoZW1lQnV0dG9uKTtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcImNvbWJvLWJ1dHRvblwiLCBDb21ib0J1dHRvbik7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtb2RhbC1hbGVydFwiLCBBbGVydCk7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtb2RhbC1jb25maXJtXCIsIENvbmZpcm0pO1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibW9kYWwtZGlhbG9ndWVcIiwgRGlhbG9ndWUpO1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibW9kYWwtd2luZG93XCIsIFdpbmRvdyk7XG5cbmV4cG9ydCB7XG4gICAgQ09NQk9fQlVUVE9OX0NTU1xufSJdLCJuYW1lcyI6WyJDb21ib0J1dHRvbiIsIkNPTUJPX0JVVFRPTl9DU1MiLCJUaGVtZUJ1dHRvbiIsIkFsZXJ0IiwiQ29uZmlybSIsIkRpYWxvZ3VlIiwiV2luZG93IiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/partials/index.js\n");

/***/ }),

/***/ "./resources/js/components/partials/modals/Abstract.js":
/*!*************************************************************!*\
  !*** ./resources/js/components/partials/modals/Abstract.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractModal\": () => (/* binding */ AbstractModal),\n/* harmony export */   \"MODAL_BASE_CSS\": () => (/* binding */ MODAL_BASE_CSS),\n/* harmony export */   \"MODAL_TEMPLATE_BEGIN\": () => (/* binding */ MODAL_TEMPLATE_BEGIN),\n/* harmony export */   \"MODAL_TEMPLATE_END\": () => (/* binding */ MODAL_TEMPLATE_END)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/lib */ \"./resources/js/components/lib/index.js\");\n/* harmony import */ var _Icons_Stack_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Icons/Stack.css */ \"./resources/js/components/Icons/Stack.css.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar AbstractModal = /*#__PURE__*/function (_Slim) {\n  _inherits(AbstractModal, _Slim);\n\n  var _super = _createSuper(AbstractModal);\n\n  function AbstractModal() {\n    var _this;\n\n    _classCallCheck(this, AbstractModal);\n\n    _this = _super.call(this);\n    _this.cancelAction = _this.cancelAction.bind(_assertThisInitialized(_this));\n    _this.confirmAction = _this.confirmAction.bind(_assertThisInitialized(_this));\n    _this.handleKey = _this.handleKey.bind(_assertThisInitialized(_this));\n    _this.promise = new Promise(function (resolve, reject) {\n      _this.reject = reject;\n      _this.resolve = resolve;\n    });\n    return _this;\n  }\n\n  _createClass(AbstractModal, [{\n    key: \"onAdded\",\n    value: function () {\n      var _onAdded = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n        var _this2 = this;\n\n        var p;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                document.body.style.overflow = \"hidden\";\n                requestAnimationFrame(this.show.bind(this));\n                _context.prev = 2;\n\n                p = function p() {\n                  return _this2.promise;\n                };\n\n                _context.next = 6;\n                return p();\n\n              case 6:\n                if (!this.skipConfirm) {\n                  this.dispatchEvent(new CustomEvent(\"confirm\"));\n                }\n\n                _context.next = 13;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](2);\n                this.dispatchEvent(new CustomEvent(\"cancel\"));\n\n                if (_context.t0) {\n                  console.error(_context.t0);\n                }\n\n              case 13:\n                _context.prev = 13;\n                this.hide();\n                return _context.finish(13);\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 9, 13, 16]]);\n      }));\n\n      function onAdded() {\n        return _onAdded.apply(this, arguments);\n      }\n\n      return onAdded;\n    }()\n  }, {\n    key: \"show\",\n    value: function show() {\n      var _this3 = this;\n\n      _components_lib__WEBPACK_IMPORTED_MODULE_1__.Iconify.scan(this.shadowRoot);\n\n      if (this.cancelButton) {\n        this.cancelButton.focus();\n      }\n\n      this.addEventListener(\"transitionend\", function () {\n        document.dispatchEvent(new CustomEvent(\"modal-show\", {\n          detail: true\n        }));\n        document.addEventListener(\"keyup\", _this3.handleKey);\n      }, {\n        once: true\n      });\n      requestAnimationFrame(function () {\n        _this3.classList.add(\"fade-in\");\n      });\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this4 = this;\n\n      document.removeEventListener(\"keyup\", this.handleKey);\n      this.addEventListener(\"transitionend\", function () {\n        _this4.className = \"\";\n        document.body.removeChild(_this4);\n        document.body.style.overflow = \"\";\n        document.dispatchEvent(new CustomEvent(\"modal-show\", {\n          detail: false\n        }));\n      }, {\n        once: true\n      });\n      this.classList.add(\"fade-out\");\n    }\n  }, {\n    key: \"confirmAction\",\n    value: function confirmAction() {\n      this.resolve();\n    }\n  }, {\n    key: \"cancelAction\",\n    value: function cancelAction() {\n      this.reject();\n    }\n  }, {\n    key: \"closeAction\",\n    value: function closeAction() {\n      this.skipConfirm = true;\n      this.resolve();\n    }\n  }, {\n    key: \"handleKey\",\n    value: function handleKey(e) {\n      if (this.cancelButton) {\n        switch (e.key) {\n          case \"Escape\":\n            this.reject();\n            break;\n\n          case \"ArrowLeft\":\n            if (this.okButton.matches(\":focus\")) {\n              this.cancelButton.focus();\n            }\n\n            break;\n\n          case \"ArrowRight\":\n            if (this.cancelButton.matches(\":focus\")) {\n              this.okButton.focus();\n            }\n\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"canClose\",\n    value: function canClose() {\n      return this.dataset.closeButton;\n    }\n  }]);\n\n  return AbstractModal;\n}(_components_lib__WEBPACK_IMPORTED_MODULE_1__.Slim);\n\nvar MODAL_BASE_CSS =\n/*html*/\n\"<style>\\n:host {\\n    position: fixed;\\n    inset: 0;\\n    display: flex;\\n    transition: opacity var(--transition-medium) linear;\\n    justify-content: center;\\n    align-items: center;\\n    opacity: 0;\\n}\\n:host(.fade-in) {\\n    opacity: 1;\\n}\\n:host(.fade-out) {\\n    transition-duration: var(--transition-slow);\\n    opacity: 0;\\n}\\nmain {\\n    max-width: 600px;\\n    min-width: 300px;\\n    background: var(--clr-bg-0);\\n    box-shadow: 0 0 10vw 3vw var(--clr-shadow-0);\\n    border: var(--window-border);\\n    border-radius: .5rem;\\n    padding: 1rem;\\n}\\nheader {\\n    font-weight: bold;\\n    padding-bottom: 1em;\\n    border-bottom: 2px solid var(--clr-bg-100);\\n    user-select: none;\\n    text-transform: uppercase;\\n    display: flex;\\n    justify-content: space-between;\\n}\\nsection {\\n    padding-block: 1rem;\\n    overflow-wrap: break-word;\\n}\\nfooter {\\n    padding: .5rem;\\n    display: flex;\\n    justify-content: flex-end;\\n    gap: .5rem;\\n}\\nbutton {\\n    background: var(--clr-bg-200);\\n    border: 2px solid var(--clr-bg-100);\\n    color: var(--clr-text-100);\\n    border-radius: 0;\\n    padding: .5rem;\\n    font-size: 1rem;\\n}\\n:host(:not([data-close-button])) .close-button {\\n    display: none;\\n}\\n.close-button {\\n    font-size: 1.5rem;\\n}\\n:host([data-no-footer]) footer {\\n    display: none;\\n}\\n</style>\\n\";\nvar MODAL_TEMPLATE_BEGIN =\n/*html*/\n\"\\n\".concat(_Icons_Stack_css__WEBPACK_IMPORTED_MODULE_2__.ICON_STACK_CSS, \"\\n<main>\\n    <header>\\n        {{ this.header }}\\n        <div @click=\\\"{{ this.closeAction() }}\\\" class=\\\"icon-stack close-button\\\">\\n            <span class=\\\"iconify\\\" data-icon=\\\"mdi-close\\\"></span>\\n            <span class=\\\"iconify hover\\\" data-icon=\\\"mdi-close\\\"></span>\\n        </div>\\n    </header>\\n    <section>\\n\");\nvar MODAL_TEMPLATE_END =\n/*html*/\n\"\\n    </section>\\n    <footer>\\n        <theme-button @click=\\\"{{ this.cancelAction() }}\\\" #ref=\\\"cancelButton\\\">Cancel</theme-button>\\n        <theme-button @click=\\\"{{ this.confirmAction() }}\\\" #ref=\\\"okButton\\\">OK</theme-button>\\n    </footer>\\n</main>\\n\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9tb2RhbHMvQWJzdHJhY3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7SUFFTUc7Ozs7O0FBQ0YsMkJBQWM7QUFBQTs7QUFBQTs7QUFDVjtBQUNBLFVBQUtDLFlBQUwsR0FBb0IsTUFBS0EsWUFBTCxDQUFrQkMsSUFBbEIsK0JBQXBCO0FBQ0EsVUFBS0MsYUFBTCxHQUFxQixNQUFLQSxhQUFMLENBQW1CRCxJQUFuQiwrQkFBckI7QUFDQSxVQUFLRSxTQUFMLEdBQWlCLE1BQUtBLFNBQUwsQ0FBZUYsSUFBZiwrQkFBakI7QUFDQSxVQUFLRyxPQUFMLEdBQWUsSUFBSUMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUM1QyxZQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxZQUFLRCxPQUFMLEdBQWVBLE9BQWY7QUFDSCxLQUhjLENBQWY7QUFMVTtBQVNiOzs7Ozs0SEFFRDtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDSUUsZ0JBQUFBLFFBQVEsQ0FBQ0MsSUFBVCxDQUFjQyxLQUFkLENBQW9CQyxRQUFwQixHQUErQixRQUEvQjtBQUNBQyxnQkFBQUEscUJBQXFCLENBQUMsS0FBS0MsSUFBTCxDQUFVWixJQUFWLENBQWUsSUFBZixDQUFELENBQXJCO0FBRko7O0FBSWNhLGdCQUFBQSxDQUpkLEdBSWtCLFNBQUpBLENBQUk7QUFBQSx5QkFBTSxNQUFJLENBQUNWLE9BQVg7QUFBQSxpQkFKbEI7O0FBQUE7QUFBQSx1QkFLY1UsQ0FBQyxFQUxmOztBQUFBO0FBTVEsb0JBQUksQ0FBQyxLQUFLQyxXQUFWLEVBQXVCO0FBQ25CLHVCQUFLQyxhQUFMLENBQW1CLElBQUlDLFdBQUosQ0FBZ0IsU0FBaEIsQ0FBbkI7QUFDSDs7QUFSVDtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQVVRLHFCQUFLRCxh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Li9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9tb2RhbHMvQWJzdHJhY3QuanM/ZjgyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGltLCBJY29uaWZ5IH0gZnJvbSBcIkAvY29tcG9uZW50cy9saWJcIjtcbmltcG9ydCB7IElDT05fU1RBQ0tfQ1NTIH0gZnJvbSBcIi4uLy4uL0ljb25zL1N0YWNrLmNzc1wiO1xuXG5jbGFzcyBBYnN0cmFjdE1vZGFsIGV4dGVuZHMgU2xpbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FuY2VsQWN0aW9uID0gdGhpcy5jYW5jZWxBY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25maXJtQWN0aW9uID0gdGhpcy5jb25maXJtQWN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5ID0gdGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBvbkFkZGVkKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc2hvdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSAoKSA9PiB0aGlzLnByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCBwKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2tpcENvbmZpcm0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY29uZmlybVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2FuY2VsXCIpKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgICBJY29uaWZ5LnNjYW4odGhpcy5zaGFkb3dSb290KTtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcIm1vZGFsLXNob3dcIiwgeyBkZXRhaWw6IHRydWUgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmhhbmRsZUtleSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChcImZhZGUtaW5cIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmhhbmRsZUtleSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcIm1vZGFsLXNob3dcIiwgeyBkZXRhaWw6IGZhbHNlIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoXCJmYWRlLW91dFwiKTtcbiAgICB9XG5cbiAgICBjb25maXJtQWN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICBjYW5jZWxBY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVqZWN0KCk7XG4gICAgfVxuXG4gICAgY2xvc2VBY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2tpcENvbmZpcm0gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICBoYW5kbGVLZXkoZSkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxCdXR0b24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiRXNjYXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub2tCdXR0b24ubWF0Y2hlcyhcIjpmb2N1c1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxCdXR0b24ubWF0Y2hlcyhcIjpmb2N1c1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5va0J1dHRvbi5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FuQ2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXQuY2xvc2VCdXR0b247XG4gICAgfVxufVxuXG5jb25zdCBNT0RBTF9CQVNFX0NTUyA9IC8qaHRtbCovIGA8c3R5bGU+XG46aG9zdCB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGluc2V0OiAwO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSB2YXIoLS10cmFuc2l0aW9uLW1lZGl1bSkgbGluZWFyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgb3BhY2l0eTogMDtcbn1cbjpob3N0KC5mYWRlLWluKSB7XG4gICAgb3BhY2l0eTogMTtcbn1cbjpob3N0KC5mYWRlLW91dCkge1xuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IHZhcigtLXRyYW5zaXRpb24tc2xvdyk7XG4gICAgb3BhY2l0eTogMDtcbn1cbm1haW4ge1xuICAgIG1heC13aWR0aDogNjAwcHg7XG4gICAgbWluLXdpZHRoOiAzMDBweDtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItYmctMCk7XG4gICAgYm94LXNoYWRvdzogMCAwIDEwdncgM3Z3IHZhcigtLWNsci1zaGFkb3ctMCk7XG4gICAgYm9yZGVyOiB2YXIoLS13aW5kb3ctYm9yZGVyKTtcbiAgICBib3JkZXItcmFkaXVzOiAuNXJlbTtcbiAgICBwYWRkaW5nOiAxcmVtO1xufVxuaGVhZGVyIHtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBwYWRkaW5nLWJvdHRvbTogMWVtO1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB2YXIoLS1jbHItYmctMTAwKTtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xufVxuc2VjdGlvbiB7XG4gICAgcGFkZGluZy1ibG9jazogMXJlbTtcbiAgICBvdmVyZmxvdy13cmFwOiBicmVhay13b3JkO1xufVxuZm9vdGVyIHtcbiAgICBwYWRkaW5nOiAuNXJlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgZ2FwOiAuNXJlbTtcbn1cbmJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tY2xyLWJnLTIwMCk7XG4gICAgYm9yZGVyOiAycHggc29saWQgdmFyKC0tY2xyLWJnLTEwMCk7XG4gICAgY29sb3I6IHZhcigtLWNsci10ZXh0LTEwMCk7XG4gICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICBwYWRkaW5nOiAuNXJlbTtcbiAgICBmb250LXNpemU6IDFyZW07XG59XG46aG9zdCg6bm90KFtkYXRhLWNsb3NlLWJ1dHRvbl0pKSAuY2xvc2UtYnV0dG9uIHtcbiAgICBkaXNwbGF5OiBub25lO1xufVxuLmNsb3NlLWJ1dHRvbiB7XG4gICAgZm9udC1zaXplOiAxLjVyZW07XG59XG46aG9zdChbZGF0YS1uby1mb290ZXJdKSBmb290ZXIge1xuICAgIGRpc3BsYXk6IG5vbmU7XG59XG48L3N0eWxlPlxuYDtcblxuY29uc3QgTU9EQUxfVEVNUExBVEVfQkVHSU4gPSAvKmh0bWwqLyBgXG4ke0lDT05fU1RBQ0tfQ1NTfVxuPG1haW4+XG4gICAgPGhlYWRlcj5cbiAgICAgICAge3sgdGhpcy5oZWFkZXIgfX1cbiAgICAgICAgPGRpdiBAY2xpY2s9XCJ7eyB0aGlzLmNsb3NlQWN0aW9uKCkgfX1cIiBjbGFzcz1cImljb24tc3RhY2sgY2xvc2UtYnV0dG9uXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnlcIiBkYXRhLWljb249XCJtZGktY2xvc2VcIj48L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25pZnkgaG92ZXJcIiBkYXRhLWljb249XCJtZGktY2xvc2VcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvaGVhZGVyPlxuICAgIDxzZWN0aW9uPlxuYDtcblxuY29uc3QgTU9EQUxfVEVNUExBVEVfRU5EID0gLypodG1sKi8gYFxuICAgIDwvc2VjdGlvbj5cbiAgICA8Zm9vdGVyPlxuICAgICAgICA8dGhlbWUtYnV0dG9uIEBjbGljaz1cInt7IHRoaXMuY2FuY2VsQWN0aW9uKCkgfX1cIiAjcmVmPVwiY2FuY2VsQnV0dG9uXCI+Q2FuY2VsPC90aGVtZS1idXR0b24+XG4gICAgICAgIDx0aGVtZS1idXR0b24gQGNsaWNrPVwie3sgdGhpcy5jb25maXJtQWN0aW9uKCkgfX1cIiAjcmVmPVwib2tCdXR0b25cIj5PSzwvdGhlbWUtYnV0dG9uPlxuICAgIDwvZm9vdGVyPlxuPC9tYWluPlxuYDtcblxuZXhwb3J0IHtcbiAgICBBYnN0cmFjdE1vZGFsLFxuICAgIE1PREFMX0JBU0VfQ1NTLFxuICAgIE1PREFMX1RFTVBMQVRFX0JFR0lOLFxuICAgIE1PREFMX1RFTVBMQVRFX0VORCxcbn07XG4iXSwibmFtZXMiOlsiU2xpbSIsIkljb25pZnkiLCJJQ09OX1NUQUNLX0NTUyIsIkFic3RyYWN0TW9kYWwiLCJjYW5jZWxBY3Rpb24iLCJiaW5kIiwiY29uZmlybUFjdGlvbiIsImhhbmRsZUtleSIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImRvY3VtZW50IiwiYm9keSIsInN0eWxlIiwib3ZlcmZsb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzaG93IiwicCIsInNraXBDb25maXJtIiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiY29uc29sZSIsImVycm9yIiwiaGlkZSIsInNjYW4iLCJzaGFkb3dSb290IiwiY2FuY2VsQnV0dG9uIiwiZm9jdXMiLCJhZGRFdmVudExpc3RlbmVyIiwiZGV0YWlsIiwib25jZSIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGFzc05hbWUiLCJyZW1vdmVDaGlsZCIsImUiLCJrZXkiLCJva0J1dHRvbiIsIm1hdGNoZXMiLCJkYXRhc2V0IiwiY2xvc2VCdXR0b24iLCJNT0RBTF9CQVNFX0NTUyIsIk1PREFMX1RFTVBMQVRFX0JFR0lOIiwiTU9EQUxfVEVNUExBVEVfRU5EIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/partials/modals/Abstract.js\n");

/***/ }),

/***/ "./resources/js/components/partials/modals/Alert/index.js":
/*!****************************************************************!*\
  !*** ./resources/js/components/partials/modals/Alert/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Alert\": () => (/* binding */ Alert)\n/* harmony export */ });\n/* harmony import */ var _Abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Abstract */ \"./resources/js/components/partials/modals/Abstract.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * usage:\n    async testModal() {\n        const m = document.createElement(\"modal-confirm\");\n        m.header = \"Cillum exercitation\";\n        m.content =\n            \"Esse sit exercitation laborum sit nostrud labore qui cupidatat.\";\n        document.body.appendChild(m);\n        try {\n            await m.confirm();\n            console.log(\"confirmed\");\n        } catch (error) {\n            console.log(\"canceled\");\n        }\n    }\n */\n\nvar Alert = /*#__PURE__*/function (_AbstractModal) {\n  _inherits(Alert, _AbstractModal);\n\n  var _super = _createSuper(Alert);\n\n  function Alert() {\n    _classCallCheck(this, Alert);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alert, [{\n    key: \"alert\",\n    value: function alert() {\n      return this.promise;\n    }\n  }]);\n\n  return Alert;\n}(_Abstract__WEBPACK_IMPORTED_MODULE_0__.AbstractModal);\n\nAlert.template =\n/*html*/\n\"\\n\".concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_BASE_CSS, \"\\n\").concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_TEMPLATE_BEGIN, \"\\n    <slot></slot>\\n    </section>\\n    <footer>\\n        <theme-button @click=\\\"{{ this.confirmAction() }}\\\" #ref=\\\"okButton\\\">OK</theme-button>\\n    </footer>\\n</main>\\n\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9tb2RhbHMvQWxlcnQvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFDTUk7Ozs7Ozs7Ozs7Ozs7V0FDRixpQkFBUTtBQUNKLGFBQU8sS0FBS0MsT0FBWjtBQUNIOzs7O0VBSGVMOztBQU1wQkksS0FBSyxDQUFDRSxRQUFOO0FBQWlCO0FBQWpCLFlBQ0VMLHFEQURGLGVBRUVDLDJEQUZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvcGFydGlhbHMvbW9kYWxzL0FsZXJ0L2luZGV4LmpzPzMwYjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBYnN0cmFjdE1vZGFsLFxuICAgIE1PREFMX0JBU0VfQ1NTLFxuICAgIE1PREFMX1RFTVBMQVRFX0JFR0lOLFxuICAgIE1PREFMX1RFTVBMQVRFX0VORCxcbn0gZnJvbSBcIi4uL0Fic3RyYWN0XCI7XG5cbi8qKlxuICogdXNhZ2U6XG4gICAgYXN5bmMgdGVzdE1vZGFsKCkge1xuICAgICAgICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1vZGFsLWNvbmZpcm1cIik7XG4gICAgICAgIG0uaGVhZGVyID0gXCJDaWxsdW0gZXhlcmNpdGF0aW9uXCI7XG4gICAgICAgIG0uY29udGVudCA9XG4gICAgICAgICAgICBcIkVzc2Ugc2l0IGV4ZXJjaXRhdGlvbiBsYWJvcnVtIHNpdCBub3N0cnVkIGxhYm9yZSBxdWkgY3VwaWRhdGF0LlwiO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbS5jb25maXJtKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbmZpcm1lZFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FuY2VsZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gKi9cbmNsYXNzIEFsZXJ0IGV4dGVuZHMgQWJzdHJhY3RNb2RhbCB7XG4gICAgYWxlcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfVxufVxuXG5BbGVydC50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7TU9EQUxfQkFTRV9DU1N9XG4ke01PREFMX1RFTVBMQVRFX0JFR0lOfVxuICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L3NlY3Rpb24+XG4gICAgPGZvb3Rlcj5cbiAgICAgICAgPHRoZW1lLWJ1dHRvbiBAY2xpY2s9XCJ7eyB0aGlzLmNvbmZpcm1BY3Rpb24oKSB9fVwiICNyZWY9XCJva0J1dHRvblwiPk9LPC90aGVtZS1idXR0b24+XG4gICAgPC9mb290ZXI+XG48L21haW4+XG5gO1xuXG5leHBvcnQgeyBBbGVydCB9O1xuIl0sIm5hbWVzIjpbIkFic3RyYWN0TW9kYWwiLCJNT0RBTF9CQVNFX0NTUyIsIk1PREFMX1RFTVBMQVRFX0JFR0lOIiwiTU9EQUxfVEVNUExBVEVfRU5EIiwiQWxlcnQiLCJwcm9taXNlIiwidGVtcGxhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/partials/modals/Alert/index.js\n");

/***/ }),

/***/ "./resources/js/components/partials/modals/Confirm/index.js":
/*!******************************************************************!*\
  !*** ./resources/js/components/partials/modals/Confirm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Confirm\": () => (/* binding */ Confirm)\n/* harmony export */ });\n/* harmony import */ var _Abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Abstract */ \"./resources/js/components/partials/modals/Abstract.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * usage:\n    async testModal() {\n        const m = document.createElement(\"modal-confirm\");\n        m.header = \"Cillum exercitation\";\n        m.content =\n            \"Esse sit exercitation laborum sit nostrud labore qui cupidatat.\";\n        document.body.appendChild(m);\n        try {\n            await m.confirm();\n            console.log(\"confirmed\");\n        } catch (error) {\n            console.log(\"canceled\");\n        }\n    }\n */\n\nvar Confirm = /*#__PURE__*/function (_AbstractModal) {\n  _inherits(Confirm, _AbstractModal);\n\n  var _super = _createSuper(Confirm);\n\n  function Confirm() {\n    _classCallCheck(this, Confirm);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Confirm, [{\n    key: \"confirm\",\n    value: function confirm() {\n      return this.promise;\n    }\n  }]);\n\n  return Confirm;\n}(_Abstract__WEBPACK_IMPORTED_MODULE_0__.AbstractModal);\n\nConfirm.template =\n/*html*/\n\"\\n\".concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_BASE_CSS, \"\\n\").concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_TEMPLATE_BEGIN, \"\\n    {{ this.content }}\\n\").concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_TEMPLATE_END, \"\\n\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9tb2RhbHMvQ29uZmlybS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNNSTs7Ozs7Ozs7Ozs7OztXQUNGLG1CQUFVO0FBQ04sYUFBTyxLQUFLQyxPQUFaO0FBQ0g7Ozs7RUFIaUJMOztBQU10QkksT0FBTyxDQUFDRSxRQUFSO0FBQW1CO0FBQW5CLFlBQ0VMLHFEQURGLGVBRUVDLDJEQUZGLHVDQUlFQyx5REFKRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3BhcnRpYWxzL21vZGFscy9Db25maXJtL2luZGV4LmpzPzI3NDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBYnN0cmFjdE1vZGFsLFxuICAgIE1PREFMX0JBU0VfQ1NTLFxuICAgIE1PREFMX1RFTVBMQVRFX0JFR0lOLFxuICAgIE1PREFMX1RFTVBMQVRFX0VORCxcbn0gZnJvbSBcIi4uL0Fic3RyYWN0XCI7XG5cbi8qKlxuICogdXNhZ2U6XG4gICAgYXN5bmMgdGVzdE1vZGFsKCkge1xuICAgICAgICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1vZGFsLWNvbmZpcm1cIik7XG4gICAgICAgIG0uaGVhZGVyID0gXCJDaWxsdW0gZXhlcmNpdGF0aW9uXCI7XG4gICAgICAgIG0uY29udGVudCA9XG4gICAgICAgICAgICBcIkVzc2Ugc2l0IGV4ZXJjaXRhdGlvbiBsYWJvcnVtIHNpdCBub3N0cnVkIGxhYm9yZSBxdWkgY3VwaWRhdGF0LlwiO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbS5jb25maXJtKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbmZpcm1lZFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FuY2VsZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gKi9cbmNsYXNzIENvbmZpcm0gZXh0ZW5kcyBBYnN0cmFjdE1vZGFsIHtcbiAgICBjb25maXJtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbn1cblxuQ29uZmlybS50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7TU9EQUxfQkFTRV9DU1N9XG4ke01PREFMX1RFTVBMQVRFX0JFR0lOfVxuICAgIHt7IHRoaXMuY29udGVudCB9fVxuJHtNT0RBTF9URU1QTEFURV9FTkR9XG5gO1xuXG5leHBvcnQgeyBDb25maXJtIH07XG4iXSwibmFtZXMiOlsiQWJzdHJhY3RNb2RhbCIsIk1PREFMX0JBU0VfQ1NTIiwiTU9EQUxfVEVNUExBVEVfQkVHSU4iLCJNT0RBTF9URU1QTEFURV9FTkQiLCJDb25maXJtIiwicHJvbWlzZSIsInRlbXBsYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/partials/modals/Confirm/index.js\n");

/***/ }),

/***/ "./resources/js/components/partials/modals/Dialogue/index.js":
/*!*******************************************************************!*\
  !*** ./resources/js/components/partials/modals/Dialogue/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Dialogue\": () => (/* binding */ Dialogue)\n/* harmony export */ });\n/* harmony import */ var _Abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Abstract */ \"./resources/js/components/partials/modals/Abstract.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * usage:\n    async testModal() {\n        const m = document.createElement(\"modal-confirm\");\n        m.header = \"Cillum exercitation\";\n        const d = m.appendChild(document.createElement(\"dialogue-scale\"));\n        m.content =\n            \"Esse sit exercitation laborum sit nostrud labore qui cupidatat.\";\n        document.body.appendChild(m);\n        try {\n            await m.confirm();\n            console.log(\"confirmed\");\n        } catch (error) {\n            console.log(\"canceled\");\n        }\n    }\n */\n\nvar Dialogue = /*#__PURE__*/function (_AbstractModal) {\n  _inherits(Dialogue, _AbstractModal);\n\n  var _super = _createSuper(Dialogue);\n\n  function Dialogue() {\n    _classCallCheck(this, Dialogue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Dialogue, [{\n    key: \"open\",\n    value: function open() {\n      return this.promise;\n    }\n  }]);\n\n  return Dialogue;\n}(_Abstract__WEBPACK_IMPORTED_MODULE_0__.AbstractModal);\n\nDialogue.template =\n/*html*/\n\"\\n\".concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_BASE_CSS, \"\\n\").concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_TEMPLATE_BEGIN, \"\\n    <slot></slot>\\n\").concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_TEMPLATE_END, \"\\n\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9tb2RhbHMvRGlhbG9ndWUvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNNSTs7Ozs7Ozs7Ozs7OztXQUNGLGdCQUFPO0FBQ0gsYUFBTyxLQUFLQyxPQUFaO0FBQ0g7Ozs7RUFIa0JMOztBQU12QkksUUFBUSxDQUFDRSxRQUFUO0FBQW9CO0FBQXBCLFlBQ0VMLHFEQURGLGVBRUVDLDJEQUZGLGtDQUlFQyx5REFKRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3BhcnRpYWxzL21vZGFscy9EaWFsb2d1ZS9pbmRleC5qcz8wZmI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQWJzdHJhY3RNb2RhbCxcbiAgICBNT0RBTF9CQVNFX0NTUyxcbiAgICBNT0RBTF9URU1QTEFURV9CRUdJTixcbiAgICBNT0RBTF9URU1QTEFURV9FTkQsXG59IGZyb20gXCIuLi9BYnN0cmFjdFwiO1xuXG4vKipcbiAqIHVzYWdlOlxuICAgIGFzeW5jIHRlc3RNb2RhbCgpIHtcbiAgICAgICAgY29uc3QgbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtb2RhbC1jb25maXJtXCIpO1xuICAgICAgICBtLmhlYWRlciA9IFwiQ2lsbHVtIGV4ZXJjaXRhdGlvblwiO1xuICAgICAgICBjb25zdCBkID0gbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGlhbG9ndWUtc2NhbGVcIikpO1xuICAgICAgICBtLmNvbnRlbnQgPVxuICAgICAgICAgICAgXCJFc3NlIHNpdCBleGVyY2l0YXRpb24gbGFib3J1bSBzaXQgbm9zdHJ1ZCBsYWJvcmUgcXVpIGN1cGlkYXRhdC5cIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IG0uY29uZmlybSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb25maXJtZWRcIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhbmNlbGVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICovXG5jbGFzcyBEaWFsb2d1ZSBleHRlbmRzIEFic3RyYWN0TW9kYWwge1xuICAgIG9wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfVxufVxuXG5EaWFsb2d1ZS50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7TU9EQUxfQkFTRV9DU1N9XG4ke01PREFMX1RFTVBMQVRFX0JFR0lOfVxuICAgIDxzbG90Pjwvc2xvdD5cbiR7TU9EQUxfVEVNUExBVEVfRU5EfVxuYDtcblxuZXhwb3J0IHsgRGlhbG9ndWUgfTtcbiJdLCJuYW1lcyI6WyJBYnN0cmFjdE1vZGFsIiwiTU9EQUxfQkFTRV9DU1MiLCJNT0RBTF9URU1QTEFURV9CRUdJTiIsIk1PREFMX1RFTVBMQVRFX0VORCIsIkRpYWxvZ3VlIiwicHJvbWlzZSIsInRlbXBsYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/partials/modals/Dialogue/index.js\n");

/***/ }),

/***/ "./resources/js/components/partials/modals/Window/index.js":
/*!*****************************************************************!*\
  !*** ./resources/js/components/partials/modals/Window/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Window\": () => (/* binding */ Window)\n/* harmony export */ });\n/* harmony import */ var _Abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Abstract */ \"./resources/js/components/partials/modals/Abstract.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar Window = /*#__PURE__*/function (_AbstractModal) {\n  _inherits(Window, _AbstractModal);\n\n  var _super = _createSuper(Window);\n\n  function Window() {\n    _classCallCheck(this, Window);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Window, [{\n    key: \"open\",\n    value: function open() {\n      return this.promise;\n    }\n  }]);\n\n  return Window;\n}(_Abstract__WEBPACK_IMPORTED_MODULE_0__.AbstractModal);\n\nWindow.template =\n/*html*/\n\"\\n\".concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_BASE_CSS, \"\\n<style>\\n    main {\\n        position: absolute;\\n        box-shadow: 0 0 10vw 3vw var(--clr-shadow-0);\\n        inset: var(--window-inset);\\n        border-radius: var(--window-border-radius);\\n        background-color: var(--clr-bg-0);\\n        padding: min(30px, var(--rel-gutter-200));\\n        max-width: revert;\\n        min-width: revert;\\n        display: grid;\\n        grid-template-rows: max-content auto max-content;\\n    }\\n    :host(.no-shadow) main {\\n        box-shadow: none;\\n    }\\n    main > section {\\n        overflow-y: auto;\\n    }\\n</style>\\n\").concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_TEMPLATE_BEGIN, \"\\n    <slot></slot>\\n\").concat(_Abstract__WEBPACK_IMPORTED_MODULE_0__.MODAL_TEMPLATE_END, \"\\n\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXJ0aWFscy9tb2RhbHMvV2luZG93L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztJQU9NSTs7Ozs7Ozs7Ozs7OztXQUNGLGdCQUFPO0FBQ0gsYUFBTyxLQUFLQyxPQUFaO0FBQ0g7Ozs7RUFIZ0JMOztBQU1yQkksTUFBTSxDQUFDRSxRQUFQO0FBQWtCO0FBQWxCLFlBQ0VMLHFEQURGLHNrQkFzQkVDLDJEQXRCRixrQ0F3QkVDLHlEQXhCRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3BhcnRpYWxzL21vZGFscy9XaW5kb3cvaW5kZXguanM/YjE4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEFic3RyYWN0TW9kYWwsXG4gICAgTU9EQUxfQkFTRV9DU1MsXG4gICAgTU9EQUxfVEVNUExBVEVfQkVHSU4sXG4gICAgTU9EQUxfVEVNUExBVEVfRU5ELFxufSBmcm9tIFwiLi4vQWJzdHJhY3RcIjtcblxuY2xhc3MgV2luZG93IGV4dGVuZHMgQWJzdHJhY3RNb2RhbCB7XG4gICAgb3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9XG59XG5cbldpbmRvdy50ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiR7TU9EQUxfQkFTRV9DU1N9XG48c3R5bGU+XG4gICAgbWFpbiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwdncgM3Z3IHZhcigtLWNsci1zaGFkb3ctMCk7XG4gICAgICAgIGluc2V0OiB2YXIoLS13aW5kb3ctaW5zZXQpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiB2YXIoLS13aW5kb3ctYm9yZGVyLXJhZGl1cyk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNsci1iZy0wKTtcbiAgICAgICAgcGFkZGluZzogbWluKDMwcHgsIHZhcigtLXJlbC1ndXR0ZXItMjAwKSk7XG4gICAgICAgIG1heC13aWR0aDogcmV2ZXJ0O1xuICAgICAgICBtaW4td2lkdGg6IHJldmVydDtcbiAgICAgICAgZGlzcGxheTogZ3JpZDtcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiBtYXgtY29udGVudCBhdXRvIG1heC1jb250ZW50O1xuICAgIH1cbiAgICA6aG9zdCgubm8tc2hhZG93KSBtYWluIHtcbiAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICB9XG4gICAgbWFpbiA+IHNlY3Rpb24ge1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIH1cbjwvc3R5bGU+XG4ke01PREFMX1RFTVBMQVRFX0JFR0lOfVxuICAgIDxzbG90Pjwvc2xvdD5cbiR7TU9EQUxfVEVNUExBVEVfRU5EfVxuYDtcblxuZXhwb3J0IHsgV2luZG93IH07XG4iXSwibmFtZXMiOlsiQWJzdHJhY3RNb2RhbCIsIk1PREFMX0JBU0VfQ1NTIiwiTU9EQUxfVEVNUExBVEVfQkVHSU4iLCJNT0RBTF9URU1QTEFURV9FTkQiLCJXaW5kb3ciLCJwcm9taXNlIiwidGVtcGxhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/partials/modals/Window/index.js\n");

/***/ }),

/***/ "./node_modules/html5sortable/dist/html5sortable.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/html5sortable/dist/html5sortable.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n * HTML5Sortable package\n * https://github.com/lukasoppermann/html5sortable\n *\n * Maintained by Lukas Oppermann <lukas@vea.re>\n *\n * Released under the MIT license.\n */\n/**\n * Get or set data on element\n * @param {HTMLElement} element\n * @param {string} key\n * @param {any} value\n * @return {*}\n */\nfunction addData(element, key, value) {\n    if (value === undefined) {\n        return element && element.h5s && element.h5s.data && element.h5s.data[key];\n    }\n    else {\n        element.h5s = element.h5s || {};\n        element.h5s.data = element.h5s.data || {};\n        element.h5s.data[key] = value;\n    }\n}\n/**\n * Remove data from element\n * @param {HTMLElement} element\n */\nfunction removeData(element) {\n    if (element.h5s) {\n        delete element.h5s.data;\n    }\n}\n\n/* eslint-env browser */\n/**\n * Filter only wanted nodes\n * @param {NodeList|HTMLCollection|Array} nodes\n * @param {String} selector\n * @returns {Array}\n */\nvar filter = (function (nodes, selector) {\n    if (!(nodes instanceof NodeList || nodes instanceof HTMLCollection || nodes instanceof Array)) {\n        throw new Error('You must provide a nodeList/HTMLCollection/Array of elements to be filtered.');\n    }\n    if (typeof selector !== 'string') {\n        return Array.from(nodes);\n    }\n    return Array.from(nodes).filter(function (item) { return item.nodeType === 1 && item.matches(selector); });\n});\n\n/* eslint-env browser */\n/* eslint-disable no-use-before-define */\nvar stores = new Map();\n/* eslint-enable no-use-before-define */\n/**\n * Stores data & configurations per Sortable\n * @param {Object} config\n */\nvar Store = /** @class */ (function () {\n    function Store() {\n        this._config = new Map(); // eslint-disable-line no-undef\n        this._placeholder = undefined; // eslint-disable-line no-undef\n        this._data = new Map(); // eslint-disable-line no-undef\n    }\n    Object.defineProperty(Store.prototype, \"config\", {\n        /**\n         * get the configuration map of a class instance\n         * @method config\n         * @return {object}\n         */\n        get: function () {\n            // transform Map to object\n            var config = {};\n            this._config.forEach(function (value, key) {\n                config[key] = value;\n            });\n            // return object\n            return config;\n        },\n        /**\n         * set the configuration of a class instance\n         * @method config\n         * @param {object} config object of configurations\n         */\n        set: function (config) {\n            if (typeof config !== 'object') {\n                throw new Error('You must provide a valid configuration object to the config setter.');\n            }\n            // combine config with default\n            var mergedConfig = Object.assign({}, config);\n            // add config to map\n            this._config = new Map(Object.entries(mergedConfig));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * set individual configuration of a class instance\n     * @method setConfig\n     * @param  key valid configuration key\n     * @param  value any value\n     * @return void\n     */\n    Store.prototype.setConfig = function (key, value) {\n        if (!this._config.has(key)) {\n            throw new Error(\"Trying to set invalid configuration item: \" + key);\n        }\n        // set config\n        this._config.set(key, value);\n    };\n    /**\n     * get an individual configuration of a class instance\n     * @method getConfig\n     * @param  key valid configuration key\n     * @return any configuration value\n     */\n    Store.prototype.getConfig = function (key) {\n        if (!this._config.has(key)) {\n            throw new Error(\"Invalid configuration item requested: \" + key);\n        }\n        return this._config.get(key);\n    };\n    Object.defineProperty(Store.prototype, \"placeholder\", {\n        /**\n         * get the placeholder for a class instance\n         * @method placeholder\n         * @return {HTMLElement|null}\n         */\n        get: function () {\n            return this._placeholder;\n        },\n        /**\n         * set the placeholder for a class instance\n         * @method placeholder\n         * @param {HTMLElement} placeholder\n         * @return {void}\n         */\n        set: function (placeholder) {\n            if (!(placeholder instanceof HTMLElement) && placeholder !== null) {\n                throw new Error('A placeholder must be an html element or null.');\n            }\n            this._placeholder = placeholder;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * set an data entry\n     * @method setData\n     * @param {string} key\n     * @param {any} value\n     * @return {void}\n     */\n    Store.prototype.setData = function (key, value) {\n        if (typeof key !== 'string') {\n            throw new Error('The key must be a string.');\n        }\n        this._data.set(key, value);\n    };\n    /**\n     * get an data entry\n     * @method getData\n     * @param {string} key an existing key\n     * @return {any}\n     */\n    Store.prototype.getData = function (key) {\n        if (typeof key !== 'string') {\n            throw new Error('The key must be a string.');\n        }\n        return this._data.get(key);\n    };\n    /**\n     * delete an data entry\n     * @method deleteData\n     * @param {string} key an existing key\n     * @return {boolean}\n     */\n    Store.prototype.deleteData = function (key) {\n        if (typeof key !== 'string') {\n            throw new Error('The key must be a string.');\n        }\n        return this._data.delete(key);\n    };\n    return Store;\n}());\n/**\n * @param {HTMLElement} sortableElement\n * @returns {Class: Store}\n */\nvar store = (function (sortableElement) {\n    // if sortableElement is wrong type\n    if (!(sortableElement instanceof HTMLElement)) {\n        throw new Error('Please provide a sortable to the store function.');\n    }\n    // create new instance if not avilable\n    if (!stores.has(sortableElement)) {\n        stores.set(sortableElement, new Store());\n    }\n    // return instance\n    return stores.get(sortableElement);\n});\n\n/**\n * @param {Array|HTMLElement} element\n * @param {Function} callback\n * @param {string} event\n */\nfunction addEventListener(element, eventName, callback) {\n    if (element instanceof Array) {\n        for (var i = 0; i < element.length; ++i) {\n            addEventListener(element[i], eventName, callback);\n        }\n        return;\n    }\n    element.addEventListener(eventName, callback);\n    store(element).setData(\"event\" + eventName, callback);\n}\n/**\n * @param {Array<HTMLElement>|HTMLElement} element\n * @param {string} eventName\n */\nfunction removeEventListener(element, eventName) {\n    if (element instanceof Array) {\n        for (var i = 0; i < element.length; ++i) {\n            removeEventListener(element[i], eventName);\n        }\n        return;\n    }\n    element.removeEventListener(eventName, store(element).getData(\"event\" + eventName));\n    store(element).deleteData(\"event\" + eventName);\n}\n\n/**\n * @param {Array<HTMLElement>|HTMLElement} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction addAttribute(element, attribute, value) {\n    if (element instanceof Array) {\n        for (var i = 0; i < element.length; ++i) {\n            addAttribute(element[i], attribute, value);\n        }\n        return;\n    }\n    element.setAttribute(attribute, value);\n}\n/**\n * @param {Array|HTMLElement} element\n * @param {string} attribute\n */\nfunction removeAttribute(element, attribute) {\n    if (element instanceof Array) {\n        for (var i = 0; i < element.length; ++i) {\n            removeAttribute(element[i], attribute);\n        }\n        return;\n    }\n    element.removeAttribute(attribute);\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {Object}\n */\nvar offset = (function (element) {\n    if (!element.parentElement || element.getClientRects().length === 0) {\n        throw new Error('target element must be part of the dom');\n    }\n    var rect = element.getClientRects()[0];\n    return {\n        left: rect.left + window.pageXOffset,\n        right: rect.right + window.pageXOffset,\n        top: rect.top + window.pageYOffset,\n        bottom: rect.bottom + window.pageYOffset\n    };\n});\n\n/**\n * Creates and returns a new debounced version of the passed function which will postpone its execution until after wait milliseconds have elapsed\n * @param {Function} func to debounce\n * @param {number} time to wait before calling function with latest arguments, 0 - no debounce\n * @returns {function} - debounced function\n */\nvar debounce = (function (func, wait) {\n    if (wait === void 0) { wait = 0; }\n    var timeout;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(function () {\n            func.apply(void 0, args);\n        }, wait);\n    };\n});\n\n/* eslint-env browser */\n/**\n * Get position of the element relatively to its sibling elements\n * @param {HTMLElement} element\n * @returns {number}\n */\nvar getIndex = (function (element, elementList) {\n    if (!(element instanceof HTMLElement) || !(elementList instanceof NodeList || elementList instanceof HTMLCollection || elementList instanceof Array)) {\n        throw new Error('You must provide an element and a list of elements.');\n    }\n    return Array.from(elementList).indexOf(element);\n});\n\n/* eslint-env browser */\n/**\n * Test whether element is in DOM\n * @param {HTMLElement} element\n * @returns {boolean}\n */\nvar isInDom = (function (element) {\n    if (!(element instanceof HTMLElement)) {\n        throw new Error('Element is not a node element.');\n    }\n    return element.parentNode !== null;\n});\n\n/* eslint-env browser */\n/**\n * Insert node before or after target\n * @param {HTMLElement} referenceNode - reference element\n * @param {HTMLElement} newElement - element to be inserted\n * @param {String} position - insert before or after reference element\n */\nvar insertNode = function (referenceNode, newElement, position) {\n    if (!(referenceNode instanceof HTMLElement) || !(referenceNode.parentElement instanceof HTMLElement)) {\n        throw new Error('target and element must be a node');\n    }\n    referenceNode.parentElement.insertBefore(newElement, (position === 'before' ? referenceNode : referenceNode.nextElementSibling));\n};\n/**\n * Insert before target\n * @param {HTMLElement} target\n * @param {HTMLElement} element\n */\nvar insertBefore = function (target, element) { return insertNode(target, element, 'before'); };\n/**\n * Insert after target\n * @param {HTMLElement} target\n * @param {HTMLElement} element\n */\nvar insertAfter = function (target, element) { return insertNode(target, element, 'after'); };\n\n/* eslint-env browser */\n/**\n * Filter only wanted nodes\n * @param {HTMLElement} sortableContainer\n * @param {Function} customSerializer\n * @returns {Array}\n */\nvar serialize = (function (sortableContainer, customItemSerializer, customContainerSerializer) {\n    if (customItemSerializer === void 0) { customItemSerializer = function (serializedItem, sortableContainer) { return serializedItem; }; }\n    if (customContainerSerializer === void 0) { customContainerSerializer = function (serializedContainer) { return serializedContainer; }; }\n    // check for valid sortableContainer\n    if (!(sortableContainer instanceof HTMLElement) || !sortableContainer.isSortable === true) {\n        throw new Error('You need to provide a sortableContainer to be serialized.');\n    }\n    // check for valid serializers\n    if (typeof customItemSerializer !== 'function' || typeof customContainerSerializer !== 'function') {\n        throw new Error('You need to provide a valid serializer for items and the container.');\n    }\n    // get options\n    var options = addData(sortableContainer, 'opts');\n    var item = options.items;\n    // serialize container\n    var items = filter(sortableContainer.children, item);\n    var serializedItems = items.map(function (item) {\n        return {\n            parent: sortableContainer,\n            node: item,\n            html: item.outerHTML,\n            index: getIndex(item, items)\n        };\n    });\n    // serialize container\n    var container = {\n        node: sortableContainer,\n        itemCount: serializedItems.length\n    };\n    return {\n        container: customContainerSerializer(container),\n        items: serializedItems.map(function (item) { return customItemSerializer(item, sortableContainer); })\n    };\n});\n\n/* eslint-env browser */\n/**\n * create a placeholder element\n * @param {HTMLElement} sortableElement a single sortable\n * @param {string|undefined} placeholder a string representing an html element\n * @param {string} placeholderClasses a string representing the classes that should be added to the placeholder\n */\nvar makePlaceholder = (function (sortableElement, placeholder, placeholderClass) {\n    var _a;\n    if (placeholderClass === void 0) { placeholderClass = 'sortable-placeholder'; }\n    if (!(sortableElement instanceof HTMLElement)) {\n        throw new Error('You must provide a valid element as a sortable.');\n    }\n    // if placeholder is not an element\n    if (!(placeholder instanceof HTMLElement) && placeholder !== undefined) {\n        throw new Error('You must provide a valid element as a placeholder or set ot to undefined.');\n    }\n    // if no placeholder element is given\n    if (placeholder === undefined) {\n        if (['UL', 'OL'].includes(sortableElement.tagName)) {\n            placeholder = document.createElement('li');\n        }\n        else if (['TABLE', 'TBODY'].includes(sortableElement.tagName)) {\n            placeholder = document.createElement('tr');\n            // set colspan to always all rows, otherwise the item can only be dropped in first column\n            placeholder.innerHTML = '<td colspan=\"100\"></td>';\n        }\n        else {\n            placeholder = document.createElement('div');\n        }\n    }\n    // add classes to placeholder\n    if (typeof placeholderClass === 'string') {\n        (_a = placeholder.classList).add.apply(_a, placeholderClass.split(' '));\n    }\n    return placeholder;\n});\n\n/* eslint-env browser */\n/**\n * Get height of an element including padding\n * @param {HTMLElement} element an dom element\n */\nvar getElementHeight = (function (element) {\n    if (!(element instanceof HTMLElement)) {\n        throw new Error('You must provide a valid dom element');\n    }\n    // get calculated style of element\n    var style = window.getComputedStyle(element);\n    // get only height if element has box-sizing: border-box specified\n    if (style.getPropertyValue('box-sizing') === 'border-box') {\n        return parseInt(style.getPropertyValue('height'), 10);\n    }\n    // pick applicable properties, convert to int and reduce by adding\n    return ['height', 'padding-top', 'padding-bottom']\n        .map(function (key) {\n        var int = parseInt(style.getPropertyValue(key), 10);\n        return isNaN(int) ? 0 : int;\n    })\n        .reduce(function (sum, value) { return sum + value; });\n});\n\n/* eslint-env browser */\n/**\n * Get width of an element including padding\n * @param {HTMLElement} element an dom element\n */\nvar getElementWidth = (function (element) {\n    if (!(element instanceof HTMLElement)) {\n        throw new Error('You must provide a valid dom element');\n    }\n    // get calculated style of element\n    var style = window.getComputedStyle(element);\n    // pick applicable properties, convert to int and reduce by adding\n    return ['width', 'padding-left', 'padding-right']\n        .map(function (key) {\n        var int = parseInt(style.getPropertyValue(key), 10);\n        return isNaN(int) ? 0 : int;\n    })\n        .reduce(function (sum, value) { return sum + value; });\n});\n\n/* eslint-env browser */\n/**\n * get handle or return item\n * @param {Array<HTMLElement>} items\n * @param {string} selector\n */\nvar getHandles = (function (items, selector) {\n    if (!(items instanceof Array)) {\n        throw new Error('You must provide a Array of HTMLElements to be filtered.');\n    }\n    if (typeof selector !== 'string') {\n        return items;\n    }\n    return items\n        // remove items without handle from array\n        .filter(function (item) {\n        return item.querySelector(selector) instanceof HTMLElement ||\n            (item.shadowRoot && item.shadowRoot.querySelector(selector) instanceof HTMLElement);\n    })\n        // replace item with handle in array\n        .map(function (item) {\n        return item.querySelector(selector) || (item.shadowRoot && item.shadowRoot.querySelector(selector));\n    });\n});\n\n/**\n * @param {Event} event\n * @returns {HTMLElement}\n */\nvar getEventTarget = (function (event) {\n    return (event.composedPath && event.composedPath()[0]) || event.target;\n});\n\n/* eslint-env browser */\n/**\n * defaultDragImage returns the current item as dragged image\n * @param {HTMLElement} draggedElement - the item that the user drags\n * @param {object} elementOffset - an object with the offsets top, left, right & bottom\n * @param {Event} event - the original drag event object\n * @return {object} with element, posX and posY properties\n */\nvar defaultDragImage = function (draggedElement, elementOffset, event) {\n    return {\n        element: draggedElement,\n        posX: event.pageX - elementOffset.left,\n        posY: event.pageY - elementOffset.top\n    };\n};\n/**\n * attaches an element as the drag image to an event\n * @param {Event} event - the original drag event object\n * @param {HTMLElement} draggedElement - the item that the user drags\n * @param {Function} customDragImage - function to create a custom dragImage\n * @return void\n */\nvar setDragImage = (function (event, draggedElement, customDragImage) {\n    // check if event is provided\n    if (!(event instanceof Event)) {\n        throw new Error('setDragImage requires a DragEvent as the first argument.');\n    }\n    // check if draggedElement is provided\n    if (!(draggedElement instanceof HTMLElement)) {\n        throw new Error('setDragImage requires the dragged element as the second argument.');\n    }\n    // set default function of none provided\n    if (!customDragImage) {\n        customDragImage = defaultDragImage;\n    }\n    // check if setDragImage method is available\n    if (event.dataTransfer && event.dataTransfer.setDragImage) {\n        // get the elements offset\n        var elementOffset = offset(draggedElement);\n        // get the dragImage\n        var dragImage = customDragImage(draggedElement, elementOffset, event);\n        // check if custom function returns correct values\n        if (!(dragImage.element instanceof HTMLElement) || typeof dragImage.posX !== 'number' || typeof dragImage.posY !== 'number') {\n            throw new Error('The customDragImage function you provided must return and object with the properties element[string], posX[integer], posY[integer].');\n        }\n        // needs to be set for HTML5 drag & drop to work\n        event.dataTransfer.effectAllowed = 'copyMove';\n        // Firefox requires it to use the event target's id for the data\n        event.dataTransfer.setData('text/plain', getEventTarget(event).id);\n        // set the drag image on the event\n        event.dataTransfer.setDragImage(dragImage.element, dragImage.posX, dragImage.posY);\n    }\n});\n\n/**\n * Check if curList accepts items from destList\n * @param {sortable} destination the container an item is move to\n * @param {sortable} origin the container an item comes from\n */\nvar listsConnected = (function (destination, origin) {\n    // check if valid sortable\n    if (destination.isSortable === true) {\n        var acceptFrom = store(destination).getConfig('acceptFrom');\n        // check if acceptFrom is valid\n        if (acceptFrom !== null && acceptFrom !== false && typeof acceptFrom !== 'string') {\n            throw new Error('HTML5Sortable: Wrong argument, \"acceptFrom\" must be \"null\", \"false\", or a valid selector string.');\n        }\n        if (acceptFrom !== null) {\n            return acceptFrom !== false && acceptFrom.split(',').filter(function (sel) {\n                return sel.length > 0 && origin.matches(sel);\n            }).length > 0;\n        }\n        // drop in same list\n        if (destination === origin) {\n            return true;\n        }\n        // check if lists are connected with connectWith\n        if (store(destination).getConfig('connectWith') !== undefined && store(destination).getConfig('connectWith') !== null) {\n            return store(destination).getConfig('connectWith') === store(origin).getConfig('connectWith');\n        }\n    }\n    return false;\n});\n\n/**\n * default configurations\n */\nvar defaultConfiguration = {\n    items: null,\n    // deprecated\n    connectWith: null,\n    // deprecated\n    disableIEFix: null,\n    acceptFrom: null,\n    copy: false,\n    placeholder: null,\n    placeholderClass: 'sortable-placeholder',\n    draggingClass: 'sortable-dragging',\n    hoverClass: false,\n    dropTargetContainerClass: false,\n    debounce: 0,\n    throttleTime: 100,\n    maxItems: 0,\n    itemSerializer: undefined,\n    containerSerializer: undefined,\n    customDragImage: null,\n    orientation: 'vertical'\n};\n\n/**\n * make sure a function is only called once within the given amount of time\n * @param {Function} fn the function to throttle\n * @param {number} threshold time limit for throttling\n */\n// must use function to keep this context\nfunction throttle (fn, threshold) {\n    var _this = this;\n    if (threshold === void 0) { threshold = 250; }\n    // check function\n    if (typeof fn !== 'function') {\n        throw new Error('You must provide a function as the first argument for throttle.');\n    }\n    // check threshold\n    if (typeof threshold !== 'number') {\n        throw new Error('You must provide a number as the second argument for throttle.');\n    }\n    var lastEventTimestamp = null;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var now = Date.now();\n        if (lastEventTimestamp === null || now - lastEventTimestamp >= threshold) {\n            lastEventTimestamp = now;\n            fn.apply(_this, args);\n        }\n    };\n}\n\n/* eslint-env browser */\n/**\n * enable or disable hoverClass on mouseenter/leave if container Items\n * @param {sortable} sortableContainer a valid sortableContainer\n * @param {boolean} enable enable or disable event\n */\nvar enableHoverClass = (function (sortableContainer, enable) {\n    if (typeof store(sortableContainer).getConfig('hoverClass') === 'string') {\n        var hoverClasses_1 = store(sortableContainer).getConfig('hoverClass').split(' ');\n        // add class on hover\n        if (enable === true) {\n            addEventListener(sortableContainer, 'mousemove', throttle(function (event) {\n                // check of no mouse button was pressed when mousemove started == no drag\n                if (event.buttons === 0) {\n                    filter(sortableContainer.children, store(sortableContainer).getConfig('items')).forEach(function (item) {\n                        var _a, _b;\n                        if (item === event.target || item.contains(event.target)) {\n                            (_a = item.classList).add.apply(_a, hoverClasses_1);\n                        }\n                        else {\n                            (_b = item.classList).remove.apply(_b, hoverClasses_1);\n                        }\n                    });\n                }\n            }, store(sortableContainer).getConfig('throttleTime')));\n            // remove class on leave\n            addEventListener(sortableContainer, 'mouseleave', function () {\n                filter(sortableContainer.children, store(sortableContainer).getConfig('items')).forEach(function (item) {\n                    var _a;\n                    (_a = item.classList).remove.apply(_a, hoverClasses_1);\n                });\n            });\n            // remove events\n        }\n        else {\n            removeEventListener(sortableContainer, 'mousemove');\n            removeEventListener(sortableContainer, 'mouseleave');\n        }\n    }\n});\n\n/* eslint-env browser */\n/*\n * variables global to the plugin\n */\nvar dragging;\nvar draggingHeight;\nvar draggingWidth;\n/*\n * Keeps track of the initialy selected list, where 'dragstart' event was triggered\n * It allows us to move the data in between individual Sortable List instances\n */\n// Origin List - data from before any item was changed\nvar originContainer;\nvar originIndex;\nvar originElementIndex;\nvar originItemsBeforeUpdate;\n// Previous Sortable Container - we dispatch as sortenter event when a\n// dragged item enters a sortableContainer for the first time\nvar previousContainer;\n// Destination List - data from before any item was changed\nvar destinationItemsBeforeUpdate;\n/**\n * remove event handlers from items\n * @param {Array|NodeList} items\n */\nvar removeItemEvents = function (items) {\n    removeEventListener(items, 'dragstart');\n    removeEventListener(items, 'dragend');\n    removeEventListener(items, 'dragover');\n    removeEventListener(items, 'dragenter');\n    removeEventListener(items, 'drop');\n    removeEventListener(items, 'mouseenter');\n    removeEventListener(items, 'mouseleave');\n};\n// Remove container events\nvar removeContainerEvents = function (originContainer, previousContainer) {\n    if (originContainer) {\n        removeEventListener(originContainer, 'dragleave');\n    }\n    if (previousContainer && (previousContainer !== originContainer)) {\n        removeEventListener(previousContainer, 'dragleave');\n    }\n};\n/**\n * getDragging returns the current element to drag or\n * a copy of the element.\n * Is Copy Active for sortable\n * @param {HTMLElement} draggedItem - the item that the user drags\n * @param {HTMLElement} sortable a single sortable\n */\nvar getDragging = function (draggedItem, sortable) {\n    var ditem = draggedItem;\n    if (store(sortable).getConfig('copy') === true) {\n        ditem = draggedItem.cloneNode(true);\n        addAttribute(ditem, 'aria-copied', 'true');\n        draggedItem.parentElement.appendChild(ditem);\n        ditem.style.display = 'none';\n        ditem.oldDisplay = draggedItem.style.display;\n    }\n    return ditem;\n};\n/**\n * Remove data from sortable\n * @param {HTMLElement} sortable a single sortable\n */\nvar removeSortableData = function (sortable) {\n    removeData(sortable);\n    removeAttribute(sortable, 'aria-dropeffect');\n};\n/**\n * Remove data from items\n * @param {Array<HTMLElement>|HTMLElement} items\n */\nvar removeItemData = function (items) {\n    removeAttribute(items, 'aria-grabbed');\n    removeAttribute(items, 'aria-copied');\n    removeAttribute(items, 'draggable');\n    removeAttribute(items, 'role');\n};\n/**\n * find sortable from element. travels up parent element until found or null.\n * @param {HTMLElement} element a single sortable\n * @param {Event} event - the current event. We need to pass it to be able to\n * find Sortable whith shadowRoot (document fragment has no parent)\n */\nfunction findSortable(element, event) {\n    if (event.composedPath) {\n        return event.composedPath().find(function (el) { return el.isSortable; });\n    }\n    while (element.isSortable !== true) {\n        element = element.parentElement;\n    }\n    return element;\n}\n/**\n * Dragging event is on the sortable element. finds the top child that\n * contains the element.\n * @param {HTMLElement} sortableElement a single sortable\n * @param {HTMLElement} element is that being dragged\n */\nfunction findDragElement(sortableElement, element) {\n    var options = addData(sortableElement, 'opts');\n    var items = filter(sortableElement.children, options.items);\n    var itemlist = items.filter(function (ele) {\n        return ele.contains(element) || (ele.shadowRoot && ele.shadowRoot.contains(element));\n    });\n    return itemlist.length > 0 ? itemlist[0] : element;\n}\n/**\n * Destroy the sortable\n * @param {HTMLElement} sortableElement a single sortable\n */\nvar destroySortable = function (sortableElement) {\n    var opts = addData(sortableElement, 'opts') || {};\n    var items = filter(sortableElement.children, opts.items);\n    var handles = getHandles(items, opts.handle);\n    // disable adding hover class\n    enableHoverClass(sortableElement, false);\n    // remove event handlers & data from sortable\n    removeEventListener(sortableElement, 'dragover');\n    removeEventListener(sortableElement, 'dragenter');\n    removeEventListener(sortableElement, 'dragstart');\n    removeEventListener(sortableElement, 'dragend');\n    removeEventListener(sortableElement, 'drop');\n    // remove event data from sortable\n    removeSortableData(sortableElement);\n    // remove event handlers & data from items\n    removeEventListener(handles, 'mousedown');\n    removeItemEvents(items);\n    removeItemData(items);\n    removeContainerEvents(originContainer, previousContainer);\n    // clear sortable flag\n    sortableElement.isSortable = false;\n};\n/**\n * Enable the sortable\n * @param {HTMLElement} sortableElement a single sortable\n */\nvar enableSortable = function (sortableElement) {\n    var opts = addData(sortableElement, 'opts');\n    var items = filter(sortableElement.children, opts.items);\n    var handles = getHandles(items, opts.handle);\n    addAttribute(sortableElement, 'aria-dropeffect', 'move');\n    addData(sortableElement, '_disabled', 'false');\n    addAttribute(handles, 'draggable', 'true');\n    // enable hover class\n    enableHoverClass(sortableElement, true);\n    // @todo: remove this fix\n    // IE FIX for ghost\n    // can be disabled as it has the side effect that other events\n    // (e.g. click) will be ignored\n    if (opts.disableIEFix === false) {\n        var spanEl = (document || window.document).createElement('span');\n        if (typeof spanEl.dragDrop === 'function') {\n            addEventListener(handles, 'mousedown', function () {\n                if (items.indexOf(this) !== -1) {\n                    this.dragDrop();\n                }\n                else {\n                    var parent = this.parentElement;\n                    while (items.indexOf(parent) === -1) {\n                        parent = parent.parentElement;\n                    }\n                    parent.dragDrop();\n                }\n            });\n        }\n    }\n};\n/**\n * Disable the sortable\n * @param {HTMLElement} sortableElement a single sortable\n */\nvar disableSortable = function (sortableElement) {\n    var opts = addData(sortableElement, 'opts');\n    var items = filter(sortableElement.children, opts.items);\n    var handles = getHandles(items, opts.handle);\n    addAttribute(sortableElement, 'aria-dropeffect', 'none');\n    addData(sortableElement, '_disabled', 'true');\n    addAttribute(handles, 'draggable', 'false');\n    removeEventListener(handles, 'mousedown');\n    enableHoverClass(sortableElement, false);\n};\n/**\n * Reload the sortable\n * @param {HTMLElement} sortableElement a single sortable\n * @description events need to be removed to not be double bound\n */\nvar reloadSortable = function (sortableElement) {\n    var opts = addData(sortableElement, 'opts');\n    var items = filter(sortableElement.children, opts.items);\n    var handles = getHandles(items, opts.handle);\n    addData(sortableElement, '_disabled', 'false');\n    // remove event handlers from items\n    removeItemEvents(items);\n    removeContainerEvents(originContainer, previousContainer);\n    removeEventListener(handles, 'mousedown');\n    // remove event handlers from sortable\n    removeEventListener(sortableElement, 'dragover');\n    removeEventListener(sortableElement, 'dragenter');\n    removeEventListener(sortableElement, 'drop');\n};\n/**\n * Public sortable object\n * @param {Array|NodeList} sortableElements\n * @param {object|string} options|method\n */\nfunction sortable(sortableElements, options) {\n    // get method string to see if a method is called\n    var method = String(options);\n    options = options || {};\n    // check if the user provided a selector instead of an element\n    if (typeof sortableElements === 'string') {\n        sortableElements = document.querySelectorAll(sortableElements);\n    }\n    // if the user provided an element, return it in an array to keep the return value consistant\n    if (sortableElements instanceof HTMLElement) {\n        sortableElements = [sortableElements];\n    }\n    sortableElements = Array.prototype.slice.call(sortableElements);\n    if (/serialize/.test(method)) {\n        return sortableElements.map(function (sortableContainer) {\n            var opts = addData(sortableContainer, 'opts');\n            return serialize(sortableContainer, opts.itemSerializer, opts.containerSerializer);\n        });\n    }\n    sortableElements.forEach(function (sortableElement) {\n        if (/enable|disable|destroy/.test(method)) {\n            return sortable[method](sortableElement);\n        }\n        // log deprecation\n        ['connectWith', 'disableIEFix'].forEach(function (configKey) {\n            if (Object.prototype.hasOwnProperty.call(options, configKey) && options[configKey] !== null) {\n                console.warn(\"HTML5Sortable: You are using the deprecated configuration \\\"\" + configKey + \"\\\". This will be removed in an upcoming version, make sure to migrate to the new options when updating.\");\n            }\n        });\n        // merge options with default options\n        options = Object.assign({}, defaultConfiguration, store(sortableElement).config, options);\n        // init data store for sortable\n        store(sortableElement).config = options;\n        // set options on sortable\n        addData(sortableElement, 'opts', options);\n        // property to define as sortable\n        sortableElement.isSortable = true;\n        // reset sortable\n        reloadSortable(sortableElement);\n        // initialize\n        var listItems = filter(sortableElement.children, options.items);\n        // create element if user defined a placeholder element as a string\n        var customPlaceholder;\n        if (options.placeholder !== null && options.placeholder !== undefined) {\n            var tempContainer = document.createElement(sortableElement.tagName);\n            if (options.placeholder instanceof HTMLElement) {\n                tempContainer.appendChild(options.placeholder);\n            }\n            else {\n                tempContainer.innerHTML = options.placeholder;\n            }\n            customPlaceholder = tempContainer.children[0];\n        }\n        // add placeholder\n        store(sortableElement).placeholder = makePlaceholder(sortableElement, customPlaceholder, options.placeholderClass);\n        addData(sortableElement, 'items', options.items);\n        if (options.acceptFrom) {\n            addData(sortableElement, 'acceptFrom', options.acceptFrom);\n        }\n        else if (options.connectWith) {\n            addData(sortableElement, 'connectWith', options.connectWith);\n        }\n        enableSortable(sortableElement);\n        addAttribute(listItems, 'role', 'option');\n        addAttribute(listItems, 'aria-grabbed', 'false');\n        /*\n         Handle drag events on draggable items\n         Handle is set at the sortableElement level as it will bubble up\n         from the item\n         */\n        addEventListener(sortableElement, 'dragstart', function (e) {\n            // ignore dragstart events\n            var target = getEventTarget(e);\n            if (target.isSortable === true) {\n                return;\n            }\n            e.stopImmediatePropagation();\n            if ((options.handle && !target.matches(options.handle)) || target.getAttribute('draggable') === 'false') {\n                return;\n            }\n            var sortableContainer = findSortable(target, e);\n            var dragItem = findDragElement(sortableContainer, target);\n            // grab values\n            originItemsBeforeUpdate = filter(sortableContainer.children, options.items);\n            originIndex = originItemsBeforeUpdate.indexOf(dragItem);\n            originElementIndex = getIndex(dragItem, sortableContainer.children);\n            originContainer = sortableContainer;\n            // add transparent clone or other ghost to cursor\n            setDragImage(e, dragItem, options.customDragImage);\n            // cache selsection & add attr for dragging\n            draggingHeight = getElementHeight(dragItem);\n            draggingWidth = getElementWidth(dragItem);\n            dragItem.classList.add(options.draggingClass);\n            dragging = getDragging(dragItem, sortableContainer);\n            addAttribute(dragging, 'aria-grabbed', 'true');\n            // dispatch sortstart event on each element in group\n            sortableContainer.dispatchEvent(new CustomEvent('sortstart', {\n                detail: {\n                    origin: {\n                        elementIndex: originElementIndex,\n                        index: originIndex,\n                        container: originContainer\n                    },\n                    item: dragging,\n                    originalTarget: target\n                }\n            }));\n        });\n        /*\n         We are capturing targetSortable before modifications with 'dragenter' event\n        */\n        addEventListener(sortableElement, 'dragenter', function (e) {\n            var target = getEventTarget(e);\n            var sortableContainer = findSortable(target, e);\n            if (sortableContainer && sortableContainer !== previousContainer) {\n                destinationItemsBeforeUpdate = filter(sortableContainer.children, addData(sortableContainer, 'items'))\n                    .filter(function (item) { return item !== store(sortableElement).placeholder; });\n                if (options.dropTargetContainerClass) {\n                    sortableContainer.classList.add(options.dropTargetContainerClass);\n                }\n                sortableContainer.dispatchEvent(new CustomEvent('sortenter', {\n                    detail: {\n                        origin: {\n                            elementIndex: originElementIndex,\n                            index: originIndex,\n                            container: originContainer\n                        },\n                        destination: {\n                            container: sortableContainer,\n                            itemsBeforeUpdate: destinationItemsBeforeUpdate\n                        },\n                        item: dragging,\n                        originalTarget: target\n                    }\n                }));\n                addEventListener(sortableContainer, 'dragleave', function (e) {\n                    // TODO: rename outTarget to be more self-explanatory\n                    // e.fromElement for very old browsers, similar to relatedTarget\n                    var outTarget = e.relatedTarget || e.fromElement;\n                    if (!e.currentTarget.contains(outTarget)) {\n                        if (options.dropTargetContainerClass) {\n                            sortableContainer.classList.remove(options.dropTargetContainerClass);\n                        }\n                        sortableContainer.dispatchEvent(new CustomEvent('sortleave', {\n                            detail: {\n                                origin: {\n                                    elementIndex: originElementIndex,\n                                    index: originIndex,\n                                    container: sortableContainer\n                                },\n                                item: dragging,\n                                originalTarget: target\n                            }\n                        }));\n                    }\n                });\n            }\n            previousContainer = sortableContainer;\n        });\n        /*\n         * Dragend Event - https://developer.mozilla.org/en-US/docs/Web/Events/dragend\n         * Fires each time dragEvent end, or ESC pressed\n         * We are using it to clean up any draggable elements and placeholders\n         */\n        addEventListener(sortableElement, 'dragend', function (e) {\n            if (!dragging) {\n                return;\n            }\n            dragging.classList.remove(options.draggingClass);\n            addAttribute(dragging, 'aria-grabbed', 'false');\n            if (dragging.getAttribute('aria-copied') === 'true' && addData(dragging, 'dropped') !== 'true') {\n                dragging.remove();\n            }\n            if (dragging.oldDisplay !== undefined) {\n                dragging.style.display = dragging.oldDisplay;\n                delete dragging.oldDisplay;\n            }\n            var visiblePlaceholder = Array.from(stores.values()).map(function (data) { return data.placeholder; })\n                .filter(function (placeholder) { return placeholder instanceof HTMLElement; })\n                .filter(isInDom)[0];\n            if (visiblePlaceholder) {\n                visiblePlaceholder.remove();\n            }\n            // dispatch sortstart event on each element in group\n            sortableElement.dispatchEvent(new CustomEvent('sortstop', {\n                detail: {\n                    origin: {\n                        elementIndex: originElementIndex,\n                        index: originIndex,\n                        container: originContainer\n                    },\n                    item: dragging\n                }\n            }));\n            previousContainer = null;\n            dragging = null;\n            draggingHeight = null;\n            draggingWidth = null;\n        });\n        /*\n         * Drop Event - https://developer.mozilla.org/en-US/docs/Web/Events/drop\n         * Fires when valid drop target area is hit\n         */\n        addEventListener(sortableElement, 'drop', function (e) {\n            if (!listsConnected(sortableElement, dragging.parentElement)) {\n                return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n            addData(dragging, 'dropped', 'true');\n            // get the one placeholder that is currently visible\n            var visiblePlaceholder = Array.from(stores.values()).map(function (data) {\n                return data.placeholder;\n            })\n                // filter only HTMLElements\n                .filter(function (placeholder) { return placeholder instanceof HTMLElement; })\n                // only elements in DOM\n                .filter(isInDom)[0];\n            if (visiblePlaceholder) {\n                visiblePlaceholder.replaceWith(dragging);\n                // to avoid flickering restoring element display immediately after replacing placeholder\n                if (dragging.oldDisplay !== undefined) {\n                    dragging.style.display = dragging.oldDisplay;\n                    delete dragging.oldDisplay;\n                }\n            }\n            else {\n                // set the dropped value to 'false' to delete copied dragging at the time of 'dragend'\n                addData(dragging, 'dropped', 'false');\n                return;\n            }\n            /*\n             * Fires Custom Event - 'sortstop'\n             */\n            sortableElement.dispatchEvent(new CustomEvent('sortstop', {\n                detail: {\n                    origin: {\n                        elementIndex: originElementIndex,\n                        index: originIndex,\n                        container: originContainer\n                    },\n                    item: dragging\n                }\n            }));\n            var placeholder = store(sortableElement).placeholder;\n            var originItems = filter(originContainer.children, options.items)\n                .filter(function (item) { return item !== placeholder; });\n            var destinationContainer = this.isSortable === true ? this : this.parentElement;\n            var destinationItems = filter(destinationContainer.children, addData(destinationContainer, 'items'))\n                .filter(function (item) { return item !== placeholder; });\n            var destinationElementIndex = getIndex(dragging, Array.from(dragging.parentElement.children)\n                .filter(function (item) { return item !== placeholder; }));\n            var destinationIndex = getIndex(dragging, destinationItems);\n            if (options.dropTargetContainerClass) {\n                destinationContainer.classList.remove(options.dropTargetContainerClass);\n            }\n            /*\n             * When a list item changed container lists or index within a list\n             * Fires Custom Event - 'sortupdate'\n             */\n            if (originElementIndex !== destinationElementIndex || originContainer !== destinationContainer) {\n                sortableElement.dispatchEvent(new CustomEvent('sortupdate', {\n                    detail: {\n                        origin: {\n                            elementIndex: originElementIndex,\n                            index: originIndex,\n                            container: originContainer,\n                            itemsBeforeUpdate: originItemsBeforeUpdate,\n                            items: originItems\n                        },\n                        destination: {\n                            index: destinationIndex,\n                            elementIndex: destinationElementIndex,\n                            container: destinationContainer,\n                            itemsBeforeUpdate: destinationItemsBeforeUpdate,\n                            items: destinationItems\n                        },\n                        item: dragging\n                    }\n                }));\n            }\n        });\n        var debouncedDragOverEnter = debounce(function (sortableElement, element, pageX, pageY) {\n            if (!dragging) {\n                return;\n            }\n            // set placeholder height if forcePlaceholderSize option is set\n            if (options.forcePlaceholderSize) {\n                store(sortableElement).placeholder.style.height = draggingHeight + 'px';\n                store(sortableElement).placeholder.style.width = draggingWidth + 'px';\n            }\n            // if element the draggedItem is dragged onto is within the array of all elements in list\n            // (not only items, but also disabled, etc.)\n            if (Array.from(sortableElement.children).indexOf(element) > -1) {\n                var thisHeight = getElementHeight(element);\n                var thisWidth = getElementWidth(element);\n                var placeholderIndex = getIndex(store(sortableElement).placeholder, element.parentElement.children);\n                var thisIndex = getIndex(element, element.parentElement.children);\n                // Check if `element` is bigger than the draggable. If it is, we have to define a dead zone to prevent flickering\n                if (thisHeight > draggingHeight || thisWidth > draggingWidth) {\n                    // Dead zone?\n                    var deadZoneVertical = thisHeight - draggingHeight;\n                    var deadZoneHorizontal = thisWidth - draggingWidth;\n                    var offsetTop = offset(element).top;\n                    var offsetLeft = offset(element).left;\n                    if (placeholderIndex < thisIndex &&\n                        ((options.orientation === 'vertical' && pageY < offsetTop) ||\n                            (options.orientation === 'horizontal' && pageX < offsetLeft))) {\n                        return;\n                    }\n                    if (placeholderIndex > thisIndex &&\n                        ((options.orientation === 'vertical' && pageY > offsetTop + thisHeight - deadZoneVertical) ||\n                            (options.orientation === 'horizontal' && pageX > offsetLeft + thisWidth - deadZoneHorizontal))) {\n                        return;\n                    }\n                }\n                if (dragging.oldDisplay === undefined) {\n                    dragging.oldDisplay = dragging.style.display;\n                }\n                if (dragging.style.display !== 'none') {\n                    dragging.style.display = 'none';\n                }\n                // To avoid flicker, determine where to position the placeholder\n                // based on where the mouse pointer is relative to the elements\n                // vertical center.\n                var placeAfter = false;\n                try {\n                    var elementMiddleVertical = offset(element).top + element.offsetHeight / 2;\n                    var elementMiddleHorizontal = offset(element).left + element.offsetWidth / 2;\n                    placeAfter = (options.orientation === 'vertical' && (pageY >= elementMiddleVertical)) ||\n                        (options.orientation === 'horizontal' && (pageX >= elementMiddleHorizontal));\n                }\n                catch (e) {\n                    placeAfter = placeholderIndex < thisIndex;\n                }\n                if (placeAfter) {\n                    insertAfter(element, store(sortableElement).placeholder);\n                }\n                else {\n                    insertBefore(element, store(sortableElement).placeholder);\n                }\n                // get placeholders from all stores & remove all but current one\n                Array.from(stores.values())\n                    // remove empty values\n                    .filter(function (data) { return data.placeholder !== undefined; })\n                    // foreach placeholder in array if outside of current sorableContainer -> remove from DOM\n                    .forEach(function (data) {\n                    if (data.placeholder !== store(sortableElement).placeholder) {\n                        data.placeholder.remove();\n                    }\n                });\n            }\n            else {\n                // get all placeholders from store\n                var placeholders = Array.from(stores.values())\n                    .filter(function (data) { return data.placeholder !== undefined; })\n                    .map(function (data) {\n                    return data.placeholder;\n                });\n                // check if element is not in placeholders\n                if (placeholders.indexOf(element) === -1 && sortableElement === element && !filter(element.children, options.items).length) {\n                    placeholders.forEach(function (element) { return element.remove(); });\n                    element.appendChild(store(sortableElement).placeholder);\n                }\n            }\n        }, options.debounce);\n        // Handle dragover and dragenter events on draggable items\n        var onDragOverEnter = function (e) {\n            var element = e.target;\n            var sortableElement = element.isSortable === true ? element : findSortable(element, e);\n            element = findDragElement(sortableElement, element);\n            if (!dragging || !listsConnected(sortableElement, dragging.parentElement) || addData(sortableElement, '_disabled') === 'true') {\n                return;\n            }\n            var options = addData(sortableElement, 'opts');\n            if (parseInt(options.maxItems) && filter(sortableElement.children, addData(sortableElement, 'items')).length > parseInt(options.maxItems) && dragging.parentElement !== sortableElement) {\n                return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n            e.dataTransfer.dropEffect = store(sortableElement).getConfig('copy') === true ? 'copy' : 'move';\n            debouncedDragOverEnter(sortableElement, element, e.pageX, e.pageY);\n        };\n        addEventListener(listItems.concat(sortableElement), 'dragover', onDragOverEnter);\n        addEventListener(listItems.concat(sortableElement), 'dragenter', onDragOverEnter);\n    });\n    return sortableElements;\n}\nsortable.destroy = function (sortableElement) {\n    destroySortable(sortableElement);\n};\nsortable.enable = function (sortableElement) {\n    enableSortable(sortableElement);\n};\nsortable.disable = function (sortableElement) {\n    disableSortable(sortableElement);\n};\n/* START.TESTS_ONLY */\nsortable.__testing = {\n    // add internal methods here for testing purposes\n    data: addData,\n    removeItemEvents: removeItemEvents,\n    removeItemData: removeItemData,\n    removeSortableData: removeSortableData,\n    removeContainerEvents: removeContainerEvents\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sortable);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDVzb3J0YWJsZS9kaXN0L2h0bWw1c29ydGFibGUuZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsdURBQXVEO0FBQzdHLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx1Q0FBdUM7QUFDdkMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxRQUFRLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbDVzb3J0YWJsZS9kaXN0L2h0bWw1c29ydGFibGUuZXMuanM/MzQ3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSFRNTDVTb3J0YWJsZSBwYWNrYWdlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbHVrYXNvcHBlcm1hbm4vaHRtbDVzb3J0YWJsZVxuICpcbiAqIE1haW50YWluZWQgYnkgTHVrYXMgT3BwZXJtYW5uIDxsdWthc0B2ZWEucmU+XG4gKlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4vKipcbiAqIEdldCBvciBzZXQgZGF0YSBvbiBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm4geyp9XG4gKi9cbmZ1bmN0aW9uIGFkZERhdGEoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQuaDVzICYmIGVsZW1lbnQuaDVzLmRhdGEgJiYgZWxlbWVudC5oNXMuZGF0YVtrZXldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5oNXMgPSBlbGVtZW50Lmg1cyB8fCB7fTtcbiAgICAgICAgZWxlbWVudC5oNXMuZGF0YSA9IGVsZW1lbnQuaDVzLmRhdGEgfHwge307XG4gICAgICAgIGVsZW1lbnQuaDVzLmRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlIGRhdGEgZnJvbSBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURhdGEoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Lmg1cykge1xuICAgICAgICBkZWxldGUgZWxlbWVudC5oNXMuZGF0YTtcbiAgICB9XG59XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyoqXG4gKiBGaWx0ZXIgb25seSB3YW50ZWQgbm9kZXNcbiAqIEBwYXJhbSB7Tm9kZUxpc3R8SFRNTENvbGxlY3Rpb258QXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xudmFyIGZpbHRlciA9IChmdW5jdGlvbiAobm9kZXMsIHNlbGVjdG9yKSB7XG4gICAgaWYgKCEobm9kZXMgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBub2RlcyBpbnN0YW5jZW9mIEhUTUxDb2xsZWN0aW9uIHx8IG5vZGVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhIG5vZGVMaXN0L0hUTUxDb2xsZWN0aW9uL0FycmF5IG9mIGVsZW1lbnRzIHRvIGJlIGZpbHRlcmVkLicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShub2Rlcyk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKG5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubm9kZVR5cGUgPT09IDEgJiYgaXRlbS5tYXRjaGVzKHNlbGVjdG9yKTsgfSk7XG59KTtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xudmFyIHN0b3JlcyA9IG5ldyBNYXAoKTtcbi8qIGVzbGludC1lbmFibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbi8qKlxuICogU3RvcmVzIGRhdGEgJiBjb25maWd1cmF0aW9ucyBwZXIgU29ydGFibGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqL1xudmFyIFN0b3JlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0b3JlKCkge1xuICAgICAgICB0aGlzLl9jb25maWcgPSBuZXcgTWFwKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSB1bmRlZmluZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGhlIGNvbmZpZ3VyYXRpb24gbWFwIG9mIGEgY2xhc3MgaW5zdGFuY2VcbiAgICAgICAgICogQG1ldGhvZCBjb25maWdcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gTWFwIHRvIG9iamVjdFxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBjb25maWdba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZXR1cm4gb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRoZSBjb25maWd1cmF0aW9uIG9mIGEgY2xhc3MgaW5zdGFuY2VcbiAgICAgICAgICogQG1ldGhvZCBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBvYmplY3Qgb2YgY29uZmlndXJhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGEgdmFsaWQgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gdGhlIGNvbmZpZyBzZXR0ZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb21iaW5lIGNvbmZpZyB3aXRoIGRlZmF1bHRcbiAgICAgICAgICAgIHZhciBtZXJnZWRDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgLy8gYWRkIGNvbmZpZyB0byBtYXBcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMobWVyZ2VkQ29uZmlnKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBzZXQgaW5kaXZpZHVhbCBjb25maWd1cmF0aW9uIG9mIGEgY2xhc3MgaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHNldENvbmZpZ1xuICAgICAqIEBwYXJhbSAga2V5IHZhbGlkIGNvbmZpZ3VyYXRpb24ga2V5XG4gICAgICogQHBhcmFtICB2YWx1ZSBhbnkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBTdG9yZS5wcm90b3R5cGUuc2V0Q29uZmlnID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byBzZXQgaW52YWxpZCBjb25maWd1cmF0aW9uIGl0ZW06IFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY29uZmlnXG4gICAgICAgIHRoaXMuX2NvbmZpZy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXQgYW4gaW5kaXZpZHVhbCBjb25maWd1cmF0aW9uIG9mIGEgY2xhc3MgaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIGdldENvbmZpZ1xuICAgICAqIEBwYXJhbSAga2V5IHZhbGlkIGNvbmZpZ3VyYXRpb24ga2V5XG4gICAgICogQHJldHVybiBhbnkgY29uZmlndXJhdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIFN0b3JlLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24gaXRlbSByZXF1ZXN0ZWQ6IFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmdldChrZXkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0b3JlLnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGhlIHBsYWNlaG9sZGVyIGZvciBhIGNsYXNzIGluc3RhbmNlXG4gICAgICAgICAqIEBtZXRob2QgcGxhY2Vob2xkZXJcbiAgICAgICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYWNlaG9sZGVyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRoZSBwbGFjZWhvbGRlciBmb3IgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgICAgKiBAbWV0aG9kIHBsYWNlaG9sZGVyXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBsYWNlaG9sZGVyXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKCEocGxhY2Vob2xkZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgJiYgcGxhY2Vob2xkZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcGxhY2Vob2xkZXIgbXVzdCBiZSBhbiBodG1sIGVsZW1lbnQgb3IgbnVsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBzZXQgYW4gZGF0YSBlbnRyeVxuICAgICAqIEBtZXRob2Qgc2V0RGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN0b3JlLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBrZXkgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldCBhbiBkYXRhIGVudHJ5XG4gICAgICogQG1ldGhvZCBnZXREYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBhbiBleGlzdGluZyBrZXlcbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgU3RvcmUucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUga2V5IG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0KGtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBkZWxldGUgYW4gZGF0YSBlbnRyeVxuICAgICAqIEBtZXRob2QgZGVsZXRlRGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgYW4gZXhpc3Rpbmcga2V5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBTdG9yZS5wcm90b3R5cGUuZGVsZXRlRGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBrZXkgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kZWxldGUoa2V5KTtcbiAgICB9O1xuICAgIHJldHVybiBTdG9yZTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNvcnRhYmxlRWxlbWVudFxuICogQHJldHVybnMge0NsYXNzOiBTdG9yZX1cbiAqL1xudmFyIHN0b3JlID0gKGZ1bmN0aW9uIChzb3J0YWJsZUVsZW1lbnQpIHtcbiAgICAvLyBpZiBzb3J0YWJsZUVsZW1lbnQgaXMgd3JvbmcgdHlwZVxuICAgIGlmICghKHNvcnRhYmxlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgc29ydGFibGUgdG8gdGhlIHN0b3JlIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgbmV3IGluc3RhbmNlIGlmIG5vdCBhdmlsYWJsZVxuICAgIGlmICghc3RvcmVzLmhhcyhzb3J0YWJsZUVsZW1lbnQpKSB7XG4gICAgICAgIHN0b3Jlcy5zZXQoc29ydGFibGVFbGVtZW50LCBuZXcgU3RvcmUoKSk7XG4gICAgfVxuICAgIC8vIHJldHVybiBpbnN0YW5jZVxuICAgIHJldHVybiBzdG9yZXMuZ2V0KHNvcnRhYmxlRWxlbWVudCk7XG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fEhUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsZW1lbnRbaV0sIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIHN0b3JlKGVsZW1lbnQpLnNldERhdGEoXCJldmVudFwiICsgZXZlbnROYW1lLCBjYWxsYmFjayk7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8SFRNTEVsZW1lbnQ+fEhUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWxlbWVudFtpXSwgZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHN0b3JlKGVsZW1lbnQpLmdldERhdGEoXCJldmVudFwiICsgZXZlbnROYW1lKSk7XG4gICAgc3RvcmUoZWxlbWVudCkuZGVsZXRlRGF0YShcImV2ZW50XCIgKyBldmVudE5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8SFRNTEVsZW1lbnQ+fEhUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gYWRkQXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYWRkQXR0cmlidXRlKGVsZW1lbnRbaV0sIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl8SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudFtpXSwgYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xudmFyIG9mZnNldCA9IChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgZWxlbWVudCBtdXN0IGJlIHBhcnQgb2YgdGhlIGRvbScpO1xuICAgIH1cbiAgICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfTtcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgZGVib3VuY2VkIHZlcnNpb24gb2YgdGhlIHBhc3NlZCBmdW5jdGlvbiB3aGljaCB3aWxsIHBvc3Rwb25lIGl0cyBleGVjdXRpb24gdW50aWwgYWZ0ZXIgd2FpdCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIHRvIGRlYm91bmNlXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIGZ1bmN0aW9uIHdpdGggbGF0ZXN0IGFyZ3VtZW50cywgMCAtIG5vIGRlYm91bmNlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cbnZhciBkZWJvdW5jZSA9IChmdW5jdGlvbiAoZnVuYywgd2FpdCkge1xuICAgIGlmICh3YWl0ID09PSB2b2lkIDApIHsgd2FpdCA9IDA7IH1cbiAgICB2YXIgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuYy5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICB9LCB3YWl0KTtcbiAgICB9O1xufSk7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyoqXG4gKiBHZXQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgcmVsYXRpdmVseSB0byBpdHMgc2libGluZyBlbGVtZW50c1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xudmFyIGdldEluZGV4ID0gKGZ1bmN0aW9uIChlbGVtZW50LCBlbGVtZW50TGlzdCkge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgfHwgIShlbGVtZW50TGlzdCBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGVsZW1lbnRMaXN0IGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24gfHwgZWxlbWVudExpc3QgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIGVsZW1lbnQgYW5kIGEgbGlzdCBvZiBlbGVtZW50cy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudExpc3QpLmluZGV4T2YoZWxlbWVudCk7XG59KTtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG4vKipcbiAqIFRlc3Qgd2hldGhlciBlbGVtZW50IGlzIGluIERPTVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBpc0luRG9tID0gKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgaXMgbm90IGEgbm9kZSBlbGVtZW50LicpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlICE9PSBudWxsO1xufSk7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyoqXG4gKiBJbnNlcnQgbm9kZSBiZWZvcmUgb3IgYWZ0ZXIgdGFyZ2V0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VOb2RlIC0gcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5ld0VsZW1lbnQgLSBlbGVtZW50IHRvIGJlIGluc2VydGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBpbnNlcnQgYmVmb3JlIG9yIGFmdGVyIHJlZmVyZW5jZSBlbGVtZW50XG4gKi9cbnZhciBpbnNlcnROb2RlID0gZnVuY3Rpb24gKHJlZmVyZW5jZU5vZGUsIG5ld0VsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKCEocmVmZXJlbmNlTm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB8fCAhKHJlZmVyZW5jZU5vZGUucGFyZW50RWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhbmQgZWxlbWVudCBtdXN0IGJlIGEgbm9kZScpO1xuICAgIH1cbiAgICByZWZlcmVuY2VOb2RlLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIChwb3NpdGlvbiA9PT0gJ2JlZm9yZScgPyByZWZlcmVuY2VOb2RlIDogcmVmZXJlbmNlTm9kZS5uZXh0RWxlbWVudFNpYmxpbmcpKTtcbn07XG4vKipcbiAqIEluc2VydCBiZWZvcmUgdGFyZ2V0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xudmFyIGluc2VydEJlZm9yZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGVsZW1lbnQpIHsgcmV0dXJuIGluc2VydE5vZGUodGFyZ2V0LCBlbGVtZW50LCAnYmVmb3JlJyk7IH07XG4vKipcbiAqIEluc2VydCBhZnRlciB0YXJnZXRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICovXG52YXIgaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBlbGVtZW50KSB7IHJldHVybiBpbnNlcnROb2RlKHRhcmdldCwgZWxlbWVudCwgJ2FmdGVyJyk7IH07XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyoqXG4gKiBGaWx0ZXIgb25seSB3YW50ZWQgbm9kZXNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNvcnRhYmxlQ29udGFpbmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21TZXJpYWxpemVyXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbnZhciBzZXJpYWxpemUgPSAoZnVuY3Rpb24gKHNvcnRhYmxlQ29udGFpbmVyLCBjdXN0b21JdGVtU2VyaWFsaXplciwgY3VzdG9tQ29udGFpbmVyU2VyaWFsaXplcikge1xuICAgIGlmIChjdXN0b21JdGVtU2VyaWFsaXplciA9PT0gdm9pZCAwKSB7IGN1c3RvbUl0ZW1TZXJpYWxpemVyID0gZnVuY3Rpb24gKHNlcmlhbGl6ZWRJdGVtLCBzb3J0YWJsZUNvbnRhaW5lcikgeyByZXR1cm4gc2VyaWFsaXplZEl0ZW07IH07IH1cbiAgICBpZiAoY3VzdG9tQ29udGFpbmVyU2VyaWFsaXplciA9PT0gdm9pZCAwKSB7IGN1c3RvbUNvbnRhaW5lclNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoc2VyaWFsaXplZENvbnRhaW5lcikgeyByZXR1cm4gc2VyaWFsaXplZENvbnRhaW5lcjsgfTsgfVxuICAgIC8vIGNoZWNrIGZvciB2YWxpZCBzb3J0YWJsZUNvbnRhaW5lclxuICAgIGlmICghKHNvcnRhYmxlQ29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8ICFzb3J0YWJsZUNvbnRhaW5lci5pc1NvcnRhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcHJvdmlkZSBhIHNvcnRhYmxlQ29udGFpbmVyIHRvIGJlIHNlcmlhbGl6ZWQuJyk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciB2YWxpZCBzZXJpYWxpemVyc1xuICAgIGlmICh0eXBlb2YgY3VzdG9tSXRlbVNlcmlhbGl6ZXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGN1c3RvbUNvbnRhaW5lclNlcmlhbGl6ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwcm92aWRlIGEgdmFsaWQgc2VyaWFsaXplciBmb3IgaXRlbXMgYW5kIHRoZSBjb250YWluZXIuJyk7XG4gICAgfVxuICAgIC8vIGdldCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBhZGREYXRhKHNvcnRhYmxlQ29udGFpbmVyLCAnb3B0cycpO1xuICAgIHZhciBpdGVtID0gb3B0aW9ucy5pdGVtcztcbiAgICAvLyBzZXJpYWxpemUgY29udGFpbmVyXG4gICAgdmFyIGl0ZW1zID0gZmlsdGVyKHNvcnRhYmxlQ29udGFpbmVyLmNoaWxkcmVuLCBpdGVtKTtcbiAgICB2YXIgc2VyaWFsaXplZEl0ZW1zID0gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJlbnQ6IHNvcnRhYmxlQ29udGFpbmVyLFxuICAgICAgICAgICAgbm9kZTogaXRlbSxcbiAgICAgICAgICAgIGh0bWw6IGl0ZW0ub3V0ZXJIVE1MLFxuICAgICAgICAgICAgaW5kZXg6IGdldEluZGV4KGl0ZW0sIGl0ZW1zKVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIHNlcmlhbGl6ZSBjb250YWluZXJcbiAgICB2YXIgY29udGFpbmVyID0ge1xuICAgICAgICBub2RlOiBzb3J0YWJsZUNvbnRhaW5lcixcbiAgICAgICAgaXRlbUNvdW50OiBzZXJpYWxpemVkSXRlbXMubGVuZ3RoXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluZXI6IGN1c3RvbUNvbnRhaW5lclNlcmlhbGl6ZXIoY29udGFpbmVyKSxcbiAgICAgICAgaXRlbXM6IHNlcmlhbGl6ZWRJdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGN1c3RvbUl0ZW1TZXJpYWxpemVyKGl0ZW0sIHNvcnRhYmxlQ29udGFpbmVyKTsgfSlcbiAgICB9O1xufSk7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyoqXG4gKiBjcmVhdGUgYSBwbGFjZWhvbGRlciBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzb3J0YWJsZUVsZW1lbnQgYSBzaW5nbGUgc29ydGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcGxhY2Vob2xkZXIgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGh0bWwgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHBsYWNlaG9sZGVyQ2xhc3NlcyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNsYXNzZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHBsYWNlaG9sZGVyXG4gKi9cbnZhciBtYWtlUGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKHNvcnRhYmxlRWxlbWVudCwgcGxhY2Vob2xkZXIsIHBsYWNlaG9sZGVyQ2xhc3MpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHBsYWNlaG9sZGVyQ2xhc3MgPT09IHZvaWQgMCkgeyBwbGFjZWhvbGRlckNsYXNzID0gJ3NvcnRhYmxlLXBsYWNlaG9sZGVyJzsgfVxuICAgIGlmICghKHNvcnRhYmxlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBlbGVtZW50IGFzIGEgc29ydGFibGUuJyk7XG4gICAgfVxuICAgIC8vIGlmIHBsYWNlaG9sZGVyIGlzIG5vdCBhbiBlbGVtZW50XG4gICAgaWYgKCEocGxhY2Vob2xkZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgJiYgcGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBlbGVtZW50IGFzIGEgcGxhY2Vob2xkZXIgb3Igc2V0IG90IHRvIHVuZGVmaW5lZC4nKTtcbiAgICB9XG4gICAgLy8gaWYgbm8gcGxhY2Vob2xkZXIgZWxlbWVudCBpcyBnaXZlblxuICAgIGlmIChwbGFjZWhvbGRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChbJ1VMJywgJ09MJ10uaW5jbHVkZXMoc29ydGFibGVFbGVtZW50LnRhZ05hbWUpKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoWydUQUJMRScsICdUQk9EWSddLmluY2x1ZGVzKHNvcnRhYmxlRWxlbWVudC50YWdOYW1lKSkge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgLy8gc2V0IGNvbHNwYW4gdG8gYWx3YXlzIGFsbCByb3dzLCBvdGhlcndpc2UgdGhlIGl0ZW0gY2FuIG9ubHkgYmUgZHJvcHBlZCBpbiBmaXJzdCBjb2x1bW5cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmlubmVySFRNTCA9ICc8dGQgY29sc3Bhbj1cIjEwMFwiPjwvdGQ+JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIGNsYXNzZXMgdG8gcGxhY2Vob2xkZXJcbiAgICBpZiAodHlwZW9mIHBsYWNlaG9sZGVyQ2xhc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIChfYSA9IHBsYWNlaG9sZGVyLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9hLCBwbGFjZWhvbGRlckNsYXNzLnNwbGl0KCcgJykpO1xuICAgIH1cbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG59KTtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG4vKipcbiAqIEdldCBoZWlnaHQgb2YgYW4gZWxlbWVudCBpbmNsdWRpbmcgcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBhbiBkb20gZWxlbWVudFxuICovXG52YXIgZ2V0RWxlbWVudEhlaWdodCA9IChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGEgdmFsaWQgZG9tIGVsZW1lbnQnKTtcbiAgICB9XG4gICAgLy8gZ2V0IGNhbGN1bGF0ZWQgc3R5bGUgb2YgZWxlbWVudFxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIC8vIGdldCBvbmx5IGhlaWdodCBpZiBlbGVtZW50IGhhcyBib3gtc2l6aW5nOiBib3JkZXItYm94IHNwZWNpZmllZFxuICAgIGlmIChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdib3gtc2l6aW5nJykgPT09ICdib3JkZXItYm94Jykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JyksIDEwKTtcbiAgICB9XG4gICAgLy8gcGljayBhcHBsaWNhYmxlIHByb3BlcnRpZXMsIGNvbnZlcnQgdG8gaW50IGFuZCByZWR1Y2UgYnkgYWRkaW5nXG4gICAgcmV0dXJuIFsnaGVpZ2h0JywgJ3BhZGRpbmctdG9wJywgJ3BhZGRpbmctYm90dG9tJ11cbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbnQgPSBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGtleSksIDEwKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGludCkgPyAwIDogaW50O1xuICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgdmFsdWUpIHsgcmV0dXJuIHN1bSArIHZhbHVlOyB9KTtcbn0pO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qKlxuICogR2V0IHdpZHRoIG9mIGFuIGVsZW1lbnQgaW5jbHVkaW5nIHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgYW4gZG9tIGVsZW1lbnRcbiAqL1xudmFyIGdldEVsZW1lbnRXaWR0aCA9IChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGEgdmFsaWQgZG9tIGVsZW1lbnQnKTtcbiAgICB9XG4gICAgLy8gZ2V0IGNhbGN1bGF0ZWQgc3R5bGUgb2YgZWxlbWVudFxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIC8vIHBpY2sgYXBwbGljYWJsZSBwcm9wZXJ0aWVzLCBjb252ZXJ0IHRvIGludCBhbmQgcmVkdWNlIGJ5IGFkZGluZ1xuICAgIHJldHVybiBbJ3dpZHRoJywgJ3BhZGRpbmctbGVmdCcsICdwYWRkaW5nLXJpZ2h0J11cbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbnQgPSBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGtleSksIDEwKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGludCkgPyAwIDogaW50O1xuICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgdmFsdWUpIHsgcmV0dXJuIHN1bSArIHZhbHVlOyB9KTtcbn0pO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qKlxuICogZ2V0IGhhbmRsZSBvciByZXR1cm4gaXRlbVxuICogQHBhcmFtIHtBcnJheTxIVE1MRWxlbWVudD59IGl0ZW1zXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqL1xudmFyIGdldEhhbmRsZXMgPSAoZnVuY3Rpb24gKGl0ZW1zLCBzZWxlY3Rvcikge1xuICAgIGlmICghKGl0ZW1zIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhIEFycmF5IG9mIEhUTUxFbGVtZW50cyB0byBiZSBmaWx0ZXJlZC4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXNcbiAgICAgICAgLy8gcmVtb3ZlIGl0ZW1zIHdpdGhvdXQgaGFuZGxlIGZyb20gYXJyYXlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoaXRlbS5zaGFkb3dSb290ICYmIGl0ZW0uc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTtcbiAgICB9KVxuICAgICAgICAvLyByZXBsYWNlIGl0ZW0gd2l0aCBoYW5kbGUgaW4gYXJyYXlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSB8fCAoaXRlbS5zaGFkb3dSb290ICYmIGl0ZW0uc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSk7XG4gICAgfSk7XG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICovXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIChldmVudC5jb21wb3NlZFBhdGggJiYgZXZlbnQuY29tcG9zZWRQYXRoKClbMF0pIHx8IGV2ZW50LnRhcmdldDtcbn0pO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qKlxuICogZGVmYXVsdERyYWdJbWFnZSByZXR1cm5zIHRoZSBjdXJyZW50IGl0ZW0gYXMgZHJhZ2dlZCBpbWFnZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZHJhZ2dlZEVsZW1lbnQgLSB0aGUgaXRlbSB0aGF0IHRoZSB1c2VyIGRyYWdzXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudE9mZnNldCAtIGFuIG9iamVjdCB3aXRoIHRoZSBvZmZzZXRzIHRvcCwgbGVmdCwgcmlnaHQgJiBib3R0b21cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIG9yaWdpbmFsIGRyYWcgZXZlbnQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IHdpdGggZWxlbWVudCwgcG9zWCBhbmQgcG9zWSBwcm9wZXJ0aWVzXG4gKi9cbnZhciBkZWZhdWx0RHJhZ0ltYWdlID0gZnVuY3Rpb24gKGRyYWdnZWRFbGVtZW50LCBlbGVtZW50T2Zmc2V0LCBldmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnQ6IGRyYWdnZWRFbGVtZW50LFxuICAgICAgICBwb3NYOiBldmVudC5wYWdlWCAtIGVsZW1lbnRPZmZzZXQubGVmdCxcbiAgICAgICAgcG9zWTogZXZlbnQucGFnZVkgLSBlbGVtZW50T2Zmc2V0LnRvcFxuICAgIH07XG59O1xuLyoqXG4gKiBhdHRhY2hlcyBhbiBlbGVtZW50IGFzIHRoZSBkcmFnIGltYWdlIHRvIGFuIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIHRoZSBvcmlnaW5hbCBkcmFnIGV2ZW50IG9iamVjdFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZHJhZ2dlZEVsZW1lbnQgLSB0aGUgaXRlbSB0aGF0IHRoZSB1c2VyIGRyYWdzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21EcmFnSW1hZ2UgLSBmdW5jdGlvbiB0byBjcmVhdGUgYSBjdXN0b20gZHJhZ0ltYWdlXG4gKiBAcmV0dXJuIHZvaWRcbiAqL1xudmFyIHNldERyYWdJbWFnZSA9IChmdW5jdGlvbiAoZXZlbnQsIGRyYWdnZWRFbGVtZW50LCBjdXN0b21EcmFnSW1hZ2UpIHtcbiAgICAvLyBjaGVjayBpZiBldmVudCBpcyBwcm92aWRlZFxuICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgRXZlbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0RHJhZ0ltYWdlIHJlcXVpcmVzIGEgRHJhZ0V2ZW50IGFzIHRoZSBmaXJzdCBhcmd1bWVudC4nKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgZHJhZ2dlZEVsZW1lbnQgaXMgcHJvdmlkZWRcbiAgICBpZiAoIShkcmFnZ2VkRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldERyYWdJbWFnZSByZXF1aXJlcyB0aGUgZHJhZ2dlZCBlbGVtZW50IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIC8vIHNldCBkZWZhdWx0IGZ1bmN0aW9uIG9mIG5vbmUgcHJvdmlkZWRcbiAgICBpZiAoIWN1c3RvbURyYWdJbWFnZSkge1xuICAgICAgICBjdXN0b21EcmFnSW1hZ2UgPSBkZWZhdWx0RHJhZ0ltYWdlO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBzZXREcmFnSW1hZ2UgbWV0aG9kIGlzIGF2YWlsYWJsZVxuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIgJiYgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSkge1xuICAgICAgICAvLyBnZXQgdGhlIGVsZW1lbnRzIG9mZnNldFxuICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IG9mZnNldChkcmFnZ2VkRWxlbWVudCk7XG4gICAgICAgIC8vIGdldCB0aGUgZHJhZ0ltYWdlXG4gICAgICAgIHZhciBkcmFnSW1hZ2UgPSBjdXN0b21EcmFnSW1hZ2UoZHJhZ2dlZEVsZW1lbnQsIGVsZW1lbnRPZmZzZXQsIGV2ZW50KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgY3VzdG9tIGZ1bmN0aW9uIHJldHVybnMgY29ycmVjdCB2YWx1ZXNcbiAgICAgICAgaWYgKCEoZHJhZ0ltYWdlLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgfHwgdHlwZW9mIGRyYWdJbWFnZS5wb3NYICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZHJhZ0ltYWdlLnBvc1kgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXN0b21EcmFnSW1hZ2UgZnVuY3Rpb24geW91IHByb3ZpZGVkIG11c3QgcmV0dXJuIGFuZCBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBlbGVtZW50W3N0cmluZ10sIHBvc1hbaW50ZWdlcl0sIHBvc1lbaW50ZWdlcl0uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgc2V0IGZvciBIVE1MNSBkcmFnICYgZHJvcCB0byB3b3JrXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ2NvcHlNb3ZlJztcbiAgICAgICAgLy8gRmlyZWZveCByZXF1aXJlcyBpdCB0byB1c2UgdGhlIGV2ZW50IHRhcmdldCdzIGlkIGZvciB0aGUgZGF0YVxuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dC9wbGFpbicsIGdldEV2ZW50VGFyZ2V0KGV2ZW50KS5pZCk7XG4gICAgICAgIC8vIHNldCB0aGUgZHJhZyBpbWFnZSBvbiB0aGUgZXZlbnRcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnSW1hZ2UuZWxlbWVudCwgZHJhZ0ltYWdlLnBvc1gsIGRyYWdJbWFnZS5wb3NZKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiBjdXJMaXN0IGFjY2VwdHMgaXRlbXMgZnJvbSBkZXN0TGlzdFxuICogQHBhcmFtIHtzb3J0YWJsZX0gZGVzdGluYXRpb24gdGhlIGNvbnRhaW5lciBhbiBpdGVtIGlzIG1vdmUgdG9cbiAqIEBwYXJhbSB7c29ydGFibGV9IG9yaWdpbiB0aGUgY29udGFpbmVyIGFuIGl0ZW0gY29tZXMgZnJvbVxuICovXG52YXIgbGlzdHNDb25uZWN0ZWQgPSAoZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBvcmlnaW4pIHtcbiAgICAvLyBjaGVjayBpZiB2YWxpZCBzb3J0YWJsZVxuICAgIGlmIChkZXN0aW5hdGlvbi5pc1NvcnRhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBhY2NlcHRGcm9tID0gc3RvcmUoZGVzdGluYXRpb24pLmdldENvbmZpZygnYWNjZXB0RnJvbScpO1xuICAgICAgICAvLyBjaGVjayBpZiBhY2NlcHRGcm9tIGlzIHZhbGlkXG4gICAgICAgIGlmIChhY2NlcHRGcm9tICE9PSBudWxsICYmIGFjY2VwdEZyb20gIT09IGZhbHNlICYmIHR5cGVvZiBhY2NlcHRGcm9tICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVE1MNVNvcnRhYmxlOiBXcm9uZyBhcmd1bWVudCwgXCJhY2NlcHRGcm9tXCIgbXVzdCBiZSBcIm51bGxcIiwgXCJmYWxzZVwiLCBvciBhIHZhbGlkIHNlbGVjdG9yIHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWNjZXB0RnJvbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VwdEZyb20gIT09IGZhbHNlICYmIGFjY2VwdEZyb20uc3BsaXQoJywnKS5maWx0ZXIoZnVuY3Rpb24gKHNlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWwubGVuZ3RoID4gMCAmJiBvcmlnaW4ubWF0Y2hlcyhzZWwpO1xuICAgICAgICAgICAgfSkubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcm9wIGluIHNhbWUgbGlzdFxuICAgICAgICBpZiAoZGVzdGluYXRpb24gPT09IG9yaWdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgbGlzdHMgYXJlIGNvbm5lY3RlZCB3aXRoIGNvbm5lY3RXaXRoXG4gICAgICAgIGlmIChzdG9yZShkZXN0aW5hdGlvbikuZ2V0Q29uZmlnKCdjb25uZWN0V2l0aCcpICE9PSB1bmRlZmluZWQgJiYgc3RvcmUoZGVzdGluYXRpb24pLmdldENvbmZpZygnY29ubmVjdFdpdGgnKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlKGRlc3RpbmF0aW9uKS5nZXRDb25maWcoJ2Nvbm5lY3RXaXRoJykgPT09IHN0b3JlKG9yaWdpbikuZ2V0Q29uZmlnKCdjb25uZWN0V2l0aCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn0pO1xuXG4vKipcbiAqIGRlZmF1bHQgY29uZmlndXJhdGlvbnNcbiAqL1xudmFyIGRlZmF1bHRDb25maWd1cmF0aW9uID0ge1xuICAgIGl0ZW1zOiBudWxsLFxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBjb25uZWN0V2l0aDogbnVsbCxcbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZGlzYWJsZUlFRml4OiBudWxsLFxuICAgIGFjY2VwdEZyb206IG51bGwsXG4gICAgY29weTogZmFsc2UsXG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgcGxhY2Vob2xkZXJDbGFzczogJ3NvcnRhYmxlLXBsYWNlaG9sZGVyJyxcbiAgICBkcmFnZ2luZ0NsYXNzOiAnc29ydGFibGUtZHJhZ2dpbmcnLFxuICAgIGhvdmVyQ2xhc3M6IGZhbHNlLFxuICAgIGRyb3BUYXJnZXRDb250YWluZXJDbGFzczogZmFsc2UsXG4gICAgZGVib3VuY2U6IDAsXG4gICAgdGhyb3R0bGVUaW1lOiAxMDAsXG4gICAgbWF4SXRlbXM6IDAsXG4gICAgaXRlbVNlcmlhbGl6ZXI6IHVuZGVmaW5lZCxcbiAgICBjb250YWluZXJTZXJpYWxpemVyOiB1bmRlZmluZWQsXG4gICAgY3VzdG9tRHJhZ0ltYWdlOiBudWxsLFxuICAgIG9yaWVudGF0aW9uOiAndmVydGljYWwnXG59O1xuXG4vKipcbiAqIG1ha2Ugc3VyZSBhIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIG9uY2Ugd2l0aGluIHRoZSBnaXZlbiBhbW91bnQgb2YgdGltZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlXG4gKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIHRpbWUgbGltaXQgZm9yIHRocm90dGxpbmdcbiAqL1xuLy8gbXVzdCB1c2UgZnVuY3Rpb24gdG8ga2VlcCB0aGlzIGNvbnRleHRcbmZ1bmN0aW9uIHRocm90dGxlIChmbiwgdGhyZXNob2xkKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHsgdGhyZXNob2xkID0gMjUwOyB9XG4gICAgLy8gY2hlY2sgZnVuY3Rpb25cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBmb3IgdGhyb3R0bGUuJyk7XG4gICAgfVxuICAgIC8vIGNoZWNrIHRocmVzaG9sZFxuICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSBudW1iZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBmb3IgdGhyb3R0bGUuJyk7XG4gICAgfVxuICAgIHZhciBsYXN0RXZlbnRUaW1lc3RhbXAgPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChsYXN0RXZlbnRUaW1lc3RhbXAgPT09IG51bGwgfHwgbm93IC0gbGFzdEV2ZW50VGltZXN0YW1wID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgbGFzdEV2ZW50VGltZXN0YW1wID0gbm93O1xuICAgICAgICAgICAgZm4uYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG4vKipcbiAqIGVuYWJsZSBvciBkaXNhYmxlIGhvdmVyQ2xhc3Mgb24gbW91c2VlbnRlci9sZWF2ZSBpZiBjb250YWluZXIgSXRlbXNcbiAqIEBwYXJhbSB7c29ydGFibGV9IHNvcnRhYmxlQ29udGFpbmVyIGEgdmFsaWQgc29ydGFibGVDb250YWluZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlIGVuYWJsZSBvciBkaXNhYmxlIGV2ZW50XG4gKi9cbnZhciBlbmFibGVIb3ZlckNsYXNzID0gKGZ1bmN0aW9uIChzb3J0YWJsZUNvbnRhaW5lciwgZW5hYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBzdG9yZShzb3J0YWJsZUNvbnRhaW5lcikuZ2V0Q29uZmlnKCdob3ZlckNsYXNzJykgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBob3ZlckNsYXNzZXNfMSA9IHN0b3JlKHNvcnRhYmxlQ29udGFpbmVyKS5nZXRDb25maWcoJ2hvdmVyQ2xhc3MnKS5zcGxpdCgnICcpO1xuICAgICAgICAvLyBhZGQgY2xhc3Mgb24gaG92ZXJcbiAgICAgICAgaWYgKGVuYWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihzb3J0YWJsZUNvbnRhaW5lciwgJ21vdXNlbW92ZScsIHRocm90dGxlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIG9mIG5vIG1vdXNlIGJ1dHRvbiB3YXMgcHJlc3NlZCB3aGVuIG1vdXNlbW92ZSBzdGFydGVkID09IG5vIGRyYWdcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIoc29ydGFibGVDb250YWluZXIuY2hpbGRyZW4sIHN0b3JlKHNvcnRhYmxlQ29udGFpbmVyKS5nZXRDb25maWcoJ2l0ZW1zJykpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gZXZlbnQudGFyZ2V0IHx8IGl0ZW0uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGl0ZW0uY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIGhvdmVyQ2xhc3Nlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGl0ZW0uY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2IsIGhvdmVyQ2xhc3Nlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc3RvcmUoc29ydGFibGVDb250YWluZXIpLmdldENvbmZpZygndGhyb3R0bGVUaW1lJykpKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjbGFzcyBvbiBsZWF2ZVxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihzb3J0YWJsZUNvbnRhaW5lciwgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyKHNvcnRhYmxlQ29udGFpbmVyLmNoaWxkcmVuLCBzdG9yZShzb3J0YWJsZUNvbnRhaW5lcikuZ2V0Q29uZmlnKCdpdGVtcycpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gaXRlbS5jbGFzc0xpc3QpLnJlbW92ZS5hcHBseShfYSwgaG92ZXJDbGFzc2VzXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXZlbnRzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHNvcnRhYmxlQ29udGFpbmVyLCAnbW91c2Vtb3ZlJyk7XG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHNvcnRhYmxlQ29udGFpbmVyLCAnbW91c2VsZWF2ZScpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLypcbiAqIHZhcmlhYmxlcyBnbG9iYWwgdG8gdGhlIHBsdWdpblxuICovXG52YXIgZHJhZ2dpbmc7XG52YXIgZHJhZ2dpbmdIZWlnaHQ7XG52YXIgZHJhZ2dpbmdXaWR0aDtcbi8qXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgaW5pdGlhbHkgc2VsZWN0ZWQgbGlzdCwgd2hlcmUgJ2RyYWdzdGFydCcgZXZlbnQgd2FzIHRyaWdnZXJlZFxuICogSXQgYWxsb3dzIHVzIHRvIG1vdmUgdGhlIGRhdGEgaW4gYmV0d2VlbiBpbmRpdmlkdWFsIFNvcnRhYmxlIExpc3QgaW5zdGFuY2VzXG4gKi9cbi8vIE9yaWdpbiBMaXN0IC0gZGF0YSBmcm9tIGJlZm9yZSBhbnkgaXRlbSB3YXMgY2hhbmdlZFxudmFyIG9yaWdpbkNvbnRhaW5lcjtcbnZhciBvcmlnaW5JbmRleDtcbnZhciBvcmlnaW5FbGVtZW50SW5kZXg7XG52YXIgb3JpZ2luSXRlbXNCZWZvcmVVcGRhdGU7XG4vLyBQcmV2aW91cyBTb3J0YWJsZSBDb250YWluZXIgLSB3ZSBkaXNwYXRjaCBhcyBzb3J0ZW50ZXIgZXZlbnQgd2hlbiBhXG4vLyBkcmFnZ2VkIGl0ZW0gZW50ZXJzIGEgc29ydGFibGVDb250YWluZXIgZm9yIHRoZSBmaXJzdCB0aW1lXG52YXIgcHJldmlvdXNDb250YWluZXI7XG4vLyBEZXN0aW5hdGlvbiBMaXN0IC0gZGF0YSBmcm9tIGJlZm9yZSBhbnkgaXRlbSB3YXMgY2hhbmdlZFxudmFyIGRlc3RpbmF0aW9uSXRlbXNCZWZvcmVVcGRhdGU7XG4vKipcbiAqIHJlbW92ZSBldmVudCBoYW5kbGVycyBmcm9tIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fE5vZGVMaXN0fSBpdGVtc1xuICovXG52YXIgcmVtb3ZlSXRlbUV2ZW50cyA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbXMsICdkcmFnc3RhcnQnKTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGl0ZW1zLCAnZHJhZ2VuZCcpO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbXMsICdkcmFnb3ZlcicpO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbXMsICdkcmFnZW50ZXInKTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGl0ZW1zLCAnZHJvcCcpO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbXMsICdtb3VzZWVudGVyJyk7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihpdGVtcywgJ21vdXNlbGVhdmUnKTtcbn07XG4vLyBSZW1vdmUgY29udGFpbmVyIGV2ZW50c1xudmFyIHJlbW92ZUNvbnRhaW5lckV2ZW50cyA9IGZ1bmN0aW9uIChvcmlnaW5Db250YWluZXIsIHByZXZpb3VzQ29udGFpbmVyKSB7XG4gICAgaWYgKG9yaWdpbkNvbnRhaW5lcikge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKG9yaWdpbkNvbnRhaW5lciwgJ2RyYWdsZWF2ZScpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNDb250YWluZXIgJiYgKHByZXZpb3VzQ29udGFpbmVyICE9PSBvcmlnaW5Db250YWluZXIpKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIocHJldmlvdXNDb250YWluZXIsICdkcmFnbGVhdmUnKTtcbiAgICB9XG59O1xuLyoqXG4gKiBnZXREcmFnZ2luZyByZXR1cm5zIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gZHJhZyBvclxuICogYSBjb3B5IG9mIHRoZSBlbGVtZW50LlxuICogSXMgQ29weSBBY3RpdmUgZm9yIHNvcnRhYmxlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkcmFnZ2VkSXRlbSAtIHRoZSBpdGVtIHRoYXQgdGhlIHVzZXIgZHJhZ3NcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNvcnRhYmxlIGEgc2luZ2xlIHNvcnRhYmxlXG4gKi9cbnZhciBnZXREcmFnZ2luZyA9IGZ1bmN0aW9uIChkcmFnZ2VkSXRlbSwgc29ydGFibGUpIHtcbiAgICB2YXIgZGl0ZW0gPSBkcmFnZ2VkSXRlbTtcbiAgICBpZiAoc3RvcmUoc29ydGFibGUpLmdldENvbmZpZygnY29weScpID09PSB0cnVlKSB7XG4gICAgICAgIGRpdGVtID0gZHJhZ2dlZEl0ZW0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBhZGRBdHRyaWJ1dGUoZGl0ZW0sICdhcmlhLWNvcGllZCcsICd0cnVlJyk7XG4gICAgICAgIGRyYWdnZWRJdGVtLnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZGl0ZW0pO1xuICAgICAgICBkaXRlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkaXRlbS5vbGREaXNwbGF5ID0gZHJhZ2dlZEl0ZW0uc3R5bGUuZGlzcGxheTtcbiAgICB9XG4gICAgcmV0dXJuIGRpdGVtO1xufTtcbi8qKlxuICogUmVtb3ZlIGRhdGEgZnJvbSBzb3J0YWJsZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc29ydGFibGUgYSBzaW5nbGUgc29ydGFibGVcbiAqL1xudmFyIHJlbW92ZVNvcnRhYmxlRGF0YSA9IGZ1bmN0aW9uIChzb3J0YWJsZSkge1xuICAgIHJlbW92ZURhdGEoc29ydGFibGUpO1xuICAgIHJlbW92ZUF0dHJpYnV0ZShzb3J0YWJsZSwgJ2FyaWEtZHJvcGVmZmVjdCcpO1xufTtcbi8qKlxuICogUmVtb3ZlIGRhdGEgZnJvbSBpdGVtc1xuICogQHBhcmFtIHtBcnJheTxIVE1MRWxlbWVudD58SFRNTEVsZW1lbnR9IGl0ZW1zXG4gKi9cbnZhciByZW1vdmVJdGVtRGF0YSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHJlbW92ZUF0dHJpYnV0ZShpdGVtcywgJ2FyaWEtZ3JhYmJlZCcpO1xuICAgIHJlbW92ZUF0dHJpYnV0ZShpdGVtcywgJ2FyaWEtY29waWVkJyk7XG4gICAgcmVtb3ZlQXR0cmlidXRlKGl0ZW1zLCAnZHJhZ2dhYmxlJyk7XG4gICAgcmVtb3ZlQXR0cmlidXRlKGl0ZW1zLCAncm9sZScpO1xufTtcbi8qKlxuICogZmluZCBzb3J0YWJsZSBmcm9tIGVsZW1lbnQuIHRyYXZlbHMgdXAgcGFyZW50IGVsZW1lbnQgdW50aWwgZm91bmQgb3IgbnVsbC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgYSBzaW5nbGUgc29ydGFibGVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGN1cnJlbnQgZXZlbnQuIFdlIG5lZWQgdG8gcGFzcyBpdCB0byBiZSBhYmxlIHRvXG4gKiBmaW5kIFNvcnRhYmxlIHdoaXRoIHNoYWRvd1Jvb3QgKGRvY3VtZW50IGZyYWdtZW50IGhhcyBubyBwYXJlbnQpXG4gKi9cbmZ1bmN0aW9uIGZpbmRTb3J0YWJsZShlbGVtZW50LCBldmVudCkge1xuICAgIGlmIChldmVudC5jb21wb3NlZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpLmZpbmQoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5pc1NvcnRhYmxlOyB9KTtcbiAgICB9XG4gICAgd2hpbGUgKGVsZW1lbnQuaXNTb3J0YWJsZSAhPT0gdHJ1ZSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogRHJhZ2dpbmcgZXZlbnQgaXMgb24gdGhlIHNvcnRhYmxlIGVsZW1lbnQuIGZpbmRzIHRoZSB0b3AgY2hpbGQgdGhhdFxuICogY29udGFpbnMgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzb3J0YWJsZUVsZW1lbnQgYSBzaW5nbGUgc29ydGFibGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgaXMgdGhhdCBiZWluZyBkcmFnZ2VkXG4gKi9cbmZ1bmN0aW9uIGZpbmREcmFnRWxlbWVudChzb3J0YWJsZUVsZW1lbnQsIGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFkZERhdGEoc29ydGFibGVFbGVtZW50LCAnb3B0cycpO1xuICAgIHZhciBpdGVtcyA9IGZpbHRlcihzb3J0YWJsZUVsZW1lbnQuY2hpbGRyZW4sIG9wdGlvbnMuaXRlbXMpO1xuICAgIHZhciBpdGVtbGlzdCA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuY29udGFpbnMoZWxlbWVudCkgfHwgKGVsZS5zaGFkb3dSb290ICYmIGVsZS5zaGFkb3dSb290LmNvbnRhaW5zKGVsZW1lbnQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbWxpc3QubGVuZ3RoID4gMCA/IGl0ZW1saXN0WzBdIDogZWxlbWVudDtcbn1cbi8qKlxuICogRGVzdHJveSB0aGUgc29ydGFibGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNvcnRhYmxlRWxlbWVudCBhIHNpbmdsZSBzb3J0YWJsZVxuICovXG52YXIgZGVzdHJveVNvcnRhYmxlID0gZnVuY3Rpb24gKHNvcnRhYmxlRWxlbWVudCkge1xuICAgIHZhciBvcHRzID0gYWRkRGF0YShzb3J0YWJsZUVsZW1lbnQsICdvcHRzJykgfHwge307XG4gICAgdmFyIGl0ZW1zID0gZmlsdGVyKHNvcnRhYmxlRWxlbWVudC5jaGlsZHJlbiwgb3B0cy5pdGVtcyk7XG4gICAgdmFyIGhhbmRsZXMgPSBnZXRIYW5kbGVzKGl0ZW1zLCBvcHRzLmhhbmRsZSk7XG4gICAgLy8gZGlzYWJsZSBhZGRpbmcgaG92ZXIgY2xhc3NcbiAgICBlbmFibGVIb3ZlckNsYXNzKHNvcnRhYmxlRWxlbWVudCwgZmFsc2UpO1xuICAgIC8vIHJlbW92ZSBldmVudCBoYW5kbGVycyAmIGRhdGEgZnJvbSBzb3J0YWJsZVxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoc29ydGFibGVFbGVtZW50LCAnZHJhZ292ZXInKTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHNvcnRhYmxlRWxlbWVudCwgJ2RyYWdlbnRlcicpO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoc29ydGFibGVFbGVtZW50LCAnZHJhZ3N0YXJ0Jyk7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihzb3J0YWJsZUVsZW1lbnQsICdkcmFnZW5kJyk7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihzb3J0YWJsZUVsZW1lbnQsICdkcm9wJyk7XG4gICAgLy8gcmVtb3ZlIGV2ZW50IGRhdGEgZnJvbSBzb3J0YWJsZVxuICAgIHJlbW92ZVNvcnRhYmxlRGF0YShzb3J0YWJsZUVsZW1lbnQpO1xuICAgIC8vIHJlbW92ZSBldmVudCBoYW5kbGVycyAmIGRhdGEgZnJvbSBpdGVtc1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlcywgJ21vdXNlZG93bicpO1xuICAgIHJlbW92ZUl0ZW1FdmVudHMoaXRlbXMpO1xuICAgIHJlbW92ZUl0ZW1EYXRhKGl0ZW1zKTtcbiAgICByZW1vdmVDb250YWluZXJFdmVudHMob3JpZ2luQ29udGFpbmVyLCBwcmV2aW91c0NvbnRhaW5lcik7XG4gICAgLy8gY2xlYXIgc29ydGFibGUgZmxhZ1xuICAgIHNvcnRhYmxlRWxlbWVudC5pc1NvcnRhYmxlID0gZmFsc2U7XG59O1xuLyoqXG4gKiBFbmFibGUgdGhlIHNvcnRhYmxlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzb3J0YWJsZUVsZW1lbnQgYSBzaW5nbGUgc29ydGFibGVcbiAqL1xudmFyIGVuYWJsZVNvcnRhYmxlID0gZnVuY3Rpb24gKHNvcnRhYmxlRWxlbWVudCkge1xuICAgIHZhciBvcHRzID0gYWRkRGF0YShzb3J0YWJsZUVsZW1lbnQsICdvcHRzJyk7XG4gICAgdmFyIGl0ZW1zID0gZmlsdGVyKHNvcnRhYmxlRWxlbWVudC5jaGlsZHJlbiwgb3B0cy5pdGVtcyk7XG4gICAgdmFyIGhhbmRsZXMgPSBnZXRIYW5kbGVzKGl0ZW1zLCBvcHRzLmhhbmRsZSk7XG4gICAgYWRkQXR0cmlidXRlKHNvcnRhYmxlRWxlbWVudCwgJ2FyaWEtZHJvcGVmZmVjdCcsICdtb3ZlJyk7XG4gICAgYWRkRGF0YShzb3J0YWJsZUVsZW1lbnQsICdfZGlzYWJsZWQnLCAnZmFsc2UnKTtcbiAgICBhZGRBdHRyaWJ1dGUoaGFuZGxlcywgJ2RyYWdnYWJsZScsICd0cnVlJyk7XG4gICAgLy8gZW5hYmxlIGhvdmVyIGNsYXNzXG4gICAgZW5hYmxlSG92ZXJDbGFzcyhzb3J0YWJsZUVsZW1lbnQsIHRydWUpO1xuICAgIC8vIEB0b2RvOiByZW1vdmUgdGhpcyBmaXhcbiAgICAvLyBJRSBGSVggZm9yIGdob3N0XG4gICAgLy8gY2FuIGJlIGRpc2FibGVkIGFzIGl0IGhhcyB0aGUgc2lkZSBlZmZlY3QgdGhhdCBvdGhlciBldmVudHNcbiAgICAvLyAoZS5nLiBjbGljaykgd2lsbCBiZSBpZ25vcmVkXG4gICAgaWYgKG9wdHMuZGlzYWJsZUlFRml4ID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgc3BhbkVsID0gKGRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudCkuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBpZiAodHlwZW9mIHNwYW5FbC5kcmFnRHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihoYW5kbGVzLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5pbmRleE9mKHRoaXMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdEcm9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaXRlbXMuaW5kZXhPZihwYXJlbnQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmRyYWdEcm9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBEaXNhYmxlIHRoZSBzb3J0YWJsZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc29ydGFibGVFbGVtZW50IGEgc2luZ2xlIHNvcnRhYmxlXG4gKi9cbnZhciBkaXNhYmxlU29ydGFibGUgPSBmdW5jdGlvbiAoc29ydGFibGVFbGVtZW50KSB7XG4gICAgdmFyIG9wdHMgPSBhZGREYXRhKHNvcnRhYmxlRWxlbWVudCwgJ29wdHMnKTtcbiAgICB2YXIgaXRlbXMgPSBmaWx0ZXIoc29ydGFibGVFbGVtZW50LmNoaWxkcmVuLCBvcHRzLml0ZW1zKTtcbiAgICB2YXIgaGFuZGxlcyA9IGdldEhhbmRsZXMoaXRlbXMsIG9wdHMuaGFuZGxlKTtcbiAgICBhZGRBdHRyaWJ1dGUoc29ydGFibGVFbGVtZW50LCAnYXJpYS1kcm9wZWZmZWN0JywgJ25vbmUnKTtcbiAgICBhZGREYXRhKHNvcnRhYmxlRWxlbWVudCwgJ19kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgYWRkQXR0cmlidXRlKGhhbmRsZXMsICdkcmFnZ2FibGUnLCAnZmFsc2UnKTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZXMsICdtb3VzZWRvd24nKTtcbiAgICBlbmFibGVIb3ZlckNsYXNzKHNvcnRhYmxlRWxlbWVudCwgZmFsc2UpO1xufTtcbi8qKlxuICogUmVsb2FkIHRoZSBzb3J0YWJsZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc29ydGFibGVFbGVtZW50IGEgc2luZ2xlIHNvcnRhYmxlXG4gKiBAZGVzY3JpcHRpb24gZXZlbnRzIG5lZWQgdG8gYmUgcmVtb3ZlZCB0byBub3QgYmUgZG91YmxlIGJvdW5kXG4gKi9cbnZhciByZWxvYWRTb3J0YWJsZSA9IGZ1bmN0aW9uIChzb3J0YWJsZUVsZW1lbnQpIHtcbiAgICB2YXIgb3B0cyA9IGFkZERhdGEoc29ydGFibGVFbGVtZW50LCAnb3B0cycpO1xuICAgIHZhciBpdGVtcyA9IGZpbHRlcihzb3J0YWJsZUVsZW1lbnQuY2hpbGRyZW4sIG9wdHMuaXRlbXMpO1xuICAgIHZhciBoYW5kbGVzID0gZ2V0SGFuZGxlcyhpdGVtcywgb3B0cy5oYW5kbGUpO1xuICAgIGFkZERhdGEoc29ydGFibGVFbGVtZW50LCAnX2Rpc2FibGVkJywgJ2ZhbHNlJyk7XG4gICAgLy8gcmVtb3ZlIGV2ZW50IGhhbmRsZXJzIGZyb20gaXRlbXNcbiAgICByZW1vdmVJdGVtRXZlbnRzKGl0ZW1zKTtcbiAgICByZW1vdmVDb250YWluZXJFdmVudHMob3JpZ2luQ29udGFpbmVyLCBwcmV2aW91c0NvbnRhaW5lcik7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGVzLCAnbW91c2Vkb3duJyk7XG4gICAgLy8gcmVtb3ZlIGV2ZW50IGhhbmRsZXJzIGZyb20gc29ydGFibGVcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHNvcnRhYmxlRWxlbWVudCwgJ2RyYWdvdmVyJyk7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihzb3J0YWJsZUVsZW1lbnQsICdkcmFnZW50ZXInKTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHNvcnRhYmxlRWxlbWVudCwgJ2Ryb3AnKTtcbn07XG4vKipcbiAqIFB1YmxpYyBzb3J0YWJsZSBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl8Tm9kZUxpc3R9IHNvcnRhYmxlRWxlbWVudHNcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gb3B0aW9uc3xtZXRob2RcbiAqL1xuZnVuY3Rpb24gc29ydGFibGUoc29ydGFibGVFbGVtZW50cywgb3B0aW9ucykge1xuICAgIC8vIGdldCBtZXRob2Qgc3RyaW5nIHRvIHNlZSBpZiBhIG1ldGhvZCBpcyBjYWxsZWRcbiAgICB2YXIgbWV0aG9kID0gU3RyaW5nKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIGNoZWNrIGlmIHRoZSB1c2VyIHByb3ZpZGVkIGEgc2VsZWN0b3IgaW5zdGVhZCBvZiBhbiBlbGVtZW50XG4gICAgaWYgKHR5cGVvZiBzb3J0YWJsZUVsZW1lbnRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBzb3J0YWJsZUVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzb3J0YWJsZUVsZW1lbnRzKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHVzZXIgcHJvdmlkZWQgYW4gZWxlbWVudCwgcmV0dXJuIGl0IGluIGFuIGFycmF5IHRvIGtlZXAgdGhlIHJldHVybiB2YWx1ZSBjb25zaXN0YW50XG4gICAgaWYgKHNvcnRhYmxlRWxlbWVudHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICBzb3J0YWJsZUVsZW1lbnRzID0gW3NvcnRhYmxlRWxlbWVudHNdO1xuICAgIH1cbiAgICBzb3J0YWJsZUVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc29ydGFibGVFbGVtZW50cyk7XG4gICAgaWYgKC9zZXJpYWxpemUvLnRlc3QobWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gc29ydGFibGVFbGVtZW50cy5tYXAoZnVuY3Rpb24gKHNvcnRhYmxlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IGFkZERhdGEoc29ydGFibGVDb250YWluZXIsICdvcHRzJyk7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKHNvcnRhYmxlQ29udGFpbmVyLCBvcHRzLml0ZW1TZXJpYWxpemVyLCBvcHRzLmNvbnRhaW5lclNlcmlhbGl6ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc29ydGFibGVFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzb3J0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKC9lbmFibGV8ZGlzYWJsZXxkZXN0cm95Ly50ZXN0KG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0YWJsZVttZXRob2RdKHNvcnRhYmxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9nIGRlcHJlY2F0aW9uXG4gICAgICAgIFsnY29ubmVjdFdpdGgnLCAnZGlzYWJsZUlFRml4J10uZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnS2V5KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGNvbmZpZ0tleSkgJiYgb3B0aW9uc1tjb25maWdLZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSFRNTDVTb3J0YWJsZTogWW91IGFyZSB1c2luZyB0aGUgZGVwcmVjYXRlZCBjb25maWd1cmF0aW9uIFxcXCJcIiArIGNvbmZpZ0tleSArIFwiXFxcIi4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgdmVyc2lvbiwgbWFrZSBzdXJlIHRvIG1pZ3JhdGUgdG8gdGhlIG5ldyBvcHRpb25zIHdoZW4gdXBkYXRpbmcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gbWVyZ2Ugb3B0aW9ucyB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZ3VyYXRpb24sIHN0b3JlKHNvcnRhYmxlRWxlbWVudCkuY29uZmlnLCBvcHRpb25zKTtcbiAgICAgICAgLy8gaW5pdCBkYXRhIHN0b3JlIGZvciBzb3J0YWJsZVxuICAgICAgICBzdG9yZShzb3J0YWJsZUVsZW1lbnQpLmNvbmZpZyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIHNldCBvcHRpb25zIG9uIHNvcnRhYmxlXG4gICAgICAgIGFkZERhdGEoc29ydGFibGVFbGVtZW50LCAnb3B0cycsIG9wdGlvbnMpO1xuICAgICAgICAvLyBwcm9wZXJ0eSB0byBkZWZpbmUgYXMgc29ydGFibGVcbiAgICAgICAgc29ydGFibGVFbGVtZW50LmlzU29ydGFibGUgPSB0cnVlO1xuICAgICAgICAvLyByZXNldCBzb3J0YWJsZVxuICAgICAgICByZWxvYWRTb3J0YWJsZShzb3J0YWJsZUVsZW1lbnQpO1xuICAgICAgICAvLyBpbml0aWFsaXplXG4gICAgICAgIHZhciBsaXN0SXRlbXMgPSBmaWx0ZXIoc29ydGFibGVFbGVtZW50LmNoaWxkcmVuLCBvcHRpb25zLml0ZW1zKTtcbiAgICAgICAgLy8gY3JlYXRlIGVsZW1lbnQgaWYgdXNlciBkZWZpbmVkIGEgcGxhY2Vob2xkZXIgZWxlbWVudCBhcyBhIHN0cmluZ1xuICAgICAgICB2YXIgY3VzdG9tUGxhY2Vob2xkZXI7XG4gICAgICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyICE9PSBudWxsICYmIG9wdGlvbnMucGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHRlbXBDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHNvcnRhYmxlRWxlbWVudC50YWdOYW1lKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29udGFpbmVyLmFwcGVuZENoaWxkKG9wdGlvbnMucGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbnRhaW5lci5pbm5lckhUTUwgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VzdG9tUGxhY2Vob2xkZXIgPSB0ZW1wQ29udGFpbmVyLmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBwbGFjZWhvbGRlclxuICAgICAgICBzdG9yZShzb3J0YWJsZUVsZW1lbnQpLnBsYWNlaG9sZGVyID0gbWFrZVBsYWNlaG9sZGVyKHNvcnRhYmxlRWxlbWVudCwgY3VzdG9tUGxhY2Vob2xkZXIsIG9wdGlvbnMucGxhY2Vob2xkZXJDbGFzcyk7XG4gICAgICAgIGFkZERhdGEoc29ydGFibGVFbGVtZW50LCAnaXRlbXMnLCBvcHRpb25zLml0ZW1zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWNjZXB0RnJvbSkge1xuICAgICAgICAgICAgYWRkRGF0YShzb3J0YWJsZUVsZW1lbnQsICdhY2NlcHRGcm9tJywgb3B0aW9ucy5hY2NlcHRGcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNvbm5lY3RXaXRoKSB7XG4gICAgICAgICAgICBhZGREYXRhKHNvcnRhYmxlRWxlbWVudCwgJ2Nvbm5lY3RXaXRoJywgb3B0aW9ucy5jb25uZWN0V2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5hYmxlU29ydGFibGUoc29ydGFibGVFbGVtZW50KTtcbiAgICAgICAgYWRkQXR0cmlidXRlKGxpc3RJdGVtcywgJ3JvbGUnLCAnb3B0aW9uJyk7XG4gICAgICAgIGFkZEF0dHJpYnV0ZShsaXN0SXRlbXMsICdhcmlhLWdyYWJiZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgLypcbiAgICAgICAgIEhhbmRsZSBkcmFnIGV2ZW50cyBvbiBkcmFnZ2FibGUgaXRlbXNcbiAgICAgICAgIEhhbmRsZSBpcyBzZXQgYXQgdGhlIHNvcnRhYmxlRWxlbWVudCBsZXZlbCBhcyBpdCB3aWxsIGJ1YmJsZSB1cFxuICAgICAgICAgZnJvbSB0aGUgaXRlbVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihzb3J0YWJsZUVsZW1lbnQsICdkcmFnc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGRyYWdzdGFydCBldmVudHNcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChlKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaXNTb3J0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMuaGFuZGxlICYmICF0YXJnZXQubWF0Y2hlcyhvcHRpb25zLmhhbmRsZSkpIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvcnRhYmxlQ29udGFpbmVyID0gZmluZFNvcnRhYmxlKHRhcmdldCwgZSk7XG4gICAgICAgICAgICB2YXIgZHJhZ0l0ZW0gPSBmaW5kRHJhZ0VsZW1lbnQoc29ydGFibGVDb250YWluZXIsIHRhcmdldCk7XG4gICAgICAgICAgICAvLyBncmFiIHZhbHVlc1xuICAgICAgICAgICAgb3JpZ2luSXRlbXNCZWZvcmVVcGRhdGUgPSBmaWx0ZXIoc29ydGFibGVDb250YWluZXIuY2hpbGRyZW4sIG9wdGlvbnMuaXRlbXMpO1xuICAgICAgICAgICAgb3JpZ2luSW5kZXggPSBvcmlnaW5JdGVtc0JlZm9yZVVwZGF0ZS5pbmRleE9mKGRyYWdJdGVtKTtcbiAgICAgICAgICAgIG9yaWdpbkVsZW1lbnRJbmRleCA9IGdldEluZGV4KGRyYWdJdGVtLCBzb3J0YWJsZUNvbnRhaW5lci5jaGlsZHJlbik7XG4gICAgICAgICAgICBvcmlnaW5Db250YWluZXIgPSBzb3J0YWJsZUNvbnRhaW5lcjtcbiAgICAgICAgICAgIC8vIGFkZCB0cmFuc3BhcmVudCBjbG9uZSBvciBvdGhlciBnaG9zdCB0byBjdXJzb3JcbiAgICAgICAgICAgIHNldERyYWdJbWFnZShlLCBkcmFnSXRlbSwgb3B0aW9ucy5jdXN0b21EcmFnSW1hZ2UpO1xuICAgICAgICAgICAgLy8gY2FjaGUgc2Vsc2VjdGlvbiAmIGFkZCBhdHRyIGZvciBkcmFnZ2luZ1xuICAgICAgICAgICAgZHJhZ2dpbmdIZWlnaHQgPSBnZXRFbGVtZW50SGVpZ2h0KGRyYWdJdGVtKTtcbiAgICAgICAgICAgIGRyYWdnaW5nV2lkdGggPSBnZXRFbGVtZW50V2lkdGgoZHJhZ0l0ZW0pO1xuICAgICAgICAgICAgZHJhZ0l0ZW0uY2xhc3NMaXN0LmFkZChvcHRpb25zLmRyYWdnaW5nQ2xhc3MpO1xuICAgICAgICAgICAgZHJhZ2dpbmcgPSBnZXREcmFnZ2luZyhkcmFnSXRlbSwgc29ydGFibGVDb250YWluZXIpO1xuICAgICAgICAgICAgYWRkQXR0cmlidXRlKGRyYWdnaW5nLCAnYXJpYS1ncmFiYmVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgIC8vIGRpc3BhdGNoIHNvcnRzdGFydCBldmVudCBvbiBlYWNoIGVsZW1lbnQgaW4gZ3JvdXBcbiAgICAgICAgICAgIHNvcnRhYmxlQ29udGFpbmVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzb3J0c3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEluZGV4OiBvcmlnaW5FbGVtZW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogb3JpZ2luSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IG9yaWdpbkNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpdGVtOiBkcmFnZ2luZyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxUYXJnZXQ6IHRhcmdldFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qXG4gICAgICAgICBXZSBhcmUgY2FwdHVyaW5nIHRhcmdldFNvcnRhYmxlIGJlZm9yZSBtb2RpZmljYXRpb25zIHdpdGggJ2RyYWdlbnRlcicgZXZlbnRcbiAgICAgICAgKi9cbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihzb3J0YWJsZUVsZW1lbnQsICdkcmFnZW50ZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgdmFyIHNvcnRhYmxlQ29udGFpbmVyID0gZmluZFNvcnRhYmxlKHRhcmdldCwgZSk7XG4gICAgICAgICAgICBpZiAoc29ydGFibGVDb250YWluZXIgJiYgc29ydGFibGVDb250YWluZXIgIT09IHByZXZpb3VzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25JdGVtc0JlZm9yZVVwZGF0ZSA9IGZpbHRlcihzb3J0YWJsZUNvbnRhaW5lci5jaGlsZHJlbiwgYWRkRGF0YShzb3J0YWJsZUNvbnRhaW5lciwgJ2l0ZW1zJykpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gIT09IHN0b3JlKHNvcnRhYmxlRWxlbWVudCkucGxhY2Vob2xkZXI7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRyb3BUYXJnZXRDb250YWluZXJDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKG9wdGlvbnMuZHJvcFRhcmdldENvbnRhaW5lckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc29ydGFibGVDb250YWluZXIuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3NvcnRlbnRlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50SW5kZXg6IG9yaWdpbkVsZW1lbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogb3JpZ2luSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBvcmlnaW5Db250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogc29ydGFibGVDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNCZWZvcmVVcGRhdGU6IGRlc3RpbmF0aW9uSXRlbXNCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBkcmFnZ2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKHNvcnRhYmxlQ29udGFpbmVyLCAnZHJhZ2xlYXZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVuYW1lIG91dFRhcmdldCB0byBiZSBtb3JlIHNlbGYtZXhwbGFuYXRvcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gZS5mcm9tRWxlbWVudCBmb3IgdmVyeSBvbGQgYnJvd3NlcnMsIHNpbWlsYXIgdG8gcmVsYXRlZFRhcmdldFxuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0VGFyZ2V0ID0gZS5yZWxhdGVkVGFyZ2V0IHx8IGUuZnJvbUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKG91dFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRyb3BUYXJnZXRDb250YWluZXJDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRhYmxlQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUob3B0aW9ucy5kcm9wVGFyZ2V0Q29udGFpbmVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGFibGVDb250YWluZXIuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3NvcnRsZWF2ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50SW5kZXg6IG9yaWdpbkVsZW1lbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBvcmlnaW5JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogc29ydGFibGVDb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogZHJhZ2dpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzQ29udGFpbmVyID0gc29ydGFibGVDb250YWluZXI7XG4gICAgICAgIH0pO1xuICAgICAgICAvKlxuICAgICAgICAgKiBEcmFnZW5kIEV2ZW50IC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL2RyYWdlbmRcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIGRyYWdFdmVudCBlbmQsIG9yIEVTQyBwcmVzc2VkXG4gICAgICAgICAqIFdlIGFyZSB1c2luZyBpdCB0byBjbGVhbiB1cCBhbnkgZHJhZ2dhYmxlIGVsZW1lbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoc29ydGFibGVFbGVtZW50LCAnZHJhZ2VuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJhZ2dpbmcuY2xhc3NMaXN0LnJlbW92ZShvcHRpb25zLmRyYWdnaW5nQ2xhc3MpO1xuICAgICAgICAgICAgYWRkQXR0cmlidXRlKGRyYWdnaW5nLCAnYXJpYS1ncmFiYmVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmcuZ2V0QXR0cmlidXRlKCdhcmlhLWNvcGllZCcpID09PSAndHJ1ZScgJiYgYWRkRGF0YShkcmFnZ2luZywgJ2Ryb3BwZWQnKSAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmcub2xkRGlzcGxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc3R5bGUuZGlzcGxheSA9IGRyYWdnaW5nLm9sZERpc3BsYXk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRyYWdnaW5nLm9sZERpc3BsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmlzaWJsZVBsYWNlaG9sZGVyID0gQXJyYXkuZnJvbShzdG9yZXMudmFsdWVzKCkpLm1hcChmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YS5wbGFjZWhvbGRlcjsgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZWhvbGRlcikgeyByZXR1cm4gcGxhY2Vob2xkZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDsgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGlzSW5Eb20pWzBdO1xuICAgICAgICAgICAgaWYgKHZpc2libGVQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIHZpc2libGVQbGFjZWhvbGRlci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRpc3BhdGNoIHNvcnRzdGFydCBldmVudCBvbiBlYWNoIGVsZW1lbnQgaW4gZ3JvdXBcbiAgICAgICAgICAgIHNvcnRhYmxlRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc29ydHN0b3AnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEluZGV4OiBvcmlnaW5FbGVtZW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogb3JpZ2luSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IG9yaWdpbkNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpdGVtOiBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHByZXZpb3VzQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgICAgIGRyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGRyYWdnaW5nSGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIGRyYWdnaW5nV2lkdGggPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgLypcbiAgICAgICAgICogRHJvcCBFdmVudCAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy9kcm9wXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdmFsaWQgZHJvcCB0YXJnZXQgYXJlYSBpcyBoaXRcbiAgICAgICAgICovXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoc29ydGFibGVFbGVtZW50LCAnZHJvcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxpc3RzQ29ubmVjdGVkKHNvcnRhYmxlRWxlbWVudCwgZHJhZ2dpbmcucGFyZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYWRkRGF0YShkcmFnZ2luZywgJ2Ryb3BwZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBvbmUgcGxhY2Vob2xkZXIgdGhhdCBpcyBjdXJyZW50bHkgdmlzaWJsZVxuICAgICAgICAgICAgdmFyIHZpc2libGVQbGFjZWhvbGRlciA9IEFycmF5LmZyb20oc3RvcmVzLnZhbHVlcygpKS5tYXAoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG9ubHkgSFRNTEVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGxhY2Vob2xkZXIpIHsgcmV0dXJuIHBsYWNlaG9sZGVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7IH0pXG4gICAgICAgICAgICAgICAgLy8gb25seSBlbGVtZW50cyBpbiBET01cbiAgICAgICAgICAgICAgICAuZmlsdGVyKGlzSW5Eb20pWzBdO1xuICAgICAgICAgICAgaWYgKHZpc2libGVQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIHZpc2libGVQbGFjZWhvbGRlci5yZXBsYWNlV2l0aChkcmFnZ2luZyk7XG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgZmxpY2tlcmluZyByZXN0b3JpbmcgZWxlbWVudCBkaXNwbGF5IGltbWVkaWF0ZWx5IGFmdGVyIHJlcGxhY2luZyBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZy5vbGREaXNwbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcuc3R5bGUuZGlzcGxheSA9IGRyYWdnaW5nLm9sZERpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkcmFnZ2luZy5vbGREaXNwbGF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgZHJvcHBlZCB2YWx1ZSB0byAnZmFsc2UnIHRvIGRlbGV0ZSBjb3BpZWQgZHJhZ2dpbmcgYXQgdGhlIHRpbWUgb2YgJ2RyYWdlbmQnXG4gICAgICAgICAgICAgICAgYWRkRGF0YShkcmFnZ2luZywgJ2Ryb3BwZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRmlyZXMgQ3VzdG9tIEV2ZW50IC0gJ3NvcnRzdG9wJ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzb3J0YWJsZUVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3NvcnRzdG9wJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJbmRleDogb3JpZ2luRWxlbWVudEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG9yaWdpbkluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBvcmlnaW5Db250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBzdG9yZShzb3J0YWJsZUVsZW1lbnQpLnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgdmFyIG9yaWdpbkl0ZW1zID0gZmlsdGVyKG9yaWdpbkNvbnRhaW5lci5jaGlsZHJlbiwgb3B0aW9ucy5pdGVtcylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtICE9PSBwbGFjZWhvbGRlcjsgfSk7XG4gICAgICAgICAgICB2YXIgZGVzdGluYXRpb25Db250YWluZXIgPSB0aGlzLmlzU29ydGFibGUgPT09IHRydWUgPyB0aGlzIDogdGhpcy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uSXRlbXMgPSBmaWx0ZXIoZGVzdGluYXRpb25Db250YWluZXIuY2hpbGRyZW4sIGFkZERhdGEoZGVzdGluYXRpb25Db250YWluZXIsICdpdGVtcycpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gIT09IHBsYWNlaG9sZGVyOyB9KTtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbkVsZW1lbnRJbmRleCA9IGdldEluZGV4KGRyYWdnaW5nLCBBcnJheS5mcm9tKGRyYWdnaW5nLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbSAhPT0gcGxhY2Vob2xkZXI7IH0pKTtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbkluZGV4ID0gZ2V0SW5kZXgoZHJhZ2dpbmcsIGRlc3RpbmF0aW9uSXRlbXMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZHJvcFRhcmdldENvbnRhaW5lckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25Db250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShvcHRpb25zLmRyb3BUYXJnZXRDb250YWluZXJDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogV2hlbiBhIGxpc3QgaXRlbSBjaGFuZ2VkIGNvbnRhaW5lciBsaXN0cyBvciBpbmRleCB3aXRoaW4gYSBsaXN0XG4gICAgICAgICAgICAgKiBGaXJlcyBDdXN0b20gRXZlbnQgLSAnc29ydHVwZGF0ZSdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG9yaWdpbkVsZW1lbnRJbmRleCAhPT0gZGVzdGluYXRpb25FbGVtZW50SW5kZXggfHwgb3JpZ2luQ29udGFpbmVyICE9PSBkZXN0aW5hdGlvbkNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc29ydHVwZGF0ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50SW5kZXg6IG9yaWdpbkVsZW1lbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogb3JpZ2luSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBvcmlnaW5Db250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNCZWZvcmVVcGRhdGU6IG9yaWdpbkl0ZW1zQmVmb3JlVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBvcmlnaW5JdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGRlc3RpbmF0aW9uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEluZGV4OiBkZXN0aW5hdGlvbkVsZW1lbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGRlc3RpbmF0aW9uQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zQmVmb3JlVXBkYXRlOiBkZXN0aW5hdGlvbkl0ZW1zQmVmb3JlVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBkZXN0aW5hdGlvbkl0ZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWJvdW5jZWREcmFnT3ZlckVudGVyID0gZGVib3VuY2UoZnVuY3Rpb24gKHNvcnRhYmxlRWxlbWVudCwgZWxlbWVudCwgcGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHBsYWNlaG9sZGVyIGhlaWdodCBpZiBmb3JjZVBsYWNlaG9sZGVyU2l6ZSBvcHRpb24gaXMgc2V0XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZVBsYWNlaG9sZGVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIHN0b3JlKHNvcnRhYmxlRWxlbWVudCkucGxhY2Vob2xkZXIuc3R5bGUuaGVpZ2h0ID0gZHJhZ2dpbmdIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHN0b3JlKHNvcnRhYmxlRWxlbWVudCkucGxhY2Vob2xkZXIuc3R5bGUud2lkdGggPSBkcmFnZ2luZ1dpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGVsZW1lbnQgdGhlIGRyYWdnZWRJdGVtIGlzIGRyYWdnZWQgb250byBpcyB3aXRoaW4gdGhlIGFycmF5IG9mIGFsbCBlbGVtZW50cyBpbiBsaXN0XG4gICAgICAgICAgICAvLyAobm90IG9ubHkgaXRlbXMsIGJ1dCBhbHNvIGRpc2FibGVkLCBldGMuKVxuICAgICAgICAgICAgaWYgKEFycmF5LmZyb20oc29ydGFibGVFbGVtZW50LmNoaWxkcmVuKS5pbmRleE9mKGVsZW1lbnQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0hlaWdodCA9IGdldEVsZW1lbnRIZWlnaHQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNXaWR0aCA9IGdldEVsZW1lbnRXaWR0aChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJJbmRleCA9IGdldEluZGV4KHN0b3JlKHNvcnRhYmxlRWxlbWVudCkucGxhY2Vob2xkZXIsIGVsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNJbmRleCA9IGdldEluZGV4KGVsZW1lbnQsIGVsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYGVsZW1lbnRgIGlzIGJpZ2dlciB0aGFuIHRoZSBkcmFnZ2FibGUuIElmIGl0IGlzLCB3ZSBoYXZlIHRvIGRlZmluZSBhIGRlYWQgem9uZSB0byBwcmV2ZW50IGZsaWNrZXJpbmdcbiAgICAgICAgICAgICAgICBpZiAodGhpc0hlaWdodCA+IGRyYWdnaW5nSGVpZ2h0IHx8IHRoaXNXaWR0aCA+IGRyYWdnaW5nV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVhZCB6b25lP1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVhZFpvbmVWZXJ0aWNhbCA9IHRoaXNIZWlnaHQgLSBkcmFnZ2luZ0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlYWRab25lSG9yaXpvbnRhbCA9IHRoaXNXaWR0aCAtIGRyYWdnaW5nV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRUb3AgPSBvZmZzZXQoZWxlbWVudCkudG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldChlbGVtZW50KS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXJJbmRleCA8IHRoaXNJbmRleCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChvcHRpb25zLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIHBhZ2VZIDwgb2Zmc2V0VG9wKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgcGFnZVggPCBvZmZzZXRMZWZ0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXJJbmRleCA+IHRoaXNJbmRleCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChvcHRpb25zLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIHBhZ2VZID4gb2Zmc2V0VG9wICsgdGhpc0hlaWdodCAtIGRlYWRab25lVmVydGljYWwpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyAmJiBwYWdlWCA+IG9mZnNldExlZnQgKyB0aGlzV2lkdGggLSBkZWFkWm9uZUhvcml6b250YWwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZy5vbGREaXNwbGF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcub2xkRGlzcGxheSA9IGRyYWdnaW5nLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVG8gYXZvaWQgZmxpY2tlciwgZGV0ZXJtaW5lIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIC8vIGJhc2VkIG9uIHdoZXJlIHRoZSBtb3VzZSBwb2ludGVyIGlzIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIHZlcnRpY2FsIGNlbnRlci5cbiAgICAgICAgICAgICAgICB2YXIgcGxhY2VBZnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50TWlkZGxlVmVydGljYWwgPSBvZmZzZXQoZWxlbWVudCkudG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE1pZGRsZUhvcml6b250YWwgPSBvZmZzZXQoZWxlbWVudCkubGVmdCArIGVsZW1lbnQub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBwbGFjZUFmdGVyID0gKG9wdGlvbnMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgKHBhZ2VZID49IGVsZW1lbnRNaWRkbGVWZXJ0aWNhbCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAob3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIChwYWdlWCA+PSBlbGVtZW50TWlkZGxlSG9yaXpvbnRhbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBwbGFjZUFmdGVyID0gcGxhY2Vob2xkZXJJbmRleCA8IHRoaXNJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWZ0ZXIoZWxlbWVudCwgc3RvcmUoc29ydGFibGVFbGVtZW50KS5wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoZWxlbWVudCwgc3RvcmUoc29ydGFibGVFbGVtZW50KS5wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldCBwbGFjZWhvbGRlcnMgZnJvbSBhbGwgc3RvcmVzICYgcmVtb3ZlIGFsbCBidXQgY3VycmVudCBvbmVcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHN0b3Jlcy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhLnBsYWNlaG9sZGVyICE9PSB1bmRlZmluZWQ7IH0pXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmVhY2ggcGxhY2Vob2xkZXIgaW4gYXJyYXkgaWYgb3V0c2lkZSBvZiBjdXJyZW50IHNvcmFibGVDb250YWluZXIgLT4gcmVtb3ZlIGZyb20gRE9NXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnBsYWNlaG9sZGVyICE9PSBzdG9yZShzb3J0YWJsZUVsZW1lbnQpLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIHBsYWNlaG9sZGVycyBmcm9tIHN0b3JlXG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVycyA9IEFycmF5LmZyb20oc3RvcmVzLnZhbHVlcygpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhLnBsYWNlaG9sZGVyICE9PSB1bmRlZmluZWQ7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGxhY2Vob2xkZXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZWxlbWVudCBpcyBub3QgaW4gcGxhY2Vob2xkZXJzXG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVycy5pbmRleE9mKGVsZW1lbnQpID09PSAtMSAmJiBzb3J0YWJsZUVsZW1lbnQgPT09IGVsZW1lbnQgJiYgIWZpbHRlcihlbGVtZW50LmNoaWxkcmVuLCBvcHRpb25zLml0ZW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQucmVtb3ZlKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHN0b3JlKHNvcnRhYmxlRWxlbWVudCkucGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5kZWJvdW5jZSk7XG4gICAgICAgIC8vIEhhbmRsZSBkcmFnb3ZlciBhbmQgZHJhZ2VudGVyIGV2ZW50cyBvbiBkcmFnZ2FibGUgaXRlbXNcbiAgICAgICAgdmFyIG9uRHJhZ092ZXJFbnRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIHNvcnRhYmxlRWxlbWVudCA9IGVsZW1lbnQuaXNTb3J0YWJsZSA9PT0gdHJ1ZSA/IGVsZW1lbnQgOiBmaW5kU29ydGFibGUoZWxlbWVudCwgZSk7XG4gICAgICAgICAgICBlbGVtZW50ID0gZmluZERyYWdFbGVtZW50KHNvcnRhYmxlRWxlbWVudCwgZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIWRyYWdnaW5nIHx8ICFsaXN0c0Nvbm5lY3RlZChzb3J0YWJsZUVsZW1lbnQsIGRyYWdnaW5nLnBhcmVudEVsZW1lbnQpIHx8IGFkZERhdGEoc29ydGFibGVFbGVtZW50LCAnX2Rpc2FibGVkJykgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gYWRkRGF0YShzb3J0YWJsZUVsZW1lbnQsICdvcHRzJyk7XG4gICAgICAgICAgICBpZiAocGFyc2VJbnQob3B0aW9ucy5tYXhJdGVtcykgJiYgZmlsdGVyKHNvcnRhYmxlRWxlbWVudC5jaGlsZHJlbiwgYWRkRGF0YShzb3J0YWJsZUVsZW1lbnQsICdpdGVtcycpKS5sZW5ndGggPiBwYXJzZUludChvcHRpb25zLm1heEl0ZW1zKSAmJiBkcmFnZ2luZy5wYXJlbnRFbGVtZW50ICE9PSBzb3J0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IHN0b3JlKHNvcnRhYmxlRWxlbWVudCkuZ2V0Q29uZmlnKCdjb3B5JykgPT09IHRydWUgPyAnY29weScgOiAnbW92ZSc7XG4gICAgICAgICAgICBkZWJvdW5jZWREcmFnT3ZlckVudGVyKHNvcnRhYmxlRWxlbWVudCwgZWxlbWVudCwgZS5wYWdlWCwgZS5wYWdlWSk7XG4gICAgICAgIH07XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIobGlzdEl0ZW1zLmNvbmNhdChzb3J0YWJsZUVsZW1lbnQpLCAnZHJhZ292ZXInLCBvbkRyYWdPdmVyRW50ZXIpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGxpc3RJdGVtcy5jb25jYXQoc29ydGFibGVFbGVtZW50KSwgJ2RyYWdlbnRlcicsIG9uRHJhZ092ZXJFbnRlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvcnRhYmxlRWxlbWVudHM7XG59XG5zb3J0YWJsZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNvcnRhYmxlRWxlbWVudCkge1xuICAgIGRlc3Ryb3lTb3J0YWJsZShzb3J0YWJsZUVsZW1lbnQpO1xufTtcbnNvcnRhYmxlLmVuYWJsZSA9IGZ1bmN0aW9uIChzb3J0YWJsZUVsZW1lbnQpIHtcbiAgICBlbmFibGVTb3J0YWJsZShzb3J0YWJsZUVsZW1lbnQpO1xufTtcbnNvcnRhYmxlLmRpc2FibGUgPSBmdW5jdGlvbiAoc29ydGFibGVFbGVtZW50KSB7XG4gICAgZGlzYWJsZVNvcnRhYmxlKHNvcnRhYmxlRWxlbWVudCk7XG59O1xuLyogU1RBUlQuVEVTVFNfT05MWSAqL1xuc29ydGFibGUuX190ZXN0aW5nID0ge1xuICAgIC8vIGFkZCBpbnRlcm5hbCBtZXRob2RzIGhlcmUgZm9yIHRlc3RpbmcgcHVycG9zZXNcbiAgICBkYXRhOiBhZGREYXRhLFxuICAgIHJlbW92ZUl0ZW1FdmVudHM6IHJlbW92ZUl0ZW1FdmVudHMsXG4gICAgcmVtb3ZlSXRlbURhdGE6IHJlbW92ZUl0ZW1EYXRhLFxuICAgIHJlbW92ZVNvcnRhYmxlRGF0YTogcmVtb3ZlU29ydGFibGVEYXRhLFxuICAgIHJlbW92ZUNvbnRhaW5lckV2ZW50czogcmVtb3ZlQ29udGFpbmVyRXZlbnRzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzb3J0YWJsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5sortable/dist/html5sortable.es.js\n");

/***/ }),

/***/ "./node_modules/laravel-echo/dist/echo.js":
/*!************************************************!*\
  !*** ./node_modules/laravel-echo/dist/echo.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar Connector = /*#__PURE__*/function () {\n  /**\r\n   * Create a new class instance.\r\n   */\n  function Connector(options) {\n    _classCallCheck(this, Connector);\n\n    /**\r\n     * Default connector options.\r\n     */\n    this._defaultOptions = {\n      auth: {\n        headers: {}\n      },\n      authEndpoint: '/broadcasting/auth',\n      broadcaster: 'pusher',\n      csrfToken: null,\n      host: null,\n      key: null,\n      namespace: 'App.Events'\n    };\n    this.setOptions(options);\n    this.connect();\n  }\n  /**\r\n   * Merge the custom options with the defaults.\r\n   */\n\n\n  _createClass(Connector, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = _extends(this._defaultOptions, options);\n\n      if (this.csrfToken()) {\n        this.options.auth.headers['X-CSRF-TOKEN'] = this.csrfToken();\n      }\n\n      return options;\n    }\n    /**\r\n     * Extract the CSRF token from the page.\r\n     */\n\n  }, {\n    key: \"csrfToken\",\n    value: function csrfToken() {\n      var selector;\n\n      if (typeof window !== 'undefined' && window['Laravel'] && window['Laravel'].csrfToken) {\n        return window['Laravel'].csrfToken;\n      } else if (this.options.csrfToken) {\n        return this.options.csrfToken;\n      } else if (typeof document !== 'undefined' && typeof document.querySelector === 'function' && (selector = document.querySelector('meta[name=\"csrf-token\"]'))) {\n        return selector.getAttribute('content');\n      }\n\n      return null;\n    }\n  }]);\n\n  return Connector;\n}();\n\n/**\r\n * This class represents a basic channel.\r\n */\nvar Channel = /*#__PURE__*/function () {\n  function Channel() {\n    _classCallCheck(this, Channel);\n  }\n\n  _createClass(Channel, [{\n    key: \"listenForWhisper\",\n\n    /**\r\n     * Listen for a whisper event on the channel instance.\r\n     */\n    value: function listenForWhisper(event, callback) {\n      return this.listen('.client-' + event, callback);\n    }\n    /**\r\n     * Listen for an event on the channel instance.\r\n     */\n\n  }, {\n    key: \"notification\",\n    value: function notification(callback) {\n      return this.listen('.Illuminate\\\\Notifications\\\\Events\\\\BroadcastNotificationCreated', callback);\n    }\n    /**\r\n     * Stop listening for a whisper event on the channel instance.\r\n     */\n\n  }, {\n    key: \"stopListeningForWhisper\",\n    value: function stopListeningForWhisper(event, callback) {\n      return this.stopListening('.client-' + event, callback);\n    }\n  }]);\n\n  return Channel;\n}();\n\n/**\r\n * Event name formatter\r\n */\nvar EventFormatter = /*#__PURE__*/function () {\n  /**\r\n   * Create a new class instance.\r\n   */\n  function EventFormatter(namespace) {\n    _classCallCheck(this, EventFormatter);\n\n    this.setNamespace(namespace);\n  }\n  /**\r\n   * Format the given event name.\r\n   */\n\n\n  _createClass(EventFormatter, [{\n    key: \"format\",\n    value: function format(event) {\n      if (event.charAt(0) === '.' || event.charAt(0) === '\\\\') {\n        return event.substr(1);\n      } else if (this.namespace) {\n        event = this.namespace + '.' + event;\n      }\n\n      return event.replace(/\\./g, '\\\\');\n    }\n    /**\r\n     * Set the event namespace.\r\n     */\n\n  }, {\n    key: \"setNamespace\",\n    value: function setNamespace(value) {\n      this.namespace = value;\n    }\n  }]);\n\n  return EventFormatter;\n}();\n\n/**\r\n * This class represents a Pusher channel.\r\n */\n\nvar PusherChannel = /*#__PURE__*/function (_Channel) {\n  _inherits(PusherChannel, _Channel);\n\n  var _super = _createSuper(PusherChannel);\n\n  /**\r\n   * Create a new class instance.\r\n   */\n  function PusherChannel(pusher, name, options) {\n    var _this;\n\n    _classCallCheck(this, PusherChannel);\n\n    _this = _super.call(this);\n    _this.name = name;\n    _this.pusher = pusher;\n    _this.options = options;\n    _this.eventFormatter = new EventFormatter(_this.options.namespace);\n\n    _this.subscribe();\n\n    return _this;\n  }\n  /**\r\n   * Subscribe to a Pusher channel.\r\n   */\n\n\n  _createClass(PusherChannel, [{\n    key: \"subscribe\",\n    value: function subscribe() {\n      this.subscription = this.pusher.subscribe(this.name);\n    }\n    /**\r\n     * Unsubscribe from a Pusher channel.\r\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      this.pusher.unsubscribe(this.name);\n    }\n    /**\r\n     * Listen for an event on the channel instance.\r\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(event, callback) {\n      this.on(this.eventFormatter.format(event), callback);\n      return this;\n    }\n    /**\r\n     * Listen for all events on the channel instance.\r\n     */\n\n  }, {\n    key: \"listenToAll\",\n    value: function listenToAll(callback) {\n      var _this2 = this;\n\n      this.subscription.bind_global(function (event, data) {\n        if (event.startsWith('pusher:')) {\n          return;\n        }\n\n        var namespace = _this2.options.namespace.replace(/\\./g, '\\\\');\n\n        var formattedEvent = event.startsWith(namespace) ? event.substring(namespace.length + 1) : '.' + event;\n        callback(formattedEvent, data);\n      });\n      return this;\n    }\n    /**\r\n     * Stop listening for an event on the channel instance.\r\n     */\n\n  }, {\n    key: \"stopListening\",\n    value: function stopListening(event, callback) {\n      if (callback) {\n        this.subscription.unbind(this.eventFormatter.format(event), callback);\n      } else {\n        this.subscription.unbind(this.eventFormatter.format(event));\n      }\n\n      return this;\n    }\n    /**\r\n     * Stop listening for all events on the channel instance.\r\n     */\n\n  }, {\n    key: \"stopListeningToAll\",\n    value: function stopListeningToAll(callback) {\n      if (callback) {\n        this.subscription.unbind_global(callback);\n      } else {\n        this.subscription.unbind_global();\n      }\n\n      return this;\n    }\n    /**\r\n     * Register a callback to be called anytime a subscription succeeds.\r\n     */\n\n  }, {\n    key: \"subscribed\",\n    value: function subscribed(callback) {\n      this.on('pusher:subscription_succeeded', function () {\n        callback();\n      });\n      return this;\n    }\n    /**\r\n     * Register a callback to be called anytime a subscription error occurs.\r\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(callback) {\n      this.on('pusher:subscription_error', function (status) {\n        callback(status);\n      });\n      return this;\n    }\n    /**\r\n     * Bind a channel to an event.\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.subscription.bind(event, callback);\n      return this;\n    }\n  }]);\n\n  return PusherChannel;\n}(Channel);\n\n/**\r\n * This class represents a Pusher private channel.\r\n */\n\nvar PusherPrivateChannel = /*#__PURE__*/function (_PusherChannel) {\n  _inherits(PusherPrivateChannel, _PusherChannel);\n\n  var _super = _createSuper(PusherPrivateChannel);\n\n  function PusherPrivateChannel() {\n    _classCallCheck(this, PusherPrivateChannel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PusherPrivateChannel, [{\n    key: \"whisper\",\n\n    /**\r\n     * Trigger client event on the channel.\r\n     */\n    value: function whisper(eventName, data) {\n      this.pusher.channels.channels[this.name].trigger(\"client-\".concat(eventName), data);\n      return this;\n    }\n  }]);\n\n  return PusherPrivateChannel;\n}(PusherChannel);\n\n/**\r\n * This class represents a Pusher private channel.\r\n */\n\nvar PusherEncryptedPrivateChannel = /*#__PURE__*/function (_PusherChannel) {\n  _inherits(PusherEncryptedPrivateChannel, _PusherChannel);\n\n  var _super = _createSuper(PusherEncryptedPrivateChannel);\n\n  function PusherEncryptedPrivateChannel() {\n    _classCallCheck(this, PusherEncryptedPrivateChannel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PusherEncryptedPrivateChannel, [{\n    key: \"whisper\",\n\n    /**\r\n     * Trigger client event on the channel.\r\n     */\n    value: function whisper(eventName, data) {\n      this.pusher.channels.channels[this.name].trigger(\"client-\".concat(eventName), data);\n      return this;\n    }\n  }]);\n\n  return PusherEncryptedPrivateChannel;\n}(PusherChannel);\n\n/**\r\n * This class represents a Pusher presence channel.\r\n */\n\nvar PusherPresenceChannel = /*#__PURE__*/function (_PusherChannel) {\n  _inherits(PusherPresenceChannel, _PusherChannel);\n\n  var _super = _createSuper(PusherPresenceChannel);\n\n  function PusherPresenceChannel() {\n    _classCallCheck(this, PusherPresenceChannel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PusherPresenceChannel, [{\n    key: \"here\",\n\n    /**\r\n     * Register a callback to be called anytime the member list changes.\r\n     */\n    value: function here(callback) {\n      this.on('pusher:subscription_succeeded', function (data) {\n        callback(Object.keys(data.members).map(function (k) {\n          return data.members[k];\n        }));\n      });\n      return this;\n    }\n    /**\r\n     * Listen for someone joining the channel.\r\n     */\n\n  }, {\n    key: \"joining\",\n    value: function joining(callback) {\n      this.on('pusher:member_added', function (member) {\n        callback(member.info);\n      });\n      return this;\n    }\n    /**\r\n     * Listen for someone leaving the channel.\r\n     */\n\n  }, {\n    key: \"leaving\",\n    value: function leaving(callback) {\n      this.on('pusher:member_removed', function (member) {\n        callback(member.info);\n      });\n      return this;\n    }\n    /**\r\n     * Trigger client event on the channel.\r\n     */\n\n  }, {\n    key: \"whisper\",\n    value: function whisper(eventName, data) {\n      this.pusher.channels.channels[this.name].trigger(\"client-\".concat(eventName), data);\n      return this;\n    }\n  }]);\n\n  return PusherPresenceChannel;\n}(PusherChannel);\n\n/**\r\n * This class represents a Socket.io channel.\r\n */\n\nvar SocketIoChannel = /*#__PURE__*/function (_Channel) {\n  _inherits(SocketIoChannel, _Channel);\n\n  var _super = _createSuper(SocketIoChannel);\n\n  /**\r\n   * Create a new class instance.\r\n   */\n  function SocketIoChannel(socket, name, options) {\n    var _this;\n\n    _classCallCheck(this, SocketIoChannel);\n\n    _this = _super.call(this);\n    /**\r\n     * The event callbacks applied to the socket.\r\n     */\n\n    _this.events = {};\n    /**\r\n     * User supplied callbacks for events on this channel.\r\n     */\n\n    _this.listeners = {};\n    _this.name = name;\n    _this.socket = socket;\n    _this.options = options;\n    _this.eventFormatter = new EventFormatter(_this.options.namespace);\n\n    _this.subscribe();\n\n    return _this;\n  }\n  /**\r\n   * Subscribe to a Socket.io channel.\r\n   */\n\n\n  _createClass(SocketIoChannel, [{\n    key: \"subscribe\",\n    value: function subscribe() {\n      this.socket.emit('subscribe', {\n        channel: this.name,\n        auth: this.options.auth || {}\n      });\n    }\n    /**\r\n     * Unsubscribe from channel and ubind event callbacks.\r\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      this.unbind();\n      this.socket.emit('unsubscribe', {\n        channel: this.name,\n        auth: this.options.auth || {}\n      });\n    }\n    /**\r\n     * Listen for an event on the channel instance.\r\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(event, callback) {\n      this.on(this.eventFormatter.format(event), callback);\n      return this;\n    }\n    /**\r\n     * Stop listening for an event on the channel instance.\r\n     */\n\n  }, {\n    key: \"stopListening\",\n    value: function stopListening(event, callback) {\n      this.unbindEvent(this.eventFormatter.format(event), callback);\n      return this;\n    }\n    /**\r\n     * Register a callback to be called anytime a subscription succeeds.\r\n     */\n\n  }, {\n    key: \"subscribed\",\n    value: function subscribed(callback) {\n      this.on('connect', function (socket) {\n        callback(socket);\n      });\n      return this;\n    }\n    /**\r\n     * Register a callback to be called anytime an error occurs.\r\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(callback) {\n      return this;\n    }\n    /**\r\n     * Bind the channel's socket to an event and store the callback.\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      var _this2 = this;\n\n      this.listeners[event] = this.listeners[event] || [];\n\n      if (!this.events[event]) {\n        this.events[event] = function (channel, data) {\n          if (_this2.name === channel && _this2.listeners[event]) {\n            _this2.listeners[event].forEach(function (cb) {\n              return cb(data);\n            });\n          }\n        };\n\n        this.socket.on(event, this.events[event]);\n      }\n\n      this.listeners[event].push(callback);\n      return this;\n    }\n    /**\r\n     * Unbind the channel's socket from all stored event callbacks.\r\n     */\n\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      var _this3 = this;\n\n      Object.keys(this.events).forEach(function (event) {\n        _this3.unbindEvent(event);\n      });\n    }\n    /**\r\n     * Unbind the listeners for the given event.\r\n     */\n\n  }, {\n    key: \"unbindEvent\",\n    value: function unbindEvent(event, callback) {\n      this.listeners[event] = this.listeners[event] || [];\n\n      if (callback) {\n        this.listeners[event] = this.listeners[event].filter(function (cb) {\n          return cb !== callback;\n        });\n      }\n\n      if (!callback || this.listeners[event].length === 0) {\n        if (this.events[event]) {\n          this.socket.removeListener(event, this.events[event]);\n          delete this.events[event];\n        }\n\n        delete this.listeners[event];\n      }\n    }\n  }]);\n\n  return SocketIoChannel;\n}(Channel);\n\n/**\r\n * This class represents a Socket.io private channel.\r\n */\n\nvar SocketIoPrivateChannel = /*#__PURE__*/function (_SocketIoChannel) {\n  _inherits(SocketIoPrivateChannel, _SocketIoChannel);\n\n  var _super = _createSuper(SocketIoPrivateChannel);\n\n  function SocketIoPrivateChannel() {\n    _classCallCheck(this, SocketIoPrivateChannel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SocketIoPrivateChannel, [{\n    key: \"whisper\",\n\n    /**\r\n     * Trigger client event on the channel.\r\n     */\n    value: function whisper(eventName, data) {\n      this.socket.emit('client event', {\n        channel: this.name,\n        event: \"client-\".concat(eventName),\n        data: data\n      });\n      return this;\n    }\n  }]);\n\n  return SocketIoPrivateChannel;\n}(SocketIoChannel);\n\n/**\r\n * This class represents a Socket.io presence channel.\r\n */\n\nvar SocketIoPresenceChannel = /*#__PURE__*/function (_SocketIoPrivateChann) {\n  _inherits(SocketIoPresenceChannel, _SocketIoPrivateChann);\n\n  var _super = _createSuper(SocketIoPresenceChannel);\n\n  function SocketIoPresenceChannel() {\n    _classCallCheck(this, SocketIoPresenceChannel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SocketIoPresenceChannel, [{\n    key: \"here\",\n\n    /**\r\n     * Register a callback to be called anytime the member list changes.\r\n     */\n    value: function here(callback) {\n      this.on('presence:subscribed', function (members) {\n        callback(members.map(function (m) {\n          return m.user_info;\n        }));\n      });\n      return this;\n    }\n    /**\r\n     * Listen for someone joining the channel.\r\n     */\n\n  }, {\n    key: \"joining\",\n    value: function joining(callback) {\n      this.on('presence:joining', function (member) {\n        return callback(member.user_info);\n      });\n      return this;\n    }\n    /**\r\n     * Listen for someone leaving the channel.\r\n     */\n\n  }, {\n    key: \"leaving\",\n    value: function leaving(callback) {\n      this.on('presence:leaving', function (member) {\n        return callback(member.user_info);\n      });\n      return this;\n    }\n  }]);\n\n  return SocketIoPresenceChannel;\n}(SocketIoPrivateChannel);\n\n/**\r\n * This class represents a null channel.\r\n */\n\nvar NullChannel = /*#__PURE__*/function (_Channel) {\n  _inherits(NullChannel, _Channel);\n\n  var _super = _createSuper(NullChannel);\n\n  function NullChannel() {\n    _classCallCheck(this, NullChannel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(NullChannel, [{\n    key: \"subscribe\",\n\n    /**\r\n     * Subscribe to a channel.\r\n     */\n    value: function subscribe() {} //\n\n    /**\r\n     * Unsubscribe from a channel.\r\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {} //\n\n    /**\r\n     * Listen for an event on the channel instance.\r\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(event, callback) {\n      return this;\n    }\n    /**\r\n     * Stop listening for an event on the channel instance.\r\n     */\n\n  }, {\n    key: \"stopListening\",\n    value: function stopListening(event, callback) {\n      return this;\n    }\n    /**\r\n     * Register a callback to be called anytime a subscription succeeds.\r\n     */\n\n  }, {\n    key: \"subscribed\",\n    value: function subscribed(callback) {\n      return this;\n    }\n    /**\r\n     * Register a callback to be called anytime an error occurs.\r\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(callback) {\n      return this;\n    }\n    /**\r\n     * Bind a channel to an event.\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      return this;\n    }\n  }]);\n\n  return NullChannel;\n}(Channel);\n\n/**\r\n * This class represents a null private channel.\r\n */\n\nvar NullPrivateChannel = /*#__PURE__*/function (_NullChannel) {\n  _inherits(NullPrivateChannel, _NullChannel);\n\n  var _super = _createSuper(NullPrivateChannel);\n\n  function NullPrivateChannel() {\n    _classCallCheck(this, NullPrivateChannel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(NullPrivateChannel, [{\n    key: \"whisper\",\n\n    /**\r\n     * Trigger client event on the channel.\r\n     */\n    value: function whisper(eventName, data) {\n      return this;\n    }\n  }]);\n\n  return NullPrivateChannel;\n}(NullChannel);\n\n/**\r\n * This class represents a null presence channel.\r\n */\n\nvar NullPresenceChannel = /*#__PURE__*/function (_NullChannel) {\n  _inherits(NullPresenceChannel, _NullChannel);\n\n  var _super = _createSuper(NullPresenceChannel);\n\n  function NullPresenceChannel() {\n    _classCallCheck(this, NullPresenceChannel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(NullPresenceChannel, [{\n    key: \"here\",\n\n    /**\r\n     * Register a callback to be called anytime the member list changes.\r\n     */\n    value: function here(callback) {\n      return this;\n    }\n    /**\r\n     * Listen for someone joining the channel.\r\n     */\n\n  }, {\n    key: \"joining\",\n    value: function joining(callback) {\n      return this;\n    }\n    /**\r\n     * Listen for someone leaving the channel.\r\n     */\n\n  }, {\n    key: \"leaving\",\n    value: function leaving(callback) {\n      return this;\n    }\n    /**\r\n     * Trigger client event on the channel.\r\n     */\n\n  }, {\n    key: \"whisper\",\n    value: function whisper(eventName, data) {\n      return this;\n    }\n  }]);\n\n  return NullPresenceChannel;\n}(NullChannel);\n\n/**\r\n * This class creates a connector to Pusher.\r\n */\n\nvar PusherConnector = /*#__PURE__*/function (_Connector) {\n  _inherits(PusherConnector, _Connector);\n\n  var _super = _createSuper(PusherConnector);\n\n  function PusherConnector() {\n    var _this;\n\n    _classCallCheck(this, PusherConnector);\n\n    _this = _super.apply(this, arguments);\n    /**\r\n     * All of the subscribed channel names.\r\n     */\n\n    _this.channels = {};\n    return _this;\n  }\n  /**\r\n   * Create a fresh Pusher connection.\r\n   */\n\n\n  _createClass(PusherConnector, [{\n    key: \"connect\",\n    value: function connect() {\n      if (typeof this.options.client !== 'undefined') {\n        this.pusher = this.options.client;\n      } else {\n        this.pusher = new Pusher(this.options.key, this.options);\n      }\n    }\n    /**\r\n     * Listen for an event on a channel instance.\r\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(name, event, callback) {\n      return this.channel(name).listen(event, callback);\n    }\n    /**\r\n     * Get a channel instance by name.\r\n     */\n\n  }, {\n    key: \"channel\",\n    value: function channel(name) {\n      if (!this.channels[name]) {\n        this.channels[name] = new PusherChannel(this.pusher, name, this.options);\n      }\n\n      return this.channels[name];\n    }\n    /**\r\n     * Get a private channel instance by name.\r\n     */\n\n  }, {\n    key: \"privateChannel\",\n    value: function privateChannel(name) {\n      if (!this.channels['private-' + name]) {\n        this.channels['private-' + name] = new PusherPrivateChannel(this.pusher, 'private-' + name, this.options);\n      }\n\n      return this.channels['private-' + name];\n    }\n    /**\r\n     * Get a private encrypted channel instance by name.\r\n     */\n\n  }, {\n    key: \"encryptedPrivateChannel\",\n    value: function encryptedPrivateChannel(name) {\n      if (!this.channels['private-encrypted-' + name]) {\n        this.channels['private-encrypted-' + name] = new PusherEncryptedPrivateChannel(this.pusher, 'private-encrypted-' + name, this.options);\n      }\n\n      return this.channels['private-encrypted-' + name];\n    }\n    /**\r\n     * Get a presence channel instance by name.\r\n     */\n\n  }, {\n    key: \"presenceChannel\",\n    value: function presenceChannel(name) {\n      if (!this.channels['presence-' + name]) {\n        this.channels['presence-' + name] = new PusherPresenceChannel(this.pusher, 'presence-' + name, this.options);\n      }\n\n      return this.channels['presence-' + name];\n    }\n    /**\r\n     * Leave the given channel, as well as its private and presence variants.\r\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(name) {\n      var _this2 = this;\n\n      var channels = [name, 'private-' + name, 'presence-' + name];\n      channels.forEach(function (name, index) {\n        _this2.leaveChannel(name);\n      });\n    }\n    /**\r\n     * Leave the given channel.\r\n     */\n\n  }, {\n    key: \"leaveChannel\",\n    value: function leaveChannel(name) {\n      if (this.channels[name]) {\n        this.channels[name].unsubscribe();\n        delete this.channels[name];\n      }\n    }\n    /**\r\n     * Get the socket ID for the connection.\r\n     */\n\n  }, {\n    key: \"socketId\",\n    value: function socketId() {\n      return this.pusher.connection.socket_id;\n    }\n    /**\r\n     * Disconnect Pusher connection.\r\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.pusher.disconnect();\n    }\n  }]);\n\n  return PusherConnector;\n}(Connector);\n\n/**\r\n * This class creates a connnector to a Socket.io server.\r\n */\n\nvar SocketIoConnector = /*#__PURE__*/function (_Connector) {\n  _inherits(SocketIoConnector, _Connector);\n\n  var _super = _createSuper(SocketIoConnector);\n\n  function SocketIoConnector() {\n    var _this;\n\n    _classCallCheck(this, SocketIoConnector);\n\n    _this = _super.apply(this, arguments);\n    /**\r\n     * All of the subscribed channel names.\r\n     */\n\n    _this.channels = {};\n    return _this;\n  }\n  /**\r\n   * Create a fresh Socket.io connection.\r\n   */\n\n\n  _createClass(SocketIoConnector, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      var io = this.getSocketIO();\n      this.socket = io(this.options.host, this.options);\n      this.socket.on('reconnect', function () {\n        Object.values(_this2.channels).forEach(function (channel) {\n          channel.subscribe();\n        });\n      });\n      return this.socket;\n    }\n    /**\r\n     * Get socket.io module from global scope or options.\r\n     */\n\n  }, {\n    key: \"getSocketIO\",\n    value: function getSocketIO() {\n      if (typeof this.options.client !== 'undefined') {\n        return this.options.client;\n      }\n\n      if (typeof io !== 'undefined') {\n        return io;\n      }\n\n      throw new Error('Socket.io client not found. Should be globally available or passed via options.client');\n    }\n    /**\r\n     * Listen for an event on a channel instance.\r\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(name, event, callback) {\n      return this.channel(name).listen(event, callback);\n    }\n    /**\r\n     * Get a channel instance by name.\r\n     */\n\n  }, {\n    key: \"channel\",\n    value: function channel(name) {\n      if (!this.channels[name]) {\n        this.channels[name] = new SocketIoChannel(this.socket, name, this.options);\n      }\n\n      return this.channels[name];\n    }\n    /**\r\n     * Get a private channel instance by name.\r\n     */\n\n  }, {\n    key: \"privateChannel\",\n    value: function privateChannel(name) {\n      if (!this.channels['private-' + name]) {\n        this.channels['private-' + name] = new SocketIoPrivateChannel(this.socket, 'private-' + name, this.options);\n      }\n\n      return this.channels['private-' + name];\n    }\n    /**\r\n     * Get a presence channel instance by name.\r\n     */\n\n  }, {\n    key: \"presenceChannel\",\n    value: function presenceChannel(name) {\n      if (!this.channels['presence-' + name]) {\n        this.channels['presence-' + name] = new SocketIoPresenceChannel(this.socket, 'presence-' + name, this.options);\n      }\n\n      return this.channels['presence-' + name];\n    }\n    /**\r\n     * Leave the given channel, as well as its private and presence variants.\r\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(name) {\n      var _this3 = this;\n\n      var channels = [name, 'private-' + name, 'presence-' + name];\n      channels.forEach(function (name) {\n        _this3.leaveChannel(name);\n      });\n    }\n    /**\r\n     * Leave the given channel.\r\n     */\n\n  }, {\n    key: \"leaveChannel\",\n    value: function leaveChannel(name) {\n      if (this.channels[name]) {\n        this.channels[name].unsubscribe();\n        delete this.channels[name];\n      }\n    }\n    /**\r\n     * Get the socket ID for the connection.\r\n     */\n\n  }, {\n    key: \"socketId\",\n    value: function socketId() {\n      return this.socket.id;\n    }\n    /**\r\n     * Disconnect Socketio connection.\r\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.socket.disconnect();\n    }\n  }]);\n\n  return SocketIoConnector;\n}(Connector);\n\n/**\r\n * This class creates a null connector.\r\n */\n\nvar NullConnector = /*#__PURE__*/function (_Connector) {\n  _inherits(NullConnector, _Connector);\n\n  var _super = _createSuper(NullConnector);\n\n  function NullConnector() {\n    var _this;\n\n    _classCallCheck(this, NullConnector);\n\n    _this = _super.apply(this, arguments);\n    /**\r\n     * All of the subscribed channel names.\r\n     */\n\n    _this.channels = {};\n    return _this;\n  }\n  /**\r\n   * Create a fresh connection.\r\n   */\n\n\n  _createClass(NullConnector, [{\n    key: \"connect\",\n    value: function connect() {} //\n\n    /**\r\n     * Listen for an event on a channel instance.\r\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(name, event, callback) {\n      return new NullChannel();\n    }\n    /**\r\n     * Get a channel instance by name.\r\n     */\n\n  }, {\n    key: \"channel\",\n    value: function channel(name) {\n      return new NullChannel();\n    }\n    /**\r\n     * Get a private channel instance by name.\r\n     */\n\n  }, {\n    key: \"privateChannel\",\n    value: function privateChannel(name) {\n      return new NullPrivateChannel();\n    }\n    /**\r\n     * Get a presence channel instance by name.\r\n     */\n\n  }, {\n    key: \"presenceChannel\",\n    value: function presenceChannel(name) {\n      return new NullPresenceChannel();\n    }\n    /**\r\n     * Leave the given channel, as well as its private and presence variants.\r\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(name) {} //\n\n    /**\r\n     * Leave the given channel.\r\n     */\n\n  }, {\n    key: \"leaveChannel\",\n    value: function leaveChannel(name) {} //\n\n    /**\r\n     * Get the socket ID for the connection.\r\n     */\n\n  }, {\n    key: \"socketId\",\n    value: function socketId() {\n      return 'fake-socket-id';\n    }\n    /**\r\n     * Disconnect the connection.\r\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {//\n    }\n  }]);\n\n  return NullConnector;\n}(Connector);\n\n/**\r\n * This class is the primary API for interacting with broadcasting.\r\n */\n\nvar Echo = /*#__PURE__*/function () {\n  /**\r\n   * Create a new class instance.\r\n   */\n  function Echo(options) {\n    _classCallCheck(this, Echo);\n\n    this.options = options;\n    this.connect();\n\n    if (!this.options.withoutInterceptors) {\n      this.registerInterceptors();\n    }\n  }\n  /**\r\n   * Get a channel instance by name.\r\n   */\n\n\n  _createClass(Echo, [{\n    key: \"channel\",\n    value: function channel(_channel) {\n      return this.connector.channel(_channel);\n    }\n    /**\r\n     * Create a new connection.\r\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      if (this.options.broadcaster == 'pusher') {\n        this.connector = new PusherConnector(this.options);\n      } else if (this.options.broadcaster == 'socket.io') {\n        this.connector = new SocketIoConnector(this.options);\n      } else if (this.options.broadcaster == 'null') {\n        this.connector = new NullConnector(this.options);\n      } else if (typeof this.options.broadcaster == 'function') {\n        this.connector = new this.options.broadcaster(this.options);\n      }\n    }\n    /**\r\n     * Disconnect from the Echo server.\r\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.connector.disconnect();\n    }\n    /**\r\n     * Get a presence channel instance by name.\r\n     */\n\n  }, {\n    key: \"join\",\n    value: function join(channel) {\n      return this.connector.presenceChannel(channel);\n    }\n    /**\r\n     * Leave the given channel, as well as its private and presence variants.\r\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(channel) {\n      this.connector.leave(channel);\n    }\n    /**\r\n     * Leave the given channel.\r\n     */\n\n  }, {\n    key: \"leaveChannel\",\n    value: function leaveChannel(channel) {\n      this.connector.leaveChannel(channel);\n    }\n    /**\r\n     * Listen for an event on a channel instance.\r\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(channel, event, callback) {\n      return this.connector.listen(channel, event, callback);\n    }\n    /**\r\n     * Get a private channel instance by name.\r\n     */\n\n  }, {\n    key: \"private\",\n    value: function _private(channel) {\n      return this.connector.privateChannel(channel);\n    }\n    /**\r\n     * Get a private encrypted channel instance by name.\r\n     */\n\n  }, {\n    key: \"encryptedPrivate\",\n    value: function encryptedPrivate(channel) {\n      return this.connector.encryptedPrivateChannel(channel);\n    }\n    /**\r\n     * Get the Socket ID for the connection.\r\n     */\n\n  }, {\n    key: \"socketId\",\n    value: function socketId() {\n      return this.connector.socketId();\n    }\n    /**\r\n     * Register 3rd party request interceptiors. These are used to automatically\r\n     * send a connections socket id to a Laravel app with a X-Socket-Id header.\r\n     */\n\n  }, {\n    key: \"registerInterceptors\",\n    value: function registerInterceptors() {\n      if (typeof Vue === 'function' && Vue.http) {\n        this.registerVueRequestInterceptor();\n      }\n\n      if (typeof axios === 'function') {\n        this.registerAxiosRequestInterceptor();\n      }\n\n      if (typeof jQuery === 'function') {\n        this.registerjQueryAjaxSetup();\n      }\n    }\n    /**\r\n     * Register a Vue HTTP interceptor to add the X-Socket-ID header.\r\n     */\n\n  }, {\n    key: \"registerVueRequestInterceptor\",\n    value: function registerVueRequestInterceptor() {\n      var _this = this;\n\n      Vue.http.interceptors.push(function (request, next) {\n        if (_this.socketId()) {\n          request.headers.set('X-Socket-ID', _this.socketId());\n        }\n\n        next();\n      });\n    }\n    /**\r\n     * Register an Axios HTTP interceptor to add the X-Socket-ID header.\r\n     */\n\n  }, {\n    key: \"registerAxiosRequestInterceptor\",\n    value: function registerAxiosRequestInterceptor() {\n      var _this2 = this;\n\n      axios.interceptors.request.use(function (config) {\n        if (_this2.socketId()) {\n          config.headers['X-Socket-Id'] = _this2.socketId();\n        }\n\n        return config;\n      });\n    }\n    /**\r\n     * Register jQuery AjaxPrefilter to add the X-Socket-ID header.\r\n     */\n\n  }, {\n    key: \"registerjQueryAjaxSetup\",\n    value: function registerjQueryAjaxSetup() {\n      var _this3 = this;\n\n      if (typeof jQuery.ajax != 'undefined') {\n        jQuery.ajaxPrefilter(function (options, originalOptions, xhr) {\n          if (_this3.socketId()) {\n            xhr.setRequestHeader('X-Socket-Id', _this3.socketId());\n          }\n        });\n      }\n    }\n  }]);\n\n  return Echo;\n}();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Echo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1lY2hvL2Rpc3QvZWNoby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sYXJhdmVsLWVjaG8vZGlzdC9lY2hvLmpzPzU2MzgiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG52YXIgQ29ubmVjdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGNsYXNzIGluc3RhbmNlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBDb25uZWN0b3Iob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25uZWN0b3IpO1xuXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IGNvbm5lY3RvciBvcHRpb25zLlxyXG4gICAgICovXG4gICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBhdXRoOiB7XG4gICAgICAgIGhlYWRlcnM6IHt9XG4gICAgICB9LFxuICAgICAgYXV0aEVuZHBvaW50OiAnL2Jyb2FkY2FzdGluZy9hdXRoJyxcbiAgICAgIGJyb2FkY2FzdGVyOiAncHVzaGVyJyxcbiAgICAgIGNzcmZUb2tlbjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBrZXk6IG51bGwsXG4gICAgICBuYW1lc3BhY2U6ICdBcHAuRXZlbnRzJ1xuICAgIH07XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIE1lcmdlIHRoZSBjdXN0b20gb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0cy5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDb25uZWN0b3IsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh0aGlzLl9kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh0aGlzLmNzcmZUb2tlbigpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5hdXRoLmhlYWRlcnNbJ1gtQ1NSRi1UT0tFTiddID0gdGhpcy5jc3JmVG9rZW4oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdCB0aGUgQ1NSRiB0b2tlbiBmcm9tIHRoZSBwYWdlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjc3JmVG9rZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3NyZlRva2VuKCkge1xuICAgICAgdmFyIHNlbGVjdG9yO1xuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93WydMYXJhdmVsJ10gJiYgd2luZG93WydMYXJhdmVsJ10uY3NyZlRva2VuKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3dbJ0xhcmF2ZWwnXS5jc3JmVG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jc3JmVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jc3JmVG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgPT09ICdmdW5jdGlvbicgJiYgKHNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpKSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb25uZWN0b3I7XG59KCk7XG5cbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBiYXNpYyBjaGFubmVsLlxyXG4gKi9cbnZhciBDaGFubmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2hhbm5lbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhbm5lbCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2hhbm5lbCwgW3tcbiAgICBrZXk6IFwibGlzdGVuRm9yV2hpc3BlclwiLFxuXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW4gZm9yIGEgd2hpc3BlciBldmVudCBvbiB0aGUgY2hhbm5lbCBpbnN0YW5jZS5cclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5Gb3JXaGlzcGVyKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuKCcuY2xpZW50LScgKyBldmVudCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIExpc3RlbiBmb3IgYW4gZXZlbnQgb24gdGhlIGNoYW5uZWwgaW5zdGFuY2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5vdGlmaWNhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3RpZmljYXRpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbignLklsbHVtaW5hdGVcXFxcTm90aWZpY2F0aW9uc1xcXFxFdmVudHNcXFxcQnJvYWRjYXN0Tm90aWZpY2F0aW9uQ3JlYXRlZCcsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYSB3aGlzcGVyIGV2ZW50IG9uIHRoZSBjaGFubmVsIGluc3RhbmNlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wTGlzdGVuaW5nRm9yV2hpc3BlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wTGlzdGVuaW5nRm9yV2hpc3BlcihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3BMaXN0ZW5pbmcoJy5jbGllbnQtJyArIGV2ZW50LCBjYWxsYmFjayk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENoYW5uZWw7XG59KCk7XG5cbi8qKlxyXG4gKiBFdmVudCBuYW1lIGZvcm1hdHRlclxyXG4gKi9cbnZhciBFdmVudEZvcm1hdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBjbGFzcyBpbnN0YW5jZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gRXZlbnRGb3JtYXR0ZXIobmFtZXNwYWNlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50Rm9ybWF0dGVyKTtcblxuICAgIHRoaXMuc2V0TmFtZXNwYWNlKG5hbWVzcGFjZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRm9ybWF0IHRoZSBnaXZlbiBldmVudCBuYW1lLlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEV2ZW50Rm9ybWF0dGVyLCBbe1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuY2hhckF0KDApID09PSAnLicgfHwgZXZlbnQuY2hhckF0KDApID09PSAnXFxcXCcpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnN1YnN0cigxKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5uYW1lc3BhY2UpIHtcbiAgICAgICAgZXZlbnQgPSB0aGlzLm5hbWVzcGFjZSArICcuJyArIGV2ZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQucmVwbGFjZSgvXFwuL2csICdcXFxcJyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBldmVudCBuYW1lc3BhY2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE5hbWVzcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROYW1lc3BhY2UodmFsdWUpIHtcbiAgICAgIHRoaXMubmFtZXNwYWNlID0gdmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV2ZW50Rm9ybWF0dGVyO1xufSgpO1xuXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgUHVzaGVyIGNoYW5uZWwuXHJcbiAqL1xuXG52YXIgUHVzaGVyQ2hhbm5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NoYW5uZWwpIHtcbiAgX2luaGVyaXRzKFB1c2hlckNoYW5uZWwsIF9DaGFubmVsKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFB1c2hlckNoYW5uZWwpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBjbGFzcyBpbnN0YW5jZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gUHVzaGVyQ2hhbm5lbChwdXNoZXIsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHVzaGVyQ2hhbm5lbCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgIF90aGlzLnB1c2hlciA9IHB1c2hlcjtcbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBfdGhpcy5ldmVudEZvcm1hdHRlciA9IG5ldyBFdmVudEZvcm1hdHRlcihfdGhpcy5vcHRpb25zLm5hbWVzcGFjZSk7XG5cbiAgICBfdGhpcy5zdWJzY3JpYmUoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBTdWJzY3JpYmUgdG8gYSBQdXNoZXIgY2hhbm5lbC5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQdXNoZXJDaGFubmVsLCBbe1xuICAgIGtleTogXCJzdWJzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlKCkge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnB1c2hlci5zdWJzY3JpYmUodGhpcy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIGEgUHVzaGVyIGNoYW5uZWwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuc3Vic2NyaWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgdGhpcy5wdXNoZXIudW5zdWJzY3JpYmUodGhpcy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW4gZm9yIGFuIGV2ZW50IG9uIHRoZSBjaGFubmVsIGluc3RhbmNlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsaXN0ZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5vbih0aGlzLmV2ZW50Rm9ybWF0dGVyLmZvcm1hdChldmVudCksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIExpc3RlbiBmb3IgYWxsIGV2ZW50cyBvbiB0aGUgY2hhbm5lbCBpbnN0YW5jZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdGVuVG9BbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuVG9BbGwoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbi5iaW5kX2dsb2JhbChmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKGV2ZW50LnN0YXJ0c1dpdGgoJ3B1c2hlcjonKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBfdGhpczIub3B0aW9ucy5uYW1lc3BhY2UucmVwbGFjZSgvXFwuL2csICdcXFxcJyk7XG5cbiAgICAgICAgdmFyIGZvcm1hdHRlZEV2ZW50ID0gZXZlbnQuc3RhcnRzV2l0aChuYW1lc3BhY2UpID8gZXZlbnQuc3Vic3RyaW5nKG5hbWVzcGFjZS5sZW5ndGggKyAxKSA6ICcuJyArIGV2ZW50O1xuICAgICAgICBjYWxsYmFjayhmb3JtYXR0ZWRFdmVudCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFN0b3AgbGlzdGVuaW5nIGZvciBhbiBldmVudCBvbiB0aGUgY2hhbm5lbCBpbnN0YW5jZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcExpc3RlbmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wTGlzdGVuaW5nKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuYmluZCh0aGlzLmV2ZW50Rm9ybWF0dGVyLmZvcm1hdChldmVudCksIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuYmluZCh0aGlzLmV2ZW50Rm9ybWF0dGVyLmZvcm1hdChldmVudCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYWxsIGV2ZW50cyBvbiB0aGUgY2hhbm5lbCBpbnN0YW5jZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcExpc3RlbmluZ1RvQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BMaXN0ZW5pbmdUb0FsbChjYWxsYmFjaykge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuYmluZF9nbG9iYWwoY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5iaW5kX2dsb2JhbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhbnl0aW1lIGEgc3Vic2NyaXB0aW9uIHN1Y2NlZWRzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZWQoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhbnl0aW1lIGEgc3Vic2NyaXB0aW9uIGVycm9yIG9jY3Vycy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oJ3B1c2hlcjpzdWJzY3JpcHRpb25fZXJyb3InLCBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgIGNhbGxiYWNrKHN0YXR1cyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEJpbmQgYSBjaGFubmVsIHRvIGFuIGV2ZW50LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmJpbmQoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQdXNoZXJDaGFubmVsO1xufShDaGFubmVsKTtcblxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIFB1c2hlciBwcml2YXRlIGNoYW5uZWwuXHJcbiAqL1xuXG52YXIgUHVzaGVyUHJpdmF0ZUNoYW5uZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXNoZXJDaGFubmVsKSB7XG4gIF9pbmhlcml0cyhQdXNoZXJQcml2YXRlQ2hhbm5lbCwgX1B1c2hlckNoYW5uZWwpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUHVzaGVyUHJpdmF0ZUNoYW5uZWwpO1xuXG4gIGZ1bmN0aW9uIFB1c2hlclByaXZhdGVDaGFubmVsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdXNoZXJQcml2YXRlQ2hhbm5lbCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUHVzaGVyUHJpdmF0ZUNoYW5uZWwsIFt7XG4gICAga2V5OiBcIndoaXNwZXJcIixcblxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlciBjbGllbnQgZXZlbnQgb24gdGhlIGNoYW5uZWwuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gd2hpc3BlcihldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgIHRoaXMucHVzaGVyLmNoYW5uZWxzLmNoYW5uZWxzW3RoaXMubmFtZV0udHJpZ2dlcihcImNsaWVudC1cIi5jb25jYXQoZXZlbnROYW1lKSwgZGF0YSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHVzaGVyUHJpdmF0ZUNoYW5uZWw7XG59KFB1c2hlckNoYW5uZWwpO1xuXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgUHVzaGVyIHByaXZhdGUgY2hhbm5lbC5cclxuICovXG5cbnZhciBQdXNoZXJFbmNyeXB0ZWRQcml2YXRlQ2hhbm5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1c2hlckNoYW5uZWwpIHtcbiAgX2luaGVyaXRzKFB1c2hlckVuY3J5cHRlZFByaXZhdGVDaGFubmVsLCBfUHVzaGVyQ2hhbm5lbCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQdXNoZXJFbmNyeXB0ZWRQcml2YXRlQ2hhbm5lbCk7XG5cbiAgZnVuY3Rpb24gUHVzaGVyRW5jcnlwdGVkUHJpdmF0ZUNoYW5uZWwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1c2hlckVuY3J5cHRlZFByaXZhdGVDaGFubmVsKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQdXNoZXJFbmNyeXB0ZWRQcml2YXRlQ2hhbm5lbCwgW3tcbiAgICBrZXk6IFwid2hpc3BlclwiLFxuXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIGNsaWVudCBldmVudCBvbiB0aGUgY2hhbm5lbC5cclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB3aGlzcGVyKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgdGhpcy5wdXNoZXIuY2hhbm5lbHMuY2hhbm5lbHNbdGhpcy5uYW1lXS50cmlnZ2VyKFwiY2xpZW50LVwiLmNvbmNhdChldmVudE5hbWUpLCBkYXRhKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQdXNoZXJFbmNyeXB0ZWRQcml2YXRlQ2hhbm5lbDtcbn0oUHVzaGVyQ2hhbm5lbCk7XG5cbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBQdXNoZXIgcHJlc2VuY2UgY2hhbm5lbC5cclxuICovXG5cbnZhciBQdXNoZXJQcmVzZW5jZUNoYW5uZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXNoZXJDaGFubmVsKSB7XG4gIF9pbmhlcml0cyhQdXNoZXJQcmVzZW5jZUNoYW5uZWwsIF9QdXNoZXJDaGFubmVsKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFB1c2hlclByZXNlbmNlQ2hhbm5lbCk7XG5cbiAgZnVuY3Rpb24gUHVzaGVyUHJlc2VuY2VDaGFubmVsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdXNoZXJQcmVzZW5jZUNoYW5uZWwpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFB1c2hlclByZXNlbmNlQ2hhbm5lbCwgW3tcbiAgICBrZXk6IFwiaGVyZVwiLFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhbnl0aW1lIHRoZSBtZW1iZXIgbGlzdCBjaGFuZ2VzLlxyXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlcmUoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgY2FsbGJhY2soT2JqZWN0LmtleXMoZGF0YS5tZW1iZXJzKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5tZW1iZXJzW2tdO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIExpc3RlbiBmb3Igc29tZW9uZSBqb2luaW5nIHRoZSBjaGFubmVsLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJqb2luaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW5pbmcoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oJ3B1c2hlcjptZW1iZXJfYWRkZWQnLCBmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgIGNhbGxiYWNrKG1lbWJlci5pbmZvKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuIGZvciBzb21lb25lIGxlYXZpbmcgdGhlIGNoYW5uZWwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxlYXZpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmluZyhjYWxsYmFjaykge1xuICAgICAgdGhpcy5vbigncHVzaGVyOm1lbWJlcl9yZW1vdmVkJywgZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgICBjYWxsYmFjayhtZW1iZXIuaW5mbyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFRyaWdnZXIgY2xpZW50IGV2ZW50IG9uIHRoZSBjaGFubmVsLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aGlzcGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdoaXNwZXIoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICB0aGlzLnB1c2hlci5jaGFubmVscy5jaGFubmVsc1t0aGlzLm5hbWVdLnRyaWdnZXIoXCJjbGllbnQtXCIuY29uY2F0KGV2ZW50TmFtZSksIGRhdGEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFB1c2hlclByZXNlbmNlQ2hhbm5lbDtcbn0oUHVzaGVyQ2hhbm5lbCk7XG5cbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBTb2NrZXQuaW8gY2hhbm5lbC5cclxuICovXG5cbnZhciBTb2NrZXRJb0NoYW5uZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaGFubmVsKSB7XG4gIF9pbmhlcml0cyhTb2NrZXRJb0NoYW5uZWwsIF9DaGFubmVsKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNvY2tldElvQ2hhbm5lbCk7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGNsYXNzIGluc3RhbmNlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBTb2NrZXRJb0NoYW5uZWwoc29ja2V0LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tldElvQ2hhbm5lbCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIC8qKlxyXG4gICAgICogVGhlIGV2ZW50IGNhbGxiYWNrcyBhcHBsaWVkIHRvIHRoZSBzb2NrZXQuXHJcbiAgICAgKi9cblxuICAgIF90aGlzLmV2ZW50cyA9IHt9O1xuICAgIC8qKlxyXG4gICAgICogVXNlciBzdXBwbGllZCBjYWxsYmFja3MgZm9yIGV2ZW50cyBvbiB0aGlzIGNoYW5uZWwuXHJcbiAgICAgKi9cblxuICAgIF90aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgIF90aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBfdGhpcy5ldmVudEZvcm1hdHRlciA9IG5ldyBFdmVudEZvcm1hdHRlcihfdGhpcy5vcHRpb25zLm5hbWVzcGFjZSk7XG5cbiAgICBfdGhpcy5zdWJzY3JpYmUoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBTdWJzY3JpYmUgdG8gYSBTb2NrZXQuaW8gY2hhbm5lbC5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTb2NrZXRJb0NoYW5uZWwsIFt7XG4gICAga2V5OiBcInN1YnNjcmliZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmUoKSB7XG4gICAgICB0aGlzLnNvY2tldC5lbWl0KCdzdWJzY3JpYmUnLCB7XG4gICAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgICAgYXV0aDogdGhpcy5vcHRpb25zLmF1dGggfHwge31cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gY2hhbm5lbCBhbmQgdWJpbmQgZXZlbnQgY2FsbGJhY2tzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnN1YnNjcmliZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICB0aGlzLnNvY2tldC5lbWl0KCd1bnN1YnNjcmliZScsIHtcbiAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgICBhdXRoOiB0aGlzLm9wdGlvbnMuYXV0aCB8fCB7fVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuIGZvciBhbiBldmVudCBvbiB0aGUgY2hhbm5lbCBpbnN0YW5jZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24odGhpcy5ldmVudEZvcm1hdHRlci5mb3JtYXQoZXZlbnQpLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYW4gZXZlbnQgb24gdGhlIGNoYW5uZWwgaW5zdGFuY2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3BMaXN0ZW5pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcExpc3RlbmluZyhldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnQodGhpcy5ldmVudEZvcm1hdHRlci5mb3JtYXQoZXZlbnQpLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhbnl0aW1lIGEgc3Vic2NyaXB0aW9uIHN1Y2NlZWRzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZWQoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIGNhbGxiYWNrKHNvY2tldCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFueXRpbWUgYW4gZXJyb3Igb2NjdXJzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQmluZCB0aGUgY2hhbm5lbCdzIHNvY2tldCB0byBhbiBldmVudCBhbmQgc3RvcmUgdGhlIGNhbGxiYWNrLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0gPSB0aGlzLmxpc3RlbmVyc1tldmVudF0gfHwgW107XG5cbiAgICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnRdKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IGZ1bmN0aW9uIChjaGFubmVsLCBkYXRhKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5uYW1lID09PSBjaGFubmVsICYmIF90aGlzMi5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICBfdGhpczIubGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICByZXR1cm4gY2IoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zb2NrZXQub24oZXZlbnQsIHRoaXMuZXZlbnRzW2V2ZW50XSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFVuYmluZCB0aGUgY2hhbm5lbCdzIHNvY2tldCBmcm9tIGFsbCBzdG9yZWQgZXZlbnQgY2FsbGJhY2tzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMudW5iaW5kRXZlbnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogVW5iaW5kIHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBldmVudC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kRXZlbnQoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0gPSB0aGlzLmxpc3RlbmVyc1tldmVudF0gfHwgW107XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0gPSB0aGlzLmxpc3RlbmVyc1tldmVudF0uZmlsdGVyKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHJldHVybiBjYiAhPT0gY2FsbGJhY2s7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbGxiYWNrIHx8IHRoaXMubGlzdGVuZXJzW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzW2V2ZW50XSkge1xuICAgICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKGV2ZW50LCB0aGlzLmV2ZW50c1tldmVudF0pO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb2NrZXRJb0NoYW5uZWw7XG59KENoYW5uZWwpO1xuXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgU29ja2V0LmlvIHByaXZhdGUgY2hhbm5lbC5cclxuICovXG5cbnZhciBTb2NrZXRJb1ByaXZhdGVDaGFubmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU29ja2V0SW9DaGFubmVsKSB7XG4gIF9pbmhlcml0cyhTb2NrZXRJb1ByaXZhdGVDaGFubmVsLCBfU29ja2V0SW9DaGFubmVsKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNvY2tldElvUHJpdmF0ZUNoYW5uZWwpO1xuXG4gIGZ1bmN0aW9uIFNvY2tldElvUHJpdmF0ZUNoYW5uZWwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tldElvUHJpdmF0ZUNoYW5uZWwpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNvY2tldElvUHJpdmF0ZUNoYW5uZWwsIFt7XG4gICAga2V5OiBcIndoaXNwZXJcIixcblxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlciBjbGllbnQgZXZlbnQgb24gdGhlIGNoYW5uZWwuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gd2hpc3BlcihldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ2NsaWVudCBldmVudCcsIHtcbiAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgICBldmVudDogXCJjbGllbnQtXCIuY29uY2F0KGV2ZW50TmFtZSksXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvY2tldElvUHJpdmF0ZUNoYW5uZWw7XG59KFNvY2tldElvQ2hhbm5lbCk7XG5cbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBTb2NrZXQuaW8gcHJlc2VuY2UgY2hhbm5lbC5cclxuICovXG5cbnZhciBTb2NrZXRJb1ByZXNlbmNlQ2hhbm5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NvY2tldElvUHJpdmF0ZUNoYW5uKSB7XG4gIF9pbmhlcml0cyhTb2NrZXRJb1ByZXNlbmNlQ2hhbm5lbCwgX1NvY2tldElvUHJpdmF0ZUNoYW5uKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNvY2tldElvUHJlc2VuY2VDaGFubmVsKTtcblxuICBmdW5jdGlvbiBTb2NrZXRJb1ByZXNlbmNlQ2hhbm5lbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU29ja2V0SW9QcmVzZW5jZUNoYW5uZWwpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNvY2tldElvUHJlc2VuY2VDaGFubmVsLCBbe1xuICAgIGtleTogXCJoZXJlXCIsXG5cbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFueXRpbWUgdGhlIG1lbWJlciBsaXN0IGNoYW5nZXMuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVyZShjYWxsYmFjaykge1xuICAgICAgdGhpcy5vbigncHJlc2VuY2U6c3Vic2NyaWJlZCcsIGZ1bmN0aW9uIChtZW1iZXJzKSB7XG4gICAgICAgIGNhbGxiYWNrKG1lbWJlcnMubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0udXNlcl9pbmZvO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIExpc3RlbiBmb3Igc29tZW9uZSBqb2luaW5nIHRoZSBjaGFubmVsLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJqb2luaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW5pbmcoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oJ3ByZXNlbmNlOmpvaW5pbmcnLCBmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhtZW1iZXIudXNlcl9pbmZvKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuIGZvciBzb21lb25lIGxlYXZpbmcgdGhlIGNoYW5uZWwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxlYXZpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmluZyhjYWxsYmFjaykge1xuICAgICAgdGhpcy5vbigncHJlc2VuY2U6bGVhdmluZycsIGZ1bmN0aW9uIChtZW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG1lbWJlci51c2VyX2luZm8pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU29ja2V0SW9QcmVzZW5jZUNoYW5uZWw7XG59KFNvY2tldElvUHJpdmF0ZUNoYW5uZWwpO1xuXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgbnVsbCBjaGFubmVsLlxyXG4gKi9cblxudmFyIE51bGxDaGFubmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2hhbm5lbCkge1xuICBfaW5oZXJpdHMoTnVsbENoYW5uZWwsIF9DaGFubmVsKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE51bGxDaGFubmVsKTtcblxuICBmdW5jdGlvbiBOdWxsQ2hhbm5lbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVsbENoYW5uZWwpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE51bGxDaGFubmVsLCBbe1xuICAgIGtleTogXCJzdWJzY3JpYmVcIixcblxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRvIGEgY2hhbm5lbC5cclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmUoKSB7fSAvL1xuXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIGEgY2hhbm5lbC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5zdWJzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7fSAvL1xuXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW4gZm9yIGFuIGV2ZW50IG9uIHRoZSBjaGFubmVsIGluc3RhbmNlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsaXN0ZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIGFuIGV2ZW50IG9uIHRoZSBjaGFubmVsIGluc3RhbmNlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wTGlzdGVuaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BMaXN0ZW5pbmcoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhbnl0aW1lIGEgc3Vic2NyaXB0aW9uIHN1Y2NlZWRzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZWQoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFueXRpbWUgYW4gZXJyb3Igb2NjdXJzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQmluZCBhIGNoYW5uZWwgdG8gYW4gZXZlbnQuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE51bGxDaGFubmVsO1xufShDaGFubmVsKTtcblxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIG51bGwgcHJpdmF0ZSBjaGFubmVsLlxyXG4gKi9cblxudmFyIE51bGxQcml2YXRlQ2hhbm5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX051bGxDaGFubmVsKSB7XG4gIF9pbmhlcml0cyhOdWxsUHJpdmF0ZUNoYW5uZWwsIF9OdWxsQ2hhbm5lbCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOdWxsUHJpdmF0ZUNoYW5uZWwpO1xuXG4gIGZ1bmN0aW9uIE51bGxQcml2YXRlQ2hhbm5lbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVsbFByaXZhdGVDaGFubmVsKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOdWxsUHJpdmF0ZUNoYW5uZWwsIFt7XG4gICAga2V5OiBcIndoaXNwZXJcIixcblxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlciBjbGllbnQgZXZlbnQgb24gdGhlIGNoYW5uZWwuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gd2hpc3BlcihldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOdWxsUHJpdmF0ZUNoYW5uZWw7XG59KE51bGxDaGFubmVsKTtcblxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIG51bGwgcHJlc2VuY2UgY2hhbm5lbC5cclxuICovXG5cbnZhciBOdWxsUHJlc2VuY2VDaGFubmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTnVsbENoYW5uZWwpIHtcbiAgX2luaGVyaXRzKE51bGxQcmVzZW5jZUNoYW5uZWwsIF9OdWxsQ2hhbm5lbCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOdWxsUHJlc2VuY2VDaGFubmVsKTtcblxuICBmdW5jdGlvbiBOdWxsUHJlc2VuY2VDaGFubmVsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOdWxsUHJlc2VuY2VDaGFubmVsKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOdWxsUHJlc2VuY2VDaGFubmVsLCBbe1xuICAgIGtleTogXCJoZXJlXCIsXG5cbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFueXRpbWUgdGhlIG1lbWJlciBsaXN0IGNoYW5nZXMuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVyZShjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuIGZvciBzb21lb25lIGpvaW5pbmcgdGhlIGNoYW5uZWwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImpvaW5pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbmluZyhjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuIGZvciBzb21lb25lIGxlYXZpbmcgdGhlIGNoYW5uZWwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxlYXZpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmluZyhjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlciBjbGllbnQgZXZlbnQgb24gdGhlIGNoYW5uZWwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndoaXNwZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2hpc3BlcihldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOdWxsUHJlc2VuY2VDaGFubmVsO1xufShOdWxsQ2hhbm5lbCk7XG5cbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGNyZWF0ZXMgYSBjb25uZWN0b3IgdG8gUHVzaGVyLlxyXG4gKi9cblxudmFyIFB1c2hlckNvbm5lY3RvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Nvbm5lY3Rvcikge1xuICBfaW5oZXJpdHMoUHVzaGVyQ29ubmVjdG9yLCBfQ29ubmVjdG9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFB1c2hlckNvbm5lY3Rvcik7XG5cbiAgZnVuY3Rpb24gUHVzaGVyQ29ubmVjdG9yKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdXNoZXJDb25uZWN0b3IpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvKipcclxuICAgICAqIEFsbCBvZiB0aGUgc3Vic2NyaWJlZCBjaGFubmVsIG5hbWVzLlxyXG4gICAgICovXG5cbiAgICBfdGhpcy5jaGFubmVscyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgYSBmcmVzaCBQdXNoZXIgY29ubmVjdGlvbi5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQdXNoZXJDb25uZWN0b3IsIFt7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmNsaWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5wdXNoZXIgPSB0aGlzLm9wdGlvbnMuY2xpZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoZXIgPSBuZXcgUHVzaGVyKHRoaXMub3B0aW9ucy5rZXksIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuIGZvciBhbiBldmVudCBvbiBhIGNoYW5uZWwgaW5zdGFuY2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxpc3RlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW4obmFtZSwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsKG5hbWUpLmxpc3RlbihldmVudCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCBhIGNoYW5uZWwgaW5zdGFuY2UgYnkgbmFtZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhbm5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFubmVsKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5jaGFubmVsc1tuYW1lXSkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzW25hbWVdID0gbmV3IFB1c2hlckNoYW5uZWwodGhpcy5wdXNoZXIsIG5hbWUsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCBhIHByaXZhdGUgY2hhbm5lbCBpbnN0YW5jZSBieSBuYW1lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcml2YXRlQ2hhbm5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcml2YXRlQ2hhbm5lbChuYW1lKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhbm5lbHNbJ3ByaXZhdGUtJyArIG5hbWVdKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHNbJ3ByaXZhdGUtJyArIG5hbWVdID0gbmV3IFB1c2hlclByaXZhdGVDaGFubmVsKHRoaXMucHVzaGVyLCAncHJpdmF0ZS0nICsgbmFtZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbJ3ByaXZhdGUtJyArIG5hbWVdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCBhIHByaXZhdGUgZW5jcnlwdGVkIGNoYW5uZWwgaW5zdGFuY2UgYnkgbmFtZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5jcnlwdGVkUHJpdmF0ZUNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5jcnlwdGVkUHJpdmF0ZUNoYW5uZWwobmFtZSkge1xuICAgICAgaWYgKCF0aGlzLmNoYW5uZWxzWydwcml2YXRlLWVuY3J5cHRlZC0nICsgbmFtZV0pIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1sncHJpdmF0ZS1lbmNyeXB0ZWQtJyArIG5hbWVdID0gbmV3IFB1c2hlckVuY3J5cHRlZFByaXZhdGVDaGFubmVsKHRoaXMucHVzaGVyLCAncHJpdmF0ZS1lbmNyeXB0ZWQtJyArIG5hbWUsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzWydwcml2YXRlLWVuY3J5cHRlZC0nICsgbmFtZV07XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgcHJlc2VuY2UgY2hhbm5lbCBpbnN0YW5jZSBieSBuYW1lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmVzZW5jZUNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlc2VuY2VDaGFubmVsKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5jaGFubmVsc1sncHJlc2VuY2UtJyArIG5hbWVdKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHNbJ3ByZXNlbmNlLScgKyBuYW1lXSA9IG5ldyBQdXNoZXJQcmVzZW5jZUNoYW5uZWwodGhpcy5wdXNoZXIsICdwcmVzZW5jZS0nICsgbmFtZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbJ3ByZXNlbmNlLScgKyBuYW1lXTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBMZWF2ZSB0aGUgZ2l2ZW4gY2hhbm5lbCwgYXMgd2VsbCBhcyBpdHMgcHJpdmF0ZSBhbmQgcHJlc2VuY2UgdmFyaWFudHMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXZlKG5hbWUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hhbm5lbHMgPSBbbmFtZSwgJ3ByaXZhdGUtJyArIG5hbWUsICdwcmVzZW5jZS0nICsgbmFtZV07XG4gICAgICBjaGFubmVscy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICAgICAgICBfdGhpczIubGVhdmVDaGFubmVsKG5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTGVhdmUgdGhlIGdpdmVuIGNoYW5uZWwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxlYXZlQ2hhbm5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWF2ZUNoYW5uZWwobmFtZSkge1xuICAgICAgaWYgKHRoaXMuY2hhbm5lbHNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tuYW1lXS51bnN1YnNjcmliZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5jaGFubmVsc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNvY2tldCBJRCBmb3IgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvY2tldElkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvY2tldElkKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIERpc2Nvbm5lY3QgUHVzaGVyIGNvbm5lY3Rpb24uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgIHRoaXMucHVzaGVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHVzaGVyQ29ubmVjdG9yO1xufShDb25uZWN0b3IpO1xuXG4vKipcclxuICogVGhpcyBjbGFzcyBjcmVhdGVzIGEgY29ubm5lY3RvciB0byBhIFNvY2tldC5pbyBzZXJ2ZXIuXHJcbiAqL1xuXG52YXIgU29ja2V0SW9Db25uZWN0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25uZWN0b3IpIHtcbiAgX2luaGVyaXRzKFNvY2tldElvQ29ubmVjdG9yLCBfQ29ubmVjdG9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNvY2tldElvQ29ubmVjdG9yKTtcblxuICBmdW5jdGlvbiBTb2NrZXRJb0Nvbm5lY3RvcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU29ja2V0SW9Db25uZWN0b3IpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvKipcclxuICAgICAqIEFsbCBvZiB0aGUgc3Vic2NyaWJlZCBjaGFubmVsIG5hbWVzLlxyXG4gICAgICovXG5cbiAgICBfdGhpcy5jaGFubmVscyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgYSBmcmVzaCBTb2NrZXQuaW8gY29ubmVjdGlvbi5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTb2NrZXRJb0Nvbm5lY3RvciwgW3tcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBpbyA9IHRoaXMuZ2V0U29ja2V0SU8oKTtcbiAgICAgIHRoaXMuc29ja2V0ID0gaW8odGhpcy5vcHRpb25zLmhvc3QsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnNvY2tldC5vbigncmVjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBPYmplY3QudmFsdWVzKF90aGlzMi5jaGFubmVscykuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5zb2NrZXQ7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IHNvY2tldC5pbyBtb2R1bGUgZnJvbSBnbG9iYWwgc2NvcGUgb3Igb3B0aW9ucy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U29ja2V0SU9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U29ja2V0SU8oKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jbGllbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xpZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gaW87XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignU29ja2V0LmlvIGNsaWVudCBub3QgZm91bmQuIFNob3VsZCBiZSBnbG9iYWxseSBhdmFpbGFibGUgb3IgcGFzc2VkIHZpYSBvcHRpb25zLmNsaWVudCcpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIExpc3RlbiBmb3IgYW4gZXZlbnQgb24gYSBjaGFubmVsIGluc3RhbmNlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsaXN0ZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKG5hbWUsIGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbChuYW1lKS5saXN0ZW4oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBjaGFubmVsIGluc3RhbmNlIGJ5IG5hbWUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbm5lbChuYW1lKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhbm5lbHNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tuYW1lXSA9IG5ldyBTb2NrZXRJb0NoYW5uZWwodGhpcy5zb2NrZXQsIG5hbWUsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCBhIHByaXZhdGUgY2hhbm5lbCBpbnN0YW5jZSBieSBuYW1lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcml2YXRlQ2hhbm5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcml2YXRlQ2hhbm5lbChuYW1lKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhbm5lbHNbJ3ByaXZhdGUtJyArIG5hbWVdKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHNbJ3ByaXZhdGUtJyArIG5hbWVdID0gbmV3IFNvY2tldElvUHJpdmF0ZUNoYW5uZWwodGhpcy5zb2NrZXQsICdwcml2YXRlLScgKyBuYW1lLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1sncHJpdmF0ZS0nICsgbmFtZV07XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgcHJlc2VuY2UgY2hhbm5lbCBpbnN0YW5jZSBieSBuYW1lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmVzZW5jZUNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlc2VuY2VDaGFubmVsKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5jaGFubmVsc1sncHJlc2VuY2UtJyArIG5hbWVdKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHNbJ3ByZXNlbmNlLScgKyBuYW1lXSA9IG5ldyBTb2NrZXRJb1ByZXNlbmNlQ2hhbm5lbCh0aGlzLnNvY2tldCwgJ3ByZXNlbmNlLScgKyBuYW1lLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1sncHJlc2VuY2UtJyArIG5hbWVdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIExlYXZlIHRoZSBnaXZlbiBjaGFubmVsLCBhcyB3ZWxsIGFzIGl0cyBwcml2YXRlIGFuZCBwcmVzZW5jZSB2YXJpYW50cy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmUobmFtZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGFubmVscyA9IFtuYW1lLCAncHJpdmF0ZS0nICsgbmFtZSwgJ3ByZXNlbmNlLScgKyBuYW1lXTtcbiAgICAgIGNoYW5uZWxzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgX3RoaXMzLmxlYXZlQ2hhbm5lbChuYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIExlYXZlIHRoZSBnaXZlbiBjaGFubmVsLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsZWF2ZUNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmVDaGFubmVsKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLmNoYW5uZWxzW25hbWVdKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHNbbmFtZV0udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzb2NrZXQgSUQgZm9yIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2NrZXRJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2NrZXRJZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pZDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEaXNjb25uZWN0IFNvY2tldGlvIGNvbm5lY3Rpb24uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU29ja2V0SW9Db25uZWN0b3I7XG59KENvbm5lY3Rvcik7XG5cbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGNyZWF0ZXMgYSBudWxsIGNvbm5lY3Rvci5cclxuICovXG5cbnZhciBOdWxsQ29ubmVjdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29ubmVjdG9yKSB7XG4gIF9pbmhlcml0cyhOdWxsQ29ubmVjdG9yLCBfQ29ubmVjdG9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE51bGxDb25uZWN0b3IpO1xuXG4gIGZ1bmN0aW9uIE51bGxDb25uZWN0b3IoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE51bGxDb25uZWN0b3IpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvKipcclxuICAgICAqIEFsbCBvZiB0aGUgc3Vic2NyaWJlZCBjaGFubmVsIG5hbWVzLlxyXG4gICAgICovXG5cbiAgICBfdGhpcy5jaGFubmVscyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgYSBmcmVzaCBjb25uZWN0aW9uLlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE51bGxDb25uZWN0b3IsIFt7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHt9IC8vXG5cbiAgICAvKipcclxuICAgICAqIExpc3RlbiBmb3IgYW4gZXZlbnQgb24gYSBjaGFubmVsIGluc3RhbmNlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsaXN0ZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKG5hbWUsIGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBOdWxsQ2hhbm5lbCgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCBhIGNoYW5uZWwgaW5zdGFuY2UgYnkgbmFtZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhbm5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFubmVsKG5hbWUpIHtcbiAgICAgIHJldHVybiBuZXcgTnVsbENoYW5uZWwoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBwcml2YXRlIGNoYW5uZWwgaW5zdGFuY2UgYnkgbmFtZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJpdmF0ZUNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpdmF0ZUNoYW5uZWwobmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBOdWxsUHJpdmF0ZUNoYW5uZWwoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBwcmVzZW5jZSBjaGFubmVsIGluc3RhbmNlIGJ5IG5hbWUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByZXNlbmNlQ2hhbm5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVzZW5jZUNoYW5uZWwobmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBOdWxsUHJlc2VuY2VDaGFubmVsKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTGVhdmUgdGhlIGdpdmVuIGNoYW5uZWwsIGFzIHdlbGwgYXMgaXRzIHByaXZhdGUgYW5kIHByZXNlbmNlIHZhcmlhbnRzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWF2ZShuYW1lKSB7fSAvL1xuXG4gICAgLyoqXHJcbiAgICAgKiBMZWF2ZSB0aGUgZ2l2ZW4gY2hhbm5lbC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGVhdmVDaGFubmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXZlQ2hhbm5lbChuYW1lKSB7fSAvL1xuXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNvY2tldCBJRCBmb3IgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvY2tldElkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvY2tldElkKCkge1xuICAgICAgcmV0dXJuICdmYWtlLXNvY2tldC1pZCc7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdCB0aGUgY29ubmVjdGlvbi5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0KCkgey8vXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE51bGxDb25uZWN0b3I7XG59KENvbm5lY3Rvcik7XG5cbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHRoZSBwcmltYXJ5IEFQSSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBicm9hZGNhc3RpbmcuXHJcbiAqL1xuXG52YXIgRWNobyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBjbGFzcyBpbnN0YW5jZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gRWNobyhvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVjaG8pO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbm5lY3QoKTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLndpdGhvdXRJbnRlcmNlcHRvcnMpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmNlcHRvcnMoKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGEgY2hhbm5lbCBpbnN0YW5jZSBieSBuYW1lLlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEVjaG8sIFt7XG4gICAga2V5OiBcImNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbm5lbChfY2hhbm5lbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLmNoYW5uZWwoX2NoYW5uZWwpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBjb25uZWN0aW9uLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJyb2FkY2FzdGVyID09ICdwdXNoZXInKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gbmV3IFB1c2hlckNvbm5lY3Rvcih0aGlzLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYnJvYWRjYXN0ZXIgPT0gJ3NvY2tldC5pbycpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBuZXcgU29ja2V0SW9Db25uZWN0b3IodGhpcy5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmJyb2FkY2FzdGVyID09ICdudWxsJykge1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBOdWxsQ29ubmVjdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYnJvYWRjYXN0ZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyB0aGlzLm9wdGlvbnMuYnJvYWRjYXN0ZXIodGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gdGhlIEVjaG8gc2VydmVyLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgcHJlc2VuY2UgY2hhbm5lbCBpbnN0YW5jZSBieSBuYW1lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4oY2hhbm5lbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLnByZXNlbmNlQ2hhbm5lbChjaGFubmVsKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBMZWF2ZSB0aGUgZ2l2ZW4gY2hhbm5lbCwgYXMgd2VsbCBhcyBpdHMgcHJpdmF0ZSBhbmQgcHJlc2VuY2UgdmFyaWFudHMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXZlKGNoYW5uZWwpIHtcbiAgICAgIHRoaXMuY29ubmVjdG9yLmxlYXZlKGNoYW5uZWwpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIExlYXZlIHRoZSBnaXZlbiBjaGFubmVsLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsZWF2ZUNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmVDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgIHRoaXMuY29ubmVjdG9yLmxlYXZlQ2hhbm5lbChjaGFubmVsKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW4gZm9yIGFuIGV2ZW50IG9uIGEgY2hhbm5lbCBpbnN0YW5jZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbihjaGFubmVsLCBldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5saXN0ZW4oY2hhbm5lbCwgZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBwcml2YXRlIGNoYW5uZWwgaW5zdGFuY2UgYnkgbmFtZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJpdmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJpdmF0ZShjaGFubmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IucHJpdmF0ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgcHJpdmF0ZSBlbmNyeXB0ZWQgY2hhbm5lbCBpbnN0YW5jZSBieSBuYW1lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmNyeXB0ZWRQcml2YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuY3J5cHRlZFByaXZhdGUoY2hhbm5lbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLmVuY3J5cHRlZFByaXZhdGVDaGFubmVsKGNoYW5uZWwpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgU29ja2V0IElEIGZvciB0aGUgY29ubmVjdGlvbi5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29ja2V0SWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ja2V0SWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3Iuc29ja2V0SWQoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciAzcmQgcGFydHkgcmVxdWVzdCBpbnRlcmNlcHRpb3JzLiBUaGVzZSBhcmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5XHJcbiAgICAgKiBzZW5kIGEgY29ubmVjdGlvbnMgc29ja2V0IGlkIHRvIGEgTGFyYXZlbCBhcHAgd2l0aCBhIFgtU29ja2V0LUlkIGhlYWRlci5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJJbnRlcmNlcHRvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJJbnRlcmNlcHRvcnMoKSB7XG4gICAgICBpZiAodHlwZW9mIFZ1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBWdWUuaHR0cCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVnVlUmVxdWVzdEludGVyY2VwdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYXhpb3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckF4aW9zUmVxdWVzdEludGVyY2VwdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgalF1ZXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJqUXVlcnlBamF4U2V0dXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIFZ1ZSBIVFRQIGludGVyY2VwdG9yIHRvIGFkZCB0aGUgWC1Tb2NrZXQtSUQgaGVhZGVyLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWdpc3RlclZ1ZVJlcXVlc3RJbnRlcmNlcHRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlclZ1ZVJlcXVlc3RJbnRlcmNlcHRvcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIFZ1ZS5odHRwLmludGVyY2VwdG9ycy5wdXNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBuZXh0KSB7XG4gICAgICAgIGlmIChfdGhpcy5zb2NrZXRJZCgpKSB7XG4gICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldCgnWC1Tb2NrZXQtSUQnLCBfdGhpcy5zb2NrZXRJZCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGFuIEF4aW9zIEhUVFAgaW50ZXJjZXB0b3IgdG8gYWRkIHRoZSBYLVNvY2tldC1JRCBoZWFkZXIuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyQXhpb3NSZXF1ZXN0SW50ZXJjZXB0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJBeGlvc1JlcXVlc3RJbnRlcmNlcHRvcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBheGlvcy5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAoX3RoaXMyLnNvY2tldElkKCkpIHtcbiAgICAgICAgICBjb25maWcuaGVhZGVyc1snWC1Tb2NrZXQtSWQnXSA9IF90aGlzMi5zb2NrZXRJZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGpRdWVyeSBBamF4UHJlZmlsdGVyIHRvIGFkZCB0aGUgWC1Tb2NrZXQtSUQgaGVhZGVyLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWdpc3RlcmpRdWVyeUFqYXhTZXR1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcmpRdWVyeUFqYXhTZXR1cCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGpRdWVyeS5hamF4ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uIChvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIHhocikge1xuICAgICAgICAgIGlmIChfdGhpczMuc29ja2V0SWQoKSkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtU29ja2V0LUlkJywgX3RoaXMzLnNvY2tldElkKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVjaG87XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEVjaG87XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/laravel-echo/dist/echo.js\n");

/***/ }),

/***/ "./resources/css/app.css":
/*!*******************************!*\
  !*** ./resources/css/app.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvY3NzL2FwcC5jc3MuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Nzcy9hcHAuY3NzPzQxY2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/css/app.css\n");

/***/ }),

/***/ "./node_modules/pusher-js/dist/web/pusher.js":
/*!***************************************************!*\
  !*** ./node_modules/pusher-js/dist/web/pusher.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/*!\n * Pusher JavaScript Library v7.0.3\n * https://pusher.com/\n *\n * Copyright 2020, Pusher\n * Released under the MIT licence.\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_669__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_669__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_669__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_669__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_669__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_669__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_669__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_669__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_669__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_669__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_669__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_669__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_669__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_669__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_669__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_669__(__nested_webpack_require_669__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package base64 implements Base64 encoding and decoding.\n */\n// Invalid character used in decoding to indicate\n// that the character to decode is out of range of\n// alphabet and cannot be decoded.\nvar INVALID_BYTE = 256;\n/**\n * Implements standard Base64 encoding.\n *\n * Operates in constant time.\n */\nvar Coder = /** @class */ (function () {\n    // TODO(dchest): methods to encode chunk-by-chunk.\n    function Coder(_paddingCharacter) {\n        if (_paddingCharacter === void 0) { _paddingCharacter = \"=\"; }\n        this._paddingCharacter = _paddingCharacter;\n    }\n    Coder.prototype.encodedLength = function (length) {\n        if (!this._paddingCharacter) {\n            return (length * 8 + 5) / 6 | 0;\n        }\n        return (length + 2) / 3 * 4 | 0;\n    };\n    Coder.prototype.encode = function (data) {\n        var out = \"\";\n        var i = 0;\n        for (; i < data.length - 2; i += 3) {\n            var c = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            out += this._encodeByte((c >>> 1 * 6) & 63);\n            out += this._encodeByte((c >>> 0 * 6) & 63);\n        }\n        var left = data.length - i;\n        if (left > 0) {\n            var c = (data[i] << 16) | (left === 2 ? data[i + 1] << 8 : 0);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            if (left === 2) {\n                out += this._encodeByte((c >>> 1 * 6) & 63);\n            }\n            else {\n                out += this._paddingCharacter || \"\";\n            }\n            out += this._paddingCharacter || \"\";\n        }\n        return out;\n    };\n    Coder.prototype.maxDecodedLength = function (length) {\n        if (!this._paddingCharacter) {\n            return (length * 6 + 7) / 8 | 0;\n        }\n        return length / 4 * 3 | 0;\n    };\n    Coder.prototype.decodedLength = function (s) {\n        return this.maxDecodedLength(s.length - this._getPaddingLength(s));\n    };\n    Coder.prototype.decode = function (s) {\n        if (s.length === 0) {\n            return new Uint8Array(0);\n        }\n        var paddingLength = this._getPaddingLength(s);\n        var length = s.length - paddingLength;\n        var out = new Uint8Array(this.maxDecodedLength(length));\n        var op = 0;\n        var i = 0;\n        var haveBad = 0;\n        var v0 = 0, v1 = 0, v2 = 0, v3 = 0;\n        for (; i < length - 4; i += 4) {\n            v0 = this._decodeChar(s.charCodeAt(i + 0));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n            haveBad |= v2 & INVALID_BYTE;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (i < length - 1) {\n            v0 = this._decodeChar(s.charCodeAt(i));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n        }\n        if (i < length - 2) {\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            haveBad |= v2 & INVALID_BYTE;\n        }\n        if (i < length - 3) {\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (haveBad !== 0) {\n            throw new Error(\"Base64Coder: incorrect characters for decoding\");\n        }\n        return out;\n    };\n    // Standard encoding have the following encoded/decoded ranges,\n    // which we need to convert between.\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   43  47\n    //\n    // Encode 6 bits in b into a new character.\n    Coder.prototype._encodeByte = function (b) {\n        // Encoding uses constant time operations as follows:\n        //\n        // 1. Define comparison of A with B using (A - B) >>> 8:\n        //          if A > B, then result is positive integer\n        //          if A <= B, then result is 0\n        //\n        // 2. Define selection of C or 0 using bitwise AND: X & C:\n        //          if X == 0, then result is 0\n        //          if X != 0, then result is C\n        //\n        // 3. Start with the smallest comparison (b >= 0), which is always\n        //    true, so set the result to the starting ASCII value (65).\n        //\n        // 4. Continue comparing b to higher ASCII values, and selecting\n        //    zero if comparison isn't true, otherwise selecting a value\n        //    to add to result, which:\n        //\n        //          a) undoes the previous addition\n        //          b) provides new value to add\n        //\n        var result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 43);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 43) - 63 + 47);\n        return String.fromCharCode(result);\n    };\n    // Decode a character code into a byte.\n    // Must return 256 if character is out of alphabet range.\n    Coder.prototype._decodeChar = function (c) {\n        // Decoding works similar to encoding: using the same comparison\n        // function, but now it works on ranges: result is always incremented\n        // by value, but this value becomes zero if the range is not\n        // satisfied.\n        //\n        // Decoding starts with invalid value, 256, which is then\n        // subtracted when the range is satisfied. If none of the ranges\n        // apply, the function returns 256, which is then checked by\n        // the caller to throw error.\n        var result = INVALID_BYTE; // start with invalid character\n        // c == 43 (c > 42 and c < 44)\n        result += (((42 - c) & (c - 44)) >>> 8) & (-INVALID_BYTE + c - 43 + 62);\n        // c == 47 (c > 46 and c < 48)\n        result += (((46 - c) & (c - 48)) >>> 8) & (-INVALID_BYTE + c - 47 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n        return result;\n    };\n    Coder.prototype._getPaddingLength = function (s) {\n        var paddingLength = 0;\n        if (this._paddingCharacter) {\n            for (var i = s.length - 1; i >= 0; i--) {\n                if (s[i] !== this._paddingCharacter) {\n                    break;\n                }\n                paddingLength++;\n            }\n            if (s.length < 4 || paddingLength > 2) {\n                throw new Error(\"Base64Coder: incorrect padding\");\n            }\n        }\n        return paddingLength;\n    };\n    return Coder;\n}());\nexports.Coder = Coder;\nvar stdCoder = new Coder();\nfunction encode(data) {\n    return stdCoder.encode(data);\n}\nexports.encode = encode;\nfunction decode(s) {\n    return stdCoder.decode(s);\n}\nexports.decode = decode;\n/**\n * Implements URL-safe Base64 encoding.\n * (Same as Base64, but '+' is replaced with '-', and '/' with '_').\n *\n * Operates in constant time.\n */\nvar URLSafeCoder = /** @class */ (function (_super) {\n    __extends(URLSafeCoder, _super);\n    function URLSafeCoder() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // URL-safe encoding have the following encoded/decoded ranges:\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   45  95\n    //\n    URLSafeCoder.prototype._encodeByte = function (b) {\n        var result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 45);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 45) - 63 + 95);\n        return String.fromCharCode(result);\n    };\n    URLSafeCoder.prototype._decodeChar = function (c) {\n        var result = INVALID_BYTE;\n        // c == 45 (c > 44 and c < 46)\n        result += (((44 - c) & (c - 46)) >>> 8) & (-INVALID_BYTE + c - 45 + 62);\n        // c == 95 (c > 94 and c < 96)\n        result += (((94 - c) & (c - 96)) >>> 8) & (-INVALID_BYTE + c - 95 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n        return result;\n    };\n    return URLSafeCoder;\n}(Coder));\nexports.URLSafeCoder = URLSafeCoder;\nvar urlSafeCoder = new URLSafeCoder();\nfunction encodeURLSafe(data) {\n    return urlSafeCoder.encode(data);\n}\nexports.encodeURLSafe = encodeURLSafe;\nfunction decodeURLSafe(s) {\n    return urlSafeCoder.decode(s);\n}\nexports.decodeURLSafe = decodeURLSafe;\nexports.encodedLength = function (length) {\n    return stdCoder.encodedLength(length);\n};\nexports.maxDecodedLength = function (length) {\n    return stdCoder.maxDecodedLength(length);\n};\nexports.decodedLength = function (s) {\n    return stdCoder.decodedLength(s);\n};\n//# sourceMappingURL=base64.js.map\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package utf8 implements UTF-8 encoding and decoding.\n */\nvar INVALID_UTF16 = \"utf8: invalid string\";\nvar INVALID_UTF8 = \"utf8: invalid source encoding\";\n/**\n * Encodes the given string into UTF-8 byte array.\n * Throws if the source string has invalid UTF-16 encoding.\n */\nfunction encode(s) {\n    // Calculate result length and allocate output array.\n    // encodedLength() also validates string and throws errors,\n    // so we don't need repeat validation here.\n    var arr = new Uint8Array(encodedLength(s));\n    var pos = 0;\n    for (var i = 0; i < s.length; i++) {\n        var c = s.charCodeAt(i);\n        if (c < 0x80) {\n            arr[pos++] = c;\n        }\n        else if (c < 0x800) {\n            arr[pos++] = 0xc0 | c >> 6;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n        else if (c < 0xd800) {\n            arr[pos++] = 0xe0 | c >> 12;\n            arr[pos++] = 0x80 | (c >> 6) & 0x3f;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n        else {\n            i++; // get one more character\n            c = (c & 0x3ff) << 10;\n            c |= s.charCodeAt(i) & 0x3ff;\n            c += 0x10000;\n            arr[pos++] = 0xf0 | c >> 18;\n            arr[pos++] = 0x80 | (c >> 12) & 0x3f;\n            arr[pos++] = 0x80 | (c >> 6) & 0x3f;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n    }\n    return arr;\n}\nexports.encode = encode;\n/**\n * Returns the number of bytes required to encode the given string into UTF-8.\n * Throws if the source string has invalid UTF-16 encoding.\n */\nfunction encodedLength(s) {\n    var result = 0;\n    for (var i = 0; i < s.length; i++) {\n        var c = s.charCodeAt(i);\n        if (c < 0x80) {\n            result += 1;\n        }\n        else if (c < 0x800) {\n            result += 2;\n        }\n        else if (c < 0xd800) {\n            result += 3;\n        }\n        else if (c <= 0xdfff) {\n            if (i >= s.length - 1) {\n                throw new Error(INVALID_UTF16);\n            }\n            i++; // \"eat\" next character\n            result += 4;\n        }\n        else {\n            throw new Error(INVALID_UTF16);\n        }\n    }\n    return result;\n}\nexports.encodedLength = encodedLength;\n/**\n * Decodes the given byte array from UTF-8 into a string.\n * Throws if encoding is invalid.\n */\nfunction decode(arr) {\n    var chars = [];\n    for (var i = 0; i < arr.length; i++) {\n        var b = arr[i];\n        if (b & 0x80) {\n            var min = void 0;\n            if (b < 0xe0) {\n                // Need 1 more byte.\n                if (i >= arr.length) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x1f) << 6 | (n1 & 0x3f);\n                min = 0x80;\n            }\n            else if (b < 0xf0) {\n                // Need 2 more bytes.\n                if (i >= arr.length - 1) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                var n2 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | (n2 & 0x3f);\n                min = 0x800;\n            }\n            else if (b < 0xf8) {\n                // Need 3 more bytes.\n                if (i >= arr.length - 2) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                var n2 = arr[++i];\n                var n3 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | (n3 & 0x3f);\n                min = 0x10000;\n            }\n            else {\n                throw new Error(INVALID_UTF8);\n            }\n            if (b < min || (b >= 0xd800 && b <= 0xdfff)) {\n                throw new Error(INVALID_UTF8);\n            }\n            if (b >= 0x10000) {\n                // Surrogate pair.\n                if (b > 0x10ffff) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b -= 0x10000;\n                chars.push(String.fromCharCode(0xd800 | (b >> 10)));\n                b = 0xdc00 | (b & 0x3ff);\n            }\n        }\n        chars.push(String.fromCharCode(b));\n    }\n    return chars.join(\"\");\n}\nexports.decode = decode;\n//# sourceMappingURL=utf8.js.map\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_19967__) {\n\n// required so we don't have to do require('pusher').default etc.\nmodule.exports = __nested_webpack_require_19967__(3).default;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_20171__) {\n\n\"use strict\";\n__nested_webpack_require_20171__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/script_receiver_factory.ts\nvar ScriptReceiverFactory = (function () {\n    function ScriptReceiverFactory(prefix, name) {\n        this.lastId = 0;\n        this.prefix = prefix;\n        this.name = name;\n    }\n    ScriptReceiverFactory.prototype.create = function (callback) {\n        this.lastId++;\n        var number = this.lastId;\n        var id = this.prefix + number;\n        var name = this.name + '[' + number + ']';\n        var called = false;\n        var callbackWrapper = function () {\n            if (!called) {\n                callback.apply(null, arguments);\n                called = true;\n            }\n        };\n        this[number] = callbackWrapper;\n        return { number: number, id: id, name: name, callback: callbackWrapper };\n    };\n    ScriptReceiverFactory.prototype.remove = function (receiver) {\n        delete this[receiver.number];\n    };\n    return ScriptReceiverFactory;\n}());\n\nvar ScriptReceivers = new ScriptReceiverFactory('_pusher_script_', 'Pusher.ScriptReceivers');\n\n// CONCATENATED MODULE: ./src/core/defaults.ts\nvar Defaults = {\n    VERSION: \"7.0.3\",\n    PROTOCOL: 7,\n    wsPort: 80,\n    wssPort: 443,\n    wsPath: '',\n    httpHost: 'sockjs.pusher.com',\n    httpPort: 80,\n    httpsPort: 443,\n    httpPath: '/pusher',\n    stats_host: 'stats.pusher.com',\n    authEndpoint: '/pusher/auth',\n    authTransport: 'ajax',\n    activityTimeout: 120000,\n    pongTimeout: 30000,\n    unavailableTimeout: 10000,\n    cluster: 'mt1',\n    cdn_http: \"http://js.pusher.com\",\n    cdn_https: \"https://js.pusher.com\",\n    dependency_suffix: \"\"\n};\n/* harmony default export */ var defaults = (Defaults);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/dependency_loader.ts\n\n\nvar dependency_loader_DependencyLoader = (function () {\n    function DependencyLoader(options) {\n        this.options = options;\n        this.receivers = options.receivers || ScriptReceivers;\n        this.loading = {};\n    }\n    DependencyLoader.prototype.load = function (name, options, callback) {\n        var self = this;\n        if (self.loading[name] && self.loading[name].length > 0) {\n            self.loading[name].push(callback);\n        }\n        else {\n            self.loading[name] = [callback];\n            var request = runtime.createScriptRequest(self.getPath(name, options));\n            var receiver = self.receivers.create(function (error) {\n                self.receivers.remove(receiver);\n                if (self.loading[name]) {\n                    var callbacks = self.loading[name];\n                    delete self.loading[name];\n                    var successCallback = function (wasSuccessful) {\n                        if (!wasSuccessful) {\n                            request.cleanup();\n                        }\n                    };\n                    for (var i = 0; i < callbacks.length; i++) {\n                        callbacks[i](error, successCallback);\n                    }\n                }\n            });\n            request.send(receiver);\n        }\n    };\n    DependencyLoader.prototype.getRoot = function (options) {\n        var cdn;\n        var protocol = runtime.getDocument().location.protocol;\n        if ((options && options.useTLS) || protocol === 'https:') {\n            cdn = this.options.cdn_https;\n        }\n        else {\n            cdn = this.options.cdn_http;\n        }\n        return cdn.replace(/\\/*$/, '') + '/' + this.options.version;\n    };\n    DependencyLoader.prototype.getPath = function (name, options) {\n        return this.getRoot(options) + '/' + name + this.options.suffix + '.js';\n    };\n    return DependencyLoader;\n}());\n/* harmony default export */ var dependency_loader = (dependency_loader_DependencyLoader);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/dependencies.ts\n\n\n\nvar DependenciesReceivers = new ScriptReceiverFactory('_pusher_dependencies', 'Pusher.DependenciesReceivers');\nvar Dependencies = new dependency_loader({\n    cdn_http: defaults.cdn_http,\n    cdn_https: defaults.cdn_https,\n    version: defaults.VERSION,\n    suffix: defaults.dependency_suffix,\n    receivers: DependenciesReceivers\n});\n\n// CONCATENATED MODULE: ./src/core/utils/url_store.ts\nvar urlStore = {\n    baseUrl: 'https://pusher.com',\n    urls: {\n        authenticationEndpoint: {\n            path: '/docs/authenticating_users'\n        },\n        javascriptQuickStart: {\n            path: '/docs/javascript_quick_start'\n        },\n        triggeringClientEvents: {\n            path: '/docs/client_api_guide/client_events#trigger-events'\n        },\n        encryptedChannelSupport: {\n            fullUrl: 'https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support'\n        }\n    }\n};\nvar buildLogSuffix = function (key) {\n    var urlPrefix = 'See:';\n    var urlObj = urlStore.urls[key];\n    if (!urlObj)\n        return '';\n    var url;\n    if (urlObj.fullUrl) {\n        url = urlObj.fullUrl;\n    }\n    else if (urlObj.path) {\n        url = urlStore.baseUrl + urlObj.path;\n    }\n    if (!url)\n        return '';\n    return urlPrefix + \" \" + url;\n};\n/* harmony default export */ var url_store = ({ buildLogSuffix: buildLogSuffix });\n\n// CONCATENATED MODULE: ./src/core/errors.ts\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar BadEventName = (function (_super) {\n    __extends(BadEventName, _super);\n    function BadEventName(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return BadEventName;\n}(Error));\n\nvar RequestTimedOut = (function (_super) {\n    __extends(RequestTimedOut, _super);\n    function RequestTimedOut(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return RequestTimedOut;\n}(Error));\n\nvar TransportPriorityTooLow = (function (_super) {\n    __extends(TransportPriorityTooLow, _super);\n    function TransportPriorityTooLow(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return TransportPriorityTooLow;\n}(Error));\n\nvar TransportClosed = (function (_super) {\n    __extends(TransportClosed, _super);\n    function TransportClosed(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return TransportClosed;\n}(Error));\n\nvar UnsupportedFeature = (function (_super) {\n    __extends(UnsupportedFeature, _super);\n    function UnsupportedFeature(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return UnsupportedFeature;\n}(Error));\n\nvar UnsupportedTransport = (function (_super) {\n    __extends(UnsupportedTransport, _super);\n    function UnsupportedTransport(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return UnsupportedTransport;\n}(Error));\n\nvar UnsupportedStrategy = (function (_super) {\n    __extends(UnsupportedStrategy, _super);\n    function UnsupportedStrategy(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return UnsupportedStrategy;\n}(Error));\n\nvar HTTPAuthError = (function (_super) {\n    __extends(HTTPAuthError, _super);\n    function HTTPAuthError(status, msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        _this.status = status;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return HTTPAuthError;\n}(Error));\n\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/auth/xhr_auth.ts\n\n\n\nvar ajax = function (context, socketId, callback) {\n    var self = this, xhr;\n    xhr = runtime.createXHR();\n    xhr.open('POST', self.options.authEndpoint, true);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    for (var headerName in this.authOptions.headers) {\n        xhr.setRequestHeader(headerName, this.authOptions.headers[headerName]);\n    }\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                var data = void 0;\n                var parsed = false;\n                try {\n                    data = JSON.parse(xhr.responseText);\n                    parsed = true;\n                }\n                catch (e) {\n                    callback(new HTTPAuthError(200, 'JSON returned from auth endpoint was invalid, yet status code was 200. Data was: ' +\n                        xhr.responseText), { auth: '' });\n                }\n                if (parsed) {\n                    callback(null, data);\n                }\n            }\n            else {\n                var suffix = url_store.buildLogSuffix('authenticationEndpoint');\n                callback(new HTTPAuthError(xhr.status, 'Unable to retrieve auth string from auth endpoint - ' +\n                    (\"received status: \" + xhr.status + \" from \" + self.options.authEndpoint + \". \") +\n                    (\"Clients must be authenticated to join private or presence channels. \" + suffix)), { auth: '' });\n            }\n        }\n    };\n    xhr.send(this.composeQuery(socketId));\n    return xhr;\n};\n/* harmony default export */ var xhr_auth = (ajax);\n\n// CONCATENATED MODULE: ./src/core/base64.ts\nfunction encode(s) {\n    return btoa(utob(s));\n}\nvar fromCharCode = String.fromCharCode;\nvar b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nvar b64tab = {};\nfor (var base64_i = 0, l = b64chars.length; base64_i < l; base64_i++) {\n    b64tab[b64chars.charAt(base64_i)] = base64_i;\n}\nvar cb_utob = function (c) {\n    var cc = c.charCodeAt(0);\n    return cc < 0x80\n        ? c\n        : cc < 0x800\n            ? fromCharCode(0xc0 | (cc >>> 6)) + fromCharCode(0x80 | (cc & 0x3f))\n            : fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) +\n                fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) +\n                fromCharCode(0x80 | (cc & 0x3f));\n};\nvar utob = function (u) {\n    return u.replace(/[^\\x00-\\x7F]/g, cb_utob);\n};\nvar cb_encode = function (ccc) {\n    var padlen = [0, 2, 1][ccc.length % 3];\n    var ord = (ccc.charCodeAt(0) << 16) |\n        ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) |\n        (ccc.length > 2 ? ccc.charCodeAt(2) : 0);\n    var chars = [\n        b64chars.charAt(ord >>> 18),\n        b64chars.charAt((ord >>> 12) & 63),\n        padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n        padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n    ];\n    return chars.join('');\n};\nvar btoa = window.btoa ||\n    function (b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n\n// CONCATENATED MODULE: ./src/core/utils/timers/abstract_timer.ts\nvar Timer = (function () {\n    function Timer(set, clear, delay, callback) {\n        var _this = this;\n        this.clear = clear;\n        this.timer = set(function () {\n            if (_this.timer) {\n                _this.timer = callback(_this.timer);\n            }\n        }, delay);\n    }\n    Timer.prototype.isRunning = function () {\n        return this.timer !== null;\n    };\n    Timer.prototype.ensureAborted = function () {\n        if (this.timer) {\n            this.clear(this.timer);\n            this.timer = null;\n        }\n    };\n    return Timer;\n}());\n/* harmony default export */ var abstract_timer = (Timer);\n\n// CONCATENATED MODULE: ./src/core/utils/timers/index.ts\nvar timers_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nfunction timers_clearTimeout(timer) {\n    window.clearTimeout(timer);\n}\nfunction timers_clearInterval(timer) {\n    window.clearInterval(timer);\n}\nvar OneOffTimer = (function (_super) {\n    timers_extends(OneOffTimer, _super);\n    function OneOffTimer(delay, callback) {\n        return _super.call(this, setTimeout, timers_clearTimeout, delay, function (timer) {\n            callback();\n            return null;\n        }) || this;\n    }\n    return OneOffTimer;\n}(abstract_timer));\n\nvar PeriodicTimer = (function (_super) {\n    timers_extends(PeriodicTimer, _super);\n    function PeriodicTimer(delay, callback) {\n        return _super.call(this, setInterval, timers_clearInterval, delay, function (timer) {\n            callback();\n            return timer;\n        }) || this;\n    }\n    return PeriodicTimer;\n}(abstract_timer));\n\n\n// CONCATENATED MODULE: ./src/core/util.ts\n\nvar Util = {\n    now: function () {\n        if (Date.now) {\n            return Date.now();\n        }\n        else {\n            return new Date().valueOf();\n        }\n    },\n    defer: function (callback) {\n        return new OneOffTimer(0, callback);\n    },\n    method: function (name) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var boundArguments = Array.prototype.slice.call(arguments, 1);\n        return function (object) {\n            return object[name].apply(object, boundArguments.concat(arguments));\n        };\n    }\n};\n/* harmony default export */ var util = (Util);\n\n// CONCATENATED MODULE: ./src/core/utils/collections.ts\n\n\nfunction extend(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < sources.length; i++) {\n        var extensions = sources[i];\n        for (var property in extensions) {\n            if (extensions[property] &&\n                extensions[property].constructor &&\n                extensions[property].constructor === Object) {\n                target[property] = extend(target[property] || {}, extensions[property]);\n            }\n            else {\n                target[property] = extensions[property];\n            }\n        }\n    }\n    return target;\n}\nfunction stringify() {\n    var m = ['Pusher'];\n    for (var i = 0; i < arguments.length; i++) {\n        if (typeof arguments[i] === 'string') {\n            m.push(arguments[i]);\n        }\n        else {\n            m.push(safeJSONStringify(arguments[i]));\n        }\n    }\n    return m.join(' : ');\n}\nfunction arrayIndexOf(array, item) {\n    var nativeIndexOf = Array.prototype.indexOf;\n    if (array === null) {\n        return -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) {\n        return array.indexOf(item);\n    }\n    for (var i = 0, l = array.length; i < l; i++) {\n        if (array[i] === item) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction objectApply(object, f) {\n    for (var key in object) {\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            f(object[key], key, object);\n        }\n    }\n}\nfunction keys(object) {\n    var keys = [];\n    objectApply(object, function (_, key) {\n        keys.push(key);\n    });\n    return keys;\n}\nfunction values(object) {\n    var values = [];\n    objectApply(object, function (value) {\n        values.push(value);\n    });\n    return values;\n}\nfunction apply(array, f, context) {\n    for (var i = 0; i < array.length; i++) {\n        f.call(context || window, array[i], i, array);\n    }\n}\nfunction map(array, f) {\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n        result.push(f(array[i], i, array, result));\n    }\n    return result;\n}\nfunction mapObject(object, f) {\n    var result = {};\n    objectApply(object, function (value, key) {\n        result[key] = f(value);\n    });\n    return result;\n}\nfunction filter(array, test) {\n    test =\n        test ||\n            function (value) {\n                return !!value;\n            };\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array, result)) {\n            result.push(array[i]);\n        }\n    }\n    return result;\n}\nfunction filterObject(object, test) {\n    var result = {};\n    objectApply(object, function (value, key) {\n        if ((test && test(value, key, object, result)) || Boolean(value)) {\n            result[key] = value;\n        }\n    });\n    return result;\n}\nfunction flatten(object) {\n    var result = [];\n    objectApply(object, function (value, key) {\n        result.push([key, value]);\n    });\n    return result;\n}\nfunction any(array, test) {\n    for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction collections_all(array, test) {\n    for (var i = 0; i < array.length; i++) {\n        if (!test(array[i], i, array)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction encodeParamsObject(data) {\n    return mapObject(data, function (value) {\n        if (typeof value === 'object') {\n            value = safeJSONStringify(value);\n        }\n        return encodeURIComponent(encode(value.toString()));\n    });\n}\nfunction buildQueryString(data) {\n    var params = filterObject(data, function (value) {\n        return value !== undefined;\n    });\n    var query = map(flatten(encodeParamsObject(params)), util.method('join', '=')).join('&');\n    return query;\n}\nfunction decycleObject(object) {\n    var objects = [], paths = [];\n    return (function derez(value, path) {\n        var i, name, nu;\n        switch (typeof value) {\n            case 'object':\n                if (!value) {\n                    return null;\n                }\n                for (i = 0; i < objects.length; i += 1) {\n                    if (objects[i] === value) {\n                        return { $ref: paths[i] };\n                    }\n                }\n                objects.push(value);\n                paths.push(path);\n                if (Object.prototype.toString.apply(value) === '[object Array]') {\n                    nu = [];\n                    for (i = 0; i < value.length; i += 1) {\n                        nu[i] = derez(value[i], path + '[' + i + ']');\n                    }\n                }\n                else {\n                    nu = {};\n                    for (name in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, name)) {\n                            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n                        }\n                    }\n                }\n                return nu;\n            case 'number':\n            case 'string':\n            case 'boolean':\n                return value;\n        }\n    })(object, '$');\n}\nfunction safeJSONStringify(source) {\n    try {\n        return JSON.stringify(source);\n    }\n    catch (e) {\n        return JSON.stringify(decycleObject(source));\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/logger.ts\n\n\nvar logger_Logger = (function () {\n    function Logger() {\n        this.globalLog = function (message) {\n            if (window.console && window.console.log) {\n                window.console.log(message);\n            }\n        };\n    }\n    Logger.prototype.debug = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.log(this.globalLog, args);\n    };\n    Logger.prototype.warn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.log(this.globalLogWarn, args);\n    };\n    Logger.prototype.error = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.log(this.globalLogError, args);\n    };\n    Logger.prototype.globalLogWarn = function (message) {\n        if (window.console && window.console.warn) {\n            window.console.warn(message);\n        }\n        else {\n            this.globalLog(message);\n        }\n    };\n    Logger.prototype.globalLogError = function (message) {\n        if (window.console && window.console.error) {\n            window.console.error(message);\n        }\n        else {\n            this.globalLogWarn(message);\n        }\n    };\n    Logger.prototype.log = function (defaultLoggingFunction) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var message = stringify.apply(this, arguments);\n        if (core_pusher.log) {\n            core_pusher.log(message);\n        }\n        else if (core_pusher.logToConsole) {\n            var log = defaultLoggingFunction.bind(this);\n            log(message);\n        }\n    };\n    return Logger;\n}());\n/* harmony default export */ var logger = (new logger_Logger());\n\n// CONCATENATED MODULE: ./src/runtimes/web/auth/jsonp_auth.ts\n\nvar jsonp = function (context, socketId, callback) {\n    if (this.authOptions.headers !== undefined) {\n        logger.warn('To send headers with the auth request, you must use AJAX, rather than JSONP.');\n    }\n    var callbackName = context.nextAuthCallbackID.toString();\n    context.nextAuthCallbackID++;\n    var document = context.getDocument();\n    var script = document.createElement('script');\n    context.auth_callbacks[callbackName] = function (data) {\n        callback(null, data);\n    };\n    var callback_name = \"Pusher.auth_callbacks['\" + callbackName + \"']\";\n    script.src =\n        this.options.authEndpoint +\n            '?callback=' +\n            encodeURIComponent(callback_name) +\n            '&' +\n            this.composeQuery(socketId);\n    var head = document.getElementsByTagName('head')[0] || document.documentElement;\n    head.insertBefore(script, head.firstChild);\n};\n/* harmony default export */ var jsonp_auth = (jsonp);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/script_request.ts\nvar ScriptRequest = (function () {\n    function ScriptRequest(src) {\n        this.src = src;\n    }\n    ScriptRequest.prototype.send = function (receiver) {\n        var self = this;\n        var errorString = 'Error loading ' + self.src;\n        self.script = document.createElement('script');\n        self.script.id = receiver.id;\n        self.script.src = self.src;\n        self.script.type = 'text/javascript';\n        self.script.charset = 'UTF-8';\n        if (self.script.addEventListener) {\n            self.script.onerror = function () {\n                receiver.callback(errorString);\n            };\n            self.script.onload = function () {\n                receiver.callback(null);\n            };\n        }\n        else {\n            self.script.onreadystatechange = function () {\n                if (self.script.readyState === 'loaded' ||\n                    self.script.readyState === 'complete') {\n                    receiver.callback(null);\n                }\n            };\n        }\n        if (self.script.async === undefined &&\n            document.attachEvent &&\n            /opera/i.test(navigator.userAgent)) {\n            self.errorScript = document.createElement('script');\n            self.errorScript.id = receiver.id + '_error';\n            self.errorScript.text = receiver.name + \"('\" + errorString + \"');\";\n            self.script.async = self.errorScript.async = false;\n        }\n        else {\n            self.script.async = true;\n        }\n        var head = document.getElementsByTagName('head')[0];\n        head.insertBefore(self.script, head.firstChild);\n        if (self.errorScript) {\n            head.insertBefore(self.errorScript, self.script.nextSibling);\n        }\n    };\n    ScriptRequest.prototype.cleanup = function () {\n        if (this.script) {\n            this.script.onload = this.script.onerror = null;\n            this.script.onreadystatechange = null;\n        }\n        if (this.script && this.script.parentNode) {\n            this.script.parentNode.removeChild(this.script);\n        }\n        if (this.errorScript && this.errorScript.parentNode) {\n            this.errorScript.parentNode.removeChild(this.errorScript);\n        }\n        this.script = null;\n        this.errorScript = null;\n    };\n    return ScriptRequest;\n}());\n/* harmony default export */ var script_request = (ScriptRequest);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/jsonp_request.ts\n\n\nvar jsonp_request_JSONPRequest = (function () {\n    function JSONPRequest(url, data) {\n        this.url = url;\n        this.data = data;\n    }\n    JSONPRequest.prototype.send = function (receiver) {\n        if (this.request) {\n            return;\n        }\n        var query = buildQueryString(this.data);\n        var url = this.url + '/' + receiver.number + '?' + query;\n        this.request = runtime.createScriptRequest(url);\n        this.request.send(receiver);\n    };\n    JSONPRequest.prototype.cleanup = function () {\n        if (this.request) {\n            this.request.cleanup();\n        }\n    };\n    return JSONPRequest;\n}());\n/* harmony default export */ var jsonp_request = (jsonp_request_JSONPRequest);\n\n// CONCATENATED MODULE: ./src/runtimes/web/timeline/jsonp_timeline.ts\n\n\nvar getAgent = function (sender, useTLS) {\n    return function (data, callback) {\n        var scheme = 'http' + (useTLS ? 's' : '') + '://';\n        var url = scheme + (sender.host || sender.options.host) + sender.options.path;\n        var request = runtime.createJSONPRequest(url, data);\n        var receiver = runtime.ScriptReceivers.create(function (error, result) {\n            ScriptReceivers.remove(receiver);\n            request.cleanup();\n            if (result && result.host) {\n                sender.host = result.host;\n            }\n            if (callback) {\n                callback(error, result);\n            }\n        });\n        request.send(receiver);\n    };\n};\nvar jsonp_timeline_jsonp = {\n    name: 'jsonp',\n    getAgent: getAgent\n};\n/* harmony default export */ var jsonp_timeline = (jsonp_timeline_jsonp);\n\n// CONCATENATED MODULE: ./src/core/transports/url_schemes.ts\n\nfunction getGenericURL(baseScheme, params, path) {\n    var scheme = baseScheme + (params.useTLS ? 's' : '');\n    var host = params.useTLS ? params.hostTLS : params.hostNonTLS;\n    return scheme + '://' + host + path;\n}\nfunction getGenericPath(key, queryString) {\n    var path = '/app/' + key;\n    var query = '?protocol=' +\n        defaults.PROTOCOL +\n        '&client=js' +\n        '&version=' +\n        defaults.VERSION +\n        (queryString ? '&' + queryString : '');\n    return path + query;\n}\nvar ws = {\n    getInitial: function (key, params) {\n        var path = (params.httpPath || '') + getGenericPath(key, 'flash=false');\n        return getGenericURL('ws', params, path);\n    }\n};\nvar http = {\n    getInitial: function (key, params) {\n        var path = (params.httpPath || '/pusher') + getGenericPath(key);\n        return getGenericURL('http', params, path);\n    }\n};\nvar sockjs = {\n    getInitial: function (key, params) {\n        return getGenericURL('http', params, params.httpPath || '/pusher');\n    },\n    getPath: function (key, params) {\n        return getGenericPath(key);\n    }\n};\n\n// CONCATENATED MODULE: ./src/core/events/callback_registry.ts\n\nvar callback_registry_CallbackRegistry = (function () {\n    function CallbackRegistry() {\n        this._callbacks = {};\n    }\n    CallbackRegistry.prototype.get = function (name) {\n        return this._callbacks[prefix(name)];\n    };\n    CallbackRegistry.prototype.add = function (name, callback, context) {\n        var prefixedEventName = prefix(name);\n        this._callbacks[prefixedEventName] =\n            this._callbacks[prefixedEventName] || [];\n        this._callbacks[prefixedEventName].push({\n            fn: callback,\n            context: context\n        });\n    };\n    CallbackRegistry.prototype.remove = function (name, callback, context) {\n        if (!name && !callback && !context) {\n            this._callbacks = {};\n            return;\n        }\n        var names = name ? [prefix(name)] : keys(this._callbacks);\n        if (callback || context) {\n            this.removeCallback(names, callback, context);\n        }\n        else {\n            this.removeAllCallbacks(names);\n        }\n    };\n    CallbackRegistry.prototype.removeCallback = function (names, callback, context) {\n        apply(names, function (name) {\n            this._callbacks[name] = filter(this._callbacks[name] || [], function (binding) {\n                return ((callback && callback !== binding.fn) ||\n                    (context && context !== binding.context));\n            });\n            if (this._callbacks[name].length === 0) {\n                delete this._callbacks[name];\n            }\n        }, this);\n    };\n    CallbackRegistry.prototype.removeAllCallbacks = function (names) {\n        apply(names, function (name) {\n            delete this._callbacks[name];\n        }, this);\n    };\n    return CallbackRegistry;\n}());\n/* harmony default export */ var callback_registry = (callback_registry_CallbackRegistry);\nfunction prefix(name) {\n    return '_' + name;\n}\n\n// CONCATENATED MODULE: ./src/core/events/dispatcher.ts\n\n\nvar dispatcher_Dispatcher = (function () {\n    function Dispatcher(failThrough) {\n        this.callbacks = new callback_registry();\n        this.global_callbacks = [];\n        this.failThrough = failThrough;\n    }\n    Dispatcher.prototype.bind = function (eventName, callback, context) {\n        this.callbacks.add(eventName, callback, context);\n        return this;\n    };\n    Dispatcher.prototype.bind_global = function (callback) {\n        this.global_callbacks.push(callback);\n        return this;\n    };\n    Dispatcher.prototype.unbind = function (eventName, callback, context) {\n        this.callbacks.remove(eventName, callback, context);\n        return this;\n    };\n    Dispatcher.prototype.unbind_global = function (callback) {\n        if (!callback) {\n            this.global_callbacks = [];\n            return this;\n        }\n        this.global_callbacks = filter(this.global_callbacks || [], function (c) { return c !== callback; });\n        return this;\n    };\n    Dispatcher.prototype.unbind_all = function () {\n        this.unbind();\n        this.unbind_global();\n        return this;\n    };\n    Dispatcher.prototype.emit = function (eventName, data, metadata) {\n        for (var i = 0; i < this.global_callbacks.length; i++) {\n            this.global_callbacks[i](eventName, data);\n        }\n        var callbacks = this.callbacks.get(eventName);\n        var args = [];\n        if (metadata) {\n            args.push(data, metadata);\n        }\n        else if (data) {\n            args.push(data);\n        }\n        if (callbacks && callbacks.length > 0) {\n            for (var i = 0; i < callbacks.length; i++) {\n                callbacks[i].fn.apply(callbacks[i].context || window, args);\n            }\n        }\n        else if (this.failThrough) {\n            this.failThrough(eventName, data);\n        }\n        return this;\n    };\n    return Dispatcher;\n}());\n/* harmony default export */ var dispatcher = (dispatcher_Dispatcher);\n\n// CONCATENATED MODULE: ./src/core/transports/transport_connection.ts\nvar transport_connection_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar transport_connection_TransportConnection = (function (_super) {\n    transport_connection_extends(TransportConnection, _super);\n    function TransportConnection(hooks, name, priority, key, options) {\n        var _this = _super.call(this) || this;\n        _this.initialize = runtime.transportConnectionInitializer;\n        _this.hooks = hooks;\n        _this.name = name;\n        _this.priority = priority;\n        _this.key = key;\n        _this.options = options;\n        _this.state = 'new';\n        _this.timeline = options.timeline;\n        _this.activityTimeout = options.activityTimeout;\n        _this.id = _this.timeline.generateUniqueID();\n        return _this;\n    }\n    TransportConnection.prototype.handlesActivityChecks = function () {\n        return Boolean(this.hooks.handlesActivityChecks);\n    };\n    TransportConnection.prototype.supportsPing = function () {\n        return Boolean(this.hooks.supportsPing);\n    };\n    TransportConnection.prototype.connect = function () {\n        var _this = this;\n        if (this.socket || this.state !== 'initialized') {\n            return false;\n        }\n        var url = this.hooks.urls.getInitial(this.key, this.options);\n        try {\n            this.socket = this.hooks.getSocket(url, this.options);\n        }\n        catch (e) {\n            util.defer(function () {\n                _this.onError(e);\n                _this.changeState('closed');\n            });\n            return false;\n        }\n        this.bindListeners();\n        logger.debug('Connecting', { transport: this.name, url: url });\n        this.changeState('connecting');\n        return true;\n    };\n    TransportConnection.prototype.close = function () {\n        if (this.socket) {\n            this.socket.close();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    TransportConnection.prototype.send = function (data) {\n        var _this = this;\n        if (this.state === 'open') {\n            util.defer(function () {\n                if (_this.socket) {\n                    _this.socket.send(data);\n                }\n            });\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    TransportConnection.prototype.ping = function () {\n        if (this.state === 'open' && this.supportsPing()) {\n            this.socket.ping();\n        }\n    };\n    TransportConnection.prototype.onOpen = function () {\n        if (this.hooks.beforeOpen) {\n            this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));\n        }\n        this.changeState('open');\n        this.socket.onopen = undefined;\n    };\n    TransportConnection.prototype.onError = function (error) {\n        this.emit('error', { type: 'WebSocketError', error: error });\n        this.timeline.error(this.buildTimelineMessage({ error: error.toString() }));\n    };\n    TransportConnection.prototype.onClose = function (closeEvent) {\n        if (closeEvent) {\n            this.changeState('closed', {\n                code: closeEvent.code,\n                reason: closeEvent.reason,\n                wasClean: closeEvent.wasClean\n            });\n        }\n        else {\n            this.changeState('closed');\n        }\n        this.unbindListeners();\n        this.socket = undefined;\n    };\n    TransportConnection.prototype.onMessage = function (message) {\n        this.emit('message', message);\n    };\n    TransportConnection.prototype.onActivity = function () {\n        this.emit('activity');\n    };\n    TransportConnection.prototype.bindListeners = function () {\n        var _this = this;\n        this.socket.onopen = function () {\n            _this.onOpen();\n        };\n        this.socket.onerror = function (error) {\n            _this.onError(error);\n        };\n        this.socket.onclose = function (closeEvent) {\n            _this.onClose(closeEvent);\n        };\n        this.socket.onmessage = function (message) {\n            _this.onMessage(message);\n        };\n        if (this.supportsPing()) {\n            this.socket.onactivity = function () {\n                _this.onActivity();\n            };\n        }\n    };\n    TransportConnection.prototype.unbindListeners = function () {\n        if (this.socket) {\n            this.socket.onopen = undefined;\n            this.socket.onerror = undefined;\n            this.socket.onclose = undefined;\n            this.socket.onmessage = undefined;\n            if (this.supportsPing()) {\n                this.socket.onactivity = undefined;\n            }\n        }\n    };\n    TransportConnection.prototype.changeState = function (state, params) {\n        this.state = state;\n        this.timeline.info(this.buildTimelineMessage({\n            state: state,\n            params: params\n        }));\n        this.emit(state, params);\n    };\n    TransportConnection.prototype.buildTimelineMessage = function (message) {\n        return extend({ cid: this.id }, message);\n    };\n    return TransportConnection;\n}(dispatcher));\n/* harmony default export */ var transport_connection = (transport_connection_TransportConnection);\n\n// CONCATENATED MODULE: ./src/core/transports/transport.ts\n\nvar transport_Transport = (function () {\n    function Transport(hooks) {\n        this.hooks = hooks;\n    }\n    Transport.prototype.isSupported = function (environment) {\n        return this.hooks.isSupported(environment);\n    };\n    Transport.prototype.createConnection = function (name, priority, key, options) {\n        return new transport_connection(this.hooks, name, priority, key, options);\n    };\n    return Transport;\n}());\n/* harmony default export */ var transports_transport = (transport_Transport);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transports.ts\n\n\n\n\nvar WSTransport = new transports_transport({\n    urls: ws,\n    handlesActivityChecks: false,\n    supportsPing: false,\n    isInitialized: function () {\n        return Boolean(runtime.getWebSocketAPI());\n    },\n    isSupported: function () {\n        return Boolean(runtime.getWebSocketAPI());\n    },\n    getSocket: function (url) {\n        return runtime.createWebSocket(url);\n    }\n});\nvar httpConfiguration = {\n    urls: http,\n    handlesActivityChecks: false,\n    supportsPing: true,\n    isInitialized: function () {\n        return true;\n    }\n};\nvar streamingConfiguration = extend({\n    getSocket: function (url) {\n        return runtime.HTTPFactory.createStreamingSocket(url);\n    }\n}, httpConfiguration);\nvar pollingConfiguration = extend({\n    getSocket: function (url) {\n        return runtime.HTTPFactory.createPollingSocket(url);\n    }\n}, httpConfiguration);\nvar xhrConfiguration = {\n    isSupported: function () {\n        return runtime.isXHRSupported();\n    }\n};\nvar XHRStreamingTransport = new transports_transport((extend({}, streamingConfiguration, xhrConfiguration)));\nvar XHRPollingTransport = new transports_transport(extend({}, pollingConfiguration, xhrConfiguration));\nvar Transports = {\n    ws: WSTransport,\n    xhr_streaming: XHRStreamingTransport,\n    xhr_polling: XHRPollingTransport\n};\n/* harmony default export */ var transports = (Transports);\n\n// CONCATENATED MODULE: ./src/runtimes/web/transports/transports.ts\n\n\n\n\n\n\nvar SockJSTransport = new transports_transport({\n    file: 'sockjs',\n    urls: sockjs,\n    handlesActivityChecks: true,\n    supportsPing: false,\n    isSupported: function () {\n        return true;\n    },\n    isInitialized: function () {\n        return window.SockJS !== undefined;\n    },\n    getSocket: function (url, options) {\n        return new window.SockJS(url, null, {\n            js_path: Dependencies.getPath('sockjs', {\n                useTLS: options.useTLS\n            }),\n            ignore_null_origin: options.ignoreNullOrigin\n        });\n    },\n    beforeOpen: function (socket, path) {\n        socket.send(JSON.stringify({\n            path: path\n        }));\n    }\n});\nvar xdrConfiguration = {\n    isSupported: function (environment) {\n        var yes = runtime.isXDRSupported(environment.useTLS);\n        return yes;\n    }\n};\nvar XDRStreamingTransport = new transports_transport((extend({}, streamingConfiguration, xdrConfiguration)));\nvar XDRPollingTransport = new transports_transport(extend({}, pollingConfiguration, xdrConfiguration));\ntransports.xdr_streaming = XDRStreamingTransport;\ntransports.xdr_polling = XDRPollingTransport;\ntransports.sockjs = SockJSTransport;\n/* harmony default export */ var transports_transports = (transports);\n\n// CONCATENATED MODULE: ./src/runtimes/web/net_info.ts\nvar net_info_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nvar NetInfo = (function (_super) {\n    net_info_extends(NetInfo, _super);\n    function NetInfo() {\n        var _this = _super.call(this) || this;\n        var self = _this;\n        if (window.addEventListener !== undefined) {\n            window.addEventListener('online', function () {\n                self.emit('online');\n            }, false);\n            window.addEventListener('offline', function () {\n                self.emit('offline');\n            }, false);\n        }\n        return _this;\n    }\n    NetInfo.prototype.isOnline = function () {\n        if (window.navigator.onLine === undefined) {\n            return true;\n        }\n        else {\n            return window.navigator.onLine;\n        }\n    };\n    return NetInfo;\n}(dispatcher));\n\nvar net_info_Network = new NetInfo();\n\n// CONCATENATED MODULE: ./src/core/transports/assistant_to_the_transport_manager.ts\n\n\nvar assistant_to_the_transport_manager_AssistantToTheTransportManager = (function () {\n    function AssistantToTheTransportManager(manager, transport, options) {\n        this.manager = manager;\n        this.transport = transport;\n        this.minPingDelay = options.minPingDelay;\n        this.maxPingDelay = options.maxPingDelay;\n        this.pingDelay = undefined;\n    }\n    AssistantToTheTransportManager.prototype.createConnection = function (name, priority, key, options) {\n        var _this = this;\n        options = extend({}, options, {\n            activityTimeout: this.pingDelay\n        });\n        var connection = this.transport.createConnection(name, priority, key, options);\n        var openTimestamp = null;\n        var onOpen = function () {\n            connection.unbind('open', onOpen);\n            connection.bind('closed', onClosed);\n            openTimestamp = util.now();\n        };\n        var onClosed = function (closeEvent) {\n            connection.unbind('closed', onClosed);\n            if (closeEvent.code === 1002 || closeEvent.code === 1003) {\n                _this.manager.reportDeath();\n            }\n            else if (!closeEvent.wasClean && openTimestamp) {\n                var lifespan = util.now() - openTimestamp;\n                if (lifespan < 2 * _this.maxPingDelay) {\n                    _this.manager.reportDeath();\n                    _this.pingDelay = Math.max(lifespan / 2, _this.minPingDelay);\n                }\n            }\n        };\n        connection.bind('open', onOpen);\n        return connection;\n    };\n    AssistantToTheTransportManager.prototype.isSupported = function (environment) {\n        return this.manager.isAlive() && this.transport.isSupported(environment);\n    };\n    return AssistantToTheTransportManager;\n}());\n/* harmony default export */ var assistant_to_the_transport_manager = (assistant_to_the_transport_manager_AssistantToTheTransportManager);\n\n// CONCATENATED MODULE: ./src/core/connection/protocol/protocol.ts\nvar Protocol = {\n    decodeMessage: function (messageEvent) {\n        try {\n            var messageData = JSON.parse(messageEvent.data);\n            var pusherEventData = messageData.data;\n            if (typeof pusherEventData === 'string') {\n                try {\n                    pusherEventData = JSON.parse(messageData.data);\n                }\n                catch (e) { }\n            }\n            var pusherEvent = {\n                event: messageData.event,\n                channel: messageData.channel,\n                data: pusherEventData\n            };\n            if (messageData.user_id) {\n                pusherEvent.user_id = messageData.user_id;\n            }\n            return pusherEvent;\n        }\n        catch (e) {\n            throw { type: 'MessageParseError', error: e, data: messageEvent.data };\n        }\n    },\n    encodeMessage: function (event) {\n        return JSON.stringify(event);\n    },\n    processHandshake: function (messageEvent) {\n        var message = Protocol.decodeMessage(messageEvent);\n        if (message.event === 'pusher:connection_established') {\n            if (!message.data.activity_timeout) {\n                throw 'No activity timeout specified in handshake';\n            }\n            return {\n                action: 'connected',\n                id: message.data.socket_id,\n                activityTimeout: message.data.activity_timeout * 1000\n            };\n        }\n        else if (message.event === 'pusher:error') {\n            return {\n                action: this.getCloseAction(message.data),\n                error: this.getCloseError(message.data)\n            };\n        }\n        else {\n            throw 'Invalid handshake';\n        }\n    },\n    getCloseAction: function (closeEvent) {\n        if (closeEvent.code < 4000) {\n            if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {\n                return 'backoff';\n            }\n            else {\n                return null;\n            }\n        }\n        else if (closeEvent.code === 4000) {\n            return 'tls_only';\n        }\n        else if (closeEvent.code < 4100) {\n            return 'refused';\n        }\n        else if (closeEvent.code < 4200) {\n            return 'backoff';\n        }\n        else if (closeEvent.code < 4300) {\n            return 'retry';\n        }\n        else {\n            return 'refused';\n        }\n    },\n    getCloseError: function (closeEvent) {\n        if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {\n            return {\n                type: 'PusherError',\n                data: {\n                    code: closeEvent.code,\n                    message: closeEvent.reason || closeEvent.message\n                }\n            };\n        }\n        else {\n            return null;\n        }\n    }\n};\n/* harmony default export */ var protocol_protocol = (Protocol);\n\n// CONCATENATED MODULE: ./src/core/connection/connection.ts\nvar connection_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\nvar connection_Connection = (function (_super) {\n    connection_extends(Connection, _super);\n    function Connection(id, transport) {\n        var _this = _super.call(this) || this;\n        _this.id = id;\n        _this.transport = transport;\n        _this.activityTimeout = transport.activityTimeout;\n        _this.bindListeners();\n        return _this;\n    }\n    Connection.prototype.handlesActivityChecks = function () {\n        return this.transport.handlesActivityChecks();\n    };\n    Connection.prototype.send = function (data) {\n        return this.transport.send(data);\n    };\n    Connection.prototype.send_event = function (name, data, channel) {\n        var event = { event: name, data: data };\n        if (channel) {\n            event.channel = channel;\n        }\n        logger.debug('Event sent', event);\n        return this.send(protocol_protocol.encodeMessage(event));\n    };\n    Connection.prototype.ping = function () {\n        if (this.transport.supportsPing()) {\n            this.transport.ping();\n        }\n        else {\n            this.send_event('pusher:ping', {});\n        }\n    };\n    Connection.prototype.close = function () {\n        this.transport.close();\n    };\n    Connection.prototype.bindListeners = function () {\n        var _this = this;\n        var listeners = {\n            message: function (messageEvent) {\n                var pusherEvent;\n                try {\n                    pusherEvent = protocol_protocol.decodeMessage(messageEvent);\n                }\n                catch (e) {\n                    _this.emit('error', {\n                        type: 'MessageParseError',\n                        error: e,\n                        data: messageEvent.data\n                    });\n                }\n                if (pusherEvent !== undefined) {\n                    logger.debug('Event recd', pusherEvent);\n                    switch (pusherEvent.event) {\n                        case 'pusher:error':\n                            _this.emit('error', {\n                                type: 'PusherError',\n                                data: pusherEvent.data\n                            });\n                            break;\n                        case 'pusher:ping':\n                            _this.emit('ping');\n                            break;\n                        case 'pusher:pong':\n                            _this.emit('pong');\n                            break;\n                    }\n                    _this.emit('message', pusherEvent);\n                }\n            },\n            activity: function () {\n                _this.emit('activity');\n            },\n            error: function (error) {\n                _this.emit('error', error);\n            },\n            closed: function (closeEvent) {\n                unbindListeners();\n                if (closeEvent && closeEvent.code) {\n                    _this.handleCloseEvent(closeEvent);\n                }\n                _this.transport = null;\n                _this.emit('closed');\n            }\n        };\n        var unbindListeners = function () {\n            objectApply(listeners, function (listener, event) {\n                _this.transport.unbind(event, listener);\n            });\n        };\n        objectApply(listeners, function (listener, event) {\n            _this.transport.bind(event, listener);\n        });\n    };\n    Connection.prototype.handleCloseEvent = function (closeEvent) {\n        var action = protocol_protocol.getCloseAction(closeEvent);\n        var error = protocol_protocol.getCloseError(closeEvent);\n        if (error) {\n            this.emit('error', error);\n        }\n        if (action) {\n            this.emit(action, { action: action, error: error });\n        }\n    };\n    return Connection;\n}(dispatcher));\n/* harmony default export */ var connection_connection = (connection_Connection);\n\n// CONCATENATED MODULE: ./src/core/connection/handshake/index.ts\n\n\n\nvar handshake_Handshake = (function () {\n    function Handshake(transport, callback) {\n        this.transport = transport;\n        this.callback = callback;\n        this.bindListeners();\n    }\n    Handshake.prototype.close = function () {\n        this.unbindListeners();\n        this.transport.close();\n    };\n    Handshake.prototype.bindListeners = function () {\n        var _this = this;\n        this.onMessage = function (m) {\n            _this.unbindListeners();\n            var result;\n            try {\n                result = protocol_protocol.processHandshake(m);\n            }\n            catch (e) {\n                _this.finish('error', { error: e });\n                _this.transport.close();\n                return;\n            }\n            if (result.action === 'connected') {\n                _this.finish('connected', {\n                    connection: new connection_connection(result.id, _this.transport),\n                    activityTimeout: result.activityTimeout\n                });\n            }\n            else {\n                _this.finish(result.action, { error: result.error });\n                _this.transport.close();\n            }\n        };\n        this.onClosed = function (closeEvent) {\n            _this.unbindListeners();\n            var action = protocol_protocol.getCloseAction(closeEvent) || 'backoff';\n            var error = protocol_protocol.getCloseError(closeEvent);\n            _this.finish(action, { error: error });\n        };\n        this.transport.bind('message', this.onMessage);\n        this.transport.bind('closed', this.onClosed);\n    };\n    Handshake.prototype.unbindListeners = function () {\n        this.transport.unbind('message', this.onMessage);\n        this.transport.unbind('closed', this.onClosed);\n    };\n    Handshake.prototype.finish = function (action, params) {\n        this.callback(extend({ transport: this.transport, action: action }, params));\n    };\n    return Handshake;\n}());\n/* harmony default export */ var connection_handshake = (handshake_Handshake);\n\n// CONCATENATED MODULE: ./src/core/auth/pusher_authorizer.ts\n\nvar pusher_authorizer_PusherAuthorizer = (function () {\n    function PusherAuthorizer(channel, options) {\n        this.channel = channel;\n        var authTransport = options.authTransport;\n        if (typeof runtime.getAuthorizers()[authTransport] === 'undefined') {\n            throw \"'\" + authTransport + \"' is not a recognized auth transport\";\n        }\n        this.type = authTransport;\n        this.options = options;\n        this.authOptions = options.auth || {};\n    }\n    PusherAuthorizer.prototype.composeQuery = function (socketId) {\n        var query = 'socket_id=' +\n            encodeURIComponent(socketId) +\n            '&channel_name=' +\n            encodeURIComponent(this.channel.name);\n        for (var i in this.authOptions.params) {\n            query +=\n                '&' +\n                    encodeURIComponent(i) +\n                    '=' +\n                    encodeURIComponent(this.authOptions.params[i]);\n        }\n        return query;\n    };\n    PusherAuthorizer.prototype.authorize = function (socketId, callback) {\n        PusherAuthorizer.authorizers =\n            PusherAuthorizer.authorizers || runtime.getAuthorizers();\n        PusherAuthorizer.authorizers[this.type].call(this, runtime, socketId, callback);\n    };\n    return PusherAuthorizer;\n}());\n/* harmony default export */ var pusher_authorizer = (pusher_authorizer_PusherAuthorizer);\n\n// CONCATENATED MODULE: ./src/core/timeline/timeline_sender.ts\n\nvar timeline_sender_TimelineSender = (function () {\n    function TimelineSender(timeline, options) {\n        this.timeline = timeline;\n        this.options = options || {};\n    }\n    TimelineSender.prototype.send = function (useTLS, callback) {\n        if (this.timeline.isEmpty()) {\n            return;\n        }\n        this.timeline.send(runtime.TimelineTransport.getAgent(this, useTLS), callback);\n    };\n    return TimelineSender;\n}());\n/* harmony default export */ var timeline_sender = (timeline_sender_TimelineSender);\n\n// CONCATENATED MODULE: ./src/core/channels/channel.ts\nvar channel_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar channel_Channel = (function (_super) {\n    channel_extends(Channel, _super);\n    function Channel(name, pusher) {\n        var _this = _super.call(this, function (event, data) {\n            logger.debug('No callbacks on ' + name + ' for ' + event);\n        }) || this;\n        _this.name = name;\n        _this.pusher = pusher;\n        _this.subscribed = false;\n        _this.subscriptionPending = false;\n        _this.subscriptionCancelled = false;\n        return _this;\n    }\n    Channel.prototype.authorize = function (socketId, callback) {\n        return callback(null, { auth: '' });\n    };\n    Channel.prototype.trigger = function (event, data) {\n        if (event.indexOf('client-') !== 0) {\n            throw new BadEventName(\"Event '\" + event + \"' does not start with 'client-'\");\n        }\n        if (!this.subscribed) {\n            var suffix = url_store.buildLogSuffix('triggeringClientEvents');\n            logger.warn(\"Client event triggered before channel 'subscription_succeeded' event . \" + suffix);\n        }\n        return this.pusher.send_event(event, data, this.name);\n    };\n    Channel.prototype.disconnect = function () {\n        this.subscribed = false;\n        this.subscriptionPending = false;\n    };\n    Channel.prototype.handleEvent = function (event) {\n        var eventName = event.event;\n        var data = event.data;\n        if (eventName === 'pusher_internal:subscription_succeeded') {\n            this.handleSubscriptionSucceededEvent(event);\n        }\n        else if (eventName.indexOf('pusher_internal:') !== 0) {\n            var metadata = {};\n            this.emit(eventName, data, metadata);\n        }\n    };\n    Channel.prototype.handleSubscriptionSucceededEvent = function (event) {\n        this.subscriptionPending = false;\n        this.subscribed = true;\n        if (this.subscriptionCancelled) {\n            this.pusher.unsubscribe(this.name);\n        }\n        else {\n            this.emit('pusher:subscription_succeeded', event.data);\n        }\n    };\n    Channel.prototype.subscribe = function () {\n        var _this = this;\n        if (this.subscribed) {\n            return;\n        }\n        this.subscriptionPending = true;\n        this.subscriptionCancelled = false;\n        this.authorize(this.pusher.connection.socket_id, function (error, data) {\n            if (error) {\n                _this.subscriptionPending = false;\n                logger.error(error.toString());\n                _this.emit('pusher:subscription_error', Object.assign({}, {\n                    type: 'AuthError',\n                    error: error.message\n                }, error instanceof HTTPAuthError ? { status: error.status } : {}));\n            }\n            else {\n                _this.pusher.send_event('pusher:subscribe', {\n                    auth: data.auth,\n                    channel_data: data.channel_data,\n                    channel: _this.name\n                });\n            }\n        });\n    };\n    Channel.prototype.unsubscribe = function () {\n        this.subscribed = false;\n        this.pusher.send_event('pusher:unsubscribe', {\n            channel: this.name\n        });\n    };\n    Channel.prototype.cancelSubscription = function () {\n        this.subscriptionCancelled = true;\n    };\n    Channel.prototype.reinstateSubscription = function () {\n        this.subscriptionCancelled = false;\n    };\n    return Channel;\n}(dispatcher));\n/* harmony default export */ var channels_channel = (channel_Channel);\n\n// CONCATENATED MODULE: ./src/core/channels/private_channel.ts\nvar private_channel_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar private_channel_PrivateChannel = (function (_super) {\n    private_channel_extends(PrivateChannel, _super);\n    function PrivateChannel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PrivateChannel.prototype.authorize = function (socketId, callback) {\n        var authorizer = factory.createAuthorizer(this, this.pusher.config);\n        return authorizer.authorize(socketId, callback);\n    };\n    return PrivateChannel;\n}(channels_channel));\n/* harmony default export */ var private_channel = (private_channel_PrivateChannel);\n\n// CONCATENATED MODULE: ./src/core/channels/members.ts\n\nvar members_Members = (function () {\n    function Members() {\n        this.reset();\n    }\n    Members.prototype.get = function (id) {\n        if (Object.prototype.hasOwnProperty.call(this.members, id)) {\n            return {\n                id: id,\n                info: this.members[id]\n            };\n        }\n        else {\n            return null;\n        }\n    };\n    Members.prototype.each = function (callback) {\n        var _this = this;\n        objectApply(this.members, function (member, id) {\n            callback(_this.get(id));\n        });\n    };\n    Members.prototype.setMyID = function (id) {\n        this.myID = id;\n    };\n    Members.prototype.onSubscription = function (subscriptionData) {\n        this.members = subscriptionData.presence.hash;\n        this.count = subscriptionData.presence.count;\n        this.me = this.get(this.myID);\n    };\n    Members.prototype.addMember = function (memberData) {\n        if (this.get(memberData.user_id) === null) {\n            this.count++;\n        }\n        this.members[memberData.user_id] = memberData.user_info;\n        return this.get(memberData.user_id);\n    };\n    Members.prototype.removeMember = function (memberData) {\n        var member = this.get(memberData.user_id);\n        if (member) {\n            delete this.members[memberData.user_id];\n            this.count--;\n        }\n        return member;\n    };\n    Members.prototype.reset = function () {\n        this.members = {};\n        this.count = 0;\n        this.myID = null;\n        this.me = null;\n    };\n    return Members;\n}());\n/* harmony default export */ var members = (members_Members);\n\n// CONCATENATED MODULE: ./src/core/channels/presence_channel.ts\nvar presence_channel_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\nvar presence_channel_PresenceChannel = (function (_super) {\n    presence_channel_extends(PresenceChannel, _super);\n    function PresenceChannel(name, pusher) {\n        var _this = _super.call(this, name, pusher) || this;\n        _this.members = new members();\n        return _this;\n    }\n    PresenceChannel.prototype.authorize = function (socketId, callback) {\n        var _this = this;\n        _super.prototype.authorize.call(this, socketId, function (error, authData) {\n            if (!error) {\n                authData = authData;\n                if (authData.channel_data === undefined) {\n                    var suffix = url_store.buildLogSuffix('authenticationEndpoint');\n                    logger.error(\"Invalid auth response for channel '\" + _this.name + \"',\" +\n                        (\"expected 'channel_data' field. \" + suffix));\n                    callback('Invalid auth response');\n                    return;\n                }\n                var channelData = JSON.parse(authData.channel_data);\n                _this.members.setMyID(channelData.user_id);\n            }\n            callback(error, authData);\n        });\n    };\n    PresenceChannel.prototype.handleEvent = function (event) {\n        var eventName = event.event;\n        if (eventName.indexOf('pusher_internal:') === 0) {\n            this.handleInternalEvent(event);\n        }\n        else {\n            var data = event.data;\n            var metadata = {};\n            if (event.user_id) {\n                metadata.user_id = event.user_id;\n            }\n            this.emit(eventName, data, metadata);\n        }\n    };\n    PresenceChannel.prototype.handleInternalEvent = function (event) {\n        var eventName = event.event;\n        var data = event.data;\n        switch (eventName) {\n            case 'pusher_internal:subscription_succeeded':\n                this.handleSubscriptionSucceededEvent(event);\n                break;\n            case 'pusher_internal:member_added':\n                var addedMember = this.members.addMember(data);\n                this.emit('pusher:member_added', addedMember);\n                break;\n            case 'pusher_internal:member_removed':\n                var removedMember = this.members.removeMember(data);\n                if (removedMember) {\n                    this.emit('pusher:member_removed', removedMember);\n                }\n                break;\n        }\n    };\n    PresenceChannel.prototype.handleSubscriptionSucceededEvent = function (event) {\n        this.subscriptionPending = false;\n        this.subscribed = true;\n        if (this.subscriptionCancelled) {\n            this.pusher.unsubscribe(this.name);\n        }\n        else {\n            this.members.onSubscription(event.data);\n            this.emit('pusher:subscription_succeeded', this.members);\n        }\n    };\n    PresenceChannel.prototype.disconnect = function () {\n        this.members.reset();\n        _super.prototype.disconnect.call(this);\n    };\n    return PresenceChannel;\n}(private_channel));\n/* harmony default export */ var presence_channel = (presence_channel_PresenceChannel);\n\n// EXTERNAL MODULE: ./node_modules/@stablelib/utf8/lib/utf8.js\nvar utf8 = __nested_webpack_require_20171__(1);\n\n// EXTERNAL MODULE: ./node_modules/@stablelib/base64/lib/base64.js\nvar base64 = __nested_webpack_require_20171__(0);\n\n// CONCATENATED MODULE: ./src/core/channels/encrypted_channel.ts\nvar encrypted_channel_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar encrypted_channel_EncryptedChannel = (function (_super) {\n    encrypted_channel_extends(EncryptedChannel, _super);\n    function EncryptedChannel(name, pusher, nacl) {\n        var _this = _super.call(this, name, pusher) || this;\n        _this.key = null;\n        _this.nacl = nacl;\n        return _this;\n    }\n    EncryptedChannel.prototype.authorize = function (socketId, callback) {\n        var _this = this;\n        _super.prototype.authorize.call(this, socketId, function (error, authData) {\n            if (error) {\n                callback(error, authData);\n                return;\n            }\n            var sharedSecret = authData['shared_secret'];\n            if (!sharedSecret) {\n                callback(new Error(\"No shared_secret key in auth payload for encrypted channel: \" + _this.name), null);\n                return;\n            }\n            _this.key = Object(base64[\"decode\"])(sharedSecret);\n            delete authData['shared_secret'];\n            callback(null, authData);\n        });\n    };\n    EncryptedChannel.prototype.trigger = function (event, data) {\n        throw new UnsupportedFeature('Client events are not currently supported for encrypted channels');\n    };\n    EncryptedChannel.prototype.handleEvent = function (event) {\n        var eventName = event.event;\n        var data = event.data;\n        if (eventName.indexOf('pusher_internal:') === 0 ||\n            eventName.indexOf('pusher:') === 0) {\n            _super.prototype.handleEvent.call(this, event);\n            return;\n        }\n        this.handleEncryptedEvent(eventName, data);\n    };\n    EncryptedChannel.prototype.handleEncryptedEvent = function (event, data) {\n        var _this = this;\n        if (!this.key) {\n            logger.debug('Received encrypted event before key has been retrieved from the authEndpoint');\n            return;\n        }\n        if (!data.ciphertext || !data.nonce) {\n            logger.error('Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: ' +\n                data);\n            return;\n        }\n        var cipherText = Object(base64[\"decode\"])(data.ciphertext);\n        if (cipherText.length < this.nacl.secretbox.overheadLength) {\n            logger.error(\"Expected encrypted event ciphertext length to be \" + this.nacl.secretbox.overheadLength + \", got: \" + cipherText.length);\n            return;\n        }\n        var nonce = Object(base64[\"decode\"])(data.nonce);\n        if (nonce.length < this.nacl.secretbox.nonceLength) {\n            logger.error(\"Expected encrypted event nonce length to be \" + this.nacl.secretbox.nonceLength + \", got: \" + nonce.length);\n            return;\n        }\n        var bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n        if (bytes === null) {\n            logger.debug('Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...');\n            this.authorize(this.pusher.connection.socket_id, function (error, authData) {\n                if (error) {\n                    logger.error(\"Failed to make a request to the authEndpoint: \" + authData + \". Unable to fetch new key, so dropping encrypted event\");\n                    return;\n                }\n                bytes = _this.nacl.secretbox.open(cipherText, nonce, _this.key);\n                if (bytes === null) {\n                    logger.error(\"Failed to decrypt event with new key. Dropping encrypted event\");\n                    return;\n                }\n                _this.emit(event, _this.getDataToEmit(bytes));\n                return;\n            });\n            return;\n        }\n        this.emit(event, this.getDataToEmit(bytes));\n    };\n    EncryptedChannel.prototype.getDataToEmit = function (bytes) {\n        var raw = Object(utf8[\"decode\"])(bytes);\n        try {\n            return JSON.parse(raw);\n        }\n        catch (_a) {\n            return raw;\n        }\n    };\n    return EncryptedChannel;\n}(private_channel));\n/* harmony default export */ var encrypted_channel = (encrypted_channel_EncryptedChannel);\n\n// CONCATENATED MODULE: ./src/core/connection/connection_manager.ts\nvar connection_manager_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar connection_manager_ConnectionManager = (function (_super) {\n    connection_manager_extends(ConnectionManager, _super);\n    function ConnectionManager(key, options) {\n        var _this = _super.call(this) || this;\n        _this.state = 'initialized';\n        _this.connection = null;\n        _this.key = key;\n        _this.options = options;\n        _this.timeline = _this.options.timeline;\n        _this.usingTLS = _this.options.useTLS;\n        _this.errorCallbacks = _this.buildErrorCallbacks();\n        _this.connectionCallbacks = _this.buildConnectionCallbacks(_this.errorCallbacks);\n        _this.handshakeCallbacks = _this.buildHandshakeCallbacks(_this.errorCallbacks);\n        var Network = runtime.getNetwork();\n        Network.bind('online', function () {\n            _this.timeline.info({ netinfo: 'online' });\n            if (_this.state === 'connecting' || _this.state === 'unavailable') {\n                _this.retryIn(0);\n            }\n        });\n        Network.bind('offline', function () {\n            _this.timeline.info({ netinfo: 'offline' });\n            if (_this.connection) {\n                _this.sendActivityCheck();\n            }\n        });\n        _this.updateStrategy();\n        return _this;\n    }\n    ConnectionManager.prototype.connect = function () {\n        if (this.connection || this.runner) {\n            return;\n        }\n        if (!this.strategy.isSupported()) {\n            this.updateState('failed');\n            return;\n        }\n        this.updateState('connecting');\n        this.startConnecting();\n        this.setUnavailableTimer();\n    };\n    ConnectionManager.prototype.send = function (data) {\n        if (this.connection) {\n            return this.connection.send(data);\n        }\n        else {\n            return false;\n        }\n    };\n    ConnectionManager.prototype.send_event = function (name, data, channel) {\n        if (this.connection) {\n            return this.connection.send_event(name, data, channel);\n        }\n        else {\n            return false;\n        }\n    };\n    ConnectionManager.prototype.disconnect = function () {\n        this.disconnectInternally();\n        this.updateState('disconnected');\n    };\n    ConnectionManager.prototype.isUsingTLS = function () {\n        return this.usingTLS;\n    };\n    ConnectionManager.prototype.startConnecting = function () {\n        var _this = this;\n        var callback = function (error, handshake) {\n            if (error) {\n                _this.runner = _this.strategy.connect(0, callback);\n            }\n            else {\n                if (handshake.action === 'error') {\n                    _this.emit('error', {\n                        type: 'HandshakeError',\n                        error: handshake.error\n                    });\n                    _this.timeline.error({ handshakeError: handshake.error });\n                }\n                else {\n                    _this.abortConnecting();\n                    _this.handshakeCallbacks[handshake.action](handshake);\n                }\n            }\n        };\n        this.runner = this.strategy.connect(0, callback);\n    };\n    ConnectionManager.prototype.abortConnecting = function () {\n        if (this.runner) {\n            this.runner.abort();\n            this.runner = null;\n        }\n    };\n    ConnectionManager.prototype.disconnectInternally = function () {\n        this.abortConnecting();\n        this.clearRetryTimer();\n        this.clearUnavailableTimer();\n        if (this.connection) {\n            var connection = this.abandonConnection();\n            connection.close();\n        }\n    };\n    ConnectionManager.prototype.updateStrategy = function () {\n        this.strategy = this.options.getStrategy({\n            key: this.key,\n            timeline: this.timeline,\n            useTLS: this.usingTLS\n        });\n    };\n    ConnectionManager.prototype.retryIn = function (delay) {\n        var _this = this;\n        this.timeline.info({ action: 'retry', delay: delay });\n        if (delay > 0) {\n            this.emit('connecting_in', Math.round(delay / 1000));\n        }\n        this.retryTimer = new OneOffTimer(delay || 0, function () {\n            _this.disconnectInternally();\n            _this.connect();\n        });\n    };\n    ConnectionManager.prototype.clearRetryTimer = function () {\n        if (this.retryTimer) {\n            this.retryTimer.ensureAborted();\n            this.retryTimer = null;\n        }\n    };\n    ConnectionManager.prototype.setUnavailableTimer = function () {\n        var _this = this;\n        this.unavailableTimer = new OneOffTimer(this.options.unavailableTimeout, function () {\n            _this.updateState('unavailable');\n        });\n    };\n    ConnectionManager.prototype.clearUnavailableTimer = function () {\n        if (this.unavailableTimer) {\n            this.unavailableTimer.ensureAborted();\n        }\n    };\n    ConnectionManager.prototype.sendActivityCheck = function () {\n        var _this = this;\n        this.stopActivityCheck();\n        this.connection.ping();\n        this.activityTimer = new OneOffTimer(this.options.pongTimeout, function () {\n            _this.timeline.error({ pong_timed_out: _this.options.pongTimeout });\n            _this.retryIn(0);\n        });\n    };\n    ConnectionManager.prototype.resetActivityCheck = function () {\n        var _this = this;\n        this.stopActivityCheck();\n        if (this.connection && !this.connection.handlesActivityChecks()) {\n            this.activityTimer = new OneOffTimer(this.activityTimeout, function () {\n                _this.sendActivityCheck();\n            });\n        }\n    };\n    ConnectionManager.prototype.stopActivityCheck = function () {\n        if (this.activityTimer) {\n            this.activityTimer.ensureAborted();\n        }\n    };\n    ConnectionManager.prototype.buildConnectionCallbacks = function (errorCallbacks) {\n        var _this = this;\n        return extend({}, errorCallbacks, {\n            message: function (message) {\n                _this.resetActivityCheck();\n                _this.emit('message', message);\n            },\n            ping: function () {\n                _this.send_event('pusher:pong', {});\n            },\n            activity: function () {\n                _this.resetActivityCheck();\n            },\n            error: function (error) {\n                _this.emit('error', error);\n            },\n            closed: function () {\n                _this.abandonConnection();\n                if (_this.shouldRetry()) {\n                    _this.retryIn(1000);\n                }\n            }\n        });\n    };\n    ConnectionManager.prototype.buildHandshakeCallbacks = function (errorCallbacks) {\n        var _this = this;\n        return extend({}, errorCallbacks, {\n            connected: function (handshake) {\n                _this.activityTimeout = Math.min(_this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);\n                _this.clearUnavailableTimer();\n                _this.setConnection(handshake.connection);\n                _this.socket_id = _this.connection.id;\n                _this.updateState('connected', { socket_id: _this.socket_id });\n            }\n        });\n    };\n    ConnectionManager.prototype.buildErrorCallbacks = function () {\n        var _this = this;\n        var withErrorEmitted = function (callback) {\n            return function (result) {\n                if (result.error) {\n                    _this.emit('error', { type: 'WebSocketError', error: result.error });\n                }\n                callback(result);\n            };\n        };\n        return {\n            tls_only: withErrorEmitted(function () {\n                _this.usingTLS = true;\n                _this.updateStrategy();\n                _this.retryIn(0);\n            }),\n            refused: withErrorEmitted(function () {\n                _this.disconnect();\n            }),\n            backoff: withErrorEmitted(function () {\n                _this.retryIn(1000);\n            }),\n            retry: withErrorEmitted(function () {\n                _this.retryIn(0);\n            })\n        };\n    };\n    ConnectionManager.prototype.setConnection = function (connection) {\n        this.connection = connection;\n        for (var event in this.connectionCallbacks) {\n            this.connection.bind(event, this.connectionCallbacks[event]);\n        }\n        this.resetActivityCheck();\n    };\n    ConnectionManager.prototype.abandonConnection = function () {\n        if (!this.connection) {\n            return;\n        }\n        this.stopActivityCheck();\n        for (var event in this.connectionCallbacks) {\n            this.connection.unbind(event, this.connectionCallbacks[event]);\n        }\n        var connection = this.connection;\n        this.connection = null;\n        return connection;\n    };\n    ConnectionManager.prototype.updateState = function (newState, data) {\n        var previousState = this.state;\n        this.state = newState;\n        if (previousState !== newState) {\n            var newStateDescription = newState;\n            if (newStateDescription === 'connected') {\n                newStateDescription += ' with new socket ID ' + data.socket_id;\n            }\n            logger.debug('State changed', previousState + ' -> ' + newStateDescription);\n            this.timeline.info({ state: newState, params: data });\n            this.emit('state_change', { previous: previousState, current: newState });\n            this.emit(newState, data);\n        }\n    };\n    ConnectionManager.prototype.shouldRetry = function () {\n        return this.state === 'connecting' || this.state === 'connected';\n    };\n    return ConnectionManager;\n}(dispatcher));\n/* harmony default export */ var connection_manager = (connection_manager_ConnectionManager);\n\n// CONCATENATED MODULE: ./src/core/channels/channels.ts\n\n\n\n\nvar channels_Channels = (function () {\n    function Channels() {\n        this.channels = {};\n    }\n    Channels.prototype.add = function (name, pusher) {\n        if (!this.channels[name]) {\n            this.channels[name] = createChannel(name, pusher);\n        }\n        return this.channels[name];\n    };\n    Channels.prototype.all = function () {\n        return values(this.channels);\n    };\n    Channels.prototype.find = function (name) {\n        return this.channels[name];\n    };\n    Channels.prototype.remove = function (name) {\n        var channel = this.channels[name];\n        delete this.channels[name];\n        return channel;\n    };\n    Channels.prototype.disconnect = function () {\n        objectApply(this.channels, function (channel) {\n            channel.disconnect();\n        });\n    };\n    return Channels;\n}());\n/* harmony default export */ var channels = (channels_Channels);\nfunction createChannel(name, pusher) {\n    if (name.indexOf('private-encrypted-') === 0) {\n        if (pusher.config.nacl) {\n            return factory.createEncryptedChannel(name, pusher, pusher.config.nacl);\n        }\n        var errMsg = 'Tried to subscribe to a private-encrypted- channel but no nacl implementation available';\n        var suffix = url_store.buildLogSuffix('encryptedChannelSupport');\n        throw new UnsupportedFeature(errMsg + \". \" + suffix);\n    }\n    else if (name.indexOf('private-') === 0) {\n        return factory.createPrivateChannel(name, pusher);\n    }\n    else if (name.indexOf('presence-') === 0) {\n        return factory.createPresenceChannel(name, pusher);\n    }\n    else {\n        return factory.createChannel(name, pusher);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/utils/factory.ts\n\n\n\n\n\n\n\n\n\n\nvar Factory = {\n    createChannels: function () {\n        return new channels();\n    },\n    createConnectionManager: function (key, options) {\n        return new connection_manager(key, options);\n    },\n    createChannel: function (name, pusher) {\n        return new channels_channel(name, pusher);\n    },\n    createPrivateChannel: function (name, pusher) {\n        return new private_channel(name, pusher);\n    },\n    createPresenceChannel: function (name, pusher) {\n        return new presence_channel(name, pusher);\n    },\n    createEncryptedChannel: function (name, pusher, nacl) {\n        return new encrypted_channel(name, pusher, nacl);\n    },\n    createTimelineSender: function (timeline, options) {\n        return new timeline_sender(timeline, options);\n    },\n    createAuthorizer: function (channel, options) {\n        if (options.authorizer) {\n            return options.authorizer(channel, options);\n        }\n        return new pusher_authorizer(channel, options);\n    },\n    createHandshake: function (transport, callback) {\n        return new connection_handshake(transport, callback);\n    },\n    createAssistantToTheTransportManager: function (manager, transport, options) {\n        return new assistant_to_the_transport_manager(manager, transport, options);\n    }\n};\n/* harmony default export */ var factory = (Factory);\n\n// CONCATENATED MODULE: ./src/core/transports/transport_manager.ts\n\nvar transport_manager_TransportManager = (function () {\n    function TransportManager(options) {\n        this.options = options || {};\n        this.livesLeft = this.options.lives || Infinity;\n    }\n    TransportManager.prototype.getAssistant = function (transport) {\n        return factory.createAssistantToTheTransportManager(this, transport, {\n            minPingDelay: this.options.minPingDelay,\n            maxPingDelay: this.options.maxPingDelay\n        });\n    };\n    TransportManager.prototype.isAlive = function () {\n        return this.livesLeft > 0;\n    };\n    TransportManager.prototype.reportDeath = function () {\n        this.livesLeft -= 1;\n    };\n    return TransportManager;\n}());\n/* harmony default export */ var transport_manager = (transport_manager_TransportManager);\n\n// CONCATENATED MODULE: ./src/core/strategies/sequential_strategy.ts\n\n\n\nvar sequential_strategy_SequentialStrategy = (function () {\n    function SequentialStrategy(strategies, options) {\n        this.strategies = strategies;\n        this.loop = Boolean(options.loop);\n        this.failFast = Boolean(options.failFast);\n        this.timeout = options.timeout;\n        this.timeoutLimit = options.timeoutLimit;\n    }\n    SequentialStrategy.prototype.isSupported = function () {\n        return any(this.strategies, util.method('isSupported'));\n    };\n    SequentialStrategy.prototype.connect = function (minPriority, callback) {\n        var _this = this;\n        var strategies = this.strategies;\n        var current = 0;\n        var timeout = this.timeout;\n        var runner = null;\n        var tryNextStrategy = function (error, handshake) {\n            if (handshake) {\n                callback(null, handshake);\n            }\n            else {\n                current = current + 1;\n                if (_this.loop) {\n                    current = current % strategies.length;\n                }\n                if (current < strategies.length) {\n                    if (timeout) {\n                        timeout = timeout * 2;\n                        if (_this.timeoutLimit) {\n                            timeout = Math.min(timeout, _this.timeoutLimit);\n                        }\n                    }\n                    runner = _this.tryStrategy(strategies[current], minPriority, { timeout: timeout, failFast: _this.failFast }, tryNextStrategy);\n                }\n                else {\n                    callback(true);\n                }\n            }\n        };\n        runner = this.tryStrategy(strategies[current], minPriority, { timeout: timeout, failFast: this.failFast }, tryNextStrategy);\n        return {\n            abort: function () {\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            }\n        };\n    };\n    SequentialStrategy.prototype.tryStrategy = function (strategy, minPriority, options, callback) {\n        var timer = null;\n        var runner = null;\n        if (options.timeout > 0) {\n            timer = new OneOffTimer(options.timeout, function () {\n                runner.abort();\n                callback(true);\n            });\n        }\n        runner = strategy.connect(minPriority, function (error, handshake) {\n            if (error && timer && timer.isRunning() && !options.failFast) {\n                return;\n            }\n            if (timer) {\n                timer.ensureAborted();\n            }\n            callback(error, handshake);\n        });\n        return {\n            abort: function () {\n                if (timer) {\n                    timer.ensureAborted();\n                }\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                runner.forceMinPriority(p);\n            }\n        };\n    };\n    return SequentialStrategy;\n}());\n/* harmony default export */ var sequential_strategy = (sequential_strategy_SequentialStrategy);\n\n// CONCATENATED MODULE: ./src/core/strategies/best_connected_ever_strategy.ts\n\n\nvar best_connected_ever_strategy_BestConnectedEverStrategy = (function () {\n    function BestConnectedEverStrategy(strategies) {\n        this.strategies = strategies;\n    }\n    BestConnectedEverStrategy.prototype.isSupported = function () {\n        return any(this.strategies, util.method('isSupported'));\n    };\n    BestConnectedEverStrategy.prototype.connect = function (minPriority, callback) {\n        return connect(this.strategies, minPriority, function (i, runners) {\n            return function (error, handshake) {\n                runners[i].error = error;\n                if (error) {\n                    if (allRunnersFailed(runners)) {\n                        callback(true);\n                    }\n                    return;\n                }\n                apply(runners, function (runner) {\n                    runner.forceMinPriority(handshake.transport.priority);\n                });\n                callback(null, handshake);\n            };\n        });\n    };\n    return BestConnectedEverStrategy;\n}());\n/* harmony default export */ var best_connected_ever_strategy = (best_connected_ever_strategy_BestConnectedEverStrategy);\nfunction connect(strategies, minPriority, callbackBuilder) {\n    var runners = map(strategies, function (strategy, i, _, rs) {\n        return strategy.connect(minPriority, callbackBuilder(i, rs));\n    });\n    return {\n        abort: function () {\n            apply(runners, abortRunner);\n        },\n        forceMinPriority: function (p) {\n            apply(runners, function (runner) {\n                runner.forceMinPriority(p);\n            });\n        }\n    };\n}\nfunction allRunnersFailed(runners) {\n    return collections_all(runners, function (runner) {\n        return Boolean(runner.error);\n    });\n}\nfunction abortRunner(runner) {\n    if (!runner.error && !runner.aborted) {\n        runner.abort();\n        runner.aborted = true;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/cached_strategy.ts\n\n\n\n\nvar cached_strategy_CachedStrategy = (function () {\n    function CachedStrategy(strategy, transports, options) {\n        this.strategy = strategy;\n        this.transports = transports;\n        this.ttl = options.ttl || 1800 * 1000;\n        this.usingTLS = options.useTLS;\n        this.timeline = options.timeline;\n    }\n    CachedStrategy.prototype.isSupported = function () {\n        return this.strategy.isSupported();\n    };\n    CachedStrategy.prototype.connect = function (minPriority, callback) {\n        var usingTLS = this.usingTLS;\n        var info = fetchTransportCache(usingTLS);\n        var strategies = [this.strategy];\n        if (info && info.timestamp + this.ttl >= util.now()) {\n            var transport = this.transports[info.transport];\n            if (transport) {\n                this.timeline.info({\n                    cached: true,\n                    transport: info.transport,\n                    latency: info.latency\n                });\n                strategies.push(new sequential_strategy([transport], {\n                    timeout: info.latency * 2 + 1000,\n                    failFast: true\n                }));\n            }\n        }\n        var startTimestamp = util.now();\n        var runner = strategies\n            .pop()\n            .connect(minPriority, function cb(error, handshake) {\n            if (error) {\n                flushTransportCache(usingTLS);\n                if (strategies.length > 0) {\n                    startTimestamp = util.now();\n                    runner = strategies.pop().connect(minPriority, cb);\n                }\n                else {\n                    callback(error);\n                }\n            }\n            else {\n                storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp);\n                callback(null, handshake);\n            }\n        });\n        return {\n            abort: function () {\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            }\n        };\n    };\n    return CachedStrategy;\n}());\n/* harmony default export */ var cached_strategy = (cached_strategy_CachedStrategy);\nfunction getTransportCacheKey(usingTLS) {\n    return 'pusherTransport' + (usingTLS ? 'TLS' : 'NonTLS');\n}\nfunction fetchTransportCache(usingTLS) {\n    var storage = runtime.getLocalStorage();\n    if (storage) {\n        try {\n            var serializedCache = storage[getTransportCacheKey(usingTLS)];\n            if (serializedCache) {\n                return JSON.parse(serializedCache);\n            }\n        }\n        catch (e) {\n            flushTransportCache(usingTLS);\n        }\n    }\n    return null;\n}\nfunction storeTransportCache(usingTLS, transport, latency) {\n    var storage = runtime.getLocalStorage();\n    if (storage) {\n        try {\n            storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({\n                timestamp: util.now(),\n                transport: transport,\n                latency: latency\n            });\n        }\n        catch (e) {\n        }\n    }\n}\nfunction flushTransportCache(usingTLS) {\n    var storage = runtime.getLocalStorage();\n    if (storage) {\n        try {\n            delete storage[getTransportCacheKey(usingTLS)];\n        }\n        catch (e) {\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/delayed_strategy.ts\n\nvar delayed_strategy_DelayedStrategy = (function () {\n    function DelayedStrategy(strategy, _a) {\n        var number = _a.delay;\n        this.strategy = strategy;\n        this.options = { delay: number };\n    }\n    DelayedStrategy.prototype.isSupported = function () {\n        return this.strategy.isSupported();\n    };\n    DelayedStrategy.prototype.connect = function (minPriority, callback) {\n        var strategy = this.strategy;\n        var runner;\n        var timer = new OneOffTimer(this.options.delay, function () {\n            runner = strategy.connect(minPriority, callback);\n        });\n        return {\n            abort: function () {\n                timer.ensureAborted();\n                if (runner) {\n                    runner.abort();\n                }\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            }\n        };\n    };\n    return DelayedStrategy;\n}());\n/* harmony default export */ var delayed_strategy = (delayed_strategy_DelayedStrategy);\n\n// CONCATENATED MODULE: ./src/core/strategies/if_strategy.ts\nvar IfStrategy = (function () {\n    function IfStrategy(test, trueBranch, falseBranch) {\n        this.test = test;\n        this.trueBranch = trueBranch;\n        this.falseBranch = falseBranch;\n    }\n    IfStrategy.prototype.isSupported = function () {\n        var branch = this.test() ? this.trueBranch : this.falseBranch;\n        return branch.isSupported();\n    };\n    IfStrategy.prototype.connect = function (minPriority, callback) {\n        var branch = this.test() ? this.trueBranch : this.falseBranch;\n        return branch.connect(minPriority, callback);\n    };\n    return IfStrategy;\n}());\n/* harmony default export */ var if_strategy = (IfStrategy);\n\n// CONCATENATED MODULE: ./src/core/strategies/first_connected_strategy.ts\nvar FirstConnectedStrategy = (function () {\n    function FirstConnectedStrategy(strategy) {\n        this.strategy = strategy;\n    }\n    FirstConnectedStrategy.prototype.isSupported = function () {\n        return this.strategy.isSupported();\n    };\n    FirstConnectedStrategy.prototype.connect = function (minPriority, callback) {\n        var runner = this.strategy.connect(minPriority, function (error, handshake) {\n            if (handshake) {\n                runner.abort();\n            }\n            callback(error, handshake);\n        });\n        return runner;\n    };\n    return FirstConnectedStrategy;\n}());\n/* harmony default export */ var first_connected_strategy = (FirstConnectedStrategy);\n\n// CONCATENATED MODULE: ./src/runtimes/web/default_strategy.ts\n\n\n\n\n\n\n\nfunction testSupportsStrategy(strategy) {\n    return function () {\n        return strategy.isSupported();\n    };\n}\nvar getDefaultStrategy = function (config, baseOptions, defineTransport) {\n    var definedTransports = {};\n    function defineTransportStrategy(name, type, priority, options, manager) {\n        var transport = defineTransport(config, name, type, priority, options, manager);\n        definedTransports[name] = transport;\n        return transport;\n    }\n    var ws_options = Object.assign({}, baseOptions, {\n        hostNonTLS: config.wsHost + ':' + config.wsPort,\n        hostTLS: config.wsHost + ':' + config.wssPort,\n        httpPath: config.wsPath\n    });\n    var wss_options = Object.assign({}, ws_options, {\n        useTLS: true\n    });\n    var sockjs_options = Object.assign({}, baseOptions, {\n        hostNonTLS: config.httpHost + ':' + config.httpPort,\n        hostTLS: config.httpHost + ':' + config.httpsPort,\n        httpPath: config.httpPath\n    });\n    var timeouts = {\n        loop: true,\n        timeout: 15000,\n        timeoutLimit: 60000\n    };\n    var ws_manager = new transport_manager({\n        lives: 2,\n        minPingDelay: 10000,\n        maxPingDelay: config.activityTimeout\n    });\n    var streaming_manager = new transport_manager({\n        lives: 2,\n        minPingDelay: 10000,\n        maxPingDelay: config.activityTimeout\n    });\n    var ws_transport = defineTransportStrategy('ws', 'ws', 3, ws_options, ws_manager);\n    var wss_transport = defineTransportStrategy('wss', 'ws', 3, wss_options, ws_manager);\n    var sockjs_transport = defineTransportStrategy('sockjs', 'sockjs', 1, sockjs_options);\n    var xhr_streaming_transport = defineTransportStrategy('xhr_streaming', 'xhr_streaming', 1, sockjs_options, streaming_manager);\n    var xdr_streaming_transport = defineTransportStrategy('xdr_streaming', 'xdr_streaming', 1, sockjs_options, streaming_manager);\n    var xhr_polling_transport = defineTransportStrategy('xhr_polling', 'xhr_polling', 1, sockjs_options);\n    var xdr_polling_transport = defineTransportStrategy('xdr_polling', 'xdr_polling', 1, sockjs_options);\n    var ws_loop = new sequential_strategy([ws_transport], timeouts);\n    var wss_loop = new sequential_strategy([wss_transport], timeouts);\n    var sockjs_loop = new sequential_strategy([sockjs_transport], timeouts);\n    var streaming_loop = new sequential_strategy([\n        new if_strategy(testSupportsStrategy(xhr_streaming_transport), xhr_streaming_transport, xdr_streaming_transport)\n    ], timeouts);\n    var polling_loop = new sequential_strategy([\n        new if_strategy(testSupportsStrategy(xhr_polling_transport), xhr_polling_transport, xdr_polling_transport)\n    ], timeouts);\n    var http_loop = new sequential_strategy([\n        new if_strategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy([\n            streaming_loop,\n            new delayed_strategy(polling_loop, { delay: 4000 })\n        ]), polling_loop)\n    ], timeouts);\n    var http_fallback_loop = new if_strategy(testSupportsStrategy(http_loop), http_loop, sockjs_loop);\n    var wsStrategy;\n    if (baseOptions.useTLS) {\n        wsStrategy = new best_connected_ever_strategy([\n            ws_loop,\n            new delayed_strategy(http_fallback_loop, { delay: 2000 })\n        ]);\n    }\n    else {\n        wsStrategy = new best_connected_ever_strategy([\n            ws_loop,\n            new delayed_strategy(wss_loop, { delay: 2000 }),\n            new delayed_strategy(http_fallback_loop, { delay: 5000 })\n        ]);\n    }\n    return new cached_strategy(new first_connected_strategy(new if_strategy(testSupportsStrategy(ws_transport), wsStrategy, http_fallback_loop)), definedTransports, {\n        ttl: 1800000,\n        timeline: baseOptions.timeline,\n        useTLS: baseOptions.useTLS\n    });\n};\n/* harmony default export */ var default_strategy = (getDefaultStrategy);\n\n// CONCATENATED MODULE: ./src/runtimes/web/transports/transport_connection_initializer.ts\n\n/* harmony default export */ var transport_connection_initializer = (function () {\n    var self = this;\n    self.timeline.info(self.buildTimelineMessage({\n        transport: self.name + (self.options.useTLS ? 's' : '')\n    }));\n    if (self.hooks.isInitialized()) {\n        self.changeState('initialized');\n    }\n    else if (self.hooks.file) {\n        self.changeState('initializing');\n        Dependencies.load(self.hooks.file, { useTLS: self.options.useTLS }, function (error, callback) {\n            if (self.hooks.isInitialized()) {\n                self.changeState('initialized');\n                callback(true);\n            }\n            else {\n                if (error) {\n                    self.onError(error);\n                }\n                self.onClose();\n                callback(false);\n            }\n        });\n    }\n    else {\n        self.onClose();\n    }\n});\n\n// CONCATENATED MODULE: ./src/runtimes/web/http/http_xdomain_request.ts\n\nvar http_xdomain_request_hooks = {\n    getRequest: function (socket) {\n        var xdr = new window.XDomainRequest();\n        xdr.ontimeout = function () {\n            socket.emit('error', new RequestTimedOut());\n            socket.close();\n        };\n        xdr.onerror = function (e) {\n            socket.emit('error', e);\n            socket.close();\n        };\n        xdr.onprogress = function () {\n            if (xdr.responseText && xdr.responseText.length > 0) {\n                socket.onChunk(200, xdr.responseText);\n            }\n        };\n        xdr.onload = function () {\n            if (xdr.responseText && xdr.responseText.length > 0) {\n                socket.onChunk(200, xdr.responseText);\n            }\n            socket.emit('finished', 200);\n            socket.close();\n        };\n        return xdr;\n    },\n    abortRequest: function (xdr) {\n        xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null;\n        xdr.abort();\n    }\n};\n/* harmony default export */ var http_xdomain_request = (http_xdomain_request_hooks);\n\n// CONCATENATED MODULE: ./src/core/http/http_request.ts\nvar http_request_extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar MAX_BUFFER_LENGTH = 256 * 1024;\nvar http_request_HTTPRequest = (function (_super) {\n    http_request_extends(HTTPRequest, _super);\n    function HTTPRequest(hooks, method, url) {\n        var _this = _super.call(this) || this;\n        _this.hooks = hooks;\n        _this.method = method;\n        _this.url = url;\n        return _this;\n    }\n    HTTPRequest.prototype.start = function (payload) {\n        var _this = this;\n        this.position = 0;\n        this.xhr = this.hooks.getRequest(this);\n        this.unloader = function () {\n            _this.close();\n        };\n        runtime.addUnloadListener(this.unloader);\n        this.xhr.open(this.method, this.url, true);\n        if (this.xhr.setRequestHeader) {\n            this.xhr.setRequestHeader('Content-Type', 'application/json');\n        }\n        this.xhr.send(payload);\n    };\n    HTTPRequest.prototype.close = function () {\n        if (this.unloader) {\n            runtime.removeUnloadListener(this.unloader);\n            this.unloader = null;\n        }\n        if (this.xhr) {\n            this.hooks.abortRequest(this.xhr);\n            this.xhr = null;\n        }\n    };\n    HTTPRequest.prototype.onChunk = function (status, data) {\n        while (true) {\n            var chunk = this.advanceBuffer(data);\n            if (chunk) {\n                this.emit('chunk', { status: status, data: chunk });\n            }\n            else {\n                break;\n            }\n        }\n        if (this.isBufferTooLong(data)) {\n            this.emit('buffer_too_long');\n        }\n    };\n    HTTPRequest.prototype.advanceBuffer = function (buffer) {\n        var unreadData = buffer.slice(this.position);\n        var endOfLinePosition = unreadData.indexOf('\\n');\n        if (endOfLinePosition !== -1) {\n            this.position += endOfLinePosition + 1;\n            return unreadData.slice(0, endOfLinePosition);\n        }\n        else {\n            return null;\n        }\n    };\n    HTTPRequest.prototype.isBufferTooLong = function (buffer) {\n        return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;\n    };\n    return HTTPRequest;\n}(dispatcher));\n/* harmony default export */ var http_request = (http_request_HTTPRequest);\n\n// CONCATENATED MODULE: ./src/core/http/state.ts\nvar State;\n(function (State) {\n    State[State[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    State[State[\"OPEN\"] = 1] = \"OPEN\";\n    State[State[\"CLOSED\"] = 3] = \"CLOSED\";\n})(State || (State = {}));\n/* harmony default export */ var state = (State);\n\n// CONCATENATED MODULE: ./src/core/http/http_socket.ts\n\n\n\nvar autoIncrement = 1;\nvar http_socket_HTTPSocket = (function () {\n    function HTTPSocket(hooks, url) {\n        this.hooks = hooks;\n        this.session = randomNumber(1000) + '/' + randomString(8);\n        this.location = getLocation(url);\n        this.readyState = state.CONNECTING;\n        this.openStream();\n    }\n    HTTPSocket.prototype.send = function (payload) {\n        return this.sendRaw(JSON.stringify([payload]));\n    };\n    HTTPSocket.prototype.ping = function () {\n        this.hooks.sendHeartbeat(this);\n    };\n    HTTPSocket.prototype.close = function (code, reason) {\n        this.onClose(code, reason, true);\n    };\n    HTTPSocket.prototype.sendRaw = function (payload) {\n        if (this.readyState === state.OPEN) {\n            try {\n                runtime.createSocketRequest('POST', getUniqueURL(getSendURL(this.location, this.session))).start(payload);\n                return true;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    };\n    HTTPSocket.prototype.reconnect = function () {\n        this.closeStream();\n        this.openStream();\n    };\n    HTTPSocket.prototype.onClose = function (code, reason, wasClean) {\n        this.closeStream();\n        this.readyState = state.CLOSED;\n        if (this.onclose) {\n            this.onclose({\n                code: code,\n                reason: reason,\n                wasClean: wasClean\n            });\n        }\n    };\n    HTTPSocket.prototype.onChunk = function (chunk) {\n        if (chunk.status !== 200) {\n            return;\n        }\n        if (this.readyState === state.OPEN) {\n            this.onActivity();\n        }\n        var payload;\n        var type = chunk.data.slice(0, 1);\n        switch (type) {\n            case 'o':\n                payload = JSON.parse(chunk.data.slice(1) || '{}');\n                this.onOpen(payload);\n                break;\n            case 'a':\n                payload = JSON.parse(chunk.data.slice(1) || '[]');\n                for (var i = 0; i < payload.length; i++) {\n                    this.onEvent(payload[i]);\n                }\n                break;\n            case 'm':\n                payload = JSON.parse(chunk.data.slice(1) || 'null');\n                this.onEvent(payload);\n                break;\n            case 'h':\n                this.hooks.onHeartbeat(this);\n                break;\n            case 'c':\n                payload = JSON.parse(chunk.data.slice(1) || '[]');\n                this.onClose(payload[0], payload[1], true);\n                break;\n        }\n    };\n    HTTPSocket.prototype.onOpen = function (options) {\n        if (this.readyState === state.CONNECTING) {\n            if (options && options.hostname) {\n                this.location.base = replaceHost(this.location.base, options.hostname);\n            }\n            this.readyState = state.OPEN;\n            if (this.onopen) {\n                this.onopen();\n            }\n        }\n        else {\n            this.onClose(1006, 'Server lost session', true);\n        }\n    };\n    HTTPSocket.prototype.onEvent = function (event) {\n        if (this.readyState === state.OPEN && this.onmessage) {\n            this.onmessage({ data: event });\n        }\n    };\n    HTTPSocket.prototype.onActivity = function () {\n        if (this.onactivity) {\n            this.onactivity();\n        }\n    };\n    HTTPSocket.prototype.onError = function (error) {\n        if (this.onerror) {\n            this.onerror(error);\n        }\n    };\n    HTTPSocket.prototype.openStream = function () {\n        var _this = this;\n        this.stream = runtime.createSocketRequest('POST', getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));\n        this.stream.bind('chunk', function (chunk) {\n            _this.onChunk(chunk);\n        });\n        this.stream.bind('finished', function (status) {\n            _this.hooks.onFinished(_this, status);\n        });\n        this.stream.bind('buffer_too_long', function () {\n            _this.reconnect();\n        });\n        try {\n            this.stream.start();\n        }\n        catch (error) {\n            util.defer(function () {\n                _this.onError(error);\n                _this.onClose(1006, 'Could not start streaming', false);\n            });\n        }\n    };\n    HTTPSocket.prototype.closeStream = function () {\n        if (this.stream) {\n            this.stream.unbind_all();\n            this.stream.close();\n            this.stream = null;\n        }\n    };\n    return HTTPSocket;\n}());\nfunction getLocation(url) {\n    var parts = /([^\\?]*)\\/*(\\??.*)/.exec(url);\n    return {\n        base: parts[1],\n        queryString: parts[2]\n    };\n}\nfunction getSendURL(url, session) {\n    return url.base + '/' + session + '/xhr_send';\n}\nfunction getUniqueURL(url) {\n    var separator = url.indexOf('?') === -1 ? '?' : '&';\n    return url + separator + 't=' + +new Date() + '&n=' + autoIncrement++;\n}\nfunction replaceHost(url, hostname) {\n    var urlParts = /(https?:\\/\\/)([^\\/:]+)((\\/|:)?.*)/.exec(url);\n    return urlParts[1] + hostname + urlParts[3];\n}\nfunction randomNumber(max) {\n    return Math.floor(Math.random() * max);\n}\nfunction randomString(length) {\n    var result = [];\n    for (var i = 0; i < length; i++) {\n        result.push(randomNumber(32).toString(32));\n    }\n    return result.join('');\n}\n/* harmony default export */ var http_socket = (http_socket_HTTPSocket);\n\n// CONCATENATED MODULE: ./src/core/http/http_streaming_socket.ts\nvar http_streaming_socket_hooks = {\n    getReceiveURL: function (url, session) {\n        return url.base + '/' + session + '/xhr_streaming' + url.queryString;\n    },\n    onHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    sendHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    onFinished: function (socket, status) {\n        socket.onClose(1006, 'Connection interrupted (' + status + ')', false);\n    }\n};\n/* harmony default export */ var http_streaming_socket = (http_streaming_socket_hooks);\n\n// CONCATENATED MODULE: ./src/core/http/http_polling_socket.ts\nvar http_polling_socket_hooks = {\n    getReceiveURL: function (url, session) {\n        return url.base + '/' + session + '/xhr' + url.queryString;\n    },\n    onHeartbeat: function () {\n    },\n    sendHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    onFinished: function (socket, status) {\n        if (status === 200) {\n            socket.reconnect();\n        }\n        else {\n            socket.onClose(1006, 'Connection interrupted (' + status + ')', false);\n        }\n    }\n};\n/* harmony default export */ var http_polling_socket = (http_polling_socket_hooks);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http_xhr_request.ts\n\nvar http_xhr_request_hooks = {\n    getRequest: function (socket) {\n        var Constructor = runtime.getXHRAPI();\n        var xhr = new Constructor();\n        xhr.onreadystatechange = xhr.onprogress = function () {\n            switch (xhr.readyState) {\n                case 3:\n                    if (xhr.responseText && xhr.responseText.length > 0) {\n                        socket.onChunk(xhr.status, xhr.responseText);\n                    }\n                    break;\n                case 4:\n                    if (xhr.responseText && xhr.responseText.length > 0) {\n                        socket.onChunk(xhr.status, xhr.responseText);\n                    }\n                    socket.emit('finished', xhr.status);\n                    socket.close();\n                    break;\n            }\n        };\n        return xhr;\n    },\n    abortRequest: function (xhr) {\n        xhr.onreadystatechange = null;\n        xhr.abort();\n    }\n};\n/* harmony default export */ var http_xhr_request = (http_xhr_request_hooks);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http.ts\n\n\n\n\n\nvar HTTP = {\n    createStreamingSocket: function (url) {\n        return this.createSocket(http_streaming_socket, url);\n    },\n    createPollingSocket: function (url) {\n        return this.createSocket(http_polling_socket, url);\n    },\n    createSocket: function (hooks, url) {\n        return new http_socket(hooks, url);\n    },\n    createXHR: function (method, url) {\n        return this.createRequest(http_xhr_request, method, url);\n    },\n    createRequest: function (hooks, method, url) {\n        return new http_request(hooks, method, url);\n    }\n};\n/* harmony default export */ var http_http = (HTTP);\n\n// CONCATENATED MODULE: ./src/runtimes/web/http/http.ts\n\n\nhttp_http.createXDR = function (method, url) {\n    return this.createRequest(http_xdomain_request, method, url);\n};\n/* harmony default export */ var web_http_http = (http_http);\n\n// CONCATENATED MODULE: ./src/runtimes/web/runtime.ts\n\n\n\n\n\n\n\n\n\n\n\n\nvar Runtime = {\n    nextAuthCallbackID: 1,\n    auth_callbacks: {},\n    ScriptReceivers: ScriptReceivers,\n    DependenciesReceivers: DependenciesReceivers,\n    getDefaultStrategy: default_strategy,\n    Transports: transports_transports,\n    transportConnectionInitializer: transport_connection_initializer,\n    HTTPFactory: web_http_http,\n    TimelineTransport: jsonp_timeline,\n    getXHRAPI: function () {\n        return window.XMLHttpRequest;\n    },\n    getWebSocketAPI: function () {\n        return window.WebSocket || window.MozWebSocket;\n    },\n    setup: function (PusherClass) {\n        var _this = this;\n        window.Pusher = PusherClass;\n        var initializeOnDocumentBody = function () {\n            _this.onDocumentBody(PusherClass.ready);\n        };\n        if (!window.JSON) {\n            Dependencies.load('json2', {}, initializeOnDocumentBody);\n        }\n        else {\n            initializeOnDocumentBody();\n        }\n    },\n    getDocument: function () {\n        return document;\n    },\n    getProtocol: function () {\n        return this.getDocument().location.protocol;\n    },\n    getAuthorizers: function () {\n        return { ajax: xhr_auth, jsonp: jsonp_auth };\n    },\n    onDocumentBody: function (callback) {\n        var _this = this;\n        if (document.body) {\n            callback();\n        }\n        else {\n            setTimeout(function () {\n                _this.onDocumentBody(callback);\n            }, 0);\n        }\n    },\n    createJSONPRequest: function (url, data) {\n        return new jsonp_request(url, data);\n    },\n    createScriptRequest: function (src) {\n        return new script_request(src);\n    },\n    getLocalStorage: function () {\n        try {\n            return window.localStorage;\n        }\n        catch (e) {\n            return undefined;\n        }\n    },\n    createXHR: function () {\n        if (this.getXHRAPI()) {\n            return this.createXMLHttpRequest();\n        }\n        else {\n            return this.createMicrosoftXHR();\n        }\n    },\n    createXMLHttpRequest: function () {\n        var Constructor = this.getXHRAPI();\n        return new Constructor();\n    },\n    createMicrosoftXHR: function () {\n        return new ActiveXObject('Microsoft.XMLHTTP');\n    },\n    getNetwork: function () {\n        return net_info_Network;\n    },\n    createWebSocket: function (url) {\n        var Constructor = this.getWebSocketAPI();\n        return new Constructor(url);\n    },\n    createSocketRequest: function (method, url) {\n        if (this.isXHRSupported()) {\n            return this.HTTPFactory.createXHR(method, url);\n        }\n        else if (this.isXDRSupported(url.indexOf('https:') === 0)) {\n            return this.HTTPFactory.createXDR(method, url);\n        }\n        else {\n            throw 'Cross-origin HTTP requests are not supported';\n        }\n    },\n    isXHRSupported: function () {\n        var Constructor = this.getXHRAPI();\n        return (Boolean(Constructor) && new Constructor().withCredentials !== undefined);\n    },\n    isXDRSupported: function (useTLS) {\n        var protocol = useTLS ? 'https:' : 'http:';\n        var documentProtocol = this.getProtocol();\n        return (Boolean(window['XDomainRequest']) && documentProtocol === protocol);\n    },\n    addUnloadListener: function (listener) {\n        if (window.addEventListener !== undefined) {\n            window.addEventListener('unload', listener, false);\n        }\n        else if (window.attachEvent !== undefined) {\n            window.attachEvent('onunload', listener);\n        }\n    },\n    removeUnloadListener: function (listener) {\n        if (window.addEventListener !== undefined) {\n            window.removeEventListener('unload', listener, false);\n        }\n        else if (window.detachEvent !== undefined) {\n            window.detachEvent('onunload', listener);\n        }\n    }\n};\n/* harmony default export */ var runtime = (Runtime);\n\n// CONCATENATED MODULE: ./src/core/timeline/level.ts\nvar TimelineLevel;\n(function (TimelineLevel) {\n    TimelineLevel[TimelineLevel[\"ERROR\"] = 3] = \"ERROR\";\n    TimelineLevel[TimelineLevel[\"INFO\"] = 6] = \"INFO\";\n    TimelineLevel[TimelineLevel[\"DEBUG\"] = 7] = \"DEBUG\";\n})(TimelineLevel || (TimelineLevel = {}));\n/* harmony default export */ var timeline_level = (TimelineLevel);\n\n// CONCATENATED MODULE: ./src/core/timeline/timeline.ts\n\n\n\nvar timeline_Timeline = (function () {\n    function Timeline(key, session, options) {\n        this.key = key;\n        this.session = session;\n        this.events = [];\n        this.options = options || {};\n        this.sent = 0;\n        this.uniqueID = 0;\n    }\n    Timeline.prototype.log = function (level, event) {\n        if (level <= this.options.level) {\n            this.events.push(extend({}, event, { timestamp: util.now() }));\n            if (this.options.limit && this.events.length > this.options.limit) {\n                this.events.shift();\n            }\n        }\n    };\n    Timeline.prototype.error = function (event) {\n        this.log(timeline_level.ERROR, event);\n    };\n    Timeline.prototype.info = function (event) {\n        this.log(timeline_level.INFO, event);\n    };\n    Timeline.prototype.debug = function (event) {\n        this.log(timeline_level.DEBUG, event);\n    };\n    Timeline.prototype.isEmpty = function () {\n        return this.events.length === 0;\n    };\n    Timeline.prototype.send = function (sendfn, callback) {\n        var _this = this;\n        var data = extend({\n            session: this.session,\n            bundle: this.sent + 1,\n            key: this.key,\n            lib: 'js',\n            version: this.options.version,\n            cluster: this.options.cluster,\n            features: this.options.features,\n            timeline: this.events\n        }, this.options.params);\n        this.events = [];\n        sendfn(data, function (error, result) {\n            if (!error) {\n                _this.sent++;\n            }\n            if (callback) {\n                callback(error, result);\n            }\n        });\n        return true;\n    };\n    Timeline.prototype.generateUniqueID = function () {\n        this.uniqueID++;\n        return this.uniqueID;\n    };\n    return Timeline;\n}());\n/* harmony default export */ var timeline_timeline = (timeline_Timeline);\n\n// CONCATENATED MODULE: ./src/core/strategies/transport_strategy.ts\n\n\n\n\nvar transport_strategy_TransportStrategy = (function () {\n    function TransportStrategy(name, priority, transport, options) {\n        this.name = name;\n        this.priority = priority;\n        this.transport = transport;\n        this.options = options || {};\n    }\n    TransportStrategy.prototype.isSupported = function () {\n        return this.transport.isSupported({\n            useTLS: this.options.useTLS\n        });\n    };\n    TransportStrategy.prototype.connect = function (minPriority, callback) {\n        var _this = this;\n        if (!this.isSupported()) {\n            return failAttempt(new UnsupportedStrategy(), callback);\n        }\n        else if (this.priority < minPriority) {\n            return failAttempt(new TransportPriorityTooLow(), callback);\n        }\n        var connected = false;\n        var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);\n        var handshake = null;\n        var onInitialized = function () {\n            transport.unbind('initialized', onInitialized);\n            transport.connect();\n        };\n        var onOpen = function () {\n            handshake = factory.createHandshake(transport, function (result) {\n                connected = true;\n                unbindListeners();\n                callback(null, result);\n            });\n        };\n        var onError = function (error) {\n            unbindListeners();\n            callback(error);\n        };\n        var onClosed = function () {\n            unbindListeners();\n            var serializedTransport;\n            serializedTransport = safeJSONStringify(transport);\n            callback(new TransportClosed(serializedTransport));\n        };\n        var unbindListeners = function () {\n            transport.unbind('initialized', onInitialized);\n            transport.unbind('open', onOpen);\n            transport.unbind('error', onError);\n            transport.unbind('closed', onClosed);\n        };\n        transport.bind('initialized', onInitialized);\n        transport.bind('open', onOpen);\n        transport.bind('error', onError);\n        transport.bind('closed', onClosed);\n        transport.initialize();\n        return {\n            abort: function () {\n                if (connected) {\n                    return;\n                }\n                unbindListeners();\n                if (handshake) {\n                    handshake.close();\n                }\n                else {\n                    transport.close();\n                }\n            },\n            forceMinPriority: function (p) {\n                if (connected) {\n                    return;\n                }\n                if (_this.priority < p) {\n                    if (handshake) {\n                        handshake.close();\n                    }\n                    else {\n                        transport.close();\n                    }\n                }\n            }\n        };\n    };\n    return TransportStrategy;\n}());\n/* harmony default export */ var transport_strategy = (transport_strategy_TransportStrategy);\nfunction failAttempt(error, callback) {\n    util.defer(function () {\n        callback(error);\n    });\n    return {\n        abort: function () { },\n        forceMinPriority: function () { }\n    };\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/strategy_builder.ts\n\n\n\n\n\nvar strategy_builder_Transports = runtime.Transports;\nvar strategy_builder_defineTransport = function (config, name, type, priority, options, manager) {\n    var transportClass = strategy_builder_Transports[type];\n    if (!transportClass) {\n        throw new UnsupportedTransport(type);\n    }\n    var enabled = (!config.enabledTransports ||\n        arrayIndexOf(config.enabledTransports, name) !== -1) &&\n        (!config.disabledTransports ||\n            arrayIndexOf(config.disabledTransports, name) === -1);\n    var transport;\n    if (enabled) {\n        options = Object.assign({ ignoreNullOrigin: config.ignoreNullOrigin }, options);\n        transport = new transport_strategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, options);\n    }\n    else {\n        transport = strategy_builder_UnsupportedStrategy;\n    }\n    return transport;\n};\nvar strategy_builder_UnsupportedStrategy = {\n    isSupported: function () {\n        return false;\n    },\n    connect: function (_, callback) {\n        var deferred = util.defer(function () {\n            callback(new UnsupportedStrategy());\n        });\n        return {\n            abort: function () {\n                deferred.ensureAborted();\n            },\n            forceMinPriority: function () { }\n        };\n    }\n};\n\n// CONCATENATED MODULE: ./src/core/config.ts\n\n\nfunction getConfig(opts) {\n    var config = {\n        activityTimeout: opts.activityTimeout || defaults.activityTimeout,\n        authEndpoint: opts.authEndpoint || defaults.authEndpoint,\n        authTransport: opts.authTransport || defaults.authTransport,\n        cluster: opts.cluster || defaults.cluster,\n        httpPath: opts.httpPath || defaults.httpPath,\n        httpPort: opts.httpPort || defaults.httpPort,\n        httpsPort: opts.httpsPort || defaults.httpsPort,\n        pongTimeout: opts.pongTimeout || defaults.pongTimeout,\n        statsHost: opts.statsHost || defaults.stats_host,\n        unavailableTimeout: opts.unavailableTimeout || defaults.unavailableTimeout,\n        wsPath: opts.wsPath || defaults.wsPath,\n        wsPort: opts.wsPort || defaults.wsPort,\n        wssPort: opts.wssPort || defaults.wssPort,\n        enableStats: getEnableStatsConfig(opts),\n        httpHost: getHttpHost(opts),\n        useTLS: shouldUseTLS(opts),\n        wsHost: getWebsocketHost(opts)\n    };\n    if ('auth' in opts)\n        config.auth = opts.auth;\n    if ('authorizer' in opts)\n        config.authorizer = opts.authorizer;\n    if ('disabledTransports' in opts)\n        config.disabledTransports = opts.disabledTransports;\n    if ('enabledTransports' in opts)\n        config.enabledTransports = opts.enabledTransports;\n    if ('ignoreNullOrigin' in opts)\n        config.ignoreNullOrigin = opts.ignoreNullOrigin;\n    if ('timelineParams' in opts)\n        config.timelineParams = opts.timelineParams;\n    if ('nacl' in opts) {\n        config.nacl = opts.nacl;\n    }\n    return config;\n}\nfunction getHttpHost(opts) {\n    if (opts.httpHost) {\n        return opts.httpHost;\n    }\n    if (opts.cluster) {\n        return \"sockjs-\" + opts.cluster + \".pusher.com\";\n    }\n    return defaults.httpHost;\n}\nfunction getWebsocketHost(opts) {\n    if (opts.wsHost) {\n        return opts.wsHost;\n    }\n    if (opts.cluster) {\n        return getWebsocketHostFromCluster(opts.cluster);\n    }\n    return getWebsocketHostFromCluster(defaults.cluster);\n}\nfunction getWebsocketHostFromCluster(cluster) {\n    return \"ws-\" + cluster + \".pusher.com\";\n}\nfunction shouldUseTLS(opts) {\n    if (runtime.getProtocol() === 'https:') {\n        return true;\n    }\n    else if (opts.forceTLS === false) {\n        return false;\n    }\n    return true;\n}\nfunction getEnableStatsConfig(opts) {\n    if ('enableStats' in opts) {\n        return opts.enableStats;\n    }\n    if ('disableStats' in opts) {\n        return !opts.disableStats;\n    }\n    return false;\n}\n\n// CONCATENATED MODULE: ./src/core/pusher.ts\n\n\n\n\n\n\n\n\n\n\n\n\nvar pusher_Pusher = (function () {\n    function Pusher(app_key, options) {\n        var _this = this;\n        checkAppKey(app_key);\n        options = options || {};\n        if (!options.cluster && !(options.wsHost || options.httpHost)) {\n            var suffix = url_store.buildLogSuffix('javascriptQuickStart');\n            logger.warn(\"You should always specify a cluster when connecting. \" + suffix);\n        }\n        if ('disableStats' in options) {\n            logger.warn('The disableStats option is deprecated in favor of enableStats');\n        }\n        this.key = app_key;\n        this.config = getConfig(options);\n        this.channels = factory.createChannels();\n        this.global_emitter = new dispatcher();\n        this.sessionID = Math.floor(Math.random() * 1000000000);\n        this.timeline = new timeline_timeline(this.key, this.sessionID, {\n            cluster: this.config.cluster,\n            features: Pusher.getClientFeatures(),\n            params: this.config.timelineParams || {},\n            limit: 50,\n            level: timeline_level.INFO,\n            version: defaults.VERSION\n        });\n        if (this.config.enableStats) {\n            this.timelineSender = factory.createTimelineSender(this.timeline, {\n                host: this.config.statsHost,\n                path: '/timeline/v2/' + runtime.TimelineTransport.name\n            });\n        }\n        var getStrategy = function (options) {\n            return runtime.getDefaultStrategy(_this.config, options, strategy_builder_defineTransport);\n        };\n        this.connection = factory.createConnectionManager(this.key, {\n            getStrategy: getStrategy,\n            timeline: this.timeline,\n            activityTimeout: this.config.activityTimeout,\n            pongTimeout: this.config.pongTimeout,\n            unavailableTimeout: this.config.unavailableTimeout,\n            useTLS: Boolean(this.config.useTLS)\n        });\n        this.connection.bind('connected', function () {\n            _this.subscribeAll();\n            if (_this.timelineSender) {\n                _this.timelineSender.send(_this.connection.isUsingTLS());\n            }\n        });\n        this.connection.bind('message', function (event) {\n            var eventName = event.event;\n            var internal = eventName.indexOf('pusher_internal:') === 0;\n            if (event.channel) {\n                var channel = _this.channel(event.channel);\n                if (channel) {\n                    channel.handleEvent(event);\n                }\n            }\n            if (!internal) {\n                _this.global_emitter.emit(event.event, event.data);\n            }\n        });\n        this.connection.bind('connecting', function () {\n            _this.channels.disconnect();\n        });\n        this.connection.bind('disconnected', function () {\n            _this.channels.disconnect();\n        });\n        this.connection.bind('error', function (err) {\n            logger.warn(err);\n        });\n        Pusher.instances.push(this);\n        this.timeline.info({ instances: Pusher.instances.length });\n        if (Pusher.isReady) {\n            this.connect();\n        }\n    }\n    Pusher.ready = function () {\n        Pusher.isReady = true;\n        for (var i = 0, l = Pusher.instances.length; i < l; i++) {\n            Pusher.instances[i].connect();\n        }\n    };\n    Pusher.getClientFeatures = function () {\n        return keys(filterObject({ ws: runtime.Transports.ws }, function (t) {\n            return t.isSupported({});\n        }));\n    };\n    Pusher.prototype.channel = function (name) {\n        return this.channels.find(name);\n    };\n    Pusher.prototype.allChannels = function () {\n        return this.channels.all();\n    };\n    Pusher.prototype.connect = function () {\n        this.connection.connect();\n        if (this.timelineSender) {\n            if (!this.timelineSenderTimer) {\n                var usingTLS = this.connection.isUsingTLS();\n                var timelineSender = this.timelineSender;\n                this.timelineSenderTimer = new PeriodicTimer(60000, function () {\n                    timelineSender.send(usingTLS);\n                });\n            }\n        }\n    };\n    Pusher.prototype.disconnect = function () {\n        this.connection.disconnect();\n        if (this.timelineSenderTimer) {\n            this.timelineSenderTimer.ensureAborted();\n            this.timelineSenderTimer = null;\n        }\n    };\n    Pusher.prototype.bind = function (event_name, callback, context) {\n        this.global_emitter.bind(event_name, callback, context);\n        return this;\n    };\n    Pusher.prototype.unbind = function (event_name, callback, context) {\n        this.global_emitter.unbind(event_name, callback, context);\n        return this;\n    };\n    Pusher.prototype.bind_global = function (callback) {\n        this.global_emitter.bind_global(callback);\n        return this;\n    };\n    Pusher.prototype.unbind_global = function (callback) {\n        this.global_emitter.unbind_global(callback);\n        return this;\n    };\n    Pusher.prototype.unbind_all = function (callback) {\n        this.global_emitter.unbind_all();\n        return this;\n    };\n    Pusher.prototype.subscribeAll = function () {\n        var channelName;\n        for (channelName in this.channels.channels) {\n            if (this.channels.channels.hasOwnProperty(channelName)) {\n                this.subscribe(channelName);\n            }\n        }\n    };\n    Pusher.prototype.subscribe = function (channel_name) {\n        var channel = this.channels.add(channel_name, this);\n        if (channel.subscriptionPending && channel.subscriptionCancelled) {\n            channel.reinstateSubscription();\n        }\n        else if (!channel.subscriptionPending &&\n            this.connection.state === 'connected') {\n            channel.subscribe();\n        }\n        return channel;\n    };\n    Pusher.prototype.unsubscribe = function (channel_name) {\n        var channel = this.channels.find(channel_name);\n        if (channel && channel.subscriptionPending) {\n            channel.cancelSubscription();\n        }\n        else {\n            channel = this.channels.remove(channel_name);\n            if (channel && channel.subscribed) {\n                channel.unsubscribe();\n            }\n        }\n    };\n    Pusher.prototype.send_event = function (event_name, data, channel) {\n        return this.connection.send_event(event_name, data, channel);\n    };\n    Pusher.prototype.shouldUseTLS = function () {\n        return this.config.useTLS;\n    };\n    Pusher.instances = [];\n    Pusher.isReady = false;\n    Pusher.logToConsole = false;\n    Pusher.Runtime = runtime;\n    Pusher.ScriptReceivers = runtime.ScriptReceivers;\n    Pusher.DependenciesReceivers = runtime.DependenciesReceivers;\n    Pusher.auth_callbacks = runtime.auth_callbacks;\n    return Pusher;\n}());\n/* harmony default export */ var core_pusher = __webpack_exports__[\"default\"] = (pusher_Pusher);\nfunction checkAppKey(key) {\n    if (key === null || key === undefined) {\n        throw 'You must pass your app key when you instantiate Pusher.';\n    }\n}\nruntime.setup(pusher_Pusher);\n\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHVzaGVyLWpzL2Rpc3Qvd2ViL3B1c2hlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS3VCO0FBQzdCLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEMsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZ0NBQWdDLDhCQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUFtQjtBQUM5QixrREFBa0QsZ0NBQWdDO0FBQ2xGLDBFQUEwRSw4QkFBbUIsNEJBQTRCLG9CQUFvQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUIsQ0FBQyw4QkFBbUI7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxVQUFVO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxD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dUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHdCQUF3QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7O0FBTUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0NBQWdDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQztBQUNuRSx3REFBd0QseUJBQXlCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNENBQTRDO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwyQ0FBMkM7QUFDakg7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2Qzs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVyx1QkFBdUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkNBQTJDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZCQUE2QixvQ0FBb0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkJBQTJCO0FBQzlELG1DQUFtQztBQUNuQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdXNoZXItanMvZGlzdC93ZWIvcHVzaGVyLmpzPzc4MmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBQdXNoZXIgSmF2YVNjcmlwdCBMaWJyYXJ5IHY3LjAuM1xuICogaHR0cHM6Ly9wdXNoZXIuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDIwLCBQdXNoZXJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5jZS5cbiAqL1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQdXNoZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUHVzaGVyXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFBhY2thZ2UgYmFzZTY0IGltcGxlbWVudHMgQmFzZTY0IGVuY29kaW5nIGFuZCBkZWNvZGluZy5cbiAqL1xuLy8gSW52YWxpZCBjaGFyYWN0ZXIgdXNlZCBpbiBkZWNvZGluZyB0byBpbmRpY2F0ZVxuLy8gdGhhdCB0aGUgY2hhcmFjdGVyIHRvIGRlY29kZSBpcyBvdXQgb2YgcmFuZ2Ugb2Zcbi8vIGFscGhhYmV0IGFuZCBjYW5ub3QgYmUgZGVjb2RlZC5cbnZhciBJTlZBTElEX0JZVEUgPSAyNTY7XG4vKipcbiAqIEltcGxlbWVudHMgc3RhbmRhcmQgQmFzZTY0IGVuY29kaW5nLlxuICpcbiAqIE9wZXJhdGVzIGluIGNvbnN0YW50IHRpbWUuXG4gKi9cbnZhciBDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPKGRjaGVzdCk6IG1ldGhvZHMgdG8gZW5jb2RlIGNodW5rLWJ5LWNodW5rLlxuICAgIGZ1bmN0aW9uIENvZGVyKF9wYWRkaW5nQ2hhcmFjdGVyKSB7XG4gICAgICAgIGlmIChfcGFkZGluZ0NoYXJhY3RlciA9PT0gdm9pZCAwKSB7IF9wYWRkaW5nQ2hhcmFjdGVyID0gXCI9XCI7IH1cbiAgICAgICAgdGhpcy5fcGFkZGluZ0NoYXJhY3RlciA9IF9wYWRkaW5nQ2hhcmFjdGVyO1xuICAgIH1cbiAgICBDb2Rlci5wcm90b3R5cGUuZW5jb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGxlbmd0aCAqIDggKyA1KSAvIDYgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobGVuZ3RoICsgMikgLyAzICogNCB8IDA7XG4gICAgfTtcbiAgICBDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBkYXRhLmxlbmd0aCAtIDI7IGkgKz0gMykge1xuICAgICAgICAgICAgdmFyIGMgPSAoZGF0YVtpXSA8PCAxNikgfCAoZGF0YVtpICsgMV0gPDwgOCkgfCAoZGF0YVtpICsgMl0pO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDMgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAyICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMSAqIDYpICYgNjMpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDAgKiA2KSAmIDYzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCA9IGRhdGEubGVuZ3RoIC0gaTtcbiAgICAgICAgaWYgKGxlZnQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgYyA9IChkYXRhW2ldIDw8IDE2KSB8IChsZWZ0ID09PSAyID8gZGF0YVtpICsgMV0gPDwgOCA6IDApO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDMgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAyICogNikgJiA2Myk7XG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gMikge1xuICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAxICogNikgJiA2Myk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5fcGFkZGluZ0NoYXJhY3RlciB8fCBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLm1heERlY29kZWRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIChsZW5ndGggKiA2ICsgNykgLyA4IHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoIC8gNCAqIDMgfCAwO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmRlY29kZWRMZW5ndGggPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhEZWNvZGVkTGVuZ3RoKHMubGVuZ3RoIC0gdGhpcy5fZ2V0UGFkZGluZ0xlbmd0aChzKSk7XG4gICAgfTtcbiAgICBDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZGRpbmdMZW5ndGggPSB0aGlzLl9nZXRQYWRkaW5nTGVuZ3RoKHMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcy5sZW5ndGggLSBwYWRkaW5nTGVuZ3RoO1xuICAgICAgICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhEZWNvZGVkTGVuZ3RoKGxlbmd0aCkpO1xuICAgICAgICB2YXIgb3AgPSAwO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBoYXZlQmFkID0gMDtcbiAgICAgICAgdmFyIHYwID0gMCwgdjEgPSAwLCB2MiA9IDAsIHYzID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGggLSA0OyBpICs9IDQpIHtcbiAgICAgICAgICAgIHYwID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDApKTtcbiAgICAgICAgICAgIHYxID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDEpKTtcbiAgICAgICAgICAgIHYyID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDIpKTtcbiAgICAgICAgICAgIHYzID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MCA8PCAyKSB8ICh2MSA+Pj4gNCk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjEgPDwgNCkgfCAodjIgPj4+IDIpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYyIDw8IDYpIHwgdjM7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYwICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MSAmIElOVkFMSURfQllURTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjIgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYzICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdjAgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICB2MSA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjAgPDwgMikgfCAodjEgPj4+IDQpO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MCAmIElOVkFMSURfQllURTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjEgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICAgICAgICB2MiA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAyKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjEgPDwgNCkgfCAodjIgPj4+IDIpO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MiAmIElOVkFMSURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDMpIHtcbiAgICAgICAgICAgIHYzID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MiA8PCA2KSB8IHYzO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MyAmIElOVkFMSURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGF2ZUJhZCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFzZTY0Q29kZXI6IGluY29ycmVjdCBjaGFyYWN0ZXJzIGZvciBkZWNvZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLy8gU3RhbmRhcmQgZW5jb2RpbmcgaGF2ZSB0aGUgZm9sbG93aW5nIGVuY29kZWQvZGVjb2RlZCByYW5nZXMsXG4gICAgLy8gd2hpY2ggd2UgbmVlZCB0byBjb252ZXJ0IGJldHdlZW4uXG4gICAgLy9cbiAgICAvLyBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiAwMTIzNDU2Nzg5ICArICAgL1xuICAgIC8vIEluZGV4OiAgIDAgLSAyNSAgICAgICAgICAgICAgICAgICAgMjYgLSA1MSAgICAgICAgICAgICAgNTIgLSA2MSAgIDYyICA2M1xuICAgIC8vIEFTQ0lJOiAgNjUgLSA5MCAgICAgICAgICAgICAgICAgICAgOTcgLSAxMjIgICAgICAgICAgICAgNDggLSA1NyAgIDQzICA0N1xuICAgIC8vXG4gICAgLy8gRW5jb2RlIDYgYml0cyBpbiBiIGludG8gYSBuZXcgY2hhcmFjdGVyLlxuICAgIENvZGVyLnByb3RvdHlwZS5fZW5jb2RlQnl0ZSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIC8vIEVuY29kaW5nIHVzZXMgY29uc3RhbnQgdGltZSBvcGVyYXRpb25zIGFzIGZvbGxvd3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIERlZmluZSBjb21wYXJpc29uIG9mIEEgd2l0aCBCIHVzaW5nIChBIC0gQikgPj4+IDg6XG4gICAgICAgIC8vICAgICAgICAgIGlmIEEgPiBCLCB0aGVuIHJlc3VsdCBpcyBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgICAgIC8vICAgICAgICAgIGlmIEEgPD0gQiwgdGhlbiByZXN1bHQgaXMgMFxuICAgICAgICAvL1xuICAgICAgICAvLyAyLiBEZWZpbmUgc2VsZWN0aW9uIG9mIEMgb3IgMCB1c2luZyBiaXR3aXNlIEFORDogWCAmIEM6XG4gICAgICAgIC8vICAgICAgICAgIGlmIFggPT0gMCwgdGhlbiByZXN1bHQgaXMgMFxuICAgICAgICAvLyAgICAgICAgICBpZiBYICE9IDAsIHRoZW4gcmVzdWx0IGlzIENcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMy4gU3RhcnQgd2l0aCB0aGUgc21hbGxlc3QgY29tcGFyaXNvbiAoYiA+PSAwKSwgd2hpY2ggaXMgYWx3YXlzXG4gICAgICAgIC8vICAgIHRydWUsIHNvIHNldCB0aGUgcmVzdWx0IHRvIHRoZSBzdGFydGluZyBBU0NJSSB2YWx1ZSAoNjUpLlxuICAgICAgICAvL1xuICAgICAgICAvLyA0LiBDb250aW51ZSBjb21wYXJpbmcgYiB0byBoaWdoZXIgQVNDSUkgdmFsdWVzLCBhbmQgc2VsZWN0aW5nXG4gICAgICAgIC8vICAgIHplcm8gaWYgY29tcGFyaXNvbiBpc24ndCB0cnVlLCBvdGhlcndpc2Ugc2VsZWN0aW5nIGEgdmFsdWVcbiAgICAgICAgLy8gICAgdG8gYWRkIHRvIHJlc3VsdCwgd2hpY2g6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgIGEpIHVuZG9lcyB0aGUgcHJldmlvdXMgYWRkaXRpb25cbiAgICAgICAgLy8gICAgICAgICAgYikgcHJvdmlkZXMgbmV3IHZhbHVlIHRvIGFkZFxuICAgICAgICAvL1xuICAgICAgICB2YXIgcmVzdWx0ID0gYjtcbiAgICAgICAgLy8gYiA+PSAwXG4gICAgICAgIHJlc3VsdCArPSA2NTtcbiAgICAgICAgLy8gYiA+IDI1XG4gICAgICAgIHJlc3VsdCArPSAoKDI1IC0gYikgPj4+IDgpICYgKCgwIC0gNjUpIC0gMjYgKyA5Nyk7XG4gICAgICAgIC8vIGIgPiA1MVxuICAgICAgICByZXN1bHQgKz0gKCg1MSAtIGIpID4+PiA4KSAmICgoMjYgLSA5NykgLSA1MiArIDQ4KTtcbiAgICAgICAgLy8gYiA+IDYxXG4gICAgICAgIHJlc3VsdCArPSAoKDYxIC0gYikgPj4+IDgpICYgKCg1MiAtIDQ4KSAtIDYyICsgNDMpO1xuICAgICAgICAvLyBiID4gNjJcbiAgICAgICAgcmVzdWx0ICs9ICgoNjIgLSBiKSA+Pj4gOCkgJiAoKDYyIC0gNDMpIC0gNjMgKyA0Nyk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlc3VsdCk7XG4gICAgfTtcbiAgICAvLyBEZWNvZGUgYSBjaGFyYWN0ZXIgY29kZSBpbnRvIGEgYnl0ZS5cbiAgICAvLyBNdXN0IHJldHVybiAyNTYgaWYgY2hhcmFjdGVyIGlzIG91dCBvZiBhbHBoYWJldCByYW5nZS5cbiAgICBDb2Rlci5wcm90b3R5cGUuX2RlY29kZUNoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBEZWNvZGluZyB3b3JrcyBzaW1pbGFyIHRvIGVuY29kaW5nOiB1c2luZyB0aGUgc2FtZSBjb21wYXJpc29uXG4gICAgICAgIC8vIGZ1bmN0aW9uLCBidXQgbm93IGl0IHdvcmtzIG9uIHJhbmdlczogcmVzdWx0IGlzIGFsd2F5cyBpbmNyZW1lbnRlZFxuICAgICAgICAvLyBieSB2YWx1ZSwgYnV0IHRoaXMgdmFsdWUgYmVjb21lcyB6ZXJvIGlmIHRoZSByYW5nZSBpcyBub3RcbiAgICAgICAgLy8gc2F0aXNmaWVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBEZWNvZGluZyBzdGFydHMgd2l0aCBpbnZhbGlkIHZhbHVlLCAyNTYsIHdoaWNoIGlzIHRoZW5cbiAgICAgICAgLy8gc3VidHJhY3RlZCB3aGVuIHRoZSByYW5nZSBpcyBzYXRpc2ZpZWQuIElmIG5vbmUgb2YgdGhlIHJhbmdlc1xuICAgICAgICAvLyBhcHBseSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgMjU2LCB3aGljaCBpcyB0aGVuIGNoZWNrZWQgYnlcbiAgICAgICAgLy8gdGhlIGNhbGxlciB0byB0aHJvdyBlcnJvci5cbiAgICAgICAgdmFyIHJlc3VsdCA9IElOVkFMSURfQllURTsgLy8gc3RhcnQgd2l0aCBpbnZhbGlkIGNoYXJhY3RlclxuICAgICAgICAvLyBjID09IDQzIChjID4gNDIgYW5kIGMgPCA0NClcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQyIC0gYykgJiAoYyAtIDQ0KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDMgKyA2Mik7XG4gICAgICAgIC8vIGMgPT0gNDcgKGMgPiA0NiBhbmQgYyA8IDQ4KVxuICAgICAgICByZXN1bHQgKz0gKCgoNDYgLSBjKSAmIChjIC0gNDgpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA0NyArIDYzKTtcbiAgICAgICAgLy8gYyA+IDQ3IGFuZCBjIDwgNThcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ3IC0gYykgJiAoYyAtIDU4KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDggKyA1Mik7XG4gICAgICAgIC8vIGMgPiA2NCBhbmQgYyA8IDkxXG4gICAgICAgIHJlc3VsdCArPSAoKCg2NCAtIGMpICYgKGMgLSA5MSkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDY1ICsgMCk7XG4gICAgICAgIC8vIGMgPiA5NiBhbmQgYyA8IDEyM1xuICAgICAgICByZXN1bHQgKz0gKCgoOTYgLSBjKSAmIChjIC0gMTIzKSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gOTcgKyAyNik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDb2Rlci5wcm90b3R5cGUuX2dldFBhZGRpbmdMZW5ndGggPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgcGFkZGluZ0xlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9PSB0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPCA0IHx8IHBhZGRpbmdMZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFzZTY0Q29kZXI6IGluY29ycmVjdCBwYWRkaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWRkaW5nTGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIENvZGVyO1xufSgpKTtcbmV4cG9ydHMuQ29kZXIgPSBDb2RlcjtcbnZhciBzdGRDb2RlciA9IG5ldyBDb2RlcigpO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZW5jb2RlKGRhdGEpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5mdW5jdGlvbiBkZWNvZGUocykge1xuICAgIHJldHVybiBzdGRDb2Rlci5kZWNvZGUocyk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKlxuICogSW1wbGVtZW50cyBVUkwtc2FmZSBCYXNlNjQgZW5jb2RpbmcuXG4gKiAoU2FtZSBhcyBCYXNlNjQsIGJ1dCAnKycgaXMgcmVwbGFjZWQgd2l0aCAnLScsIGFuZCAnLycgd2l0aCAnXycpLlxuICpcbiAqIE9wZXJhdGVzIGluIGNvbnN0YW50IHRpbWUuXG4gKi9cbnZhciBVUkxTYWZlQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVSTFNhZmVDb2RlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVUkxTYWZlQ29kZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLy8gVVJMLXNhZmUgZW5jb2RpbmcgaGF2ZSB0aGUgZm9sbG93aW5nIGVuY29kZWQvZGVjb2RlZCByYW5nZXM6XG4gICAgLy9cbiAgICAvLyBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiAwMTIzNDU2Nzg5ICAtICAgX1xuICAgIC8vIEluZGV4OiAgIDAgLSAyNSAgICAgICAgICAgICAgICAgICAgMjYgLSA1MSAgICAgICAgICAgICAgNTIgLSA2MSAgIDYyICA2M1xuICAgIC8vIEFTQ0lJOiAgNjUgLSA5MCAgICAgICAgICAgICAgICAgICAgOTcgLSAxMjIgICAgICAgICAgICAgNDggLSA1NyAgIDQ1ICA5NVxuICAgIC8vXG4gICAgVVJMU2FmZUNvZGVyLnByb3RvdHlwZS5fZW5jb2RlQnl0ZSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBiO1xuICAgICAgICAvLyBiID49IDBcbiAgICAgICAgcmVzdWx0ICs9IDY1O1xuICAgICAgICAvLyBiID4gMjVcbiAgICAgICAgcmVzdWx0ICs9ICgoMjUgLSBiKSA+Pj4gOCkgJiAoKDAgLSA2NSkgLSAyNiArIDk3KTtcbiAgICAgICAgLy8gYiA+IDUxXG4gICAgICAgIHJlc3VsdCArPSAoKDUxIC0gYikgPj4+IDgpICYgKCgyNiAtIDk3KSAtIDUyICsgNDgpO1xuICAgICAgICAvLyBiID4gNjFcbiAgICAgICAgcmVzdWx0ICs9ICgoNjEgLSBiKSA+Pj4gOCkgJiAoKDUyIC0gNDgpIC0gNjIgKyA0NSk7XG4gICAgICAgIC8vIGIgPiA2MlxuICAgICAgICByZXN1bHQgKz0gKCg2MiAtIGIpID4+PiA4KSAmICgoNjIgLSA0NSkgLSA2MyArIDk1KTtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocmVzdWx0KTtcbiAgICB9O1xuICAgIFVSTFNhZmVDb2Rlci5wcm90b3R5cGUuX2RlY29kZUNoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gSU5WQUxJRF9CWVRFO1xuICAgICAgICAvLyBjID09IDQ1IChjID4gNDQgYW5kIGMgPCA0NilcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ0IC0gYykgJiAoYyAtIDQ2KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDUgKyA2Mik7XG4gICAgICAgIC8vIGMgPT0gOTUgKGMgPiA5NCBhbmQgYyA8IDk2KVxuICAgICAgICByZXN1bHQgKz0gKCgoOTQgLSBjKSAmIChjIC0gOTYpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA5NSArIDYzKTtcbiAgICAgICAgLy8gYyA+IDQ3IGFuZCBjIDwgNThcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ3IC0gYykgJiAoYyAtIDU4KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDggKyA1Mik7XG4gICAgICAgIC8vIGMgPiA2NCBhbmQgYyA8IDkxXG4gICAgICAgIHJlc3VsdCArPSAoKCg2NCAtIGMpICYgKGMgLSA5MSkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDY1ICsgMCk7XG4gICAgICAgIC8vIGMgPiA5NiBhbmQgYyA8IDEyM1xuICAgICAgICByZXN1bHQgKz0gKCgoOTYgLSBjKSAmIChjIC0gMTIzKSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gOTcgKyAyNik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gVVJMU2FmZUNvZGVyO1xufShDb2RlcikpO1xuZXhwb3J0cy5VUkxTYWZlQ29kZXIgPSBVUkxTYWZlQ29kZXI7XG52YXIgdXJsU2FmZUNvZGVyID0gbmV3IFVSTFNhZmVDb2RlcigpO1xuZnVuY3Rpb24gZW5jb2RlVVJMU2FmZShkYXRhKSB7XG4gICAgcmV0dXJuIHVybFNhZmVDb2Rlci5lbmNvZGUoZGF0YSk7XG59XG5leHBvcnRzLmVuY29kZVVSTFNhZmUgPSBlbmNvZGVVUkxTYWZlO1xuZnVuY3Rpb24gZGVjb2RlVVJMU2FmZShzKSB7XG4gICAgcmV0dXJuIHVybFNhZmVDb2Rlci5kZWNvZGUocyk7XG59XG5leHBvcnRzLmRlY29kZVVSTFNhZmUgPSBkZWNvZGVVUkxTYWZlO1xuZXhwb3J0cy5lbmNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBzdGRDb2Rlci5lbmNvZGVkTGVuZ3RoKGxlbmd0aCk7XG59O1xuZXhwb3J0cy5tYXhEZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBzdGRDb2Rlci5tYXhEZWNvZGVkTGVuZ3RoKGxlbmd0aCk7XG59O1xuZXhwb3J0cy5kZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZGVjb2RlZExlbmd0aChzKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIHV0ZjggaW1wbGVtZW50cyBVVEYtOCBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKi9cbnZhciBJTlZBTElEX1VURjE2ID0gXCJ1dGY4OiBpbnZhbGlkIHN0cmluZ1wiO1xudmFyIElOVkFMSURfVVRGOCA9IFwidXRmODogaW52YWxpZCBzb3VyY2UgZW5jb2RpbmdcIjtcbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gVVRGLTggYnl0ZSBhcnJheS5cbiAqIFRocm93cyBpZiB0aGUgc291cmNlIHN0cmluZyBoYXMgaW52YWxpZCBVVEYtMTYgZW5jb2RpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHJlc3VsdCBsZW5ndGggYW5kIGFsbG9jYXRlIG91dHB1dCBhcnJheS5cbiAgICAvLyBlbmNvZGVkTGVuZ3RoKCkgYWxzbyB2YWxpZGF0ZXMgc3RyaW5nIGFuZCB0aHJvd3MgZXJyb3JzLFxuICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgcmVwZWF0IHZhbGlkYXRpb24gaGVyZS5cbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZExlbmd0aChzKSk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4YzAgfCBjID4+IDY7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGUwIHwgYyA+PiAxMjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKzsgLy8gZ2V0IG9uZSBtb3JlIGNoYXJhY3RlclxuICAgICAgICAgICAgYyA9IChjICYgMHgzZmYpIDw8IDEwO1xuICAgICAgICAgICAgYyB8PSBzLmNoYXJDb2RlQXQoaSkgJiAweDNmZjtcbiAgICAgICAgICAgIGMgKz0gMHgxMDAwMDtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGYwIHwgYyA+PiAxODtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gMTIpICYgMHgzZjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBlbmNvZGUgdGhlIGdpdmVuIHN0cmluZyBpbnRvIFVURi04LlxuICogVGhyb3dzIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGhhcyBpbnZhbGlkIFVURi0xNiBlbmNvZGluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlZExlbmd0aChzKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGlmIChpID49IHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKzsgLy8gXCJlYXRcIiBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgcmVzdWx0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEYxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZW5jb2RlZExlbmd0aCA9IGVuY29kZWRMZW5ndGg7XG4vKipcbiAqIERlY29kZXMgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgZnJvbSBVVEYtOCBpbnRvIGEgc3RyaW5nLlxuICogVGhyb3dzIGlmIGVuY29kaW5nIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShhcnIpIHtcbiAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYiA9IGFycltpXTtcbiAgICAgICAgaWYgKGIgJiAweDgwKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGIgPCAweGUwKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAxIG1vcmUgYnl0ZS5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbjEgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG4xICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSAoYiAmIDB4MWYpIDw8IDYgfCAobjEgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA8IDB4ZjApIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIDIgbW9yZSBieXRlcy5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG4xID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgdmFyIG4yID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgaWYgKChuMSAmIDB4YzApICE9PSAweDgwIHx8IChuMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gKGIgJiAweDBmKSA8PCAxMiB8IChuMSAmIDB4M2YpIDw8IDYgfCAobjIgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPCAweGY4KSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAzIG1vcmUgYnl0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuMSA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMiA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMyA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIGlmICgobjEgJiAweGMwKSAhPT0gMHg4MCB8fCAobjIgJiAweGMwKSAhPT0gMHg4MCB8fCAobjMgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IChiICYgMHgwZikgPDwgMTggfCAobjEgJiAweDNmKSA8PCAxMiB8IChuMiAmIDB4M2YpIDw8IDYgfCAobjMgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDEwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA8IG1pbiB8fCAoYiA+PSAweGQ4MDAgJiYgYiA8PSAweGRmZmYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA+PSAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgaWYgKGIgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgfCAoYiA+PiAxMCkpKTtcbiAgICAgICAgICAgICAgICBiID0gMHhkYzAwIHwgKGIgJiAweDNmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyByZXF1aXJlZCBzbyB3ZSBkb24ndCBoYXZlIHRvIGRvIHJlcXVpcmUoJ3B1c2hlcicpLmRlZmF1bHQgZXRjLlxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLmRlZmF1bHQ7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZG9tL3NjcmlwdF9yZWNlaXZlcl9mYWN0b3J5LnRzXG52YXIgU2NyaXB0UmVjZWl2ZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JpcHRSZWNlaXZlckZhY3RvcnkocHJlZml4LCBuYW1lKSB7XG4gICAgICAgIHRoaXMubGFzdElkID0gMDtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIFNjcmlwdFJlY2VpdmVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGFzdElkKys7XG4gICAgICAgIHZhciBudW1iZXIgPSB0aGlzLmxhc3RJZDtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5wcmVmaXggKyBudW1iZXI7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lICsgJ1snICsgbnVtYmVyICsgJ10nO1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBjYWxsYmFja1dyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1tudW1iZXJdID0gY2FsbGJhY2tXcmFwcGVyO1xuICAgICAgICByZXR1cm4geyBudW1iZXI6IG51bWJlciwgaWQ6IGlkLCBuYW1lOiBuYW1lLCBjYWxsYmFjazogY2FsbGJhY2tXcmFwcGVyIH07XG4gICAgfTtcbiAgICBTY3JpcHRSZWNlaXZlckZhY3RvcnkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNlaXZlcikge1xuICAgICAgICBkZWxldGUgdGhpc1tyZWNlaXZlci5udW1iZXJdO1xuICAgIH07XG4gICAgcmV0dXJuIFNjcmlwdFJlY2VpdmVyRmFjdG9yeTtcbn0oKSk7XG5cbnZhciBTY3JpcHRSZWNlaXZlcnMgPSBuZXcgU2NyaXB0UmVjZWl2ZXJGYWN0b3J5KCdfcHVzaGVyX3NjcmlwdF8nLCAnUHVzaGVyLlNjcmlwdFJlY2VpdmVycycpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2RlZmF1bHRzLnRzXG52YXIgRGVmYXVsdHMgPSB7XG4gICAgVkVSU0lPTjogXCI3LjAuM1wiLFxuICAgIFBST1RPQ09MOiA3LFxuICAgIHdzUG9ydDogODAsXG4gICAgd3NzUG9ydDogNDQzLFxuICAgIHdzUGF0aDogJycsXG4gICAgaHR0cEhvc3Q6ICdzb2NranMucHVzaGVyLmNvbScsXG4gICAgaHR0cFBvcnQ6IDgwLFxuICAgIGh0dHBzUG9ydDogNDQzLFxuICAgIGh0dHBQYXRoOiAnL3B1c2hlcicsXG4gICAgc3RhdHNfaG9zdDogJ3N0YXRzLnB1c2hlci5jb20nLFxuICAgIGF1dGhFbmRwb2ludDogJy9wdXNoZXIvYXV0aCcsXG4gICAgYXV0aFRyYW5zcG9ydDogJ2FqYXgnLFxuICAgIGFjdGl2aXR5VGltZW91dDogMTIwMDAwLFxuICAgIHBvbmdUaW1lb3V0OiAzMDAwMCxcbiAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IDEwMDAwLFxuICAgIGNsdXN0ZXI6ICdtdDEnLFxuICAgIGNkbl9odHRwOiBcImh0dHA6Ly9qcy5wdXNoZXIuY29tXCIsXG4gICAgY2RuX2h0dHBzOiBcImh0dHBzOi8vanMucHVzaGVyLmNvbVwiLFxuICAgIGRlcGVuZGVuY3lfc3VmZml4OiBcIlwiXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVmYXVsdHMgPSAoRGVmYXVsdHMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZG9tL2RlcGVuZGVuY3lfbG9hZGVyLnRzXG5cblxudmFyIGRlcGVuZGVuY3lfbG9hZGVyX0RlcGVuZGVuY3lMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcGVuZGVuY3lMb2FkZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlY2VpdmVycyA9IG9wdGlvbnMucmVjZWl2ZXJzIHx8IFNjcmlwdFJlY2VpdmVycztcbiAgICAgICAgdGhpcy5sb2FkaW5nID0ge307XG4gICAgfVxuICAgIERlcGVuZGVuY3lMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5sb2FkaW5nW25hbWVdICYmIHNlbGYubG9hZGluZ1tuYW1lXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRpbmdbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRpbmdbbmFtZV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBydW50aW1lLmNyZWF0ZVNjcmlwdFJlcXVlc3Qoc2VsZi5nZXRQYXRoKG5hbWUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHNlbGYucmVjZWl2ZXJzLmNyZWF0ZShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlY2VpdmVycy5yZW1vdmUocmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvYWRpbmdbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHNlbGYubG9hZGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYubG9hZGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICh3YXNTdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhc1N1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXShlcnJvciwgc3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVwZW5kZW5jeUxvYWRlci5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBjZG47XG4gICAgICAgIHZhciBwcm90b2NvbCA9IHJ1bnRpbWUuZ2V0RG9jdW1lbnQoKS5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgaWYgKChvcHRpb25zICYmIG9wdGlvbnMudXNlVExTKSB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGNkbiA9IHRoaXMub3B0aW9ucy5jZG5faHR0cHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZG4gPSB0aGlzLm9wdGlvbnMuY2RuX2h0dHA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNkbi5yZXBsYWNlKC9cXC8qJC8sICcnKSArICcvJyArIHRoaXMub3B0aW9ucy52ZXJzaW9uO1xuICAgIH07XG4gICAgRGVwZW5kZW5jeUxvYWRlci5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJvb3Qob3B0aW9ucykgKyAnLycgKyBuYW1lICsgdGhpcy5vcHRpb25zLnN1ZmZpeCArICcuanMnO1xuICAgIH07XG4gICAgcmV0dXJuIERlcGVuZGVuY3lMb2FkZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVwZW5kZW5jeV9sb2FkZXIgPSAoZGVwZW5kZW5jeV9sb2FkZXJfRGVwZW5kZW5jeUxvYWRlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9kb20vZGVwZW5kZW5jaWVzLnRzXG5cblxuXG52YXIgRGVwZW5kZW5jaWVzUmVjZWl2ZXJzID0gbmV3IFNjcmlwdFJlY2VpdmVyRmFjdG9yeSgnX3B1c2hlcl9kZXBlbmRlbmNpZXMnLCAnUHVzaGVyLkRlcGVuZGVuY2llc1JlY2VpdmVycycpO1xudmFyIERlcGVuZGVuY2llcyA9IG5ldyBkZXBlbmRlbmN5X2xvYWRlcih7XG4gICAgY2RuX2h0dHA6IGRlZmF1bHRzLmNkbl9odHRwLFxuICAgIGNkbl9odHRwczogZGVmYXVsdHMuY2RuX2h0dHBzLFxuICAgIHZlcnNpb246IGRlZmF1bHRzLlZFUlNJT04sXG4gICAgc3VmZml4OiBkZWZhdWx0cy5kZXBlbmRlbmN5X3N1ZmZpeCxcbiAgICByZWNlaXZlcnM6IERlcGVuZGVuY2llc1JlY2VpdmVyc1xufSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdXJsX3N0b3JlLnRzXG52YXIgdXJsU3RvcmUgPSB7XG4gICAgYmFzZVVybDogJ2h0dHBzOi8vcHVzaGVyLmNvbScsXG4gICAgdXJsczoge1xuICAgICAgICBhdXRoZW50aWNhdGlvbkVuZHBvaW50OiB7XG4gICAgICAgICAgICBwYXRoOiAnL2RvY3MvYXV0aGVudGljYXRpbmdfdXNlcnMnXG4gICAgICAgIH0sXG4gICAgICAgIGphdmFzY3JpcHRRdWlja1N0YXJ0OiB7XG4gICAgICAgICAgICBwYXRoOiAnL2RvY3MvamF2YXNjcmlwdF9xdWlja19zdGFydCdcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlcmluZ0NsaWVudEV2ZW50czoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NsaWVudF9hcGlfZ3VpZGUvY2xpZW50X2V2ZW50cyN0cmlnZ2VyLWV2ZW50cydcbiAgICAgICAgfSxcbiAgICAgICAgZW5jcnlwdGVkQ2hhbm5lbFN1cHBvcnQ6IHtcbiAgICAgICAgICAgIGZ1bGxVcmw6ICdodHRwczovL2dpdGh1Yi5jb20vcHVzaGVyL3B1c2hlci1qcy90cmVlL2NjNDkxMDE1MzcxYTRiZGU1NzQzZDFjODdhMGZiYWMwZmViNTMxOTUjZW5jcnlwdGVkLWNoYW5uZWwtc3VwcG9ydCdcbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgYnVpbGRMb2dTdWZmaXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHVybFByZWZpeCA9ICdTZWU6JztcbiAgICB2YXIgdXJsT2JqID0gdXJsU3RvcmUudXJsc1trZXldO1xuICAgIGlmICghdXJsT2JqKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgdmFyIHVybDtcbiAgICBpZiAodXJsT2JqLmZ1bGxVcmwpIHtcbiAgICAgICAgdXJsID0gdXJsT2JqLmZ1bGxVcmw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVybE9iai5wYXRoKSB7XG4gICAgICAgIHVybCA9IHVybFN0b3JlLmJhc2VVcmwgKyB1cmxPYmoucGF0aDtcbiAgICB9XG4gICAgaWYgKCF1cmwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4gdXJsUHJlZml4ICsgXCIgXCIgKyB1cmw7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXJsX3N0b3JlID0gKHsgYnVpbGRMb2dTdWZmaXg6IGJ1aWxkTG9nU3VmZml4IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Vycm9ycy50c1xudmFyIF9fZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEJhZEV2ZW50TmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhZEV2ZW50TmFtZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYWRFdmVudE5hbWUobXNnKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbXNnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQmFkRXZlbnROYW1lO1xufShFcnJvcikpO1xuXG52YXIgUmVxdWVzdFRpbWVkT3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVxdWVzdFRpbWVkT3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcXVlc3RUaW1lZE91dChtc2cpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtc2cpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZXF1ZXN0VGltZWRPdXQ7XG59KEVycm9yKSk7XG5cbnZhciBUcmFuc3BvcnRQcmlvcml0eVRvb0xvdyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYW5zcG9ydFByaW9yaXR5VG9vTG93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydFByaW9yaXR5VG9vTG93KG1zZykge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1zZykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBfbmV3VGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zcG9ydFByaW9yaXR5VG9vTG93O1xufShFcnJvcikpO1xuXG52YXIgVHJhbnNwb3J0Q2xvc2VkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhbnNwb3J0Q2xvc2VkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydENsb3NlZChtc2cpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtc2cpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc3BvcnRDbG9zZWQ7XG59KEVycm9yKSk7XG5cbnZhciBVbnN1cHBvcnRlZEZlYXR1cmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbnN1cHBvcnRlZEZlYXR1cmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdXBwb3J0ZWRGZWF0dXJlKG1zZykge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1zZykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBfbmV3VGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFVuc3VwcG9ydGVkRmVhdHVyZTtcbn0oRXJyb3IpKTtcblxudmFyIFVuc3VwcG9ydGVkVHJhbnNwb3J0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5zdXBwb3J0ZWRUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdXBwb3J0ZWRUcmFuc3BvcnQobXNnKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbXNnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVW5zdXBwb3J0ZWRUcmFuc3BvcnQ7XG59KEVycm9yKSk7XG5cbnZhciBVbnN1cHBvcnRlZFN0cmF0ZWd5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5zdXBwb3J0ZWRTdHJhdGVneSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbnN1cHBvcnRlZFN0cmF0ZWd5KG1zZykge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1zZykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBfbmV3VGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFVuc3VwcG9ydGVkU3RyYXRlZ3k7XG59KEVycm9yKSk7XG5cbnZhciBIVFRQQXV0aEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSFRUUEF1dGhFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIVFRQQXV0aEVycm9yKHN0YXR1cywgbXNnKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbXNnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIVFRQQXV0aEVycm9yO1xufShFcnJvcikpO1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL2lzb21vcnBoaWMvYXV0aC94aHJfYXV0aC50c1xuXG5cblxudmFyIGFqYXggPSBmdW5jdGlvbiAoY29udGV4dCwgc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCB4aHI7XG4gICAgeGhyID0gcnVudGltZS5jcmVhdGVYSFIoKTtcbiAgICB4aHIub3BlbignUE9TVCcsIHNlbGYub3B0aW9ucy5hdXRoRW5kcG9pbnQsIHRydWUpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiB0aGlzLmF1dGhPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgdGhpcy5hdXRoT3B0aW9ucy5oZWFkZXJzW2hlYWRlck5hbWVdKTtcbiAgICB9XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgSFRUUEF1dGhFcnJvcigyMDAsICdKU09OIHJldHVybmVkIGZyb20gYXV0aCBlbmRwb2ludCB3YXMgaW52YWxpZCwgeWV0IHN0YXR1cyBjb2RlIHdhcyAyMDAuIERhdGEgd2FzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQpLCB7IGF1dGg6ICcnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdWZmaXggPSB1cmxfc3RvcmUuYnVpbGRMb2dTdWZmaXgoJ2F1dGhlbnRpY2F0aW9uRW5kcG9pbnQnKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgSFRUUEF1dGhFcnJvcih4aHIuc3RhdHVzLCAnVW5hYmxlIHRvIHJldHJpZXZlIGF1dGggc3RyaW5nIGZyb20gYXV0aCBlbmRwb2ludCAtICcgK1xuICAgICAgICAgICAgICAgICAgICAoXCJyZWNlaXZlZCBzdGF0dXM6IFwiICsgeGhyLnN0YXR1cyArIFwiIGZyb20gXCIgKyBzZWxmLm9wdGlvbnMuYXV0aEVuZHBvaW50ICsgXCIuIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChcIkNsaWVudHMgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIGpvaW4gcHJpdmF0ZSBvciBwcmVzZW5jZSBjaGFubmVscy4gXCIgKyBzdWZmaXgpKSwgeyBhdXRoOiAnJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgeGhyLnNlbmQodGhpcy5jb21wb3NlUXVlcnkoc29ja2V0SWQpKTtcbiAgICByZXR1cm4geGhyO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocl9hdXRoID0gKGFqYXgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Jhc2U2NC50c1xuZnVuY3Rpb24gZW5jb2RlKHMpIHtcbiAgICByZXR1cm4gYnRvYSh1dG9iKHMpKTtcbn1cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIGI2NGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xudmFyIGI2NHRhYiA9IHt9O1xuZm9yICh2YXIgYmFzZTY0X2kgPSAwLCBsID0gYjY0Y2hhcnMubGVuZ3RoOyBiYXNlNjRfaSA8IGw7IGJhc2U2NF9pKyspIHtcbiAgICBiNjR0YWJbYjY0Y2hhcnMuY2hhckF0KGJhc2U2NF9pKV0gPSBiYXNlNjRfaTtcbn1cbnZhciBjYl91dG9iID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGNjIDwgMHg4MFxuICAgICAgICA/IGNcbiAgICAgICAgOiBjYyA8IDB4ODAwXG4gICAgICAgICAgICA/IGZyb21DaGFyQ29kZSgweGMwIHwgKGNjID4+PiA2KSkgKyBmcm9tQ2hhckNvZGUoMHg4MCB8IChjYyAmIDB4M2YpKVxuICAgICAgICAgICAgOiBmcm9tQ2hhckNvZGUoMHhlMCB8ICgoY2MgPj4+IDEyKSAmIDB4MGYpKSArXG4gICAgICAgICAgICAgICAgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKSArXG4gICAgICAgICAgICAgICAgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSk7XG59O1xudmFyIHV0b2IgPSBmdW5jdGlvbiAodSkge1xuICAgIHJldHVybiB1LnJlcGxhY2UoL1teXFx4MDAtXFx4N0ZdL2csIGNiX3V0b2IpO1xufTtcbnZhciBjYl9lbmNvZGUgPSBmdW5jdGlvbiAoY2NjKSB7XG4gICAgdmFyIHBhZGxlbiA9IFswLCAyLCAxXVtjY2MubGVuZ3RoICUgM107XG4gICAgdmFyIG9yZCA9IChjY2MuY2hhckNvZGVBdCgwKSA8PCAxNikgfFxuICAgICAgICAoKGNjYy5sZW5ndGggPiAxID8gY2NjLmNoYXJDb2RlQXQoMSkgOiAwKSA8PCA4KSB8XG4gICAgICAgIChjY2MubGVuZ3RoID4gMiA/IGNjYy5jaGFyQ29kZUF0KDIpIDogMCk7XG4gICAgdmFyIGNoYXJzID0gW1xuICAgICAgICBiNjRjaGFycy5jaGFyQXQob3JkID4+PiAxOCksXG4gICAgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MyksXG4gICAgICAgIHBhZGxlbiA+PSAyID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDYpICYgNjMpLFxuICAgICAgICBwYWRsZW4gPj0gMSA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdChvcmQgJiA2MylcbiAgICBdO1xuICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbn07XG52YXIgYnRvYSA9IHdpbmRvdy5idG9hIHx8XG4gICAgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZSgvW1xcc1xcU117MSwzfS9nLCBjYl9lbmNvZGUpO1xuICAgIH07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdGltZXJzL2Fic3RyYWN0X3RpbWVyLnRzXG52YXIgVGltZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVyKHNldCwgY2xlYXIsIGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFyID0gY2xlYXI7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudGltZXIgPSBjYWxsYmFjayhfdGhpcy50aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9XG4gICAgVGltZXIucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXIgIT09IG51bGw7XG4gICAgfTtcbiAgICBUaW1lci5wcm90b3R5cGUuZW5zdXJlQWJvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRpbWVyO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGFic3RyYWN0X3RpbWVyID0gKFRpbWVyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy90aW1lcnMvaW5kZXgudHNcbnZhciB0aW1lcnNfZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuXG5mdW5jdGlvbiB0aW1lcnNfY2xlYXJUaW1lb3V0KHRpbWVyKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG59XG5mdW5jdGlvbiB0aW1lcnNfY2xlYXJJbnRlcnZhbCh0aW1lcikge1xuICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRpbWVyKTtcbn1cbnZhciBPbmVPZmZUaW1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdGltZXJzX2V4dGVuZHMoT25lT2ZmVGltZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT25lT2ZmVGltZXIoZGVsYXksIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzZXRUaW1lb3V0LCB0aW1lcnNfY2xlYXJUaW1lb3V0LCBkZWxheSwgZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBPbmVPZmZUaW1lcjtcbn0oYWJzdHJhY3RfdGltZXIpKTtcblxudmFyIFBlcmlvZGljVGltZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRpbWVyc19leHRlbmRzKFBlcmlvZGljVGltZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGVyaW9kaWNUaW1lcihkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNldEludGVydmFsLCB0aW1lcnNfY2xlYXJJbnRlcnZhbCwgZGVsYXksIGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lcjtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBlcmlvZGljVGltZXI7XG59KGFic3RyYWN0X3RpbWVyKSk7XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlsLnRzXG5cbnZhciBVdGlsID0ge1xuICAgIG5vdzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoRGF0ZS5ub3cpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZWZlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgT25lT2ZmVGltZXIoMCwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgbWV0aG9kOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm91bmRBcmd1bWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtuYW1lXS5hcHBseShvYmplY3QsIGJvdW5kQXJndW1lbnRzLmNvbmNhdChhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXRpbCA9IChVdGlsKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy9jb2xsZWN0aW9ucy50c1xuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zW3Byb3BlcnR5XSAmJlxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNbcHJvcGVydHldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1twcm9wZXJ0eV0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBleHRlbmQodGFyZ2V0W3Byb3BlcnR5XSB8fCB7fSwgZXh0ZW5zaW9uc1twcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGV4dGVuc2lvbnNbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgdmFyIG0gPSBbJ1B1c2hlciddO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbS5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtLnB1c2goc2FmZUpTT05TdHJpbmdpZnkoYXJndW1lbnRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uam9pbignIDogJyk7XG59XG5mdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyYXksIGl0ZW0pIHtcbiAgICB2YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIGlmIChhcnJheSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gb2JqZWN0QXBwbHkob2JqZWN0LCBmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgZihvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBhcHBseShhcnJheSwgZiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZi5jYWxsKGNvbnRleHQgfHwgd2luZG93LCBhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGYoYXJyYXlbaV0sIGksIGFycmF5LCByZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGYpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGYodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXIoYXJyYXksIHRlc3QpIHtcbiAgICB0ZXN0ID1cbiAgICAgICAgdGVzdCB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXN0KGFycmF5W2ldLCBpLCBhcnJheSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXJPYmplY3Qob2JqZWN0LCB0ZXN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKCh0ZXN0ICYmIHRlc3QodmFsdWUsIGtleSwgb2JqZWN0LCByZXN1bHQpKSB8fCBCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmbGF0dGVuKG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBvYmplY3RBcHBseShvYmplY3QsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFueShhcnJheSwgdGVzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdGlvbnNfYWxsKGFycmF5LCB0ZXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5jb2RlUGFyYW1zT2JqZWN0KGRhdGEpIHtcbiAgICByZXR1cm4gbWFwT2JqZWN0KGRhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSBzYWZlSlNPTlN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlbmNvZGUodmFsdWUudG9TdHJpbmcoKSkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRRdWVyeVN0cmluZyhkYXRhKSB7XG4gICAgdmFyIHBhcmFtcyA9IGZpbHRlck9iamVjdChkYXRhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgdmFyIHF1ZXJ5ID0gbWFwKGZsYXR0ZW4oZW5jb2RlUGFyYW1zT2JqZWN0KHBhcmFtcykpLCB1dGlsLm1ldGhvZCgnam9pbicsICc9JykpLmpvaW4oJyYnKTtcbiAgICByZXR1cm4gcXVlcnk7XG59XG5mdW5jdGlvbiBkZWN5Y2xlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBvYmplY3RzID0gW10sIHBhdGhzID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBkZXJleih2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgaSwgbmFtZSwgbnU7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgJHJlZjogcGF0aHNbaV0gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICAgIG51ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVbaV0gPSBkZXJleih2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBudSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVbbmFtZV0gPSBkZXJleih2YWx1ZVtuYW1lXSwgcGF0aCArICdbJyArIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnU7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pKG9iamVjdCwgJyQnKTtcbn1cbmZ1bmN0aW9uIHNhZmVKU09OU3RyaW5naWZ5KHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3VyY2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGVjeWNsZU9iamVjdChzb3VyY2UpKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvbG9nZ2VyLnRzXG5cblxudmFyIGxvZ2dlcl9Mb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlcigpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxMb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZyh0aGlzLmdsb2JhbExvZywgYXJncyk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2codGhpcy5nbG9iYWxMb2dXYXJuLCBhcmdzKTtcbiAgICB9O1xuICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2codGhpcy5nbG9iYWxMb2dFcnJvciwgYXJncyk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmdsb2JhbExvZ1dhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmdsb2JhbExvZ0Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nV2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoZGVmYXVsdExvZ2dpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZSA9IHN0cmluZ2lmeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoY29yZV9wdXNoZXIubG9nKSB7XG4gICAgICAgICAgICBjb3JlX3B1c2hlci5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29yZV9wdXNoZXIubG9nVG9Db25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgbG9nID0gZGVmYXVsdExvZ2dpbmdGdW5jdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgbG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxvZ2dlciA9IChuZXcgbG9nZ2VyX0xvZ2dlcigpKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL2F1dGgvanNvbnBfYXV0aC50c1xuXG52YXIganNvbnAgPSBmdW5jdGlvbiAoY29udGV4dCwgc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuYXV0aE9wdGlvbnMuaGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdUbyBzZW5kIGhlYWRlcnMgd2l0aCB0aGUgYXV0aCByZXF1ZXN0LCB5b3UgbXVzdCB1c2UgQUpBWCwgcmF0aGVyIHRoYW4gSlNPTlAuJyk7XG4gICAgfVxuICAgIHZhciBjYWxsYmFja05hbWUgPSBjb250ZXh0Lm5leHRBdXRoQ2FsbGJhY2tJRC50b1N0cmluZygpO1xuICAgIGNvbnRleHQubmV4dEF1dGhDYWxsYmFja0lEKys7XG4gICAgdmFyIGRvY3VtZW50ID0gY29udGV4dC5nZXREb2N1bWVudCgpO1xuICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBjb250ZXh0LmF1dGhfY2FsbGJhY2tzW2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9O1xuICAgIHZhciBjYWxsYmFja19uYW1lID0gXCJQdXNoZXIuYXV0aF9jYWxsYmFja3NbJ1wiICsgY2FsbGJhY2tOYW1lICsgXCInXVwiO1xuICAgIHNjcmlwdC5zcmMgPVxuICAgICAgICB0aGlzLm9wdGlvbnMuYXV0aEVuZHBvaW50ICtcbiAgICAgICAgICAgICc/Y2FsbGJhY2s9JyArXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoY2FsbGJhY2tfbmFtZSkgK1xuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zZVF1ZXJ5KHNvY2tldElkKTtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBqc29ucF9hdXRoID0gKGpzb25wKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL2RvbS9zY3JpcHRfcmVxdWVzdC50c1xudmFyIFNjcmlwdFJlcXVlc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcmlwdFJlcXVlc3Qoc3JjKSB7XG4gICAgICAgIHRoaXMuc3JjID0gc3JjO1xuICAgIH1cbiAgICBTY3JpcHRSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gJ0Vycm9yIGxvYWRpbmcgJyArIHNlbGYuc3JjO1xuICAgICAgICBzZWxmLnNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzZWxmLnNjcmlwdC5pZCA9IHJlY2VpdmVyLmlkO1xuICAgICAgICBzZWxmLnNjcmlwdC5zcmMgPSBzZWxmLnNyYztcbiAgICAgICAgc2VsZi5zY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzZWxmLnNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgICAgICAgaWYgKHNlbGYuc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuY2FsbGJhY2soZXJyb3JTdHJpbmcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5jYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2NyaXB0LnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2NyaXB0LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIuY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5zY3JpcHQuYXN5bmMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQgJiZcbiAgICAgICAgICAgIC9vcGVyYS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIHNlbGYuZXJyb3JTY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNlbGYuZXJyb3JTY3JpcHQuaWQgPSByZWNlaXZlci5pZCArICdfZXJyb3InO1xuICAgICAgICAgICAgc2VsZi5lcnJvclNjcmlwdC50ZXh0ID0gcmVjZWl2ZXIubmFtZSArIFwiKCdcIiArIGVycm9yU3RyaW5nICsgXCInKTtcIjtcbiAgICAgICAgICAgIHNlbGYuc2NyaXB0LmFzeW5jID0gc2VsZi5lcnJvclNjcmlwdC5hc3luYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2VsZi5zY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgICAgIGlmIChzZWxmLmVycm9yU2NyaXB0KSB7XG4gICAgICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzZWxmLmVycm9yU2NyaXB0LCBzZWxmLnNjcmlwdC5uZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcmlwdFJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcmlwdCkge1xuICAgICAgICAgICAgdGhpcy5zY3JpcHQub25sb2FkID0gdGhpcy5zY3JpcHQub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjcmlwdCAmJiB0aGlzLnNjcmlwdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lcnJvclNjcmlwdCAmJiB0aGlzLmVycm9yU2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JTY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVycm9yU2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZXJyb3JTY3JpcHQgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFNjcmlwdFJlcXVlc3Q7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc2NyaXB0X3JlcXVlc3QgPSAoU2NyaXB0UmVxdWVzdCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9kb20vanNvbnBfcmVxdWVzdC50c1xuXG5cbnZhciBqc29ucF9yZXF1ZXN0X0pTT05QUmVxdWVzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTlBSZXF1ZXN0KHVybCwgZGF0YSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgSlNPTlBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKHRoaXMuZGF0YSk7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnVybCArICcvJyArIHJlY2VpdmVyLm51bWJlciArICc/JyArIHF1ZXJ5O1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSBydW50aW1lLmNyZWF0ZVNjcmlwdFJlcXVlc3QodXJsKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0LnNlbmQocmVjZWl2ZXIpO1xuICAgIH07XG4gICAgSlNPTlBSZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTlBSZXF1ZXN0O1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGpzb25wX3JlcXVlc3QgPSAoanNvbnBfcmVxdWVzdF9KU09OUFJlcXVlc3QpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvdGltZWxpbmUvanNvbnBfdGltZWxpbmUudHNcblxuXG52YXIgZ2V0QWdlbnQgPSBmdW5jdGlvbiAoc2VuZGVyLCB1c2VUTFMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzY2hlbWUgPSAnaHR0cCcgKyAodXNlVExTID8gJ3MnIDogJycpICsgJzovLyc7XG4gICAgICAgIHZhciB1cmwgPSBzY2hlbWUgKyAoc2VuZGVyLmhvc3QgfHwgc2VuZGVyLm9wdGlvbnMuaG9zdCkgKyBzZW5kZXIub3B0aW9ucy5wYXRoO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHJ1bnRpbWUuY3JlYXRlSlNPTlBSZXF1ZXN0KHVybCwgZGF0YSk7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHJ1bnRpbWUuU2NyaXB0UmVjZWl2ZXJzLmNyZWF0ZShmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICAgICAgU2NyaXB0UmVjZWl2ZXJzLnJlbW92ZShyZWNlaXZlcik7XG4gICAgICAgICAgICByZXF1ZXN0LmNsZWFudXAoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmhvc3QpIHtcbiAgICAgICAgICAgICAgICBzZW5kZXIuaG9zdCA9IHJlc3VsdC5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LnNlbmQocmVjZWl2ZXIpO1xuICAgIH07XG59O1xudmFyIGpzb25wX3RpbWVsaW5lX2pzb25wID0ge1xuICAgIG5hbWU6ICdqc29ucCcsXG4gICAgZ2V0QWdlbnQ6IGdldEFnZW50XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIganNvbnBfdGltZWxpbmUgPSAoanNvbnBfdGltZWxpbmVfanNvbnApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RyYW5zcG9ydHMvdXJsX3NjaGVtZXMudHNcblxuZnVuY3Rpb24gZ2V0R2VuZXJpY1VSTChiYXNlU2NoZW1lLCBwYXJhbXMsIHBhdGgpIHtcbiAgICB2YXIgc2NoZW1lID0gYmFzZVNjaGVtZSArIChwYXJhbXMudXNlVExTID8gJ3MnIDogJycpO1xuICAgIHZhciBob3N0ID0gcGFyYW1zLnVzZVRMUyA/IHBhcmFtcy5ob3N0VExTIDogcGFyYW1zLmhvc3ROb25UTFM7XG4gICAgcmV0dXJuIHNjaGVtZSArICc6Ly8nICsgaG9zdCArIHBhdGg7XG59XG5mdW5jdGlvbiBnZXRHZW5lcmljUGF0aChrZXksIHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIHBhdGggPSAnL2FwcC8nICsga2V5O1xuICAgIHZhciBxdWVyeSA9ICc/cHJvdG9jb2w9JyArXG4gICAgICAgIGRlZmF1bHRzLlBST1RPQ09MICtcbiAgICAgICAgJyZjbGllbnQ9anMnICtcbiAgICAgICAgJyZ2ZXJzaW9uPScgK1xuICAgICAgICBkZWZhdWx0cy5WRVJTSU9OICtcbiAgICAgICAgKHF1ZXJ5U3RyaW5nID8gJyYnICsgcXVlcnlTdHJpbmcgOiAnJyk7XG4gICAgcmV0dXJuIHBhdGggKyBxdWVyeTtcbn1cbnZhciB3cyA9IHtcbiAgICBnZXRJbml0aWFsOiBmdW5jdGlvbiAoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhdGggPSAocGFyYW1zLmh0dHBQYXRoIHx8ICcnKSArIGdldEdlbmVyaWNQYXRoKGtleSwgJ2ZsYXNoPWZhbHNlJyk7XG4gICAgICAgIHJldHVybiBnZXRHZW5lcmljVVJMKCd3cycsIHBhcmFtcywgcGF0aCk7XG4gICAgfVxufTtcbnZhciBodHRwID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICB2YXIgcGF0aCA9IChwYXJhbXMuaHR0cFBhdGggfHwgJy9wdXNoZXInKSArIGdldEdlbmVyaWNQYXRoKGtleSk7XG4gICAgICAgIHJldHVybiBnZXRHZW5lcmljVVJMKCdodHRwJywgcGFyYW1zLCBwYXRoKTtcbiAgICB9XG59O1xudmFyIHNvY2tqcyA9IHtcbiAgICBnZXRJbml0aWFsOiBmdW5jdGlvbiAoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ2h0dHAnLCBwYXJhbXMsIHBhcmFtcy5odHRwUGF0aCB8fCAnL3B1c2hlcicpO1xuICAgIH0sXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24gKGtleSwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBnZXRHZW5lcmljUGF0aChrZXkpO1xuICAgIH1cbn07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZXZlbnRzL2NhbGxiYWNrX3JlZ2lzdHJ5LnRzXG5cbnZhciBjYWxsYmFja19yZWdpc3RyeV9DYWxsYmFja1JlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWxsYmFja1JlZ2lzdHJ5KCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICB9XG4gICAgQ2FsbGJhY2tSZWdpc3RyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1twcmVmaXgobmFtZSldO1xuICAgIH07XG4gICAgQ2FsbGJhY2tSZWdpc3RyeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBwcmVmaXhlZEV2ZW50TmFtZSA9IHByZWZpeChuYW1lKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzW3ByZWZpeGVkRXZlbnROYW1lXSA9XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3NbcHJlZml4ZWRFdmVudE5hbWVdIHx8IFtdO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3NbcHJlZml4ZWRFdmVudE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgZm46IGNhbGxiYWNrLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGxiYWNrUmVnaXN0cnkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICBpZiAoIW5hbWUgJiYgIWNhbGxiYWNrICYmICFjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lID8gW3ByZWZpeChuYW1lKV0gOiBrZXlzKHRoaXMuX2NhbGxiYWNrcyk7XG4gICAgICAgIGlmIChjYWxsYmFjayB8fCBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNhbGxiYWNrKG5hbWVzLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbENhbGxiYWNrcyhuYW1lcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGxiYWNrUmVnaXN0cnkucHJvdG90eXBlLnJlbW92ZUNhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWVzLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICBhcHBseShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1tuYW1lXSA9IGZpbHRlcih0aGlzLl9jYWxsYmFja3NbbmFtZV0gfHwgW10sIGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGJpbmRpbmcuZm4pIHx8XG4gICAgICAgICAgICAgICAgICAgIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGJpbmRpbmcuY29udGV4dCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgQ2FsbGJhY2tSZWdpc3RyeS5wcm90b3R5cGUucmVtb3ZlQWxsQ2FsbGJhY2tzID0gZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAgIGFwcGx5KG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tuYW1lXTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbGJhY2tSZWdpc3RyeTtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjYWxsYmFja19yZWdpc3RyeSA9IChjYWxsYmFja19yZWdpc3RyeV9DYWxsYmFja1JlZ2lzdHJ5KTtcbmZ1bmN0aW9uIHByZWZpeChuYW1lKSB7XG4gICAgcmV0dXJuICdfJyArIG5hbWU7XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZXZlbnRzL2Rpc3BhdGNoZXIudHNcblxuXG52YXIgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXNwYXRjaGVyKGZhaWxUaHJvdWdoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IGNhbGxiYWNrX3JlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmZhaWxUaHJvdWdoID0gZmFpbFRocm91Z2g7XG4gICAgfVxuICAgIERpc3BhdGNoZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5hZGQoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRGlzcGF0Y2hlci5wcm90b3R5cGUuYmluZF9nbG9iYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERpc3BhdGNoZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnJlbW92ZShldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS51bmJpbmRfZ2xvYmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gZmlsdGVyKHRoaXMuZ2xvYmFsX2NhbGxiYWNrcyB8fCBbXSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgIT09IGNhbGxiYWNrOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS51bmJpbmRfYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgICB0aGlzLnVuYmluZF9nbG9iYWwoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdsb2JhbF9jYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrc1tpXShldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2tzICYmIGNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5mbi5hcHBseShjYWxsYmFja3NbaV0uY29udGV4dCB8fCB3aW5kb3csIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmFpbFRocm91Z2gpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbFRocm91Z2goZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBEaXNwYXRjaGVyO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRpc3BhdGNoZXIgPSAoZGlzcGF0Y2hlcl9EaXNwYXRjaGVyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL3RyYW5zcG9ydF9jb25uZWN0aW9uLnRzXG52YXIgdHJhbnNwb3J0X2Nvbm5lY3Rpb25fZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuXG5cblxuXG5cbnZhciB0cmFuc3BvcnRfY29ubmVjdGlvbl9UcmFuc3BvcnRDb25uZWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0cmFuc3BvcnRfY29ubmVjdGlvbl9leHRlbmRzKFRyYW5zcG9ydENvbm5lY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3J0Q29ubmVjdGlvbihob29rcywgbmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbml0aWFsaXplID0gcnVudGltZS50cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXI7XG4gICAgICAgIF90aGlzLmhvb2tzID0gaG9va3M7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICBfdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9ICduZXcnO1xuICAgICAgICBfdGhpcy50aW1lbGluZSA9IG9wdGlvbnMudGltZWxpbmU7XG4gICAgICAgIF90aGlzLmFjdGl2aXR5VGltZW91dCA9IG9wdGlvbnMuYWN0aXZpdHlUaW1lb3V0O1xuICAgICAgICBfdGhpcy5pZCA9IF90aGlzLnRpbWVsaW5lLmdlbmVyYXRlVW5pcXVlSUQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVzQWN0aXZpdHlDaGVja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaG9va3MuaGFuZGxlc0FjdGl2aXR5Q2hlY2tzKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLnN1cHBvcnRzUGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5ob29rcy5zdXBwb3J0c1BpbmcpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0Q29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0IHx8IHRoaXMuc3RhdGUgIT09ICdpbml0aWFsaXplZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gdGhpcy5ob29rcy51cmxzLmdldEluaXRpYWwodGhpcy5rZXksIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldCA9IHRoaXMuaG9va3MuZ2V0U29ja2V0KHVybCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXRpbC5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTdGF0ZSgnY2xvc2VkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdDb25uZWN0aW5nJywgeyB0cmFuc3BvcnQ6IHRoaXMubmFtZSwgdXJsOiB1cmwgfSk7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICB1dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnb3BlbicgJiYgdGhpcy5zdXBwb3J0c1BpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQucGluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmJlZm9yZU9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MuYmVmb3JlT3Blbih0aGlzLnNvY2tldCwgdGhpcy5ob29rcy51cmxzLmdldFBhdGgodGhpcy5rZXksIHRoaXMub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ29wZW4nKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgVHJhbnNwb3J0Q29ubmVjdGlvbi5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgeyB0eXBlOiAnV2ViU29ja2V0RXJyb3InLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgIHRoaXMudGltZWxpbmUuZXJyb3IodGhpcy5idWlsZFRpbWVsaW5lTWVzc2FnZSh7IGVycm9yOiBlcnJvci50b1N0cmluZygpIH0pKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoY2xvc2VFdmVudCkge1xuICAgICAgICBpZiAoY2xvc2VFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnY2xvc2VkJywge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNsb3NlRXZlbnQuY29kZSxcbiAgICAgICAgICAgICAgICByZWFzb246IGNsb3NlRXZlbnQucmVhc29uLFxuICAgICAgICAgICAgICAgIHdhc0NsZWFuOiBjbG9zZUV2ZW50Lndhc0NsZWFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgVHJhbnNwb3J0Q29ubmVjdGlvbi5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5vbkFjdGl2aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2aXR5Jyk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5iaW5kTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMub25FcnJvcihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbiAoY2xvc2VFdmVudCkge1xuICAgICAgICAgICAgX3RoaXMub25DbG9zZShjbG9zZUV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzLm9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uYWN0aXZpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25BY3Rpdml0eSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNwb3J0Q29ubmVjdGlvbi5wcm90b3R5cGUudW5iaW5kTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9ub3BlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbmNsb3NlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5vbmFjdGl2aXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHRoaXMuYnVpbGRUaW1lbGluZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVtaXQoc3RhdGUsIHBhcmFtcyk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5idWlsZFRpbWVsaW5lTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoeyBjaWQ6IHRoaXMuaWQgfSwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNwb3J0Q29ubmVjdGlvbjtcbn0oZGlzcGF0Y2hlcikpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0X2Nvbm5lY3Rpb24gPSAodHJhbnNwb3J0X2Nvbm5lY3Rpb25fVHJhbnNwb3J0Q29ubmVjdGlvbik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnQudHNcblxudmFyIHRyYW5zcG9ydF9UcmFuc3BvcnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydChob29rcykge1xuICAgICAgICB0aGlzLmhvb2tzID0gaG9va3M7XG4gICAgfVxuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9va3MuaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHByaW9yaXR5LCBrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRfY29ubmVjdGlvbih0aGlzLmhvb2tzLCBuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc3BvcnQ7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0c190cmFuc3BvcnQgPSAodHJhbnNwb3J0X1RyYW5zcG9ydCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL2lzb21vcnBoaWMvdHJhbnNwb3J0cy90cmFuc3BvcnRzLnRzXG5cblxuXG5cbnZhciBXU1RyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzX3RyYW5zcG9ydCh7XG4gICAgdXJsczogd3MsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiBmYWxzZSxcbiAgICBzdXBwb3J0c1Bpbmc6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocnVudGltZS5nZXRXZWJTb2NrZXRBUEkoKSk7XG4gICAgfSxcbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihydW50aW1lLmdldFdlYlNvY2tldEFQSSgpKTtcbiAgICB9LFxuICAgIGdldFNvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gcnVudGltZS5jcmVhdGVXZWJTb2NrZXQodXJsKTtcbiAgICB9XG59KTtcbnZhciBodHRwQ29uZmlndXJhdGlvbiA9IHtcbiAgICB1cmxzOiBodHRwLFxuICAgIGhhbmRsZXNBY3Rpdml0eUNoZWNrczogZmFsc2UsXG4gICAgc3VwcG9ydHNQaW5nOiB0cnVlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbnZhciBzdHJlYW1pbmdDb25maWd1cmF0aW9uID0gZXh0ZW5kKHtcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHJ1bnRpbWUuSFRUUEZhY3RvcnkuY3JlYXRlU3RyZWFtaW5nU29ja2V0KHVybCk7XG4gICAgfVxufSwgaHR0cENvbmZpZ3VyYXRpb24pO1xudmFyIHBvbGxpbmdDb25maWd1cmF0aW9uID0gZXh0ZW5kKHtcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHJ1bnRpbWUuSFRUUEZhY3RvcnkuY3JlYXRlUG9sbGluZ1NvY2tldCh1cmwpO1xuICAgIH1cbn0sIGh0dHBDb25maWd1cmF0aW9uKTtcbnZhciB4aHJDb25maWd1cmF0aW9uID0ge1xuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBydW50aW1lLmlzWEhSU3VwcG9ydGVkKCk7XG4gICAgfVxufTtcbnZhciBYSFJTdHJlYW1pbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c190cmFuc3BvcnQoKGV4dGVuZCh7fSwgc3RyZWFtaW5nQ29uZmlndXJhdGlvbiwgeGhyQ29uZmlndXJhdGlvbikpKTtcbnZhciBYSFJQb2xsaW5nVHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNfdHJhbnNwb3J0KGV4dGVuZCh7fSwgcG9sbGluZ0NvbmZpZ3VyYXRpb24sIHhockNvbmZpZ3VyYXRpb24pKTtcbnZhciBUcmFuc3BvcnRzID0ge1xuICAgIHdzOiBXU1RyYW5zcG9ydCxcbiAgICB4aHJfc3RyZWFtaW5nOiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQsXG4gICAgeGhyX3BvbGxpbmc6IFhIUlBvbGxpbmdUcmFuc3BvcnRcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRzID0gKFRyYW5zcG9ydHMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvdHJhbnNwb3J0cy90cmFuc3BvcnRzLnRzXG5cblxuXG5cblxuXG52YXIgU29ja0pTVHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNfdHJhbnNwb3J0KHtcbiAgICBmaWxlOiAnc29ja2pzJyxcbiAgICB1cmxzOiBzb2NranMsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiB0cnVlLFxuICAgIHN1cHBvcnRzUGluZzogZmFsc2UsXG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBpc0luaXRpYWxpemVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuU29ja0pTICE9PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU29ja0pTKHVybCwgbnVsbCwge1xuICAgICAgICAgICAganNfcGF0aDogRGVwZW5kZW5jaWVzLmdldFBhdGgoJ3NvY2tqcycsIHtcbiAgICAgICAgICAgICAgICB1c2VUTFM6IG9wdGlvbnMudXNlVExTXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGlnbm9yZV9udWxsX29yaWdpbjogb3B0aW9ucy5pZ25vcmVOdWxsT3JpZ2luXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgYmVmb3JlT3BlbjogZnVuY3Rpb24gKHNvY2tldCwgcGF0aCkge1xuICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH0pKTtcbiAgICB9XG59KTtcbnZhciB4ZHJDb25maWd1cmF0aW9uID0ge1xuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHllcyA9IHJ1bnRpbWUuaXNYRFJTdXBwb3J0ZWQoZW52aXJvbm1lbnQudXNlVExTKTtcbiAgICAgICAgcmV0dXJuIHllcztcbiAgICB9XG59O1xudmFyIFhEUlN0cmVhbWluZ1RyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzX3RyYW5zcG9ydCgoZXh0ZW5kKHt9LCBzdHJlYW1pbmdDb25maWd1cmF0aW9uLCB4ZHJDb25maWd1cmF0aW9uKSkpO1xudmFyIFhEUlBvbGxpbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c190cmFuc3BvcnQoZXh0ZW5kKHt9LCBwb2xsaW5nQ29uZmlndXJhdGlvbiwgeGRyQ29uZmlndXJhdGlvbikpO1xudHJhbnNwb3J0cy54ZHJfc3RyZWFtaW5nID0gWERSU3RyZWFtaW5nVHJhbnNwb3J0O1xudHJhbnNwb3J0cy54ZHJfcG9sbGluZyA9IFhEUlBvbGxpbmdUcmFuc3BvcnQ7XG50cmFuc3BvcnRzLnNvY2tqcyA9IFNvY2tKU1RyYW5zcG9ydDtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcG9ydHNfdHJhbnNwb3J0cyA9ICh0cmFuc3BvcnRzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL25ldF9pbmZvLnRzXG52YXIgbmV0X2luZm9fZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuXG52YXIgTmV0SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgbmV0X2luZm9fZXh0ZW5kcyhOZXRJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5ldEluZm8oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBzZWxmID0gX3RoaXM7XG4gICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgnb25saW5lJyk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ29mZmxpbmUnKTtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE5ldEluZm8ucHJvdG90eXBlLmlzT25saW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5vbkxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5vbkxpbmU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZXRJbmZvO1xufShkaXNwYXRjaGVyKSk7XG5cbnZhciBuZXRfaW5mb19OZXR3b3JrID0gbmV3IE5ldEluZm8oKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL2Fzc2lzdGFudF90b190aGVfdHJhbnNwb3J0X21hbmFnZXIudHNcblxuXG52YXIgYXNzaXN0YW50X3RvX3RoZV90cmFuc3BvcnRfbWFuYWdlcl9Bc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlcihtYW5hZ2VyLCB0cmFuc3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMubWluUGluZ0RlbGF5ID0gb3B0aW9ucy5taW5QaW5nRGVsYXk7XG4gICAgICAgIHRoaXMubWF4UGluZ0RlbGF5ID0gb3B0aW9ucy5tYXhQaW5nRGVsYXk7XG4gICAgICAgIHRoaXMucGluZ0RlbGF5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAobmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IHRoaXMucGluZ0RlbGF5XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMudHJhbnNwb3J0LmNyZWF0ZUNvbm5lY3Rpb24obmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBvcGVuVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdmFyIG9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24udW5iaW5kKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICAgICAgb3BlblRpbWVzdGFtcCA9IHV0aWwubm93KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkNsb3NlZCA9IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnVuYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA9PT0gMTAwMiB8fCBjbG9zZUV2ZW50LmNvZGUgPT09IDEwMDMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYW5hZ2VyLnJlcG9ydERlYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY2xvc2VFdmVudC53YXNDbGVhbiAmJiBvcGVuVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpZmVzcGFuID0gdXRpbC5ub3coKSAtIG9wZW5UaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgaWYgKGxpZmVzcGFuIDwgMiAqIF90aGlzLm1heFBpbmdEZWxheSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYW5hZ2VyLnJlcG9ydERlYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBpbmdEZWxheSA9IE1hdGgubWF4KGxpZmVzcGFuIC8gMiwgX3RoaXMubWluUGluZ0RlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbm5lY3Rpb24uYmluZCgnb3BlbicsIG9uT3Blbik7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH07XG4gICAgQXNzaXN0YW50VG9UaGVUcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmlzQWxpdmUoKSAmJiB0aGlzLnRyYW5zcG9ydC5pc1N1cHBvcnRlZChlbnZpcm9ubWVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXNzaXN0YW50VG9UaGVUcmFuc3BvcnRNYW5hZ2VyO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGFzc2lzdGFudF90b190aGVfdHJhbnNwb3J0X21hbmFnZXIgPSAoYXNzaXN0YW50X3RvX3RoZV90cmFuc3BvcnRfbWFuYWdlcl9Bc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Nvbm5lY3Rpb24vcHJvdG9jb2wvcHJvdG9jb2wudHNcbnZhciBQcm90b2NvbCA9IHtcbiAgICBkZWNvZGVNZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZURhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2VFdmVudC5kYXRhKTtcbiAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudERhdGEgPSBtZXNzYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwdXNoZXJFdmVudERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaGVyRXZlbnREYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlRGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHB1c2hlckV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlRGF0YS5ldmVudCxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBtZXNzYWdlRGF0YS5jaGFubmVsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHB1c2hlckV2ZW50RGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlRGF0YS51c2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgcHVzaGVyRXZlbnQudXNlcl9pZCA9IG1lc3NhZ2VEYXRhLnVzZXJfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVzaGVyRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ01lc3NhZ2VQYXJzZUVycm9yJywgZXJyb3I6IGUsIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVuY29kZU1lc3NhZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXZlbnQpO1xuICAgIH0sXG4gICAgcHJvY2Vzc0hhbmRzaGFrZTogZnVuY3Rpb24gKG1lc3NhZ2VFdmVudCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFByb3RvY29sLmRlY29kZU1lc3NhZ2UobWVzc2FnZUV2ZW50KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnQgPT09ICdwdXNoZXI6Y29ubmVjdGlvbl9lc3RhYmxpc2hlZCcpIHtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZS5kYXRhLmFjdGl2aXR5X3RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTm8gYWN0aXZpdHkgdGltZW91dCBzcGVjaWZpZWQgaW4gaGFuZHNoYWtlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICBpZDogbWVzc2FnZS5kYXRhLnNvY2tldF9pZCxcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IG1lc3NhZ2UuZGF0YS5hY3Rpdml0eV90aW1lb3V0ICogMTAwMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmV2ZW50ID09PSAncHVzaGVyOmVycm9yJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuZ2V0Q2xvc2VBY3Rpb24obWVzc2FnZS5kYXRhKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5nZXRDbG9zZUVycm9yKG1lc3NhZ2UuZGF0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBoYW5kc2hha2UnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRDbG9zZUFjdGlvbjogZnVuY3Rpb24gKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQwMDApIHtcbiAgICAgICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgPj0gMTAwMiAmJiBjbG9zZUV2ZW50LmNvZGUgPD0gMTAwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYmFja29mZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPT09IDQwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAndGxzX29ubHknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQxMDApIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xvc2VFdmVudC5jb2RlIDwgNDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuICdiYWNrb2ZmJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPCA0MzAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JldHJ5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldENsb3NlRXJyb3I6IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgIT09IDEwMDAgJiYgY2xvc2VFdmVudC5jb2RlICE9PSAxMDAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQdXNoZXJFcnJvcicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjbG9zZUV2ZW50LmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNsb3NlRXZlbnQucmVhc29uIHx8IGNsb3NlRXZlbnQubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwcm90b2NvbF9wcm90b2NvbCA9IChQcm90b2NvbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9jb25uZWN0aW9uLnRzXG52YXIgY29ubmVjdGlvbl9leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5cblxuXG5cbnZhciBjb25uZWN0aW9uX0Nvbm5lY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGNvbm5lY3Rpb25fZXh0ZW5kcyhDb25uZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb24oaWQsIHRyYW5zcG9ydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZCA9IGlkO1xuICAgICAgICBfdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIF90aGlzLmFjdGl2aXR5VGltZW91dCA9IHRyYW5zcG9ydC5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgICAgIF90aGlzLmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVzQWN0aXZpdHlDaGVja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5oYW5kbGVzQWN0aXZpdHlDaGVja3MoKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuc2VuZChkYXRhKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRfZXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZGF0YSwgY2hhbm5lbCkge1xuICAgICAgICB2YXIgZXZlbnQgPSB7IGV2ZW50OiBuYW1lLCBkYXRhOiBkYXRhIH07XG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICBldmVudC5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ0V2ZW50IHNlbnQnLCBldmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQocHJvdG9jb2xfcHJvdG9jb2wuZW5jb2RlTWVzc2FnZShldmVudCkpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5waW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRfZXZlbnQoJ3B1c2hlcjpwaW5nJywge30pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmJpbmRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHB1c2hlckV2ZW50O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hlckV2ZW50ID0gcHJvdG9jb2xfcHJvdG9jb2wuZGVjb2RlTWVzc2FnZShtZXNzYWdlRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZXNzYWdlUGFyc2VFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHVzaGVyRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0V2ZW50IHJlY2QnLCBwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHVzaGVyRXZlbnQuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1c2hlcjplcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQdXNoZXJFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHB1c2hlckV2ZW50LmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1c2hlcjpwaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdwaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwdXNoZXI6cG9uZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ21lc3NhZ2UnLCBwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFjdGl2aXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnYWN0aXZpdHknKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2VkOiBmdW5jdGlvbiAoY2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZUV2ZW50ICYmIGNsb3NlRXZlbnQuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVDbG9zZUV2ZW50KGNsb3NlRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdW5iaW5kTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb2JqZWN0QXBwbHkobGlzdGVuZXJzLCBmdW5jdGlvbiAobGlzdGVuZXIsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNwb3J0LnVuYmluZChldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIG9iamVjdEFwcGx5KGxpc3RlbmVycywgZnVuY3Rpb24gKGxpc3RlbmVyLCBldmVudCkge1xuICAgICAgICAgICAgX3RoaXMudHJhbnNwb3J0LmJpbmQoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVDbG9zZUV2ZW50ID0gZnVuY3Rpb24gKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHByb3RvY29sX3Byb3RvY29sLmdldENsb3NlQWN0aW9uKGNsb3NlRXZlbnQpO1xuICAgICAgICB2YXIgZXJyb3IgPSBwcm90b2NvbF9wcm90b2NvbC5nZXRDbG9zZUVycm9yKGNsb3NlRXZlbnQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KGFjdGlvbiwgeyBhY3Rpb246IGFjdGlvbiwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGlvbjtcbn0oZGlzcGF0Y2hlcikpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29ubmVjdGlvbl9jb25uZWN0aW9uID0gKGNvbm5lY3Rpb25fQ29ubmVjdGlvbik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9oYW5kc2hha2UvaW5kZXgudHNcblxuXG5cbnZhciBoYW5kc2hha2VfSGFuZHNoYWtlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIYW5kc2hha2UodHJhbnNwb3J0LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmJpbmRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgSGFuZHNoYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9O1xuICAgIEhhbmRzaGFrZS5wcm90b3R5cGUuYmluZExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgX3RoaXMudW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm90b2NvbF9wcm90b2NvbC5wcm9jZXNzSGFuZHNoYWtlKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maW5pc2goJ2Vycm9yJywgeyBlcnJvcjogZSB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjdGlvbiA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maW5pc2goJ2Nvbm5lY3RlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjogbmV3IGNvbm5lY3Rpb25fY29ubmVjdGlvbihyZXN1bHQuaWQsIF90aGlzLnRyYW5zcG9ydCksXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogcmVzdWx0LmFjdGl2aXR5VGltZW91dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmluaXNoKHJlc3VsdC5hY3Rpb24sIHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkNsb3NlZCA9IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy51bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBwcm90b2NvbF9wcm90b2NvbC5nZXRDbG9zZUFjdGlvbihjbG9zZUV2ZW50KSB8fCAnYmFja29mZic7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBwcm90b2NvbF9wcm90b2NvbC5nZXRDbG9zZUVycm9yKGNsb3NlRXZlbnQpO1xuICAgICAgICAgICAgX3RoaXMuZmluaXNoKGFjdGlvbiwgeyBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmJpbmQoJ21lc3NhZ2UnLCB0aGlzLm9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmJpbmQoJ2Nsb3NlZCcsIHRoaXMub25DbG9zZWQpO1xuICAgIH07XG4gICAgSGFuZHNoYWtlLnByb3RvdHlwZS51bmJpbmRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnVuYmluZCgnbWVzc2FnZScsIHRoaXMub25NZXNzYWdlKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQudW5iaW5kKCdjbG9zZWQnLCB0aGlzLm9uQ2xvc2VkKTtcbiAgICB9O1xuICAgIEhhbmRzaGFrZS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKGFjdGlvbiwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soZXh0ZW5kKHsgdHJhbnNwb3J0OiB0aGlzLnRyYW5zcG9ydCwgYWN0aW9uOiBhY3Rpb24gfSwgcGFyYW1zKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGFuZHNoYWtlO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbm5lY3Rpb25faGFuZHNoYWtlID0gKGhhbmRzaGFrZV9IYW5kc2hha2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvcHVzaGVyX2F1dGhvcml6ZXIudHNcblxudmFyIHB1c2hlcl9hdXRob3JpemVyX1B1c2hlckF1dGhvcml6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1c2hlckF1dGhvcml6ZXIoY2hhbm5lbCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB2YXIgYXV0aFRyYW5zcG9ydCA9IG9wdGlvbnMuYXV0aFRyYW5zcG9ydDtcbiAgICAgICAgaWYgKHR5cGVvZiBydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aFRyYW5zcG9ydF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBcIidcIiArIGF1dGhUcmFuc3BvcnQgKyBcIicgaXMgbm90IGEgcmVjb2duaXplZCBhdXRoIHRyYW5zcG9ydFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IGF1dGhUcmFuc3BvcnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXV0aE9wdGlvbnMgPSBvcHRpb25zLmF1dGggfHwge307XG4gICAgfVxuICAgIFB1c2hlckF1dGhvcml6ZXIucHJvdG90eXBlLmNvbXBvc2VRdWVyeSA9IGZ1bmN0aW9uIChzb2NrZXRJZCkge1xuICAgICAgICB2YXIgcXVlcnkgPSAnc29ja2V0X2lkPScgK1xuICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHNvY2tldElkKSArXG4gICAgICAgICAgICAnJmNoYW5uZWxfbmFtZT0nICtcbiAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmNoYW5uZWwubmFtZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5hdXRoT3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICAgIHF1ZXJ5ICs9XG4gICAgICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGkpICtcbiAgICAgICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuYXV0aE9wdGlvbnMucGFyYW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfTtcbiAgICBQdXNoZXJBdXRob3JpemVyLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbiAoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIFB1c2hlckF1dGhvcml6ZXIuYXV0aG9yaXplcnMgPVxuICAgICAgICAgICAgUHVzaGVyQXV0aG9yaXplci5hdXRob3JpemVycyB8fCBydW50aW1lLmdldEF1dGhvcml6ZXJzKCk7XG4gICAgICAgIFB1c2hlckF1dGhvcml6ZXIuYXV0aG9yaXplcnNbdGhpcy50eXBlXS5jYWxsKHRoaXMsIHJ1bnRpbWUsIHNvY2tldElkLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gUHVzaGVyQXV0aG9yaXplcjtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwdXNoZXJfYXV0aG9yaXplciA9IChwdXNoZXJfYXV0aG9yaXplcl9QdXNoZXJBdXRob3JpemVyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90aW1lbGluZS90aW1lbGluZV9zZW5kZXIudHNcblxudmFyIHRpbWVsaW5lX3NlbmRlcl9UaW1lbGluZVNlbmRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZWxpbmVTZW5kZXIodGltZWxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIH1cbiAgICBUaW1lbGluZVNlbmRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICh1c2VUTFMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZWxpbmUuc2VuZChydW50aW1lLlRpbWVsaW5lVHJhbnNwb3J0LmdldEFnZW50KHRoaXMsIHVzZVRMUyksIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lbGluZVNlbmRlcjtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0aW1lbGluZV9zZW5kZXIgPSAodGltZWxpbmVfc2VuZGVyX1RpbWVsaW5lU2VuZGVyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9jaGFubmVsLnRzXG52YXIgY2hhbm5lbF9leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5cblxuXG5cblxudmFyIGNoYW5uZWxfQ2hhbm5lbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgY2hhbm5lbF9leHRlbmRzKENoYW5uZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiAnICsgbmFtZSArICcgZm9yICcgKyBldmVudCk7XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5wdXNoZXIgPSBwdXNoZXI7XG4gICAgICAgIF90aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDaGFubmVsLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbiAoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7IGF1dGg6ICcnIH0pO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICBpZiAoZXZlbnQuaW5kZXhPZignY2xpZW50LScpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQmFkRXZlbnROYW1lKFwiRXZlbnQgJ1wiICsgZXZlbnQgKyBcIicgZG9lcyBub3Qgc3RhcnQgd2l0aCAnY2xpZW50LSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSB1cmxfc3RvcmUuYnVpbGRMb2dTdWZmaXgoJ3RyaWdnZXJpbmdDbGllbnRFdmVudHMnKTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiQ2xpZW50IGV2ZW50IHRyaWdnZXJlZCBiZWZvcmUgY2hhbm5lbCAnc3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcgZXZlbnQgLiBcIiArIHN1ZmZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoZXZlbnQsIGRhdGEsIHRoaXMubmFtZSk7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCBkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLmhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnVuc3Vic2NyaWJlKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0aG9yaXplKHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkLCBmdW5jdGlvbiAoZXJyb3IsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncHVzaGVyOnN1YnNjcmlwdGlvbl9lcnJvcicsIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0F1dGhFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgaW5zdGFuY2VvZiBIVFRQQXV0aEVycm9yID8geyBzdGF0dXM6IGVycm9yLnN0YXR1cyB9IDoge30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLnB1c2hlci5zZW5kX2V2ZW50KCdwdXNoZXI6c3Vic2NyaWJlJywge1xuICAgICAgICAgICAgICAgICAgICBhdXRoOiBkYXRhLmF1dGgsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxfZGF0YTogZGF0YS5jaGFubmVsX2RhdGEsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IF90aGlzLm5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjp1bnN1YnNjcmliZScsIHtcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMubmFtZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLmNhbmNlbFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUucmVpbnN0YXRlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIENoYW5uZWw7XG59KGRpc3BhdGNoZXIpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNoYW5uZWxzX2NoYW5uZWwgPSAoY2hhbm5lbF9DaGFubmVsKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9wcml2YXRlX2NoYW5uZWwudHNcbnZhciBwcml2YXRlX2NoYW5uZWxfZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuXG5cbnZhciBwcml2YXRlX2NoYW5uZWxfUHJpdmF0ZUNoYW5uZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHByaXZhdGVfY2hhbm5lbF9leHRlbmRzKFByaXZhdGVDaGFubmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByaXZhdGVDaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFByaXZhdGVDaGFubmVsLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbiAoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBhdXRob3JpemVyID0gZmFjdG9yeS5jcmVhdGVBdXRob3JpemVyKHRoaXMsIHRoaXMucHVzaGVyLmNvbmZpZyk7XG4gICAgICAgIHJldHVybiBhdXRob3JpemVyLmF1dGhvcml6ZShzb2NrZXRJZCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIFByaXZhdGVDaGFubmVsO1xufShjaGFubmVsc19jaGFubmVsKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwcml2YXRlX2NoYW5uZWwgPSAocHJpdmF0ZV9jaGFubmVsX1ByaXZhdGVDaGFubmVsKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9tZW1iZXJzLnRzXG5cbnZhciBtZW1iZXJzX01lbWJlcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lbWJlcnMoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgTWVtYmVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tZW1iZXJzLCBpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGluZm86IHRoaXMubWVtYmVyc1tpZF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVtYmVycy5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvYmplY3RBcHBseSh0aGlzLm1lbWJlcnMsIGZ1bmN0aW9uIChtZW1iZXIsIGlkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfdGhpcy5nZXQoaWQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNZW1iZXJzLnByb3RvdHlwZS5zZXRNeUlEID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xuICAgIH07XG4gICAgTWVtYmVycy5wcm90b3R5cGUub25TdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uRGF0YSkge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBzdWJzY3JpcHRpb25EYXRhLnByZXNlbmNlLmhhc2g7XG4gICAgICAgIHRoaXMuY291bnQgPSBzdWJzY3JpcHRpb25EYXRhLnByZXNlbmNlLmNvdW50O1xuICAgICAgICB0aGlzLm1lID0gdGhpcy5nZXQodGhpcy5teUlEKTtcbiAgICB9O1xuICAgIE1lbWJlcnMucHJvdG90eXBlLmFkZE1lbWJlciA9IGZ1bmN0aW9uIChtZW1iZXJEYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZW1iZXJzW21lbWJlckRhdGEudXNlcl9pZF0gPSBtZW1iZXJEYXRhLnVzZXJfaW5mbztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG1lbWJlckRhdGEudXNlcl9pZCk7XG4gICAgfTtcbiAgICBNZW1iZXJzLnByb3RvdHlwZS5yZW1vdmVNZW1iZXIgPSBmdW5jdGlvbiAobWVtYmVyRGF0YSkge1xuICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5nZXQobWVtYmVyRGF0YS51c2VyX2lkKTtcbiAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWVtYmVyc1ttZW1iZXJEYXRhLnVzZXJfaWRdO1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1iZXI7XG4gICAgfTtcbiAgICBNZW1iZXJzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0ge307XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLm15SUQgPSBudWxsO1xuICAgICAgICB0aGlzLm1lID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBNZW1iZXJzO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1lbWJlcnMgPSAobWVtYmVyc19NZW1iZXJzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9wcmVzZW5jZV9jaGFubmVsLnRzXG52YXIgcHJlc2VuY2VfY2hhbm5lbF9leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5cblxuXG5cbnZhciBwcmVzZW5jZV9jaGFubmVsX1ByZXNlbmNlQ2hhbm5lbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgcHJlc2VuY2VfY2hhbm5lbF9leHRlbmRzKFByZXNlbmNlQ2hhbm5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZUNoYW5uZWwobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIHB1c2hlcikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVtYmVycyA9IG5ldyBtZW1iZXJzKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJlc2VuY2VDaGFubmVsLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbiAoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYXV0aG9yaXplLmNhbGwodGhpcywgc29ja2V0SWQsIGZ1bmN0aW9uIChlcnJvciwgYXV0aERhdGEpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhdXRoRGF0YSA9IGF1dGhEYXRhO1xuICAgICAgICAgICAgICAgIGlmIChhdXRoRGF0YS5jaGFubmVsX2RhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VmZml4ID0gdXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCdhdXRoZW50aWNhdGlvbkVuZHBvaW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgYXV0aCByZXNwb25zZSBmb3IgY2hhbm5lbCAnXCIgKyBfdGhpcy5uYW1lICsgXCInLFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImV4cGVjdGVkICdjaGFubmVsX2RhdGEnIGZpZWxkLiBcIiArIHN1ZmZpeCkpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygnSW52YWxpZCBhdXRoIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWxEYXRhID0gSlNPTi5wYXJzZShhdXRoRGF0YS5jaGFubmVsX2RhdGEpO1xuICAgICAgICAgICAgICAgIF90aGlzLm1lbWJlcnMuc2V0TXlJRChjaGFubmVsRGF0YS51c2VyX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBhdXRoRGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJlc2VuY2VDaGFubmVsLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludGVybmFsRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICBpZiAoZXZlbnQudXNlcl9pZCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnVzZXJfaWQgPSBldmVudC51c2VyX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmVzZW5jZUNoYW5uZWwucHJvdG90eXBlLmhhbmRsZUludGVybmFsRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6bWVtYmVyX2FkZGVkJzpcbiAgICAgICAgICAgICAgICB2YXIgYWRkZWRNZW1iZXIgPSB0aGlzLm1lbWJlcnMuYWRkTWVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9hZGRlZCcsIGFkZGVkTWVtYmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDptZW1iZXJfcmVtb3ZlZCc6XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRNZW1iZXIgPSB0aGlzLm1lbWJlcnMucmVtb3ZlTWVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9yZW1vdmVkJywgcmVtb3ZlZE1lbWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmVzZW5jZUNoYW5uZWwucHJvdG90eXBlLmhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnVuc3Vic2NyaWJlKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMub25TdWJzY3JpcHRpb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgdGhpcy5tZW1iZXJzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJlc2VuY2VDaGFubmVsLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMucmVzZXQoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNjb25uZWN0LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlc2VuY2VDaGFubmVsO1xufShwcml2YXRlX2NoYW5uZWwpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHByZXNlbmNlX2NoYW5uZWwgPSAocHJlc2VuY2VfY2hhbm5lbF9QcmVzZW5jZUNoYW5uZWwpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvdXRmOC9saWIvdXRmOC5qc1xudmFyIHV0ZjggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvYmFzZTY0L2xpYi9iYXNlNjQuanNcbnZhciBiYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2VuY3J5cHRlZF9jaGFubmVsLnRzXG52YXIgZW5jcnlwdGVkX2NoYW5uZWxfZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuXG5cblxuXG5cbnZhciBlbmNyeXB0ZWRfY2hhbm5lbF9FbmNyeXB0ZWRDaGFubmVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlbmNyeXB0ZWRfY2hhbm5lbF9leHRlbmRzKEVuY3J5cHRlZENoYW5uZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW5jcnlwdGVkQ2hhbm5lbChuYW1lLCBwdXNoZXIsIG5hY2wpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgcHVzaGVyKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5rZXkgPSBudWxsO1xuICAgICAgICBfdGhpcy5uYWNsID0gbmFjbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFbmNyeXB0ZWRDaGFubmVsLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbiAoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYXV0aG9yaXplLmNhbGwodGhpcywgc29ja2V0SWQsIGZ1bmN0aW9uIChlcnJvciwgYXV0aERhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBhdXRoRGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNoYXJlZFNlY3JldCA9IGF1dGhEYXRhWydzaGFyZWRfc2VjcmV0J107XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFNlY3JldCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIk5vIHNoYXJlZF9zZWNyZXQga2V5IGluIGF1dGggcGF5bG9hZCBmb3IgZW5jcnlwdGVkIGNoYW5uZWw6IFwiICsgX3RoaXMubmFtZSksIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmtleSA9IE9iamVjdChiYXNlNjRbXCJkZWNvZGVcIl0pKHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICBkZWxldGUgYXV0aERhdGFbJ3NoYXJlZF9zZWNyZXQnXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGF1dGhEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbmNyeXB0ZWRDaGFubmVsLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZlYXR1cmUoJ0NsaWVudCBldmVudHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBlbmNyeXB0ZWQgY2hhbm5lbHMnKTtcbiAgICB9O1xuICAgIEVuY3J5cHRlZENoYW5uZWwucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMCB8fFxuICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZUVuY3J5cHRlZEV2ZW50KGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgfTtcbiAgICBFbmNyeXB0ZWRDaGFubmVsLnByb3RvdHlwZS5oYW5kbGVFbmNyeXB0ZWRFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMua2V5KSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ1JlY2VpdmVkIGVuY3J5cHRlZCBldmVudCBiZWZvcmUga2V5IGhhcyBiZWVuIHJldHJpZXZlZCBmcm9tIHRoZSBhdXRoRW5kcG9pbnQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEuY2lwaGVydGV4dCB8fCAhZGF0YS5ub25jZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdVbmV4cGVjdGVkIGZvcm1hdCBmb3IgZW5jcnlwdGVkIGV2ZW50LCBleHBlY3RlZCBvYmplY3Qgd2l0aCBgY2lwaGVydGV4dGAgYW5kIGBub25jZWAgZmllbGRzLCBnb3Q6ICcgK1xuICAgICAgICAgICAgICAgIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaXBoZXJUZXh0ID0gT2JqZWN0KGJhc2U2NFtcImRlY29kZVwiXSkoZGF0YS5jaXBoZXJ0ZXh0KTtcbiAgICAgICAgaWYgKGNpcGhlclRleHQubGVuZ3RoIDwgdGhpcy5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IGNpcGhlcnRleHQgbGVuZ3RoIHRvIGJlIFwiICsgdGhpcy5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCArIFwiLCBnb3Q6IFwiICsgY2lwaGVyVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub25jZSA9IE9iamVjdChiYXNlNjRbXCJkZWNvZGVcIl0pKGRhdGEubm9uY2UpO1xuICAgICAgICBpZiAobm9uY2UubGVuZ3RoIDwgdGhpcy5uYWNsLnNlY3JldGJveC5ub25jZUxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IG5vbmNlIGxlbmd0aCB0byBiZSBcIiArIHRoaXMubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGggKyBcIiwgZ290OiBcIiArIG5vbmNlLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gdGhpcy5uYWNsLnNlY3JldGJveC5vcGVuKGNpcGhlclRleHQsIG5vbmNlLCB0aGlzLmtleSk7XG4gICAgICAgIGlmIChieXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdGYWlsZWQgdG8gZGVjcnlwdCBhbiBldmVudCwgcHJvYmFibHkgYmVjYXVzZSBpdCB3YXMgZW5jcnlwdGVkIHdpdGggYSBkaWZmZXJlbnQga2V5LiBGZXRjaGluZyBhIG5ldyBrZXkgZnJvbSB0aGUgYXV0aEVuZHBvaW50Li4uJyk7XG4gICAgICAgICAgICB0aGlzLmF1dGhvcml6ZSh0aGlzLnB1c2hlci5jb25uZWN0aW9uLnNvY2tldF9pZCwgZnVuY3Rpb24gKGVycm9yLCBhdXRoRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbWFrZSBhIHJlcXVlc3QgdG8gdGhlIGF1dGhFbmRwb2ludDogXCIgKyBhdXRoRGF0YSArIFwiLiBVbmFibGUgdG8gZmV0Y2ggbmV3IGtleSwgc28gZHJvcHBpbmcgZW5jcnlwdGVkIGV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ5dGVzID0gX3RoaXMubmFjbC5zZWNyZXRib3gub3BlbihjaXBoZXJUZXh0LCBub25jZSwgX3RoaXMua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgZXZlbnQgd2l0aCBuZXcga2V5LiBEcm9wcGluZyBlbmNyeXB0ZWQgZXZlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChldmVudCwgX3RoaXMuZ2V0RGF0YVRvRW1pdChieXRlcykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChldmVudCwgdGhpcy5nZXREYXRhVG9FbWl0KGJ5dGVzKSk7XG4gICAgfTtcbiAgICBFbmNyeXB0ZWRDaGFubmVsLnByb3RvdHlwZS5nZXREYXRhVG9FbWl0ID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgIHZhciByYXcgPSBPYmplY3QodXRmOFtcImRlY29kZVwiXSkoYnl0ZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiByYXc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFbmNyeXB0ZWRDaGFubmVsO1xufShwcml2YXRlX2NoYW5uZWwpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGVuY3J5cHRlZF9jaGFubmVsID0gKGVuY3J5cHRlZF9jaGFubmVsX0VuY3J5cHRlZENoYW5uZWwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Nvbm5lY3Rpb24vY29ubmVjdGlvbl9tYW5hZ2VyLnRzXG52YXIgY29ubmVjdGlvbl9tYW5hZ2VyX2V4dGVuZHMgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcblxuXG5cblxuXG52YXIgY29ubmVjdGlvbl9tYW5hZ2VyX0Nvbm5lY3Rpb25NYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBjb25uZWN0aW9uX21hbmFnZXJfZXh0ZW5kcyhDb25uZWN0aW9uTWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uTWFuYWdlcihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSAnaW5pdGlhbGl6ZWQnO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgX3RoaXMudGltZWxpbmUgPSBfdGhpcy5vcHRpb25zLnRpbWVsaW5lO1xuICAgICAgICBfdGhpcy51c2luZ1RMUyA9IF90aGlzLm9wdGlvbnMudXNlVExTO1xuICAgICAgICBfdGhpcy5lcnJvckNhbGxiYWNrcyA9IF90aGlzLmJ1aWxkRXJyb3JDYWxsYmFja3MoKTtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbkNhbGxiYWNrcyA9IF90aGlzLmJ1aWxkQ29ubmVjdGlvbkNhbGxiYWNrcyhfdGhpcy5lcnJvckNhbGxiYWNrcyk7XG4gICAgICAgIF90aGlzLmhhbmRzaGFrZUNhbGxiYWNrcyA9IF90aGlzLmJ1aWxkSGFuZHNoYWtlQ2FsbGJhY2tzKF90aGlzLmVycm9yQ2FsbGJhY2tzKTtcbiAgICAgICAgdmFyIE5ldHdvcmsgPSBydW50aW1lLmdldE5ldHdvcmsoKTtcbiAgICAgICAgTmV0d29yay5iaW5kKCdvbmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lbGluZS5pbmZvKHsgbmV0aW5mbzogJ29ubGluZScgfSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJyB8fCBfdGhpcy5zdGF0ZSA9PT0gJ3VuYXZhaWxhYmxlJykge1xuICAgICAgICAgICAgICAgIF90aGlzLnJldHJ5SW4oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBOZXR3b3JrLmJpbmQoJ29mZmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lbGluZS5pbmZvKHsgbmV0aW5mbzogJ29mZmxpbmUnIH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMudXBkYXRlU3RyYXRlZ3koKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbiB8fCB0aGlzLnJ1bm5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdmYWlsZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIHRoaXMuc2V0VW5hdmFpbGFibGVUaW1lcigpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kX2V2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SW50ZXJuYWxseSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5pc1VzaW5nVExTID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2luZ1RMUztcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydENvbm5lY3RpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ydW5uZXIgPSBfdGhpcy5zdHJhdGVneS5jb25uZWN0KDAsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kc2hha2UuYWN0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0hhbmRzaGFrZUVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBoYW5kc2hha2UuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRpbWVsaW5lLmVycm9yKHsgaGFuZHNoYWtlRXJyb3I6IGhhbmRzaGFrZS5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFib3J0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kc2hha2VDYWxsYmFja3NbaGFuZHNoYWtlLmFjdGlvbl0oaGFuZHNoYWtlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVubmVyID0gdGhpcy5zdHJhdGVneS5jb25uZWN0KDAsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hYm9ydENvbm5lY3RpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5lcikge1xuICAgICAgICAgICAgdGhpcy5ydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMucnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RJbnRlcm5hbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFib3J0Q29ubmVjdGluZygpO1xuICAgICAgICB0aGlzLmNsZWFyUmV0cnlUaW1lcigpO1xuICAgICAgICB0aGlzLmNsZWFyVW5hdmFpbGFibGVUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuYWJhbmRvbkNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVN0cmF0ZWd5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5vcHRpb25zLmdldFN0cmF0ZWd5KHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgICAgICAgIHVzZVRMUzogdGhpcy51c2luZ1RMU1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZXRyeUluID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IGFjdGlvbjogJ3JldHJ5JywgZGVsYXk6IGRlbGF5IH0pO1xuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmdfaW4nLCBNYXRoLnJvdW5kKGRlbGF5IC8gMTAwMCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0cnlUaW1lciA9IG5ldyBPbmVPZmZUaW1lcihkZWxheSB8fCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0SW50ZXJuYWxseSgpO1xuICAgICAgICAgICAgX3RoaXMuY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhclJldHJ5VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5VGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnlUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VW5hdmFpbGFibGVUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy51bmF2YWlsYWJsZVRpbWVyID0gbmV3IE9uZU9mZlRpbWVyKHRoaXMub3B0aW9ucy51bmF2YWlsYWJsZVRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVN0YXRlKCd1bmF2YWlsYWJsZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhclVuYXZhaWxhYmxlVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuYXZhaWxhYmxlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudW5hdmFpbGFibGVUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kQWN0aXZpdHlDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdG9wQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ucGluZygpO1xuICAgICAgICB0aGlzLmFjdGl2aXR5VGltZXIgPSBuZXcgT25lT2ZmVGltZXIodGhpcy5vcHRpb25zLnBvbmdUaW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lbGluZS5lcnJvcih7IHBvbmdfdGltZWRfb3V0OiBfdGhpcy5vcHRpb25zLnBvbmdUaW1lb3V0IH0pO1xuICAgICAgICAgICAgX3RoaXMucmV0cnlJbigwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVzZXRBY3Rpdml0eUNoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0b3BBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gJiYgIXRoaXMuY29ubmVjdGlvbi5oYW5kbGVzQWN0aXZpdHlDaGVja3MoKSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVyID0gbmV3IE9uZU9mZlRpbWVyKHRoaXMuYWN0aXZpdHlUaW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RvcEFjdGl2aXR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2aXR5VGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5idWlsZENvbm5lY3Rpb25DYWxsYmFja3MgPSBmdW5jdGlvbiAoZXJyb3JDYWxsYmFja3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZXJyb3JDYWxsYmFja3MsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kX2V2ZW50KCdwdXNoZXI6cG9uZycsIHt9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3Rpdml0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0QWN0aXZpdHlDaGVjaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hYmFuZG9uQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zaG91bGRSZXRyeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJldHJ5SW4oMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5idWlsZEhhbmRzaGFrZUNhbGxiYWNrcyA9IGZ1bmN0aW9uIChlcnJvckNhbGxiYWNrcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBlcnJvckNhbGxiYWNrcywge1xuICAgICAgICAgICAgY29ubmVjdGVkOiBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZpdHlUaW1lb3V0ID0gTWF0aC5taW4oX3RoaXMub3B0aW9ucy5hY3Rpdml0eVRpbWVvdXQsIGhhbmRzaGFrZS5hY3Rpdml0eVRpbWVvdXQsIGhhbmRzaGFrZS5jb25uZWN0aW9uLmFjdGl2aXR5VGltZW91dCB8fCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0Q29ubmVjdGlvbihoYW5kc2hha2UuY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgX3RoaXMuc29ja2V0X2lkID0gX3RoaXMuY29ubmVjdGlvbi5pZDtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVTdGF0ZSgnY29ubmVjdGVkJywgeyBzb2NrZXRfaWQ6IF90aGlzLnNvY2tldF9pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYnVpbGRFcnJvckNhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHdpdGhFcnJvckVtaXR0ZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIHsgdHlwZTogJ1dlYlNvY2tldEVycm9yJywgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0bHNfb25seTogd2l0aEVycm9yRW1pdHRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXNpbmdUTFMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVN0cmF0ZWd5KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmV0cnlJbigwKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVmdXNlZDogd2l0aEVycm9yRW1pdHRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBiYWNrb2ZmOiB3aXRoRXJyb3JFbWl0dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXRyeUluKDEwMDApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXRyeTogd2l0aEVycm9yRW1pdHRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmV0cnlJbigwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGZvciAodmFyIGV2ZW50IGluIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoZXZlbnQsIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWJhbmRvbkNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9wQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi51bmJpbmQoZXZlbnQsIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgZGF0YSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5ld1N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGVEZXNjcmlwdGlvbiA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlRGVzY3JpcHRpb24gPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVEZXNjcmlwdGlvbiArPSAnIHdpdGggbmV3IHNvY2tldCBJRCAnICsgZGF0YS5zb2NrZXRfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ1N0YXRlIGNoYW5nZWQnLCBwcmV2aW91c1N0YXRlICsgJyAtPiAnICsgbmV3U3RhdGVEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBzdGF0ZTogbmV3U3RhdGUsIHBhcmFtczogZGF0YSB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhdGVfY2hhbmdlJywgeyBwcmV2aW91czogcHJldmlvdXNTdGF0ZSwgY3VycmVudDogbmV3U3RhdGUgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQobmV3U3RhdGUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2hvdWxkUmV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGlvbk1hbmFnZXI7XG59KGRpc3BhdGNoZXIpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbm5lY3Rpb25fbWFuYWdlciA9IChjb25uZWN0aW9uX21hbmFnZXJfQ29ubmVjdGlvbk1hbmFnZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2NoYW5uZWxzLnRzXG5cblxuXG5cbnZhciBjaGFubmVsc19DaGFubmVscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbHMoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSB7fTtcbiAgICB9XG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYW5uZWxzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW25hbWVdID0gY3JlYXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgIH07XG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh0aGlzLmNoYW5uZWxzKTtcbiAgICB9O1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgfTtcbiAgICBDaGFubmVscy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgICAgICBkZWxldGUgdGhpcy5jaGFubmVsc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfTtcbiAgICBDaGFubmVscy5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2JqZWN0QXBwbHkodGhpcy5jaGFubmVscywgZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFubmVscztcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjaGFubmVscyA9IChjaGFubmVsc19DaGFubmVscyk7XG5mdW5jdGlvbiBjcmVhdGVDaGFubmVsKG5hbWUsIHB1c2hlcikge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJ3ByaXZhdGUtZW5jcnlwdGVkLScpID09PSAwKSB7XG4gICAgICAgIGlmIChwdXNoZXIuY29uZmlnLm5hY2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUVuY3J5cHRlZENoYW5uZWwobmFtZSwgcHVzaGVyLCBwdXNoZXIuY29uZmlnLm5hY2wpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJNc2cgPSAnVHJpZWQgdG8gc3Vic2NyaWJlIHRvIGEgcHJpdmF0ZS1lbmNyeXB0ZWQtIGNoYW5uZWwgYnV0IG5vIG5hY2wgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnZW5jcnlwdGVkQ2hhbm5lbFN1cHBvcnQnKTtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRmVhdHVyZShlcnJNc2cgKyBcIi4gXCIgKyBzdWZmaXgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3ByaXZhdGUtJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlUHJpdmF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdwcmVzZW5jZS0nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVQcmVzZW5jZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvZmFjdG9yeS50c1xuXG5cblxuXG5cblxuXG5cblxuXG52YXIgRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVDaGFubmVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGNoYW5uZWxzKCk7XG4gICAgfSxcbiAgICBjcmVhdGVDb25uZWN0aW9uTWFuYWdlcjogZnVuY3Rpb24gKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbm5lY3Rpb25fbWFuYWdlcihrZXksIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2hhbm5lbDogZnVuY3Rpb24gKG5hbWUsIHB1c2hlcikge1xuICAgICAgICByZXR1cm4gbmV3IGNoYW5uZWxzX2NoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9LFxuICAgIGNyZWF0ZVByaXZhdGVDaGFubmVsOiBmdW5jdGlvbiAobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJpdmF0ZV9jaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfSxcbiAgICBjcmVhdGVQcmVzZW5jZUNoYW5uZWw6IGZ1bmN0aW9uIChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwcmVzZW5jZV9jaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfSxcbiAgICBjcmVhdGVFbmNyeXB0ZWRDaGFubmVsOiBmdW5jdGlvbiAobmFtZSwgcHVzaGVyLCBuYWNsKSB7XG4gICAgICAgIHJldHVybiBuZXcgZW5jcnlwdGVkX2NoYW5uZWwobmFtZSwgcHVzaGVyLCBuYWNsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVRpbWVsaW5lU2VuZGVyOiBmdW5jdGlvbiAodGltZWxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aW1lbGluZV9zZW5kZXIodGltZWxpbmUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgY3JlYXRlQXV0aG9yaXplcjogZnVuY3Rpb24gKGNoYW5uZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0aG9yaXplcikge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuYXV0aG9yaXplcihjaGFubmVsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHB1c2hlcl9hdXRob3JpemVyKGNoYW5uZWwsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgY3JlYXRlSGFuZHNoYWtlOiBmdW5jdGlvbiAodHJhbnNwb3J0LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbm5lY3Rpb25faGFuZHNoYWtlKHRyYW5zcG9ydCwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgY3JlYXRlQXNzaXN0YW50VG9UaGVUcmFuc3BvcnRNYW5hZ2VyOiBmdW5jdGlvbiAobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNzaXN0YW50X3RvX3RoZV90cmFuc3BvcnRfbWFuYWdlcihtYW5hZ2VyLCB0cmFuc3BvcnQsIG9wdGlvbnMpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmYWN0b3J5ID0gKEZhY3RvcnkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RyYW5zcG9ydHMvdHJhbnNwb3J0X21hbmFnZXIudHNcblxudmFyIHRyYW5zcG9ydF9tYW5hZ2VyX1RyYW5zcG9ydE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydE1hbmFnZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmxpdmVzTGVmdCA9IHRoaXMub3B0aW9ucy5saXZlcyB8fCBJbmZpbml0eTtcbiAgICB9XG4gICAgVHJhbnNwb3J0TWFuYWdlci5wcm90b3R5cGUuZ2V0QXNzaXN0YW50ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIodGhpcywgdHJhbnNwb3J0LCB7XG4gICAgICAgICAgICBtaW5QaW5nRGVsYXk6IHRoaXMub3B0aW9ucy5taW5QaW5nRGVsYXksXG4gICAgICAgICAgICBtYXhQaW5nRGVsYXk6IHRoaXMub3B0aW9ucy5tYXhQaW5nRGVsYXlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS5pc0FsaXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXZlc0xlZnQgPiAwO1xuICAgIH07XG4gICAgVHJhbnNwb3J0TWFuYWdlci5wcm90b3R5cGUucmVwb3J0RGVhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGl2ZXNMZWZ0IC09IDE7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNwb3J0TWFuYWdlcjtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRfbWFuYWdlciA9ICh0cmFuc3BvcnRfbWFuYWdlcl9UcmFuc3BvcnRNYW5hZ2VyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL3NlcXVlbnRpYWxfc3RyYXRlZ3kudHNcblxuXG5cbnZhciBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VxdWVudGlhbFN0cmF0ZWd5KHN0cmF0ZWdpZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVnaWVzID0gc3RyYXRlZ2llcztcbiAgICAgICAgdGhpcy5sb29wID0gQm9vbGVhbihvcHRpb25zLmxvb3ApO1xuICAgICAgICB0aGlzLmZhaWxGYXN0ID0gQm9vbGVhbihvcHRpb25zLmZhaWxGYXN0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICB0aGlzLnRpbWVvdXRMaW1pdCA9IG9wdGlvbnMudGltZW91dExpbWl0O1xuICAgIH1cbiAgICBTZXF1ZW50aWFsU3RyYXRlZ3kucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuc3RyYXRlZ2llcywgdXRpbC5tZXRob2QoJ2lzU3VwcG9ydGVkJykpO1xuICAgIH07XG4gICAgU2VxdWVudGlhbFN0cmF0ZWd5LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3RyYXRlZ2llcyA9IHRoaXMuc3RyYXRlZ2llcztcbiAgICAgICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgdmFyIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIHZhciB0cnlOZXh0U3RyYXRlZ3kgPSBmdW5jdGlvbiAoZXJyb3IsIGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgaWYgKGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhbmRzaGFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQgJSBzdHJhdGVnaWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPCBzdHJhdGVnaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHRpbWVvdXQgKiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnRpbWVvdXRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0LCBfdGhpcy50aW1lb3V0TGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lciA9IF90aGlzLnRyeVN0cmF0ZWd5KHN0cmF0ZWdpZXNbY3VycmVudF0sIG1pblByaW9yaXR5LCB7IHRpbWVvdXQ6IHRpbWVvdXQsIGZhaWxGYXN0OiBfdGhpcy5mYWlsRmFzdCB9LCB0cnlOZXh0U3RyYXRlZ3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBydW5uZXIgPSB0aGlzLnRyeVN0cmF0ZWd5KHN0cmF0ZWdpZXNbY3VycmVudF0sIG1pblByaW9yaXR5LCB7IHRpbWVvdXQ6IHRpbWVvdXQsIGZhaWxGYXN0OiB0aGlzLmZhaWxGYXN0IH0sIHRyeU5leHRTdHJhdGVneSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgU2VxdWVudGlhbFN0cmF0ZWd5LnByb3RvdHlwZS50cnlTdHJhdGVneSA9IGZ1bmN0aW9uIChzdHJhdGVneSwgbWluUHJpb3JpdHksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgICAgIHZhciBydW5uZXIgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdGltZXIgPSBuZXcgT25lT2ZmVGltZXIob3B0aW9ucy50aW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW5uZXIgPSBzdHJhdGVneS5jb25uZWN0KG1pblByaW9yaXR5LCBmdW5jdGlvbiAoZXJyb3IsIGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIHRpbWVyICYmIHRpbWVyLmlzUnVubmluZygpICYmICFvcHRpb25zLmZhaWxGYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGhhbmRzaGFrZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNlcXVlbnRpYWxTdHJhdGVneTtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzZXF1ZW50aWFsX3N0cmF0ZWd5ID0gKHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2Jlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3kudHNcblxuXG52YXIgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5KHN0cmF0ZWdpZXMpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVnaWVzID0gc3RyYXRlZ2llcztcbiAgICB9XG4gICAgQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneS5wcm90b3R5cGUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5zdHJhdGVnaWVzLCB1dGlsLm1ldGhvZCgnaXNTdXBwb3J0ZWQnKSk7XG4gICAgfTtcbiAgICBCZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY29ubmVjdCh0aGlzLnN0cmF0ZWdpZXMsIG1pblByaW9yaXR5LCBmdW5jdGlvbiAoaSwgcnVubmVycykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyc1tpXS5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsUnVubmVyc0ZhaWxlZChydW5uZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBseShydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KGhhbmRzaGFrZS50cmFuc3BvcnQucHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhbmRzaGFrZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5O1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3kgPSAoYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5KTtcbmZ1bmN0aW9uIGNvbm5lY3Qoc3RyYXRlZ2llcywgbWluUHJpb3JpdHksIGNhbGxiYWNrQnVpbGRlcikge1xuICAgIHZhciBydW5uZXJzID0gbWFwKHN0cmF0ZWdpZXMsIGZ1bmN0aW9uIChzdHJhdGVneSwgaSwgXywgcnMpIHtcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrQnVpbGRlcihpLCBycykpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcHBseShydW5uZXJzLCBhYm9ydFJ1bm5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBhcHBseShydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBhbGxSdW5uZXJzRmFpbGVkKHJ1bm5lcnMpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbnNfYWxsKHJ1bm5lcnMsIGZ1bmN0aW9uIChydW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocnVubmVyLmVycm9yKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFib3J0UnVubmVyKHJ1bm5lcikge1xuICAgIGlmICghcnVubmVyLmVycm9yICYmICFydW5uZXIuYWJvcnRlZCkge1xuICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgcnVubmVyLmFib3J0ZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2NhY2hlZF9zdHJhdGVneS50c1xuXG5cblxuXG52YXIgY2FjaGVkX3N0cmF0ZWd5X0NhY2hlZFN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWNoZWRTdHJhdGVneShzdHJhdGVneSwgdHJhbnNwb3J0cywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0cyA9IHRyYW5zcG9ydHM7XG4gICAgICAgIHRoaXMudHRsID0gb3B0aW9ucy50dGwgfHwgMTgwMCAqIDEwMDA7XG4gICAgICAgIHRoaXMudXNpbmdUTFMgPSBvcHRpb25zLnVzZVRMUztcbiAgICAgICAgdGhpcy50aW1lbGluZSA9IG9wdGlvbnMudGltZWxpbmU7XG4gICAgfVxuICAgIENhY2hlZFN0cmF0ZWd5LnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9O1xuICAgIENhY2hlZFN0cmF0ZWd5LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdXNpbmdUTFMgPSB0aGlzLnVzaW5nVExTO1xuICAgICAgICB2YXIgaW5mbyA9IGZldGNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpO1xuICAgICAgICB2YXIgc3RyYXRlZ2llcyA9IFt0aGlzLnN0cmF0ZWd5XTtcbiAgICAgICAgaWYgKGluZm8gJiYgaW5mby50aW1lc3RhbXAgKyB0aGlzLnR0bCA+PSB1dGlsLm5vdygpKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzW2luZm8udHJhbnNwb3J0XTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oe1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaW5mby50cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgICAgIGxhdGVuY3k6IGluZm8ubGF0ZW5jeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0cmF0ZWdpZXMucHVzaChuZXcgc2VxdWVudGlhbF9zdHJhdGVneShbdHJhbnNwb3J0XSwge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiBpbmZvLmxhdGVuY3kgKiAyICsgMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgZmFpbEZhc3Q6IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0VGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgdmFyIHJ1bm5lciA9IHN0cmF0ZWdpZXNcbiAgICAgICAgICAgIC5wb3AoKVxuICAgICAgICAgICAgLmNvbm5lY3QobWluUHJpb3JpdHksIGZ1bmN0aW9uIGNiKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGZsdXNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVnaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXAgPSB1dGlsLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIgPSBzdHJhdGVnaWVzLnBvcCgpLmNvbm5lY3QobWluUHJpb3JpdHksIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yZVRyYW5zcG9ydENhY2hlKHVzaW5nVExTLCBoYW5kc2hha2UudHJhbnNwb3J0Lm5hbWUsIHV0aWwubm93KCkgLSBzdGFydFRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaGFuZHNoYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENhY2hlZFN0cmF0ZWd5O1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNhY2hlZF9zdHJhdGVneSA9IChjYWNoZWRfc3RyYXRlZ3lfQ2FjaGVkU3RyYXRlZ3kpO1xuZnVuY3Rpb24gZ2V0VHJhbnNwb3J0Q2FjaGVLZXkodXNpbmdUTFMpIHtcbiAgICByZXR1cm4gJ3B1c2hlclRyYW5zcG9ydCcgKyAodXNpbmdUTFMgPyAnVExTJyA6ICdOb25UTFMnKTtcbn1cbmZ1bmN0aW9uIGZldGNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpIHtcbiAgICB2YXIgc3RvcmFnZSA9IHJ1bnRpbWUuZ2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkQ2FjaGUgPSBzdG9yYWdlW2dldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKV07XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZENhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc2VyaWFsaXplZENhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZmx1c2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzdG9yZVRyYW5zcG9ydENhY2hlKHVzaW5nVExTLCB0cmFuc3BvcnQsIGxhdGVuY3kpIHtcbiAgICB2YXIgc3RvcmFnZSA9IHJ1bnRpbWUuZ2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0b3JhZ2VbZ2V0VHJhbnNwb3J0Q2FjaGVLZXkodXNpbmdUTFMpXSA9IHNhZmVKU09OU3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHV0aWwubm93KCksXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiB0cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgbGF0ZW5jeTogbGF0ZW5jeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZsdXNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpIHtcbiAgICB2YXIgc3RvcmFnZSA9IHJ1bnRpbWUuZ2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yYWdlW2dldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2RlbGF5ZWRfc3RyYXRlZ3kudHNcblxudmFyIGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheWVkU3RyYXRlZ3koc3RyYXRlZ3ksIF9hKSB7XG4gICAgICAgIHZhciBudW1iZXIgPSBfYS5kZWxheTtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7IGRlbGF5OiBudW1iZXIgfTtcbiAgICB9XG4gICAgRGVsYXllZFN0cmF0ZWd5LnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9O1xuICAgIERlbGF5ZWRTdHJhdGVneS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVneTtcbiAgICAgICAgdmFyIHJ1bm5lcjtcbiAgICAgICAgdmFyIHRpbWVyID0gbmV3IE9uZU9mZlRpbWVyKHRoaXMub3B0aW9ucy5kZWxheSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcnVubmVyID0gc3RyYXRlZ3kuY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIERlbGF5ZWRTdHJhdGVneTtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWxheWVkX3N0cmF0ZWd5ID0gKGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2lmX3N0cmF0ZWd5LnRzXG52YXIgSWZTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWZTdHJhdGVneSh0ZXN0LCB0cnVlQnJhbmNoLCBmYWxzZUJyYW5jaCkge1xuICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICB0aGlzLnRydWVCcmFuY2ggPSB0cnVlQnJhbmNoO1xuICAgICAgICB0aGlzLmZhbHNlQnJhbmNoID0gZmFsc2VCcmFuY2g7XG4gICAgfVxuICAgIElmU3RyYXRlZ3kucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnJhbmNoID0gdGhpcy50ZXN0KCkgPyB0aGlzLnRydWVCcmFuY2ggOiB0aGlzLmZhbHNlQnJhbmNoO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmlzU3VwcG9ydGVkKCk7XG4gICAgfTtcbiAgICBJZlN0cmF0ZWd5LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgYnJhbmNoID0gdGhpcy50ZXN0KCkgPyB0aGlzLnRydWVCcmFuY2ggOiB0aGlzLmZhbHNlQnJhbmNoO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBJZlN0cmF0ZWd5O1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGlmX3N0cmF0ZWd5ID0gKElmU3RyYXRlZ3kpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvZmlyc3RfY29ubmVjdGVkX3N0cmF0ZWd5LnRzXG52YXIgRmlyc3RDb25uZWN0ZWRTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlyc3RDb25uZWN0ZWRTdHJhdGVneShzdHJhdGVneSkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgfVxuICAgIEZpcnN0Q29ubmVjdGVkU3RyYXRlZ3kucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpO1xuICAgIH07XG4gICAgRmlyc3RDb25uZWN0ZWRTdHJhdGVneS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJ1bm5lciA9IHRoaXMuc3RyYXRlZ3kuY29ubmVjdChtaW5Qcmlvcml0eSwgZnVuY3Rpb24gKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgIGlmIChoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBoYW5kc2hha2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9O1xuICAgIHJldHVybiBGaXJzdENvbm5lY3RlZFN0cmF0ZWd5O1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGZpcnN0X2Nvbm5lY3RlZF9zdHJhdGVneSA9IChGaXJzdENvbm5lY3RlZFN0cmF0ZWd5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL2RlZmF1bHRfc3RyYXRlZ3kudHNcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gdGVzdFN1cHBvcnRzU3RyYXRlZ3koc3RyYXRlZ3kpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9O1xufVxudmFyIGdldERlZmF1bHRTdHJhdGVneSA9IGZ1bmN0aW9uIChjb25maWcsIGJhc2VPcHRpb25zLCBkZWZpbmVUcmFuc3BvcnQpIHtcbiAgICB2YXIgZGVmaW5lZFRyYW5zcG9ydHMgPSB7fTtcbiAgICBmdW5jdGlvbiBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneShuYW1lLCB0eXBlLCBwcmlvcml0eSwgb3B0aW9ucywgbWFuYWdlcikge1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0KGNvbmZpZywgbmFtZSwgdHlwZSwgcHJpb3JpdHksIG9wdGlvbnMsIG1hbmFnZXIpO1xuICAgICAgICBkZWZpbmVkVHJhbnNwb3J0c1tuYW1lXSA9IHRyYW5zcG9ydDtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICB9XG4gICAgdmFyIHdzX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlT3B0aW9ucywge1xuICAgICAgICBob3N0Tm9uVExTOiBjb25maWcud3NIb3N0ICsgJzonICsgY29uZmlnLndzUG9ydCxcbiAgICAgICAgaG9zdFRMUzogY29uZmlnLndzSG9zdCArICc6JyArIGNvbmZpZy53c3NQb3J0LFxuICAgICAgICBodHRwUGF0aDogY29uZmlnLndzUGF0aFxuICAgIH0pO1xuICAgIHZhciB3c3Nfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHdzX29wdGlvbnMsIHtcbiAgICAgICAgdXNlVExTOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIHNvY2tqc19vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZU9wdGlvbnMsIHtcbiAgICAgICAgaG9zdE5vblRMUzogY29uZmlnLmh0dHBIb3N0ICsgJzonICsgY29uZmlnLmh0dHBQb3J0LFxuICAgICAgICBob3N0VExTOiBjb25maWcuaHR0cEhvc3QgKyAnOicgKyBjb25maWcuaHR0cHNQb3J0LFxuICAgICAgICBodHRwUGF0aDogY29uZmlnLmh0dHBQYXRoXG4gICAgfSk7XG4gICAgdmFyIHRpbWVvdXRzID0ge1xuICAgICAgICBsb29wOiB0cnVlLFxuICAgICAgICB0aW1lb3V0OiAxNTAwMCxcbiAgICAgICAgdGltZW91dExpbWl0OiA2MDAwMFxuICAgIH07XG4gICAgdmFyIHdzX21hbmFnZXIgPSBuZXcgdHJhbnNwb3J0X21hbmFnZXIoe1xuICAgICAgICBsaXZlczogMixcbiAgICAgICAgbWluUGluZ0RlbGF5OiAxMDAwMCxcbiAgICAgICAgbWF4UGluZ0RlbGF5OiBjb25maWcuYWN0aXZpdHlUaW1lb3V0XG4gICAgfSk7XG4gICAgdmFyIHN0cmVhbWluZ19tYW5hZ2VyID0gbmV3IHRyYW5zcG9ydF9tYW5hZ2VyKHtcbiAgICAgICAgbGl2ZXM6IDIsXG4gICAgICAgIG1pblBpbmdEZWxheTogMTAwMDAsXG4gICAgICAgIG1heFBpbmdEZWxheTogY29uZmlnLmFjdGl2aXR5VGltZW91dFxuICAgIH0pO1xuICAgIHZhciB3c190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgnd3MnLCAnd3MnLCAzLCB3c19vcHRpb25zLCB3c19tYW5hZ2VyKTtcbiAgICB2YXIgd3NzX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd3c3MnLCAnd3MnLCAzLCB3c3Nfb3B0aW9ucywgd3NfbWFuYWdlcik7XG4gICAgdmFyIHNvY2tqc190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgnc29ja2pzJywgJ3NvY2tqcycsIDEsIHNvY2tqc19vcHRpb25zKTtcbiAgICB2YXIgeGhyX3N0cmVhbWluZ190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgneGhyX3N0cmVhbWluZycsICd4aHJfc3RyZWFtaW5nJywgMSwgc29ja2pzX29wdGlvbnMsIHN0cmVhbWluZ19tYW5hZ2VyKTtcbiAgICB2YXIgeGRyX3N0cmVhbWluZ190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgneGRyX3N0cmVhbWluZycsICd4ZHJfc3RyZWFtaW5nJywgMSwgc29ja2pzX29wdGlvbnMsIHN0cmVhbWluZ19tYW5hZ2VyKTtcbiAgICB2YXIgeGhyX3BvbGxpbmdfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3hocl9wb2xsaW5nJywgJ3hocl9wb2xsaW5nJywgMSwgc29ja2pzX29wdGlvbnMpO1xuICAgIHZhciB4ZHJfcG9sbGluZ190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgneGRyX3BvbGxpbmcnLCAneGRyX3BvbGxpbmcnLCAxLCBzb2NranNfb3B0aW9ucyk7XG4gICAgdmFyIHdzX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneShbd3NfdHJhbnNwb3J0XSwgdGltZW91dHMpO1xuICAgIHZhciB3c3NfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5KFt3c3NfdHJhbnNwb3J0XSwgdGltZW91dHMpO1xuICAgIHZhciBzb2NranNfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5KFtzb2NranNfdHJhbnNwb3J0XSwgdGltZW91dHMpO1xuICAgIHZhciBzdHJlYW1pbmdfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5KFtcbiAgICAgICAgbmV3IGlmX3N0cmF0ZWd5KHRlc3RTdXBwb3J0c1N0cmF0ZWd5KHhocl9zdHJlYW1pbmdfdHJhbnNwb3J0KSwgeGhyX3N0cmVhbWluZ190cmFuc3BvcnQsIHhkcl9zdHJlYW1pbmdfdHJhbnNwb3J0KVxuICAgIF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgcG9sbGluZ19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3koW1xuICAgICAgICBuZXcgaWZfc3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3koeGhyX3BvbGxpbmdfdHJhbnNwb3J0KSwgeGhyX3BvbGxpbmdfdHJhbnNwb3J0LCB4ZHJfcG9sbGluZ190cmFuc3BvcnQpXG4gICAgXSwgdGltZW91dHMpO1xuICAgIHZhciBodHRwX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneShbXG4gICAgICAgIG5ldyBpZl9zdHJhdGVneSh0ZXN0U3VwcG9ydHNTdHJhdGVneShzdHJlYW1pbmdfbG9vcCksIG5ldyBiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5KFtcbiAgICAgICAgICAgIHN0cmVhbWluZ19sb29wLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3kocG9sbGluZ19sb29wLCB7IGRlbGF5OiA0MDAwIH0pXG4gICAgICAgIF0pLCBwb2xsaW5nX2xvb3ApXG4gICAgXSwgdGltZW91dHMpO1xuICAgIHZhciBodHRwX2ZhbGxiYWNrX2xvb3AgPSBuZXcgaWZfc3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3koaHR0cF9sb29wKSwgaHR0cF9sb29wLCBzb2NranNfbG9vcCk7XG4gICAgdmFyIHdzU3RyYXRlZ3k7XG4gICAgaWYgKGJhc2VPcHRpb25zLnVzZVRMUykge1xuICAgICAgICB3c1N0cmF0ZWd5ID0gbmV3IGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3koW1xuICAgICAgICAgICAgd3NfbG9vcCxcbiAgICAgICAgICAgIG5ldyBkZWxheWVkX3N0cmF0ZWd5KGh0dHBfZmFsbGJhY2tfbG9vcCwgeyBkZWxheTogMjAwMCB9KVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdzU3RyYXRlZ3kgPSBuZXcgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneShbXG4gICAgICAgICAgICB3c19sb29wLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3kod3NzX2xvb3AsIHsgZGVsYXk6IDIwMDAgfSksXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneShodHRwX2ZhbGxiYWNrX2xvb3AsIHsgZGVsYXk6IDUwMDAgfSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgY2FjaGVkX3N0cmF0ZWd5KG5ldyBmaXJzdF9jb25uZWN0ZWRfc3RyYXRlZ3kobmV3IGlmX3N0cmF0ZWd5KHRlc3RTdXBwb3J0c1N0cmF0ZWd5KHdzX3RyYW5zcG9ydCksIHdzU3RyYXRlZ3ksIGh0dHBfZmFsbGJhY2tfbG9vcCkpLCBkZWZpbmVkVHJhbnNwb3J0cywge1xuICAgICAgICB0dGw6IDE4MDAwMDAsXG4gICAgICAgIHRpbWVsaW5lOiBiYXNlT3B0aW9ucy50aW1lbGluZSxcbiAgICAgICAgdXNlVExTOiBiYXNlT3B0aW9ucy51c2VUTFNcbiAgICB9KTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWZhdWx0X3N0cmF0ZWd5ID0gKGdldERlZmF1bHRTdHJhdGVneSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi90cmFuc3BvcnRzL3RyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyLnRzXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi50aW1lbGluZS5pbmZvKHNlbGYuYnVpbGRUaW1lbGluZU1lc3NhZ2Uoe1xuICAgICAgICB0cmFuc3BvcnQ6IHNlbGYubmFtZSArIChzZWxmLm9wdGlvbnMudXNlVExTID8gJ3MnIDogJycpXG4gICAgfSkpO1xuICAgIGlmIChzZWxmLmhvb2tzLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICBzZWxmLmNoYW5nZVN0YXRlKCdpbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxmLmhvb2tzLmZpbGUpIHtcbiAgICAgICAgc2VsZi5jaGFuZ2VTdGF0ZSgnaW5pdGlhbGl6aW5nJyk7XG4gICAgICAgIERlcGVuZGVuY2llcy5sb2FkKHNlbGYuaG9va3MuZmlsZSwgeyB1c2VUTFM6IHNlbGYub3B0aW9ucy51c2VUTFMgfSwgZnVuY3Rpb24gKGVycm9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHNlbGYuaG9va3MuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VTdGF0ZSgnaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgfVxufSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9odHRwL2h0dHBfeGRvbWFpbl9yZXF1ZXN0LnRzXG5cbnZhciBodHRwX3hkb21haW5fcmVxdWVzdF9ob29rcyA9IHtcbiAgICBnZXRSZXF1ZXN0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHZhciB4ZHIgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCBuZXcgUmVxdWVzdFRpbWVkT3V0KCkpO1xuICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHhkci5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHhkci5yZXNwb25zZVRleHQgJiYgeGRyLnJlc3BvbnNlVGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uQ2h1bmsoMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh4ZHIucmVzcG9uc2VUZXh0ICYmIHhkci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbkNodW5rKDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgnZmluaXNoZWQnLCAyMDApO1xuICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB4ZHI7XG4gICAgfSxcbiAgICBhYm9ydFJlcXVlc3Q6IGZ1bmN0aW9uICh4ZHIpIHtcbiAgICAgICAgeGRyLm9udGltZW91dCA9IHhkci5vbmVycm9yID0geGRyLm9ucHJvZ3Jlc3MgPSB4ZHIub25sb2FkID0gbnVsbDtcbiAgICAgICAgeGRyLmFib3J0KCk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfeGRvbWFpbl9yZXF1ZXN0ID0gKGh0dHBfeGRvbWFpbl9yZXF1ZXN0X2hvb2tzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9odHRwL2h0dHBfcmVxdWVzdC50c1xudmFyIGh0dHBfcmVxdWVzdF9leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5cblxudmFyIE1BWF9CVUZGRVJfTEVOR1RIID0gMjU2ICogMTAyNDtcbnZhciBodHRwX3JlcXVlc3RfSFRUUFJlcXVlc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGh0dHBfcmVxdWVzdF9leHRlbmRzKEhUVFBSZXF1ZXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhUVFBSZXF1ZXN0KGhvb2tzLCBtZXRob2QsIHVybCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgICAgICBfdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIF90aGlzLnVybCA9IHVybDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBIVFRQUmVxdWVzdC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgICAgdGhpcy54aHIgPSB0aGlzLmhvb2tzLmdldFJlcXVlc3QodGhpcyk7XG4gICAgICAgIHRoaXMudW5sb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBydW50aW1lLmFkZFVubG9hZExpc3RlbmVyKHRoaXMudW5sb2FkZXIpO1xuICAgICAgICB0aGlzLnhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQocGF5bG9hZCk7XG4gICAgfTtcbiAgICBIVFRQUmVxdWVzdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVubG9hZGVyKSB7XG4gICAgICAgICAgICBydW50aW1lLnJlbW92ZVVubG9hZExpc3RlbmVyKHRoaXMudW5sb2FkZXIpO1xuICAgICAgICAgICAgdGhpcy51bmxvYWRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMueGhyKSB7XG4gICAgICAgICAgICB0aGlzLmhvb2tzLmFib3J0UmVxdWVzdCh0aGlzLnhocik7XG4gICAgICAgICAgICB0aGlzLnhociA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhUVFBSZXF1ZXN0LnByb3RvdHlwZS5vbkNodW5rID0gZnVuY3Rpb24gKHN0YXR1cywgZGF0YSkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGNodW5rID0gdGhpcy5hZHZhbmNlQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjaHVuaycsIHsgc3RhdHVzOiBzdGF0dXMsIGRhdGE6IGNodW5rIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNCdWZmZXJUb29Mb25nKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2J1ZmZlcl90b29fbG9uZycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIVFRQUmVxdWVzdC5wcm90b3R5cGUuYWR2YW5jZUJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgdmFyIHVucmVhZERhdGEgPSBidWZmZXIuc2xpY2UodGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHZhciBlbmRPZkxpbmVQb3NpdGlvbiA9IHVucmVhZERhdGEuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIGlmIChlbmRPZkxpbmVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gZW5kT2ZMaW5lUG9zaXRpb24gKyAxO1xuICAgICAgICAgICAgcmV0dXJuIHVucmVhZERhdGEuc2xpY2UoMCwgZW5kT2ZMaW5lUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhUVFBSZXF1ZXN0LnByb3RvdHlwZS5pc0J1ZmZlclRvb0xvbmcgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlci5sZW5ndGggPiBNQVhfQlVGRkVSX0xFTkdUSDtcbiAgICB9O1xuICAgIHJldHVybiBIVFRQUmVxdWVzdDtcbn0oZGlzcGF0Y2hlcikpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF9yZXF1ZXN0ID0gKGh0dHBfcmVxdWVzdF9IVFRQUmVxdWVzdCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9zdGF0ZS50c1xudmFyIFN0YXRlO1xuKGZ1bmN0aW9uIChTdGF0ZSkge1xuICAgIFN0YXRlW1N0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDBdID0gXCJDT05ORUNUSU5HXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUEVOXCJdID0gMV0gPSBcIk9QRU5cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkNMT1NFRFwiXSA9IDNdID0gXCJDTE9TRURcIjtcbn0pKFN0YXRlIHx8IChTdGF0ZSA9IHt9KSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzdGF0ZSA9IChTdGF0ZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9odHRwX3NvY2tldC50c1xuXG5cblxudmFyIGF1dG9JbmNyZW1lbnQgPSAxO1xudmFyIGh0dHBfc29ja2V0X0hUVFBTb2NrZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhUVFBTb2NrZXQoaG9va3MsIHVybCkge1xuICAgICAgICB0aGlzLmhvb2tzID0gaG9va3M7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHJhbmRvbU51bWJlcigxMDAwKSArICcvJyArIHJhbmRvbVN0cmluZyg4KTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGdldExvY2F0aW9uKHVybCk7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgICAgIHRoaXMub3BlblN0cmVhbSgpO1xuICAgIH1cbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJhdyhKU09OLnN0cmluZ2lmeShbcGF5bG9hZF0pKTtcbiAgICB9O1xuICAgIEhUVFBTb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaG9va3Muc2VuZEhlYXJ0YmVhdCh0aGlzKTtcbiAgICB9O1xuICAgIEhUVFBTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLm9uQ2xvc2UoY29kZSwgcmVhc29uLCB0cnVlKTtcbiAgICB9O1xuICAgIEhUVFBTb2NrZXQucHJvdG90eXBlLnNlbmRSYXcgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5PUEVOKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bnRpbWUuY3JlYXRlU29ja2V0UmVxdWVzdCgnUE9TVCcsIGdldFVuaXF1ZVVSTChnZXRTZW5kVVJMKHRoaXMubG9jYXRpb24sIHRoaXMuc2Vzc2lvbikpKS5zdGFydChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XG4gICAgfTtcbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgICAgICAgdGhpcy5jbG9zZVN0cmVhbSgpO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBzdGF0ZS5DTE9TRUQ7XG4gICAgICAgIGlmICh0aGlzLm9uY2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMub25jbG9zZSh7XG4gICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgICAgICB3YXNDbGVhbjogd2FzQ2xlYW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5vbkNodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIGlmIChjaHVuay5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLk9QRU4pIHtcbiAgICAgICAgICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXlsb2FkO1xuICAgICAgICB2YXIgdHlwZSA9IGNodW5rLmRhdGEuc2xpY2UoMCwgMSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY2h1bmsuZGF0YS5zbGljZSgxKSB8fCAne30nKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uT3BlbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ1tdJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXlsb2FkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FdmVudChwYXlsb2FkW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICdudWxsJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkV2ZW50KHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcy5vbkhlYXJ0YmVhdCh0aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ1tdJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi5iYXNlID0gcmVwbGFjZUhvc3QodGhpcy5sb2NhdGlvbi5iYXNlLCBvcHRpb25zLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlLk9QRU47XG4gICAgICAgICAgICBpZiAodGhpcy5vbm9wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhUVFBTb2NrZXQucHJvdG90eXBlLm9uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gc3RhdGUuT1BFTiAmJiB0aGlzLm9ubWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5vbm1lc3NhZ2UoeyBkYXRhOiBldmVudCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSFRUUFNvY2tldC5wcm90b3R5cGUub25BY3Rpdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub25hY3Rpdml0eSkge1xuICAgICAgICAgICAgdGhpcy5vbmFjdGl2aXR5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhUVFBTb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMub25lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSFRUUFNvY2tldC5wcm90b3R5cGUub3BlblN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBydW50aW1lLmNyZWF0ZVNvY2tldFJlcXVlc3QoJ1BPU1QnLCBnZXRVbmlxdWVVUkwodGhpcy5ob29rcy5nZXRSZWNlaXZlVVJMKHRoaXMubG9jYXRpb24sIHRoaXMuc2Vzc2lvbikpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnY2h1bmsnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIF90aGlzLm9uQ2h1bmsoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnZmluaXNoZWQnLCBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgICAgICBfdGhpcy5ob29rcy5vbkZpbmlzaGVkKF90aGlzLCBzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnYnVmZmVyX3Rvb19sb25nJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0uc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHV0aWwuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uQ2xvc2UoMTAwNiwgJ0NvdWxkIG5vdCBzdGFydCBzdHJlYW1pbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSFRUUFNvY2tldC5wcm90b3R5cGUuY2xvc2VTdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0udW5iaW5kX2FsbCgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEhUVFBTb2NrZXQ7XG59KCkpO1xuZnVuY3Rpb24gZ2V0TG9jYXRpb24odXJsKSB7XG4gICAgdmFyIHBhcnRzID0gLyhbXlxcP10qKVxcLyooXFw/Py4qKS8uZXhlYyh1cmwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IHBhcnRzWzFdLFxuICAgICAgICBxdWVyeVN0cmluZzogcGFydHNbMl1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VuZFVSTCh1cmwsIHNlc3Npb24pIHtcbiAgICByZXR1cm4gdXJsLmJhc2UgKyAnLycgKyBzZXNzaW9uICsgJy94aHJfc2VuZCc7XG59XG5mdW5jdGlvbiBnZXRVbmlxdWVVUkwodXJsKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnO1xuICAgIHJldHVybiB1cmwgKyBzZXBhcmF0b3IgKyAndD0nICsgK25ldyBEYXRlKCkgKyAnJm49JyArIGF1dG9JbmNyZW1lbnQrKztcbn1cbmZ1bmN0aW9uIHJlcGxhY2VIb3N0KHVybCwgaG9zdG5hbWUpIHtcbiAgICB2YXIgdXJsUGFydHMgPSAvKGh0dHBzPzpcXC9cXC8pKFteXFwvOl0rKSgoXFwvfDopPy4qKS8uZXhlYyh1cmwpO1xuICAgIHJldHVybiB1cmxQYXJ0c1sxXSArIGhvc3RuYW1lICsgdXJsUGFydHNbM107XG59XG5mdW5jdGlvbiByYW5kb21OdW1iZXIobWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG59XG5mdW5jdGlvbiByYW5kb21TdHJpbmcobGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmFuZG9tTnVtYmVyKDMyKS50b1N0cmluZygzMikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF9zb2NrZXQgPSAoaHR0cF9zb2NrZXRfSFRUUFNvY2tldCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9odHRwX3N0cmVhbWluZ19zb2NrZXQudHNcbnZhciBodHRwX3N0cmVhbWluZ19zb2NrZXRfaG9va3MgPSB7XG4gICAgZ2V0UmVjZWl2ZVVSTDogZnVuY3Rpb24gKHVybCwgc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gdXJsLmJhc2UgKyAnLycgKyBzZXNzaW9uICsgJy94aHJfc3RyZWFtaW5nJyArIHVybC5xdWVyeVN0cmluZztcbiAgICB9LFxuICAgIG9uSGVhcnRiZWF0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHNvY2tldC5zZW5kUmF3KCdbXScpO1xuICAgIH0sXG4gICAgc2VuZEhlYXJ0YmVhdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQuc2VuZFJhdygnW10nKTtcbiAgICB9LFxuICAgIG9uRmluaXNoZWQ6IGZ1bmN0aW9uIChzb2NrZXQsIHN0YXR1cykge1xuICAgICAgICBzb2NrZXQub25DbG9zZSgxMDA2LCAnQ29ubmVjdGlvbiBpbnRlcnJ1cHRlZCAoJyArIHN0YXR1cyArICcpJywgZmFsc2UpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3N0cmVhbWluZ19zb2NrZXQgPSAoaHR0cF9zdHJlYW1pbmdfc29ja2V0X2hvb2tzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9odHRwL2h0dHBfcG9sbGluZ19zb2NrZXQudHNcbnZhciBodHRwX3BvbGxpbmdfc29ja2V0X2hvb2tzID0ge1xuICAgIGdldFJlY2VpdmVVUkw6IGZ1bmN0aW9uICh1cmwsIHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHVybC5iYXNlICsgJy8nICsgc2Vzc2lvbiArICcveGhyJyArIHVybC5xdWVyeVN0cmluZztcbiAgICB9LFxuICAgIG9uSGVhcnRiZWF0OiBmdW5jdGlvbiAoKSB7XG4gICAgfSxcbiAgICBzZW5kSGVhcnRiZWF0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHNvY2tldC5zZW5kUmF3KCdbXScpO1xuICAgIH0sXG4gICAgb25GaW5pc2hlZDogZnVuY3Rpb24gKHNvY2tldCwgc3RhdHVzKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgc29ja2V0LnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc29ja2V0Lm9uQ2xvc2UoMTAwNiwgJ0Nvbm5lY3Rpb24gaW50ZXJydXB0ZWQgKCcgKyBzdGF0dXMgKyAnKScsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3BvbGxpbmdfc29ja2V0ID0gKGh0dHBfcG9sbGluZ19zb2NrZXRfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2h0dHAvaHR0cF94aHJfcmVxdWVzdC50c1xuXG52YXIgaHR0cF94aHJfcmVxdWVzdF9ob29rcyA9IHtcbiAgICBnZXRSZXF1ZXN0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHJ1bnRpbWUuZ2V0WEhSQVBJKCk7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZVRleHQgJiYgeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25DaHVuayh4aHIuc3RhdHVzLCB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUZXh0ICYmIHhoci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uQ2h1bmsoeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2ZpbmlzaGVkJywgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuICAgIGFib3J0UmVxdWVzdDogZnVuY3Rpb24gKHhocikge1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfeGhyX3JlcXVlc3QgPSAoaHR0cF94aHJfcmVxdWVzdF9ob29rcyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL2lzb21vcnBoaWMvaHR0cC9odHRwLnRzXG5cblxuXG5cblxudmFyIEhUVFAgPSB7XG4gICAgY3JlYXRlU3RyZWFtaW5nU29ja2V0OiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvY2tldChodHRwX3N0cmVhbWluZ19zb2NrZXQsIHVybCk7XG4gICAgfSxcbiAgICBjcmVhdGVQb2xsaW5nU29ja2V0OiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvY2tldChodHRwX3BvbGxpbmdfc29ja2V0LCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlU29ja2V0OiBmdW5jdGlvbiAoaG9va3MsIHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IGh0dHBfc29ja2V0KGhvb2tzLCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlWEhSOiBmdW5jdGlvbiAobWV0aG9kLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVxdWVzdChodHRwX3hocl9yZXF1ZXN0LCBtZXRob2QsIHVybCk7XG4gICAgfSxcbiAgICBjcmVhdGVSZXF1ZXN0OiBmdW5jdGlvbiAoaG9va3MsIG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgaHR0cF9yZXF1ZXN0KGhvb2tzLCBtZXRob2QsIHVybCk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfaHR0cCA9IChIVFRQKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL2h0dHAvaHR0cC50c1xuXG5cbmh0dHBfaHR0cC5jcmVhdGVYRFIgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXF1ZXN0KGh0dHBfeGRvbWFpbl9yZXF1ZXN0LCBtZXRob2QsIHVybCk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgd2ViX2h0dHBfaHR0cCA9IChodHRwX2h0dHApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvcnVudGltZS50c1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIFJ1bnRpbWUgPSB7XG4gICAgbmV4dEF1dGhDYWxsYmFja0lEOiAxLFxuICAgIGF1dGhfY2FsbGJhY2tzOiB7fSxcbiAgICBTY3JpcHRSZWNlaXZlcnM6IFNjcmlwdFJlY2VpdmVycyxcbiAgICBEZXBlbmRlbmNpZXNSZWNlaXZlcnM6IERlcGVuZGVuY2llc1JlY2VpdmVycyxcbiAgICBnZXREZWZhdWx0U3RyYXRlZ3k6IGRlZmF1bHRfc3RyYXRlZ3ksXG4gICAgVHJhbnNwb3J0czogdHJhbnNwb3J0c190cmFuc3BvcnRzLFxuICAgIHRyYW5zcG9ydENvbm5lY3Rpb25Jbml0aWFsaXplcjogdHJhbnNwb3J0X2Nvbm5lY3Rpb25faW5pdGlhbGl6ZXIsXG4gICAgSFRUUEZhY3Rvcnk6IHdlYl9odHRwX2h0dHAsXG4gICAgVGltZWxpbmVUcmFuc3BvcnQ6IGpzb25wX3RpbWVsaW5lLFxuICAgIGdldFhIUkFQSTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xuICAgIH0sXG4gICAgZ2V0V2ViU29ja2V0QVBJOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuV2ViU29ja2V0IHx8IHdpbmRvdy5Nb3pXZWJTb2NrZXQ7XG4gICAgfSxcbiAgICBzZXR1cDogZnVuY3Rpb24gKFB1c2hlckNsYXNzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHdpbmRvdy5QdXNoZXIgPSBQdXNoZXJDbGFzcztcbiAgICAgICAgdmFyIGluaXRpYWxpemVPbkRvY3VtZW50Qm9keSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm9uRG9jdW1lbnRCb2R5KFB1c2hlckNsYXNzLnJlYWR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF3aW5kb3cuSlNPTikge1xuICAgICAgICAgICAgRGVwZW5kZW5jaWVzLmxvYWQoJ2pzb24yJywge30sIGluaXRpYWxpemVPbkRvY3VtZW50Qm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsaXplT25Eb2N1bWVudEJvZHkoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH0sXG4gICAgZ2V0UHJvdG9jb2w6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnQoKS5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICB9LFxuICAgIGdldEF1dGhvcml6ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGFqYXg6IHhocl9hdXRoLCBqc29ucDoganNvbnBfYXV0aCB9O1xuICAgIH0sXG4gICAgb25Eb2N1bWVudEJvZHk6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRG9jdW1lbnRCb2R5KGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVKU09OUFJlcXVlc3Q6IGZ1bmN0aW9uICh1cmwsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBqc29ucF9yZXF1ZXN0KHVybCwgZGF0YSk7XG4gICAgfSxcbiAgICBjcmVhdGVTY3JpcHRSZXF1ZXN0OiBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgIHJldHVybiBuZXcgc2NyaXB0X3JlcXVlc3Qoc3JjKTtcbiAgICB9LFxuICAgIGdldExvY2FsU3RvcmFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVhIUjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRYSFJBUEkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU1pY3Jvc29mdFhIUigpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVYTUxIdHRwUmVxdWVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzLmdldFhIUkFQSSgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgfSxcbiAgICBjcmVhdGVNaWNyb3NvZnRYSFI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0sXG4gICAgZ2V0TmV0d29yazogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV0X2luZm9fTmV0d29yaztcbiAgICB9LFxuICAgIGNyZWF0ZVdlYlNvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzLmdldFdlYlNvY2tldEFQSSgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHVybCk7XG4gICAgfSxcbiAgICBjcmVhdGVTb2NrZXRSZXF1ZXN0OiBmdW5jdGlvbiAobWV0aG9kLCB1cmwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNYSFJTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSFRUUEZhY3RvcnkuY3JlYXRlWEhSKG1ldGhvZCwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzWERSU3VwcG9ydGVkKHVybC5pbmRleE9mKCdodHRwczonKSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkhUVFBGYWN0b3J5LmNyZWF0ZVhEUihtZXRob2QsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnQ3Jvc3Mtb3JpZ2luIEhUVFAgcmVxdWVzdHMgYXJlIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpc1hIUlN1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzLmdldFhIUkFQSSgpO1xuICAgICAgICByZXR1cm4gKEJvb2xlYW4oQ29uc3RydWN0b3IpICYmIG5ldyBDb25zdHJ1Y3RvcigpLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGlzWERSU3VwcG9ydGVkOiBmdW5jdGlvbiAodXNlVExTKSB7XG4gICAgICAgIHZhciBwcm90b2NvbCA9IHVzZVRMUyA/ICdodHRwczonIDogJ2h0dHA6JztcbiAgICAgICAgdmFyIGRvY3VtZW50UHJvdG9jb2wgPSB0aGlzLmdldFByb3RvY29sKCk7XG4gICAgICAgIHJldHVybiAoQm9vbGVhbih3aW5kb3dbJ1hEb21haW5SZXF1ZXN0J10pICYmIGRvY3VtZW50UHJvdG9jb2wgPT09IHByb3RvY29sKTtcbiAgICB9LFxuICAgIGFkZFVubG9hZExpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmxvYWQnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpbmRvdy5hdHRhY2hFdmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVVbmxvYWRMaXN0ZW5lcjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aW5kb3cuZGV0YWNoRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmRldGFjaEV2ZW50KCdvbnVubG9hZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBydW50aW1lID0gKFJ1bnRpbWUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RpbWVsaW5lL2xldmVsLnRzXG52YXIgVGltZWxpbmVMZXZlbDtcbihmdW5jdGlvbiAoVGltZWxpbmVMZXZlbCkge1xuICAgIFRpbWVsaW5lTGV2ZWxbVGltZWxpbmVMZXZlbFtcIkVSUk9SXCJdID0gM10gPSBcIkVSUk9SXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiSU5GT1wiXSA9IDZdID0gXCJJTkZPXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiREVCVUdcIl0gPSA3XSA9IFwiREVCVUdcIjtcbn0pKFRpbWVsaW5lTGV2ZWwgfHwgKFRpbWVsaW5lTGV2ZWwgPSB7fSkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGltZWxpbmVfbGV2ZWwgPSAoVGltZWxpbmVMZXZlbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdGltZWxpbmUvdGltZWxpbmUudHNcblxuXG5cbnZhciB0aW1lbGluZV9UaW1lbGluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZWxpbmUoa2V5LCBzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLnNlbnQgPSAwO1xuICAgICAgICB0aGlzLnVuaXF1ZUlEID0gMDtcbiAgICB9XG4gICAgVGltZWxpbmUucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGxldmVsIDw9IHRoaXMub3B0aW9ucy5sZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaChleHRlbmQoe30sIGV2ZW50LCB7IHRpbWVzdGFtcDogdXRpbC5ub3coKSB9KSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpbWl0ICYmIHRoaXMuZXZlbnRzLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5saW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmxvZyh0aW1lbGluZV9sZXZlbC5FUlJPUiwgZXZlbnQpO1xuICAgIH07XG4gICAgVGltZWxpbmUucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2codGltZWxpbmVfbGV2ZWwuSU5GTywgZXZlbnQpO1xuICAgIH07XG4gICAgVGltZWxpbmUucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nKHRpbWVsaW5lX2xldmVsLkRFQlVHLCBldmVudCk7XG4gICAgfTtcbiAgICBUaW1lbGluZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHNlbmRmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSBleHRlbmQoe1xuICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5zZXNzaW9uLFxuICAgICAgICAgICAgYnVuZGxlOiB0aGlzLnNlbnQgKyAxLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGxpYjogJ2pzJyxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMub3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5vcHRpb25zLmNsdXN0ZXIsXG4gICAgICAgICAgICBmZWF0dXJlczogdGhpcy5vcHRpb25zLmZlYXR1cmVzLFxuICAgICAgICAgICAgdGltZWxpbmU6IHRoaXMuZXZlbnRzXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICBzZW5kZm4oZGF0YSwgZnVuY3Rpb24gKGVycm9yLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVGltZWxpbmUucHJvdG90eXBlLmdlbmVyYXRlVW5pcXVlSUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5pcXVlSUQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pcXVlSUQ7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZWxpbmU7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGltZWxpbmVfdGltZWxpbmUgPSAodGltZWxpbmVfVGltZWxpbmUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvdHJhbnNwb3J0X3N0cmF0ZWd5LnRzXG5cblxuXG5cbnZhciB0cmFuc3BvcnRfc3RyYXRlZ3lfVHJhbnNwb3J0U3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydFN0cmF0ZWd5KG5hbWUsIHByaW9yaXR5LCB0cmFuc3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB9XG4gICAgVHJhbnNwb3J0U3RyYXRlZ3kucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuaXNTdXBwb3J0ZWQoe1xuICAgICAgICAgICAgdXNlVExTOiB0aGlzLm9wdGlvbnMudXNlVExTXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHJhbnNwb3J0U3RyYXRlZ3kucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbEF0dGVtcHQobmV3IFVuc3VwcG9ydGVkU3RyYXRlZ3koKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJpb3JpdHkgPCBtaW5Qcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWxBdHRlbXB0KG5ldyBUcmFuc3BvcnRQcmlvcml0eVRvb0xvdygpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ29ubmVjdGlvbih0aGlzLm5hbWUsIHRoaXMucHJpb3JpdHksIHRoaXMub3B0aW9ucy5rZXksIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHZhciBoYW5kc2hha2UgPSBudWxsO1xuICAgICAgICB2YXIgb25Jbml0aWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2luaXRpYWxpemVkJywgb25Jbml0aWFsaXplZCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaGFuZHNoYWtlID0gZmFjdG9yeS5jcmVhdGVIYW5kc2hha2UodHJhbnNwb3J0LCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB1bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZFRyYW5zcG9ydDtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRUcmFuc3BvcnQgPSBzYWZlSlNPTlN0cmluZ2lmeSh0cmFuc3BvcnQpO1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFRyYW5zcG9ydENsb3NlZChzZXJpYWxpemVkVHJhbnNwb3J0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1bmJpbmRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdpbml0aWFsaXplZCcsIG9uSW5pdGlhbGl6ZWQpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnb3BlbicsIG9uT3Blbik7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc3BvcnQuYmluZCgnaW5pdGlhbGl6ZWQnLCBvbkluaXRpYWxpemVkKTtcbiAgICAgICAgdHJhbnNwb3J0LmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICB0cmFuc3BvcnQuYmluZCgnZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgdHJhbnNwb3J0LmJpbmQoJ2Nsb3NlZCcsIG9uQ2xvc2VkKTtcbiAgICAgICAgdHJhbnNwb3J0LmluaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByaW9yaXR5IDwgcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zcG9ydFN0cmF0ZWd5O1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcG9ydF9zdHJhdGVneSA9ICh0cmFuc3BvcnRfc3RyYXRlZ3lfVHJhbnNwb3J0U3RyYXRlZ3kpO1xuZnVuY3Rpb24gZmFpbEF0dGVtcHQoZXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgdXRpbC5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAoKSB7IH1cbiAgICB9O1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvc3RyYXRlZ3lfYnVpbGRlci50c1xuXG5cblxuXG5cbnZhciBzdHJhdGVneV9idWlsZGVyX1RyYW5zcG9ydHMgPSBydW50aW1lLlRyYW5zcG9ydHM7XG52YXIgc3RyYXRlZ3lfYnVpbGRlcl9kZWZpbmVUcmFuc3BvcnQgPSBmdW5jdGlvbiAoY29uZmlnLCBuYW1lLCB0eXBlLCBwcmlvcml0eSwgb3B0aW9ucywgbWFuYWdlcikge1xuICAgIHZhciB0cmFuc3BvcnRDbGFzcyA9IHN0cmF0ZWd5X2J1aWxkZXJfVHJhbnNwb3J0c1t0eXBlXTtcbiAgICBpZiAoIXRyYW5zcG9ydENsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRyYW5zcG9ydCh0eXBlKTtcbiAgICB9XG4gICAgdmFyIGVuYWJsZWQgPSAoIWNvbmZpZy5lbmFibGVkVHJhbnNwb3J0cyB8fFxuICAgICAgICBhcnJheUluZGV4T2YoY29uZmlnLmVuYWJsZWRUcmFuc3BvcnRzLCBuYW1lKSAhPT0gLTEpICYmXG4gICAgICAgICghY29uZmlnLmRpc2FibGVkVHJhbnNwb3J0cyB8fFxuICAgICAgICAgICAgYXJyYXlJbmRleE9mKGNvbmZpZy5kaXNhYmxlZFRyYW5zcG9ydHMsIG5hbWUpID09PSAtMSk7XG4gICAgdmFyIHRyYW5zcG9ydDtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGlnbm9yZU51bGxPcmlnaW46IGNvbmZpZy5pZ25vcmVOdWxsT3JpZ2luIH0sIG9wdGlvbnMpO1xuICAgICAgICB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X3N0cmF0ZWd5KG5hbWUsIHByaW9yaXR5LCBtYW5hZ2VyID8gbWFuYWdlci5nZXRBc3Npc3RhbnQodHJhbnNwb3J0Q2xhc3MpIDogdHJhbnNwb3J0Q2xhc3MsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJhbnNwb3J0ID0gc3RyYXRlZ3lfYnVpbGRlcl9VbnN1cHBvcnRlZFN0cmF0ZWd5O1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0O1xufTtcbnZhciBzdHJhdGVneV9idWlsZGVyX1Vuc3VwcG9ydGVkU3RyYXRlZ3kgPSB7XG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY29ubmVjdDogZnVuY3Rpb24gKF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFVuc3VwcG9ydGVkU3RyYXRlZ3koKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25maWcudHNcblxuXG5mdW5jdGlvbiBnZXRDb25maWcob3B0cykge1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIGFjdGl2aXR5VGltZW91dDogb3B0cy5hY3Rpdml0eVRpbWVvdXQgfHwgZGVmYXVsdHMuYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICBhdXRoRW5kcG9pbnQ6IG9wdHMuYXV0aEVuZHBvaW50IHx8IGRlZmF1bHRzLmF1dGhFbmRwb2ludCxcbiAgICAgICAgYXV0aFRyYW5zcG9ydDogb3B0cy5hdXRoVHJhbnNwb3J0IHx8IGRlZmF1bHRzLmF1dGhUcmFuc3BvcnQsXG4gICAgICAgIGNsdXN0ZXI6IG9wdHMuY2x1c3RlciB8fCBkZWZhdWx0cy5jbHVzdGVyLFxuICAgICAgICBodHRwUGF0aDogb3B0cy5odHRwUGF0aCB8fCBkZWZhdWx0cy5odHRwUGF0aCxcbiAgICAgICAgaHR0cFBvcnQ6IG9wdHMuaHR0cFBvcnQgfHwgZGVmYXVsdHMuaHR0cFBvcnQsXG4gICAgICAgIGh0dHBzUG9ydDogb3B0cy5odHRwc1BvcnQgfHwgZGVmYXVsdHMuaHR0cHNQb3J0LFxuICAgICAgICBwb25nVGltZW91dDogb3B0cy5wb25nVGltZW91dCB8fCBkZWZhdWx0cy5wb25nVGltZW91dCxcbiAgICAgICAgc3RhdHNIb3N0OiBvcHRzLnN0YXRzSG9zdCB8fCBkZWZhdWx0cy5zdGF0c19ob3N0LFxuICAgICAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IG9wdHMudW5hdmFpbGFibGVUaW1lb3V0IHx8IGRlZmF1bHRzLnVuYXZhaWxhYmxlVGltZW91dCxcbiAgICAgICAgd3NQYXRoOiBvcHRzLndzUGF0aCB8fCBkZWZhdWx0cy53c1BhdGgsXG4gICAgICAgIHdzUG9ydDogb3B0cy53c1BvcnQgfHwgZGVmYXVsdHMud3NQb3J0LFxuICAgICAgICB3c3NQb3J0OiBvcHRzLndzc1BvcnQgfHwgZGVmYXVsdHMud3NzUG9ydCxcbiAgICAgICAgZW5hYmxlU3RhdHM6IGdldEVuYWJsZVN0YXRzQ29uZmlnKG9wdHMpLFxuICAgICAgICBodHRwSG9zdDogZ2V0SHR0cEhvc3Qob3B0cyksXG4gICAgICAgIHVzZVRMUzogc2hvdWxkVXNlVExTKG9wdHMpLFxuICAgICAgICB3c0hvc3Q6IGdldFdlYnNvY2tldEhvc3Qob3B0cylcbiAgICB9O1xuICAgIGlmICgnYXV0aCcgaW4gb3B0cylcbiAgICAgICAgY29uZmlnLmF1dGggPSBvcHRzLmF1dGg7XG4gICAgaWYgKCdhdXRob3JpemVyJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcuYXV0aG9yaXplciA9IG9wdHMuYXV0aG9yaXplcjtcbiAgICBpZiAoJ2Rpc2FibGVkVHJhbnNwb3J0cycgaW4gb3B0cylcbiAgICAgICAgY29uZmlnLmRpc2FibGVkVHJhbnNwb3J0cyA9IG9wdHMuZGlzYWJsZWRUcmFuc3BvcnRzO1xuICAgIGlmICgnZW5hYmxlZFRyYW5zcG9ydHMnIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy5lbmFibGVkVHJhbnNwb3J0cyA9IG9wdHMuZW5hYmxlZFRyYW5zcG9ydHM7XG4gICAgaWYgKCdpZ25vcmVOdWxsT3JpZ2luJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcuaWdub3JlTnVsbE9yaWdpbiA9IG9wdHMuaWdub3JlTnVsbE9yaWdpbjtcbiAgICBpZiAoJ3RpbWVsaW5lUGFyYW1zJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcudGltZWxpbmVQYXJhbXMgPSBvcHRzLnRpbWVsaW5lUGFyYW1zO1xuICAgIGlmICgnbmFjbCcgaW4gb3B0cykge1xuICAgICAgICBjb25maWcubmFjbCA9IG9wdHMubmFjbDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cbmZ1bmN0aW9uIGdldEh0dHBIb3N0KG9wdHMpIHtcbiAgICBpZiAob3B0cy5odHRwSG9zdCkge1xuICAgICAgICByZXR1cm4gb3B0cy5odHRwSG9zdDtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2x1c3Rlcikge1xuICAgICAgICByZXR1cm4gXCJzb2NranMtXCIgKyBvcHRzLmNsdXN0ZXIgKyBcIi5wdXNoZXIuY29tXCI7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cy5odHRwSG9zdDtcbn1cbmZ1bmN0aW9uIGdldFdlYnNvY2tldEhvc3Qob3B0cykge1xuICAgIGlmIChvcHRzLndzSG9zdCkge1xuICAgICAgICByZXR1cm4gb3B0cy53c0hvc3Q7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsdXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldFdlYnNvY2tldEhvc3RGcm9tQ2x1c3RlcihvcHRzLmNsdXN0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0V2Vic29ja2V0SG9zdEZyb21DbHVzdGVyKGRlZmF1bHRzLmNsdXN0ZXIpO1xufVxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0SG9zdEZyb21DbHVzdGVyKGNsdXN0ZXIpIHtcbiAgICByZXR1cm4gXCJ3cy1cIiArIGNsdXN0ZXIgKyBcIi5wdXNoZXIuY29tXCI7XG59XG5mdW5jdGlvbiBzaG91bGRVc2VUTFMob3B0cykge1xuICAgIGlmIChydW50aW1lLmdldFByb3RvY29sKCkgPT09ICdodHRwczonKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRzLmZvcmNlVExTID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0RW5hYmxlU3RhdHNDb25maWcob3B0cykge1xuICAgIGlmICgnZW5hYmxlU3RhdHMnIGluIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIG9wdHMuZW5hYmxlU3RhdHM7XG4gICAgfVxuICAgIGlmICgnZGlzYWJsZVN0YXRzJyBpbiBvcHRzKSB7XG4gICAgICAgIHJldHVybiAhb3B0cy5kaXNhYmxlU3RhdHM7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9wdXNoZXIudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwdXNoZXJfUHVzaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdXNoZXIoYXBwX2tleSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjaGVja0FwcEtleShhcHBfa2V5KTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy5jbHVzdGVyICYmICEob3B0aW9ucy53c0hvc3QgfHwgb3B0aW9ucy5odHRwSG9zdCkpIHtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSB1cmxfc3RvcmUuYnVpbGRMb2dTdWZmaXgoJ2phdmFzY3JpcHRRdWlja1N0YXJ0Jyk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIllvdSBzaG91bGQgYWx3YXlzIHNwZWNpZnkgYSBjbHVzdGVyIHdoZW4gY29ubmVjdGluZy4gXCIgKyBzdWZmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZGlzYWJsZVN0YXRzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignVGhlIGRpc2FibGVTdGF0cyBvcHRpb24gaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBlbmFibGVTdGF0cycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5ID0gYXBwX2tleTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBnZXRDb25maWcob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBmYWN0b3J5LmNyZWF0ZUNoYW5uZWxzKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIgPSBuZXcgZGlzcGF0Y2hlcigpO1xuICAgICAgICB0aGlzLnNlc3Npb25JRCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDApO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gbmV3IHRpbWVsaW5lX3RpbWVsaW5lKHRoaXMua2V5LCB0aGlzLnNlc3Npb25JRCwge1xuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5jb25maWcuY2x1c3RlcixcbiAgICAgICAgICAgIGZlYXR1cmVzOiBQdXNoZXIuZ2V0Q2xpZW50RmVhdHVyZXMoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy5jb25maWcudGltZWxpbmVQYXJhbXMgfHwge30sXG4gICAgICAgICAgICBsaW1pdDogNTAsXG4gICAgICAgICAgICBsZXZlbDogdGltZWxpbmVfbGV2ZWwuSU5GTyxcbiAgICAgICAgICAgIHZlcnNpb246IGRlZmF1bHRzLlZFUlNJT05cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTdGF0cykge1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlciA9IGZhY3RvcnkuY3JlYXRlVGltZWxpbmVTZW5kZXIodGhpcy50aW1lbGluZSwge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHRoaXMuY29uZmlnLnN0YXRzSG9zdCxcbiAgICAgICAgICAgICAgICBwYXRoOiAnL3RpbWVsaW5lL3YyLycgKyBydW50aW1lLlRpbWVsaW5lVHJhbnNwb3J0Lm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRTdHJhdGVneSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVudGltZS5nZXREZWZhdWx0U3RyYXRlZ3koX3RoaXMuY29uZmlnLCBvcHRpb25zLCBzdHJhdGVneV9idWlsZGVyX2RlZmluZVRyYW5zcG9ydCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGZhY3RvcnkuY3JlYXRlQ29ubmVjdGlvbk1hbmFnZXIodGhpcy5rZXksIHtcbiAgICAgICAgICAgIGdldFN0cmF0ZWd5OiBnZXRTdHJhdGVneSxcbiAgICAgICAgICAgIHRpbWVsaW5lOiB0aGlzLnRpbWVsaW5lLFxuICAgICAgICAgICAgYWN0aXZpdHlUaW1lb3V0OiB0aGlzLmNvbmZpZy5hY3Rpdml0eVRpbWVvdXQsXG4gICAgICAgICAgICBwb25nVGltZW91dDogdGhpcy5jb25maWcucG9uZ1RpbWVvdXQsXG4gICAgICAgICAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IHRoaXMuY29uZmlnLnVuYXZhaWxhYmxlVGltZW91dCxcbiAgICAgICAgICAgIHVzZVRMUzogQm9vbGVhbih0aGlzLmNvbmZpZy51c2VUTFMpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnY29ubmVjdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlQWxsKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMudGltZWxpbmVTZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50aW1lbGluZVNlbmRlci5zZW5kKF90aGlzLmNvbm5lY3Rpb24uaXNVc2luZ1RMUygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5iaW5kKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJuYWwgPSBldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IF90aGlzLmNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdsb2JhbF9lbWl0dGVyLmVtaXQoZXZlbnQuZXZlbnQsIGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Nvbm5lY3RpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jaGFubmVscy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnZGlzY29ubmVjdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFB1c2hlci5pbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHsgaW5zdGFuY2VzOiBQdXNoZXIuaW5zdGFuY2VzLmxlbmd0aCB9KTtcbiAgICAgICAgaWYgKFB1c2hlci5pc1JlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQdXNoZXIucmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFB1c2hlci5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBQdXNoZXIuaW5zdGFuY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgUHVzaGVyLmluc3RhbmNlc1tpXS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFB1c2hlci5nZXRDbGllbnRGZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGtleXMoZmlsdGVyT2JqZWN0KHsgd3M6IHJ1bnRpbWUuVHJhbnNwb3J0cy53cyB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuaXNTdXBwb3J0ZWQoe30pO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBQdXNoZXIucHJvdG90eXBlLmNoYW5uZWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVscy5maW5kKG5hbWUpO1xuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS5hbGxDaGFubmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHMuYWxsKCk7XG4gICAgfTtcbiAgICBQdXNoZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lU2VuZGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGltZWxpbmVTZW5kZXJUaW1lcikge1xuICAgICAgICAgICAgICAgIHZhciB1c2luZ1RMUyA9IHRoaXMuY29ubmVjdGlvbi5pc1VzaW5nVExTKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lU2VuZGVyID0gdGhpcy50aW1lbGluZVNlbmRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIgPSBuZXcgUGVyaW9kaWNUaW1lcig2MDAwMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZVNlbmRlci5zZW5kKHVzaW5nVExTKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlclRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlclRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGV2ZW50X25hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIuYmluZChldmVudF9uYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci51bmJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUuYmluZF9nbG9iYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci5iaW5kX2dsb2JhbChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS51bmJpbmRfZ2xvYmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIudW5iaW5kX2dsb2JhbChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS51bmJpbmRfYWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIudW5iaW5kX2FsbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUuc3Vic2NyaWJlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhbm5lbE5hbWU7XG4gICAgICAgIGZvciAoY2hhbm5lbE5hbWUgaW4gdGhpcy5jaGFubmVscy5jaGFubmVscykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHMuY2hhbm5lbHMuaGFzT3duUHJvcGVydHkoY2hhbm5lbE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoY2hhbm5lbE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQdXNoZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjaGFubmVsX25hbWUpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmFkZChjaGFubmVsX25hbWUsIHRoaXMpO1xuICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjaGFubmVsLnJlaW5zdGF0ZVN1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfTtcbiAgICBQdXNoZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNoYW5uZWxfbmFtZSkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChjaGFubmVsX25hbWUpO1xuICAgICAgICBpZiAoY2hhbm5lbCAmJiBjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuY2FuY2VsU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVscy5yZW1vdmUoY2hhbm5lbF9uYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsICYmIGNoYW5uZWwuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS5zZW5kX2V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50X25hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kX2V2ZW50KGV2ZW50X25hbWUsIGRhdGEsIGNoYW5uZWwpO1xuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS5zaG91bGRVc2VUTFMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy51c2VUTFM7XG4gICAgfTtcbiAgICBQdXNoZXIuaW5zdGFuY2VzID0gW107XG4gICAgUHVzaGVyLmlzUmVhZHkgPSBmYWxzZTtcbiAgICBQdXNoZXIubG9nVG9Db25zb2xlID0gZmFsc2U7XG4gICAgUHVzaGVyLlJ1bnRpbWUgPSBydW50aW1lO1xuICAgIFB1c2hlci5TY3JpcHRSZWNlaXZlcnMgPSBydW50aW1lLlNjcmlwdFJlY2VpdmVycztcbiAgICBQdXNoZXIuRGVwZW5kZW5jaWVzUmVjZWl2ZXJzID0gcnVudGltZS5EZXBlbmRlbmNpZXNSZWNlaXZlcnM7XG4gICAgUHVzaGVyLmF1dGhfY2FsbGJhY2tzID0gcnVudGltZS5hdXRoX2NhbGxiYWNrcztcbiAgICByZXR1cm4gUHVzaGVyO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvcmVfcHVzaGVyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAocHVzaGVyX1B1c2hlcik7XG5mdW5jdGlvbiBjaGVja0FwcEtleShrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93ICdZb3UgbXVzdCBwYXNzIHlvdXIgYXBwIGtleSB3aGVuIHlvdSBpbnN0YW50aWF0ZSBQdXNoZXIuJztcbiAgICB9XG59XG5ydW50aW1lLnNldHVwKHB1c2hlcl9QdXNoZXIpO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pusher-js/dist/web/pusher.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUEwQixvQkFBb0IsQ0FBRTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzPzk2Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCBpbiBtb2Rlcm4gZW5naW5lc1xuICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/hls.js/dist/hls.mjs":
/*!******************************************!*\
  !*** ./node_modules/hls.js/dist/hls.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hls)\n/* harmony export */ });\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar urlToolkit = {exports: {}};\n\n(function (module, exports) {\n\t// see https://tools.ietf.org/html/rfc1808\n\n\t(function (root) {\n\t  var URL_REGEX =\n\t    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n\t  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n\t  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n\t  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n\t  var URLToolkit = {\n\t    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n\t    // E.g\n\t    // With opts.alwaysNormalize = false (default, spec compliant)\n\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n\t    // With opts.alwaysNormalize = true (not spec compliant)\n\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n\t    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n\t      opts = opts || {};\n\t      // remove any remaining space and CRLF\n\t      baseURL = baseURL.trim();\n\t      relativeURL = relativeURL.trim();\n\t      if (!relativeURL) {\n\t        // 2a) If the embedded URL is entirely empty, it inherits the\n\t        // entire base URL (i.e., is set equal to the base URL)\n\t        // and we are done.\n\t        if (!opts.alwaysNormalize) {\n\t          return baseURL;\n\t        }\n\t        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n\t        if (!basePartsForNormalise) {\n\t          throw new Error('Error trying to parse base URL.');\n\t        }\n\t        basePartsForNormalise.path = URLToolkit.normalizePath(\n\t          basePartsForNormalise.path\n\t        );\n\t        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n\t      }\n\t      var relativeParts = URLToolkit.parseURL(relativeURL);\n\t      if (!relativeParts) {\n\t        throw new Error('Error trying to parse relative URL.');\n\t      }\n\t      if (relativeParts.scheme) {\n\t        // 2b) If the embedded URL starts with a scheme name, it is\n\t        // interpreted as an absolute URL and we are done.\n\t        if (!opts.alwaysNormalize) {\n\t          return relativeURL;\n\t        }\n\t        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n\t        return URLToolkit.buildURLFromParts(relativeParts);\n\t      }\n\t      var baseParts = URLToolkit.parseURL(baseURL);\n\t      if (!baseParts) {\n\t        throw new Error('Error trying to parse base URL.');\n\t      }\n\t      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n\t        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n\t        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n\t        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n\t        baseParts.netLoc = pathParts[1];\n\t        baseParts.path = pathParts[2];\n\t      }\n\t      if (baseParts.netLoc && !baseParts.path) {\n\t        baseParts.path = '/';\n\t      }\n\t      var builtParts = {\n\t        // 2c) Otherwise, the embedded URL inherits the scheme of\n\t        // the base URL.\n\t        scheme: baseParts.scheme,\n\t        netLoc: relativeParts.netLoc,\n\t        path: null,\n\t        params: relativeParts.params,\n\t        query: relativeParts.query,\n\t        fragment: relativeParts.fragment,\n\t      };\n\t      if (!relativeParts.netLoc) {\n\t        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n\t        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n\t        // (if any) of the base URL.\n\t        builtParts.netLoc = baseParts.netLoc;\n\t        // 4) If the embedded URL path is preceded by a slash \"/\", the\n\t        // path is not relative and we skip to Step 7.\n\t        if (relativeParts.path[0] !== '/') {\n\t          if (!relativeParts.path) {\n\t            // 5) If the embedded URL path is empty (and not preceded by a\n\t            // slash), then the embedded URL inherits the base URL path\n\t            builtParts.path = baseParts.path;\n\t            // 5a) if the embedded URL's <params> is non-empty, we skip to\n\t            // step 7; otherwise, it inherits the <params> of the base\n\t            // URL (if any) and\n\t            if (!relativeParts.params) {\n\t              builtParts.params = baseParts.params;\n\t              // 5b) if the embedded URL's <query> is non-empty, we skip to\n\t              // step 7; otherwise, it inherits the <query> of the base\n\t              // URL (if any) and we skip to step 7.\n\t              if (!relativeParts.query) {\n\t                builtParts.query = baseParts.query;\n\t              }\n\t            }\n\t          } else {\n\t            // 6) The last segment of the base URL's path (anything\n\t            // following the rightmost slash \"/\", or the entire path if no\n\t            // slash is present) is removed and the embedded URL's path is\n\t            // appended in its place.\n\t            var baseURLPath = baseParts.path;\n\t            var newPath =\n\t              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n\t              relativeParts.path;\n\t            builtParts.path = URLToolkit.normalizePath(newPath);\n\t          }\n\t        }\n\t      }\n\t      if (builtParts.path === null) {\n\t        builtParts.path = opts.alwaysNormalize\n\t          ? URLToolkit.normalizePath(relativeParts.path)\n\t          : relativeParts.path;\n\t      }\n\t      return URLToolkit.buildURLFromParts(builtParts);\n\t    },\n\t    parseURL: function (url) {\n\t      var parts = URL_REGEX.exec(url);\n\t      if (!parts) {\n\t        return null;\n\t      }\n\t      return {\n\t        scheme: parts[1] || '',\n\t        netLoc: parts[2] || '',\n\t        path: parts[3] || '',\n\t        params: parts[4] || '',\n\t        query: parts[5] || '',\n\t        fragment: parts[6] || '',\n\t      };\n\t    },\n\t    normalizePath: function (path) {\n\t      // The following operations are\n\t      // then applied, in order, to the new path:\n\t      // 6a) All occurrences of \"./\", where \".\" is a complete path\n\t      // segment, are removed.\n\t      // 6b) If the path ends with \".\" as a complete path segment,\n\t      // that \".\" is removed.\n\t      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n\t      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n\t      // complete path segment not equal to \"..\", are removed.\n\t      // Removal of these path segments is performed iteratively,\n\t      // removing the leftmost matching pattern on each iteration,\n\t      // until no matching pattern remains.\n\t      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n\t      // complete path segment not equal to \"..\", that\n\t      // \"<segment>/..\" is removed.\n\t      while (\n\t        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n\t      ) {}\n\t      return path.split('').reverse().join('');\n\t    },\n\t    buildURLFromParts: function (parts) {\n\t      return (\n\t        parts.scheme +\n\t        parts.netLoc +\n\t        parts.path +\n\t        parts.params +\n\t        parts.query +\n\t        parts.fragment\n\t      );\n\t    },\n\t  };\n\n\t  module.exports = URLToolkit;\n\t})(); \n} (urlToolkit));\n\nvar urlToolkitExports = urlToolkit.exports;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nconst isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\nlet Events = /*#__PURE__*/function (Events) {\n  Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n  Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n  Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n  Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n  Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n  Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n  Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n  Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n  Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n  Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n  Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n  Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n  Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n  Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n  Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n  Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n  Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n  Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n  Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n  Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n  Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n  Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n  Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n  Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n  Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n  Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n  Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n  Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n  Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n  Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n  Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n  Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n  Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n  Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n  Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n  Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n  Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n  Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n  Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n  Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n  Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n  Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n  Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n  Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n  Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n  Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n  Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n  Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n  Events[\"ERROR\"] = \"hlsError\";\n  Events[\"DESTROYING\"] = \"hlsDestroying\";\n  Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n  Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n  Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n  Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n  return Events;\n}({});\n\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */\n\nlet ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n  ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n  ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n  ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n  ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n  ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n  return ErrorTypes;\n}({});\nlet ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n  ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n  ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n  ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n  ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n  ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n  ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n  ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n  ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n  ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n  ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n  ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n  ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n  ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n  ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n  ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n  ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n  ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n  ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n  ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n  ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n  ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n  ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n  ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n  ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n  ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n  ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n  ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n  ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n  ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n  ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n  ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n  ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n  ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n  ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n  ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n  return ErrorDetails;\n}({});\n\nconst noop = function noop() {};\nconst fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\nlet exportedLogger = fakeLogger;\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type) {\n  const func = self.console[type];\n  if (func) {\n    return func.bind(self.console, `[${type}] >`);\n  }\n  return noop;\n}\nfunction exportLoggerFunctions(debugConfig, ...functions) {\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\nfunction enableLogs(debugConfig, id) {\n  // check that console is available\n  if (self.console && debugConfig === true || typeof debugConfig === 'object') {\n    exportLoggerFunctions(debugConfig,\n    // Remove out from list here to hard-disable a log-level\n    // 'trace',\n    'debug', 'log', 'info', 'warn', 'error');\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      exportedLogger.log(`Debug logs enabled for \"${id}\" in hls.js version ${\"1.4.12\"}`);\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n}\nconst logger = exportedLogger;\n\nconst DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nconst ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nclass AttrList {\n  constructor(attrs) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n    for (const attr in attrs) {\n      if (attrs.hasOwnProperty(attr)) {\n        if (attr.substring(0, 2) === 'X-') {\n          this.clientAttrs = this.clientAttrs || [];\n          this.clientAttrs.push(attr);\n        }\n        this[attr] = attrs[attr];\n      }\n    }\n  }\n  decimalInteger(attrName) {\n    const intValue = parseInt(this[attrName], 10);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  hexadecimalInteger(attrName) {\n    if (this[attrName]) {\n      let stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n      const value = new Uint8Array(stringValue.length / 2);\n      for (let i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n      return value;\n    } else {\n      return null;\n    }\n  }\n  hexadecimalIntegerAsNumber(attrName) {\n    const intValue = parseInt(this[attrName], 16);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  decimalFloatingPoint(attrName) {\n    return parseFloat(this[attrName]);\n  }\n  optionalFloat(attrName, defaultValue) {\n    const value = this[attrName];\n    return value ? parseFloat(value) : defaultValue;\n  }\n  enumeratedString(attrName) {\n    return this[attrName];\n  }\n  bool(attrName) {\n    return this[attrName] === 'YES';\n  }\n  decimalResolution(attrName) {\n    const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n    if (res === null) {\n      return undefined;\n    }\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  }\n  static parseAttrList(input) {\n    let match;\n    const attrs = {};\n    const quote = '\"';\n    ATTR_LIST_REGEX.lastIndex = 0;\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      let value = match[2];\n      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n        value = value.slice(1, -1);\n      }\n      const name = match[1].trim();\n      attrs[name] = value;\n    }\n    return attrs;\n  }\n}\n\n// Avoid exporting const enum so that these values can be inlined\n\nfunction isDateRangeCueAttribute(attrName) {\n  return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n}\nfunction isSCTE35Attribute(attrName) {\n  return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\";\n}\nclass DateRange {\n  constructor(dateRangeAttr, dateRangeWithSameId) {\n    this.attr = void 0;\n    this._startDate = void 0;\n    this._endDate = void 0;\n    this._badValueForSameId = void 0;\n    if (dateRangeWithSameId) {\n      const previousAttr = dateRangeWithSameId.attr;\n      for (const key in previousAttr) {\n        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n          logger.warn(`DATERANGE tag attribute: \"${key}\" does not match for tags with ID: \"${dateRangeAttr.ID}\"`);\n          this._badValueForSameId = key;\n          break;\n        }\n      }\n      // Merge DateRange tags with the same ID\n      dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n    }\n    this.attr = dateRangeAttr;\n    this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n    if (\"END-DATE\" in this.attr) {\n      const endDate = new Date(this.attr[\"END-DATE\"]);\n      if (isFiniteNumber(endDate.getTime())) {\n        this._endDate = endDate;\n      }\n    }\n  }\n  get id() {\n    return this.attr.ID;\n  }\n  get class() {\n    return this.attr.CLASS;\n  }\n  get startDate() {\n    return this._startDate;\n  }\n  get endDate() {\n    if (this._endDate) {\n      return this._endDate;\n    }\n    const duration = this.duration;\n    if (duration !== null) {\n      return new Date(this._startDate.getTime() + duration * 1000);\n    }\n    return null;\n  }\n  get duration() {\n    if (\"DURATION\" in this.attr) {\n      const duration = this.attr.decimalFloatingPoint(\"DURATION\");\n      if (isFiniteNumber(duration)) {\n        return duration;\n      }\n    } else if (this._endDate) {\n      return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n    }\n    return null;\n  }\n  get plannedDuration() {\n    if (\"PLANNED-DURATION\" in this.attr) {\n      return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n    }\n    return null;\n  }\n  get endOnNext() {\n    return this.attr.bool(\"END-ON-NEXT\");\n  }\n  get isValid() {\n    return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n  }\n}\n\nclass LoadStats {\n  constructor() {\n    this.aborted = false;\n    this.loaded = 0;\n    this.retry = 0;\n    this.total = 0;\n    this.chunkCount = 0;\n    this.bwEstimate = 0;\n    this.loading = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n    this.parsing = {\n      start: 0,\n      end: 0\n    };\n    this.buffering = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n  }\n}\n\nvar ElementaryStreamTypes = {\n  AUDIO: \"audio\",\n  VIDEO: \"video\",\n  AUDIOVIDEO: \"audiovideo\"\n};\nclass BaseSegment {\n  // baseurl is the URL to the playlist\n\n  // relurl is the portion of the URL that comes from inside the playlist.\n\n  // Holds the types of data this fragment supports\n\n  constructor(baseurl) {\n    this._byteRange = null;\n    this._url = null;\n    this.baseurl = void 0;\n    this.relurl = void 0;\n    this.elementaryStreams = {\n      [ElementaryStreamTypes.AUDIO]: null,\n      [ElementaryStreamTypes.VIDEO]: null,\n      [ElementaryStreamTypes.AUDIOVIDEO]: null\n    };\n    this.baseurl = baseurl;\n  }\n\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n  setByteRange(value, previous) {\n    const params = value.split('@', 2);\n    const byteRange = [];\n    if (params.length === 1) {\n      byteRange[0] = previous ? previous.byteRangeEndOffset : 0;\n    } else {\n      byteRange[0] = parseInt(params[1]);\n    }\n    byteRange[1] = parseInt(params[0]) + byteRange[0];\n    this._byteRange = byteRange;\n  }\n  get byteRange() {\n    if (!this._byteRange) {\n      return [];\n    }\n    return this._byteRange;\n  }\n  get byteRangeStartOffset() {\n    return this.byteRange[0];\n  }\n  get byteRangeEndOffset() {\n    return this.byteRange[1];\n  }\n  get url() {\n    if (!this._url && this.baseurl && this.relurl) {\n      this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n        alwaysNormalize: true\n      });\n    }\n    return this._url || '';\n  }\n  set url(value) {\n    this._url = value;\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n */\nclass Fragment extends BaseSegment {\n  // EXTINF has to be present for a m3u8 to be considered valid\n\n  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n\n  // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n  // core difference from the private field _decryptdata is the lack of the initialized IV\n  // _decryptdata will set the IV for this segment based on the segment number in the fragment\n  // A string representing the fragment type\n  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n  // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n  // The level/track index to which the fragment belongs\n  // The continuity counter of the fragment\n  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n  // Set by `updateFragPTSDTS` in level-helper\n  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  // Load/parse timing information\n  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n  // #EXTINF  segment title\n  // The Media Initialization Section for this segment\n  // Fragment is the last fragment in the media playlist\n  // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n  constructor(type, baseurl) {\n    super(baseurl);\n    this._decryptdata = null;\n    this.rawProgramDateTime = null;\n    this.programDateTime = null;\n    this.tagList = [];\n    this.duration = 0;\n    this.sn = 0;\n    this.levelkeys = void 0;\n    this.type = void 0;\n    this.loader = null;\n    this.keyLoader = null;\n    this.level = -1;\n    this.cc = 0;\n    this.startPTS = void 0;\n    this.endPTS = void 0;\n    this.startDTS = void 0;\n    this.endDTS = void 0;\n    this.start = 0;\n    this.deltaPTS = void 0;\n    this.maxStartPTS = void 0;\n    this.minEndPTS = void 0;\n    this.stats = new LoadStats();\n    this.urlId = 0;\n    this.data = void 0;\n    this.bitrateTest = false;\n    this.title = null;\n    this.initSegment = null;\n    this.endList = void 0;\n    this.gap = void 0;\n    this.type = type;\n  }\n  get decryptdata() {\n    const {\n      levelkeys\n    } = this;\n    if (!levelkeys && !this._decryptdata) {\n      return null;\n    }\n    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n      const key = this.levelkeys.identity;\n      if (key) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      } else {\n        const keyFormats = Object.keys(this.levelkeys);\n        if (keyFormats.length === 1) {\n          return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n        }\n      }\n    }\n    return this._decryptdata;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get endProgramDateTime() {\n    if (this.programDateTime === null) {\n      return null;\n    }\n    if (!isFiniteNumber(this.programDateTime)) {\n      return null;\n    }\n    const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n    return this.programDateTime + duration * 1000;\n  }\n  get encrypted() {\n    var _this$_decryptdata;\n    // At the m3u8-parser level we need to add support for manifest signalled keyformats\n    // when we want the fragment to start reporting that it is encrypted.\n    // Currently, keyFormat will only be set for identity keys\n    if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n      return true;\n    } else if (this.levelkeys) {\n      const keyFormats = Object.keys(this.levelkeys);\n      const len = keyFormats.length;\n      if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n        return true;\n      }\n    }\n    return false;\n  }\n  setKeyFormat(keyFormat) {\n    if (this.levelkeys) {\n      const key = this.levelkeys[keyFormat];\n      if (key && !this._decryptdata) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      }\n    }\n  }\n  abortRequests() {\n    var _this$loader, _this$keyLoader;\n    (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n    (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n  }\n  setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {\n    const {\n      elementaryStreams\n    } = this;\n    const info = elementaryStreams[type];\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS,\n        partial\n      };\n      return;\n    }\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  }\n  clearElementaryStreamInfo() {\n    const {\n      elementaryStreams\n    } = this;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n */\nclass Part extends BaseSegment {\n  constructor(partAttrs, frag, baseurl, index, previous) {\n    super(baseurl);\n    this.fragOffset = 0;\n    this.duration = 0;\n    this.gap = false;\n    this.independent = false;\n    this.relurl = void 0;\n    this.fragment = void 0;\n    this.index = void 0;\n    this.stats = new LoadStats();\n    this.duration = partAttrs.decimalFloatingPoint('DURATION');\n    this.gap = partAttrs.bool('GAP');\n    this.independent = partAttrs.bool('INDEPENDENT');\n    this.relurl = partAttrs.enumeratedString('URI');\n    this.fragment = frag;\n    this.index = index;\n    const byteRange = partAttrs.enumeratedString('BYTERANGE');\n    if (byteRange) {\n      this.setByteRange(byteRange, previous);\n    }\n    if (previous) {\n      this.fragOffset = previous.fragOffset + previous.duration;\n    }\n  }\n  get start() {\n    return this.fragment.start + this.fragOffset;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get loaded() {\n    const {\n      elementaryStreams\n    } = this;\n    return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n  }\n}\n\nconst DEFAULT_TARGET_DURATION = 10;\n\n/**\n * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n */\nclass LevelDetails {\n  // Manifest reload synchronization\n\n  constructor(baseUrl) {\n    this.PTSKnown = false;\n    this.alignedSliding = false;\n    this.averagetargetduration = void 0;\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = void 0;\n    this.fragmentHint = void 0;\n    this.partList = null;\n    this.dateRanges = void 0;\n    this.live = true;\n    this.ageHeader = 0;\n    this.advancedDateTime = void 0;\n    this.updated = true;\n    this.advanced = true;\n    this.availabilityDelay = void 0;\n    this.misses = 0;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = void 0;\n    this.m3u8 = '';\n    this.version = null;\n    this.canBlockReload = false;\n    this.canSkipUntil = 0;\n    this.canSkipDateRanges = false;\n    this.skippedSegments = 0;\n    this.recentlyRemovedDateranges = void 0;\n    this.partHoldBack = 0;\n    this.holdBack = 0;\n    this.partTarget = 0;\n    this.preloadHint = void 0;\n    this.renditionReports = void 0;\n    this.tuneInGoal = 0;\n    this.deltaUpdateFailed = void 0;\n    this.driftStartTime = 0;\n    this.driftEndTime = 0;\n    this.driftStart = 0;\n    this.driftEnd = 0;\n    this.encryptedFragments = void 0;\n    this.playlistParsingError = null;\n    this.variableList = null;\n    this.hasVariableRefs = false;\n    this.fragments = [];\n    this.encryptedFragments = [];\n    this.dateRanges = {};\n    this.url = baseUrl;\n  }\n  reloaded(previous) {\n    if (!previous) {\n      this.advanced = true;\n      this.updated = true;\n      return;\n    }\n    const partSnDiff = this.lastPartSn - previous.lastPartSn;\n    const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;\n    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n    if (this.updated || this.advanced) {\n      this.misses = Math.floor(previous.misses * 0.6);\n    } else {\n      this.misses = previous.misses + 1;\n    }\n    this.availabilityDelay = previous.availabilityDelay;\n  }\n  get hasProgramDateTime() {\n    if (this.fragments.length) {\n      return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n    }\n    return false;\n  }\n  get levelTargetDuration() {\n    return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n  }\n  get drift() {\n    const runTime = this.driftEndTime - this.driftStartTime;\n    if (runTime > 0) {\n      const runDuration = this.driftEnd - this.driftStart;\n      return runDuration * 1000 / runTime;\n    }\n    return 1;\n  }\n  get edge() {\n    return this.partEnd || this.fragmentEnd;\n  }\n  get partEnd() {\n    var _this$partList;\n    if ((_this$partList = this.partList) != null && _this$partList.length) {\n      return this.partList[this.partList.length - 1].end;\n    }\n    return this.fragmentEnd;\n  }\n  get fragmentEnd() {\n    var _this$fragments;\n    if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n      return this.fragments[this.fragments.length - 1].end;\n    }\n    return 0;\n  }\n  get age() {\n    if (this.advancedDateTime) {\n      return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n    }\n    return 0;\n  }\n  get lastPartIndex() {\n    var _this$partList2;\n    if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n      return this.partList[this.partList.length - 1].index;\n    }\n    return -1;\n  }\n  get lastPartSn() {\n    var _this$partList3;\n    if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n      return this.partList[this.partList.length - 1].fragment.sn;\n    }\n    return this.endSN;\n  }\n}\n\nfunction base64Decode(base64encodedStr) {\n  return Uint8Array.from(atob(base64encodedStr), c => c.charCodeAt(0));\n}\n\nfunction getKeyIdBytes(str) {\n  const keyIdbytes = strToUtf8array(str).subarray(0, 16);\n  const paddedkeyIdbytes = new Uint8Array(16);\n  paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n  return paddedkeyIdbytes;\n}\nfunction changeEndianness(keyId) {\n  const swap = function swap(array, from, to) {\n    const cur = array[from];\n    array[from] = array[to];\n    array[to] = cur;\n  };\n  swap(keyId, 0, 3);\n  swap(keyId, 1, 2);\n  swap(keyId, 4, 5);\n  swap(keyId, 6, 7);\n}\nfunction convertDataUriToArrayBytes(uri) {\n  // data:[<media type][;attribute=value][;base64],<data>\n  const colonsplit = uri.split(':');\n  let keydata = null;\n  if (colonsplit[0] === 'data' && colonsplit.length === 2) {\n    const semicolonsplit = colonsplit[1].split(';');\n    const commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');\n    if (commasplit.length === 2) {\n      const isbase64 = commasplit[0] === 'base64';\n      const data = commasplit[1];\n      if (isbase64) {\n        semicolonsplit.splice(-1, 1); // remove from processing\n        keydata = base64Decode(data);\n      } else {\n        keydata = getKeyIdBytes(data);\n      }\n    }\n  }\n  return keydata;\n}\nfunction strToUtf8array(str) {\n  return Uint8Array.from(unescape(encodeURIComponent(str)), c => c.charCodeAt(0));\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */\nvar KeySystems = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.fps\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"com.widevine.alpha\"\n};\n\n// Playlist #EXT-X-KEY KEYFORMAT values\nvar KeySystemFormats = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.streamingkeydelivery\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n};\nfunction keySystemFormatToKeySystemDomain(format) {\n  switch (format) {\n    case KeySystemFormats.FAIRPLAY:\n      return KeySystems.FAIRPLAY;\n    case KeySystemFormats.PLAYREADY:\n      return KeySystems.PLAYREADY;\n    case KeySystemFormats.WIDEVINE:\n      return KeySystems.WIDEVINE;\n    case KeySystemFormats.CLEARKEY:\n      return KeySystems.CLEARKEY;\n  }\n}\n\n// System IDs for which we can extract a key ID from \"encrypted\" event PSSH\nvar KeySystemIds = {\n  WIDEVINE: \"edef8ba979d64acea3c827dcd51d21ed\"\n};\nfunction keySystemIdToKeySystemDomain(systemId) {\n  if (systemId === KeySystemIds.WIDEVINE) {\n    return KeySystems.WIDEVINE;\n    // } else if (systemId === KeySystemIds.PLAYREADY) {\n    //   return KeySystems.PLAYREADY;\n    // } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {\n    //   return KeySystems.CLEARKEY;\n  }\n}\n\nfunction keySystemDomainToKeySystemFormat(keySystem) {\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      return KeySystemFormats.FAIRPLAY;\n    case KeySystems.PLAYREADY:\n      return KeySystemFormats.PLAYREADY;\n    case KeySystems.WIDEVINE:\n      return KeySystemFormats.WIDEVINE;\n    case KeySystems.CLEARKEY:\n      return KeySystemFormats.CLEARKEY;\n  }\n}\nfunction getKeySystemsForConfig(config) {\n  const {\n    drmSystems,\n    widevineLicenseUrl\n  } = config;\n  const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(keySystem => !!drmSystems[keySystem]) : [];\n  if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n    keySystemsToAttempt.push(KeySystems.WIDEVINE);\n  }\n  return keySystemsToAttempt;\n}\nconst requestMediaKeySystemAccess = function () {\n  if (typeof self !== 'undefined' && self.navigator && self.navigator.requestMediaKeySystemAccess) {\n    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n  } else {\n    return null;\n  }\n}();\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n */\nfunction getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n  let initDataTypes;\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      initDataTypes = ['cenc', 'sinf'];\n      break;\n    case KeySystems.WIDEVINE:\n    case KeySystems.PLAYREADY:\n      initDataTypes = ['cenc'];\n      break;\n    case KeySystems.CLEARKEY:\n      initDataTypes = ['cenc', 'keyids'];\n      break;\n    default:\n      throw new Error(`Unknown key-system: ${keySystem}`);\n  }\n  return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n}\nfunction createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n  const baseConfig = {\n    initDataTypes: initDataTypes,\n    persistentState: drmSystemOptions.persistentState || 'not-allowed',\n    distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'not-allowed',\n    sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],\n    audioCapabilities: audioCodecs.map(codec => ({\n      contentType: `audio/mp4; codecs=\"${codec}\"`,\n      robustness: drmSystemOptions.audioRobustness || '',\n      encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n    })),\n    videoCapabilities: videoCodecs.map(codec => ({\n      contentType: `video/mp4; codecs=\"${codec}\"`,\n      robustness: drmSystemOptions.videoRobustness || '',\n      encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n    }))\n  };\n  return [baseConfig];\n}\n\nfunction sliceUint8(array, start, end) {\n  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n\n// breaking up those two types in order to clarify what is happening in the decoding path.\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nconst isHeader$2 = (data, offset) => {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nconst isFooter = (data, offset) => {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n * @returns the block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */\nconst getID3Data = (data, offset) => {\n  const front = offset;\n  let length = 0;\n  while (isHeader$2(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n    const size = readSize(data, offset + 6);\n    length += size;\n    if (isFooter(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n    offset += length;\n  }\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n  return undefined;\n};\nconst readSize = (data, offset) => {\n  let size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n};\nconst canParse$2 = (data, offset) => {\n  return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n};\n\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param data - Block of data containing one or more ID3 tags\n */\nconst getTimeStamp = data => {\n  const frames = getID3Frames(data);\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n    if (isTimeStampFrame(frame)) {\n      return readTimeStamp(frame);\n    }\n  }\n  return undefined;\n};\n\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n */\nconst isTimeStampFrame = frame => {\n  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n};\nconst getFrameData = data => {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  const size = readSize(data, 4);\n\n  // skip frame id, size, and flags\n  const offset = 10;\n  return {\n    type,\n    size,\n    data: data.subarray(offset, offset + size)\n  };\n};\n\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param id3Data - The ID3 data containing one or more ID3 tags\n */\nconst getID3Frames = id3Data => {\n  let offset = 0;\n  const frames = [];\n  while (isHeader$2(id3Data, offset)) {\n    const size = readSize(id3Data, offset + 6);\n    // skip past ID3 header\n    offset += 10;\n    const end = offset + size;\n    // loop through frames in the ID3 tag\n    while (offset + 8 < end) {\n      const frameData = getFrameData(id3Data.subarray(offset));\n      const frame = decodeFrame(frameData);\n      if (frame) {\n        frames.push(frame);\n      }\n\n      // skip frame header and frame data\n      offset += frameData.size + 10;\n    }\n    if (isFooter(id3Data, offset)) {\n      offset += 10;\n    }\n  }\n  return frames;\n};\nconst decodeFrame = frame => {\n  if (frame.type === 'PRIV') {\n    return decodePrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeURLFrame(frame);\n  }\n  return decodeTextFrame(frame);\n};\nconst decodePrivFrame = frame => {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n  const owner = utf8ArrayToStr(frame.data, true);\n  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n  return {\n    key: frame.type,\n    info: owner,\n    data: privateData.buffer\n  };\n};\nconst decodeTextFrame = frame => {\n  if (frame.size < 2) {\n    return undefined;\n  }\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n  const text = utf8ArrayToStr(frame.data.subarray(1));\n  return {\n    key: frame.type,\n    data: text\n  };\n};\nconst decodeURLFrame = frame => {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n  const url = utf8ArrayToStr(frame.data);\n  return {\n    key: frame.type,\n    data: url\n  };\n};\nconst readTimeStamp = timeStampFrame => {\n  if (timeStampFrame.data.byteLength === 8) {\n    const data = new Uint8Array(timeStampFrame.data);\n    // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n    const pts33Bit = data[3] & 0x1;\n    let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n\n    return Math.round(timestamp);\n  }\n  return undefined;\n};\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\nconst utf8ArrayToStr = (array, exitOnNull = false) => {\n  const decoder = getTextDecoder();\n  if (decoder) {\n    const decoded = decoder.decode(array);\n    if (exitOnNull) {\n      // grab up to the first null\n      const idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    }\n\n    // remove any null characters\n    return decoded.replace(/\\0/g, '');\n  }\n  const len = array.length;\n  let c;\n  let char2;\n  let char3;\n  let out = '';\n  let i = 0;\n  while (i < len) {\n    c = array[i++];\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n        break;\n    }\n  }\n  return out;\n};\nlet decoder;\nfunction getTextDecoder() {\n  if (!decoder && typeof self.TextDecoder !== 'undefined') {\n    decoder = new self.TextDecoder('utf-8');\n  }\n  return decoder;\n}\n\n/**\n *  hex dump helper class\n */\n\nconst Hex = {\n  hexDump: function (array) {\n    let str = '';\n    for (let i = 0; i < array.length; i++) {\n      let h = array[i].toString(16);\n      if (h.length < 2) {\n        h = '0' + h;\n      }\n      str += h;\n    }\n    return str;\n  }\n};\n\nconst UINT32_MAX$1 = Math.pow(2, 32) - 1;\nconst push = [].push;\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nconst RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\nfunction bin2str(data) {\n  return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n  const val = buffer[offset] << 8 | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n  const val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\nfunction readSint32(buffer, offset) {\n  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction writeUint32(buffer, offset, value) {\n  buffer[offset] = value >> 24;\n  buffer[offset + 1] = value >> 16 & 0xff;\n  buffer[offset + 2] = value >> 8 & 0xff;\n  buffer[offset + 3] = value & 0xff;\n}\n\n// Find the data for a box specified by its path\nfunction findBox(data, path) {\n  const results = [];\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    const type = bin2str(data.subarray(i + 4, i + 8));\n    const endbox = size > 1 ? i + size : end;\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n    i = endbox;\n  }\n\n  // we've finished searching all of data\n  return results;\n}\nfunction parseSegmentIndex(sidx) {\n  const references = [];\n  const version = sidx[0];\n\n  // set initial offset, we skip the reference ID (not needed)\n  let index = 8;\n  const timescale = readUint32(sidx, index);\n  index += 4;\n\n  // TODO: parse earliestPresentationTime and firstOffset\n  // usually zero in our case\n  const earliestPresentationTime = 0;\n  const firstOffset = 0;\n  if (version === 0) {\n    index += 8;\n  } else {\n    index += 16;\n  }\n\n  // skip reserved\n  index += 2;\n  let startByte = sidx.length + firstOffset;\n  const referencesCount = readUint16(sidx, index);\n  index += 2;\n  for (let i = 0; i < referencesCount; i++) {\n    let referenceIndex = index;\n    const referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    const referenceSize = referenceInfo & 0x7fffffff;\n    const referenceType = (referenceInfo & 0x80000000) >>> 31;\n    if (referenceType === 1) {\n      logger.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n    const subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    references.push({\n      referenceSize,\n      subsegmentDuration,\n      // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1\n      }\n    });\n    startByte += referenceSize;\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    referenceIndex += 4;\n\n    // skip to next ref\n    index = referenceIndex;\n  }\n  return {\n    earliestPresentationTime,\n    timescale,\n    version,\n    referencesCount,\n    references\n  };\n}\n\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nfunction parseInitSegment(initSegment) {\n  const result = [];\n  const traks = findBox(initSegment, ['moov', 'trak']);\n  for (let i = 0; i < traks.length; i++) {\n    const trak = traks[i];\n    const tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd) {\n      let version = tkhd[0];\n      let index = version === 0 ? 12 : 20;\n      const trackId = readUint32(tkhd, index);\n      const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n      if (mdhd) {\n        version = mdhd[0];\n        index = version === 0 ? 12 : 20;\n        const timescale = readUint32(mdhd, index);\n        const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n        if (hdlr) {\n          const hdlrType = bin2str(hdlr.subarray(8, 12));\n          const type = {\n            soun: ElementaryStreamTypes.AUDIO,\n            vide: ElementaryStreamTypes.VIDEO\n          }[hdlrType];\n          if (type) {\n            // Parse codec details\n            const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n            let codec;\n            if (stsd) {\n              codec = bin2str(stsd.subarray(12, 16));\n              // TODO: Parse codec details to be able to build MIME type.\n              // stsd.start += 8;\n              // const codecBox = findBox(stsd, [codec])[0];\n              // if (codecBox) {\n              //   TODO: Codec parsing support for avc1, mp4a, hevc, av01...\n              // }\n            }\n\n            result[trackId] = {\n              timescale,\n              type\n            };\n            result[type] = {\n              timescale,\n              id: trackId,\n              codec\n            };\n          }\n        }\n      }\n    }\n  }\n  const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach(trex => {\n    const trackId = readUint32(trex, 4);\n    const track = result[trackId];\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20)\n      };\n    }\n  });\n  return result;\n}\nfunction patchEncyptionData(initSegment, decryptdata) {\n  if (!initSegment || !decryptdata) {\n    return initSegment;\n  }\n  const keyId = decryptdata.keyId;\n  if (keyId && decryptdata.isCommonEncryption) {\n    const traks = findBox(initSegment, ['moov', 'trak']);\n    traks.forEach(trak => {\n      const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      // skip the sample entry count\n      const sampleEntries = stsd.subarray(8);\n      let encBoxes = findBox(sampleEntries, ['enca']);\n      const isAudio = encBoxes.length > 0;\n      if (!isAudio) {\n        encBoxes = findBox(sampleEntries, ['encv']);\n      }\n      encBoxes.forEach(enc => {\n        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n        const sinfBoxes = findBox(encBoxChildren, ['sinf']);\n        sinfBoxes.forEach(sinf => {\n          const tenc = parseSinf(sinf);\n          if (tenc) {\n            // Look for default key id (keyID offset is always 8 within the tenc box):\n            const tencKeyId = tenc.subarray(8, 24);\n            if (!tencKeyId.some(b => b !== 0)) {\n              logger.log(`[eme] Patching keyId in 'enc${isAudio ? 'a' : 'v'}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);\n              tenc.set(keyId, 8);\n            }\n          }\n        });\n      });\n    });\n  }\n  return initSegment;\n}\nfunction parseSinf(sinf) {\n  const schm = findBox(sinf, ['schm'])[0];\n  if (schm) {\n    const scheme = bin2str(schm.subarray(4, 8));\n    if (scheme === 'cbcs' || scheme === 'cenc') {\n      return findBox(sinf, ['schi', 'tenc'])[0];\n    }\n  }\n  logger.error(`[eme] missing 'schm' box`);\n  return null;\n}\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData - a hash of track type to timescale values\n * @param fmp4 - the bytes of the mp4 fragment\n * @returns the earliest base media decode start time for the\n * fragment, in seconds\n */\nfunction getStartDTS(initData, fmp4) {\n  // we need info from two children of each track fragment box\n  return findBox(fmp4, ['moof', 'traf']).reduce((result, traf) => {\n    const tfdt = findBox(traf, ['tfdt'])[0];\n    const version = tfdt[0];\n    const start = findBox(traf, ['tfhd']).reduce((result, tfhd) => {\n      // get the track id from the tfhd\n      const id = readUint32(tfhd, 4);\n      const track = initData[id];\n      if (track) {\n        let baseTime = readUint32(tfdt, 4);\n        if (version === 1) {\n          // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n          // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n          // https://github.com/video-dev/hls.js/issues/5303\n          if (baseTime === UINT32_MAX$1) {\n            logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);\n            return result;\n          }\n          baseTime *= UINT32_MAX$1 + 1;\n          baseTime += readUint32(tfdt, 8);\n        }\n        // assume a 90kHz clock if no timescale was specified\n        const scale = track.timescale || 90e3;\n        // convert base time to seconds\n        const startTime = baseTime / scale;\n        if (isFinite(startTime) && (result === null || startTime < result)) {\n          return startTime;\n        }\n      }\n      return result;\n    }, null);\n    if (start !== null && isFinite(start) && (result === null || start < result)) {\n      return start;\n    }\n    return result;\n  }, null);\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(tfhd, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\nfunction getDuration(data, initData) {\n  let rawDuration = 0;\n  let videoDuration = 0;\n  let audioDuration = 0;\n  const trafs = findBox(data, ['moof', 'traf']);\n  for (let i = 0; i < trafs.length; i++) {\n    const traf = trafs[i];\n    // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n    const tfhd = findBox(traf, ['tfhd'])[0];\n    // get the track id from the tfhd\n    const id = readUint32(tfhd, 4);\n    const track = initData[id];\n    if (!track) {\n      continue;\n    }\n    const trackDefault = track.default;\n    const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n    let sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        sampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        sampleDuration = readUint32(tfhd, 8);\n      }\n    }\n    // assume a 90kHz clock if no timescale was specified\n    const timescale = track.timescale || 90e3;\n    const truns = findBox(traf, ['trun']);\n    for (let j = 0; j < truns.length; j++) {\n      rawDuration = computeRawDurationFromSamples(truns[j]);\n      if (!rawDuration && sampleDuration) {\n        const sampleCount = readUint32(truns[j], 4);\n        rawDuration = sampleDuration * sampleCount;\n      }\n      if (track.type === ElementaryStreamTypes.VIDEO) {\n        videoDuration += rawDuration / timescale;\n      } else if (track.type === ElementaryStreamTypes.AUDIO) {\n        audioDuration += rawDuration / timescale;\n      }\n    }\n  }\n  if (videoDuration === 0 && audioDuration === 0) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    let sidxDuration = 0;\n    const sidxs = findBox(data, ['sidx']);\n    for (let i = 0; i < sidxs.length; i++) {\n      const sidx = parseSegmentIndex(sidxs[i]);\n      if (sidx != null && sidx.references) {\n        sidxDuration += sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);\n      }\n    }\n    return sidxDuration;\n  }\n  if (videoDuration) {\n    return videoDuration;\n  }\n  return audioDuration;\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(trun, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */\nfunction computeRawDurationFromSamples(trun) {\n  const flags = readUint32(trun, 0);\n  // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n  // Each field is an int32, which is 4 bytes\n  let offset = 8;\n  // data-offset-present flag\n  if (flags & 0x000001) {\n    offset += 4;\n  }\n  // first-sample-flags-present flag\n  if (flags & 0x000004) {\n    offset += 4;\n  }\n  let duration = 0;\n  const sampleCount = readUint32(trun, 4);\n  for (let i = 0; i < sampleCount; i++) {\n    // sample-duration-present flag\n    if (flags & 0x000100) {\n      const sampleDuration = readUint32(trun, offset);\n      duration += sampleDuration;\n      offset += 4;\n    }\n    // sample-size-present flag\n    if (flags & 0x000200) {\n      offset += 4;\n    }\n    // sample-flags-present flag\n    if (flags & 0x000400) {\n      offset += 4;\n    }\n    // sample-composition-time-offsets-present flag\n    if (flags & 0x000800) {\n      offset += 4;\n    }\n  }\n  return duration;\n}\nfunction offsetStartDTS(initData, fmp4, timeOffset) {\n  findBox(fmp4, ['moof', 'traf']).forEach(traf => {\n    findBox(traf, ['tfhd']).forEach(tfhd => {\n      // get the track id from the tfhd\n      const id = readUint32(tfhd, 4);\n      const track = initData[id];\n      if (!track) {\n        return;\n      }\n      // assume a 90kHz clock if no timescale was specified\n      const timescale = track.timescale || 90e3;\n      // get the base media decode time from the tfdt\n      findBox(traf, ['tfdt']).forEach(tfdt => {\n        const version = tfdt[0];\n        let baseMediaDecodeTime = readUint32(tfdt, 4);\n        if (version === 0) {\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          writeUint32(tfdt, 4, baseMediaDecodeTime);\n        } else {\n          baseMediaDecodeTime *= Math.pow(2, 32);\n          baseMediaDecodeTime += readUint32(tfdt, 8);\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));\n          const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));\n          writeUint32(tfdt, 4, upper);\n          writeUint32(tfdt, 8, lower);\n        }\n      });\n    });\n  });\n}\n\n// TODO: Check if the last moof+mdat pair is part of the valid range\nfunction segmentValidRange(data) {\n  const segmentedRange = {\n    valid: null,\n    remainder: null\n  };\n  const moofs = findBox(data, ['moof']);\n  if (!moofs) {\n    return segmentedRange;\n  } else if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n  const last = moofs[moofs.length - 1];\n  // Offset by 8 bytes; findBox offsets the start by as much\n  segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n  segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n  return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n  const temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\nfunction parseSamples(timeOffset, track) {\n  const seiSamples = [];\n  const videoData = track.samples;\n  const timescale = track.timescale;\n  const trackId = track.id;\n  let isHEVCFlavor = false;\n  const moofs = findBox(videoData, ['moof']);\n  moofs.map(moof => {\n    const moofOffset = moof.byteOffset - 8;\n    const trafs = findBox(moof, ['traf']);\n    trafs.map(traf => {\n      // get the base media decode time from the tfdt\n      const baseTime = findBox(traf, ['tfdt']).map(tfdt => {\n        const version = tfdt[0];\n        let result = readUint32(tfdt, 4);\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n        return result / timescale;\n      })[0];\n      if (baseTime !== undefined) {\n        timeOffset = baseTime;\n      }\n      return findBox(traf, ['tfhd']).map(tfhd => {\n        const id = readUint32(tfhd, 4);\n        const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        let defaultSampleDuration = 0;\n        const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        let defaultSampleSize = 0;\n        const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        let tfhdOffset = 8;\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n          findBox(traf, ['trun']).map(trun => {\n            const version = trun[0];\n            const flags = readUint32(trun, 0) & 0xffffff;\n            const dataOffsetPresent = (flags & 0x000001) !== 0;\n            let dataOffset = 0;\n            const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            const sampleDurationPresent = (flags & 0x000100) !== 0;\n            let sampleDuration = 0;\n            const sampleSizePresent = (flags & 0x000200) !== 0;\n            let sampleSize = 0;\n            const sampleFlagsPresent = (flags & 0x000400) !== 0;\n            const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            let compositionOffset = 0;\n            const sampleCount = readUint32(trun, 4);\n            let trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n            let sampleOffset = dataOffset + moofOffset;\n            for (let ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n                trunOffset += 4;\n              }\n              if (track.type === ElementaryStreamTypes.VIDEO) {\n                let naluTotalSize = 0;\n                while (naluTotalSize < sampleSize) {\n                  const naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                    const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                  }\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\nfunction isHEVC(codec) {\n  if (!codec) {\n    return false;\n  }\n  const delimit = codec.indexOf('.');\n  const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n  return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n  // Dolby Vision\n  baseCodec === 'dvh1' || baseCodec === 'dvhe';\n}\nfunction isSEIMessage(isHEVCFlavor, naluHeader) {\n  if (isHEVCFlavor) {\n    const naluType = naluHeader >> 1 & 0x3f;\n    return naluType === 39 || naluType === 40;\n  } else {\n    const naluType = naluHeader & 0x1f;\n    return naluType === 6;\n  }\n}\nfunction parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n  const data = discardEPB(unescapedData);\n  let seiPtr = 0;\n  // skip nal header\n  seiPtr += headerSize;\n  let payloadType = 0;\n  let payloadSize = 0;\n  let endOfCaptions = false;\n  let b = 0;\n  while (seiPtr < data.length) {\n    payloadType = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff);\n\n    // Parse payload size.\n    payloadSize = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n    const leftOver = data.length - seiPtr;\n    if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {\n      endOfCaptions = true;\n      const countryCode = data[seiPtr++];\n      if (countryCode === 181) {\n        const providerCode = readUint16(data, seiPtr);\n        seiPtr += 2;\n        if (providerCode === 49) {\n          const userStructure = readUint32(data, seiPtr);\n          seiPtr += 4;\n          if (userStructure === 0x47413934) {\n            const userDataType = data[seiPtr++];\n\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\n            if (userDataType === 3) {\n              const firstByte = data[seiPtr++];\n              const totalCCs = 0x1f & firstByte;\n              const enabled = 0x40 & firstByte;\n              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              const byteArray = new Uint8Array(totalBytes);\n              if (enabled) {\n                byteArray[0] = firstByte;\n                for (let i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[seiPtr++];\n                }\n              }\n              samples.push({\n                type: userDataType,\n                payloadType,\n                pts,\n                bytes: byteArray\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5 && payloadSize < leftOver) {\n      endOfCaptions = true;\n      if (payloadSize > 16) {\n        const uuidStrArray = [];\n        for (let i = 0; i < 16; i++) {\n          const _b = data[seiPtr++].toString(16);\n          uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n        const length = payloadSize - 16;\n        const userDataBytes = new Uint8Array(length);\n        for (let i = 0; i < length; i++) {\n          userDataBytes[i] = data[seiPtr++];\n        }\n        samples.push({\n          payloadType,\n          pts,\n          uuid: uuidStrArray.join(''),\n          userData: utf8ArrayToStr(userDataBytes),\n          userDataBytes\n        });\n      }\n    } else if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      break;\n    }\n  }\n}\n\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\nfunction discardEPB(data) {\n  const length = data.byteLength;\n  const EPBPositions = [];\n  let i = 1;\n\n  // Find all `Emulation Prevention Bytes`\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n\n  // If no Emulation Prevention Bytes were found just return the original\n  // array\n  if (EPBPositions.length === 0) {\n    return data;\n  }\n\n  // Create a new array to hold the NAL unit data\n  const newLength = length - EPBPositions.length;\n  const newData = new Uint8Array(newLength);\n  let sourceIndex = 0;\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++;\n      // Remove this position index\n      EPBPositions.shift();\n    }\n    newData[i] = data[sourceIndex];\n  }\n  return newData;\n}\nfunction parseEmsg(data) {\n  const version = data[0];\n  let schemeIdUri = '';\n  let value = '';\n  let timeScale = 0;\n  let presentationTimeDelta = 0;\n  let presentationTime = 0;\n  let eventDuration = 0;\n  let id = 0;\n  let offset = 0;\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    const leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    const rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n    if (!Number.isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER;\n      logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n    }\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n  const payload = data.subarray(offset, data.byteLength);\n  return {\n    schemeIdUri,\n    value,\n    timeScale,\n    presentationTime,\n    presentationTimeDelta,\n    eventDuration,\n    id,\n    payload\n  };\n}\nfunction mp4Box(type, ...payload) {\n  const len = payload.length;\n  let size = 8;\n  let i = len;\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  const result = new Uint8Array(size);\n  result[0] = size >> 24 & 0xff;\n  result[1] = size >> 16 & 0xff;\n  result[2] = size >> 8 & 0xff;\n  result[3] = size & 0xff;\n  result.set(type, 4);\n  for (i = 0, size = 8; i < len; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n}\nfunction mp4pssh(systemId, keyids, data) {\n  if (systemId.byteLength !== 16) {\n    throw new RangeError('Invalid system id');\n  }\n  let version;\n  let kids;\n  if (keyids) {\n    version = 1;\n    kids = new Uint8Array(keyids.length * 16);\n    for (let ix = 0; ix < keyids.length; ix++) {\n      const k = keyids[ix]; // uint8array\n      if (k.byteLength !== 16) {\n        throw new RangeError('Invalid key');\n      }\n      kids.set(k, ix * 16);\n    }\n  } else {\n    version = 0;\n    kids = new Uint8Array();\n  }\n  let kidCount;\n  if (version > 0) {\n    kidCount = new Uint8Array(4);\n    if (keyids.length > 0) {\n      new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n    }\n  } else {\n    kidCount = new Uint8Array();\n  }\n  const dataSize = new Uint8Array(4);\n  if (data && data.byteLength > 0) {\n    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n  }\n  return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags\n  ]), systemId,\n  // 16 bytes\n  kidCount, kids, dataSize, data || new Uint8Array());\n}\nfunction parsePssh(initData) {\n  if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {\n    return null;\n  }\n  const result = {\n    version: 0,\n    systemId: '',\n    kids: null,\n    data: null\n  };\n  const view = new DataView(initData);\n  const boxSize = view.getUint32(0);\n  if (initData.byteLength !== boxSize && boxSize > 44) {\n    return null;\n  }\n  const type = view.getUint32(4);\n  if (type !== 0x70737368) {\n    return null;\n  }\n  result.version = view.getUint32(8) >>> 24;\n  if (result.version > 1) {\n    return null;\n  }\n  result.systemId = Hex.hexDump(new Uint8Array(initData, 12, 16));\n  const dataSizeOrKidCount = view.getUint32(28);\n  if (result.version === 0) {\n    if (boxSize - 32 < dataSizeOrKidCount) {\n      return null;\n    }\n    result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);\n  } else if (result.version === 1) {\n    result.kids = [];\n    for (let i = 0; i < dataSizeOrKidCount; i++) {\n      result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));\n    }\n  }\n  return result;\n}\n\nlet keyUriToKeyIdMap = {};\nclass LevelKey {\n  static clearKeyUriToKeyIdMap() {\n    keyUriToKeyIdMap = {};\n  }\n  constructor(method, uri, format, formatversions = [1], iv = null) {\n    this.uri = void 0;\n    this.method = void 0;\n    this.keyFormat = void 0;\n    this.keyFormatVersions = void 0;\n    this.encrypted = void 0;\n    this.isCommonEncryption = void 0;\n    this.iv = null;\n    this.key = null;\n    this.keyId = null;\n    this.pssh = null;\n    this.method = method;\n    this.uri = uri;\n    this.keyFormat = format;\n    this.keyFormatVersions = formatversions;\n    this.iv = iv;\n    this.encrypted = method ? method !== 'NONE' : false;\n    this.isCommonEncryption = this.encrypted && method !== 'AES-128';\n  }\n  isSupported() {\n    // If it's Segment encryption or No encryption, just select that key system\n    if (this.method) {\n      if (this.method === 'AES-128' || this.method === 'NONE') {\n        return true;\n      }\n      if (this.keyFormat === 'identity') {\n        // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n        return this.method === 'SAMPLE-AES';\n      } else {\n        switch (this.keyFormat) {\n          case KeySystemFormats.FAIRPLAY:\n          case KeySystemFormats.WIDEVINE:\n          case KeySystemFormats.PLAYREADY:\n          case KeySystemFormats.CLEARKEY:\n            return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;\n        }\n      }\n    }\n    return false;\n  }\n  getDecryptData(sn) {\n    if (!this.encrypted || !this.uri) {\n      return null;\n    }\n    if (this.method === 'AES-128' && this.uri && !this.iv) {\n      if (typeof sn !== 'number') {\n        // We are fetching decryption data for a initialization segment\n        // If the segment was encrypted with AES-128\n        // It must have an IV defined. We cannot substitute the Segment Number in.\n        if (this.method === 'AES-128' && !this.iv) {\n          logger.warn(`missing IV for initialization segment with method=\"${this.method}\" - compliance issue`);\n        }\n        // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n        sn = 0;\n      }\n      const iv = createInitializationVector(sn);\n      const decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n      return decryptdata;\n    }\n\n    // Initialize keyId if possible\n    const keyBytes = convertDataUriToArrayBytes(this.uri);\n    if (keyBytes) {\n      switch (this.keyFormat) {\n        case KeySystemFormats.WIDEVINE:\n          this.pssh = keyBytes;\n          // In case of widevine keyID is embedded in PSSH box. Read Key ID.\n          if (keyBytes.length >= 22) {\n            this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);\n          }\n          break;\n        case KeySystemFormats.PLAYREADY:\n          {\n            const PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);\n            this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);\n            const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n            const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n\n            // Parse Playready WRMHeader XML\n            const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');\n            const keyData = xmlDoc.getElementsByTagName('KID')[0];\n            if (keyData) {\n              const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');\n              if (keyId) {\n                const keyIdArray = base64Decode(keyId).subarray(0, 16);\n                // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n                // KID value in tenc is a big endian UUID GUID interpretation of UUID\n                changeEndianness(keyIdArray);\n                this.keyId = keyIdArray;\n              }\n            }\n            break;\n          }\n        default:\n          {\n            let keydata = keyBytes.subarray(0, 16);\n            if (keydata.length !== 16) {\n              const padded = new Uint8Array(16);\n              padded.set(keydata, 16 - keydata.length);\n              keydata = padded;\n            }\n            this.keyId = keydata;\n            break;\n          }\n      }\n    }\n\n    // Default behavior: assign a new keyId for each uri\n    if (!this.keyId || this.keyId.byteLength !== 16) {\n      let keyId = keyUriToKeyIdMap[this.uri];\n      if (!keyId) {\n        const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n        keyId = new Uint8Array(16);\n        const dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes\n        dv.setUint32(0, val);\n        keyUriToKeyIdMap[this.uri] = keyId;\n      }\n      this.keyId = keyId;\n    }\n    return this;\n  }\n}\nfunction createInitializationVector(segmentNumber) {\n  const uint8View = new Uint8Array(16);\n  for (let i = 12; i < 16; i++) {\n    uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n  }\n  return uint8View;\n}\n\nconst VARIABLE_REPLACEMENT_REGEX = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\nfunction hasVariableReferences(str) {\n  return VARIABLE_REPLACEMENT_REGEX.test(str);\n}\nfunction substituteVariablesInAttributes(parsed, attr, attributeNames) {\n  if (parsed.variableList !== null || parsed.hasVariableRefs) {\n    for (let i = attributeNames.length; i--;) {\n      const name = attributeNames[i];\n      const value = attr[name];\n      if (value) {\n        attr[name] = substituteVariables(parsed, value);\n      }\n    }\n  }\n}\nfunction substituteVariables(parsed, value) {\n  if (parsed.variableList !== null || parsed.hasVariableRefs) {\n    const variableList = parsed.variableList;\n    return value.replace(VARIABLE_REPLACEMENT_REGEX, variableReference => {\n      const variableName = variableReference.substring(2, variableReference.length - 1);\n      const variableValue = variableList == null ? void 0 : variableList[variableName];\n      if (variableValue === undefined) {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: \"${variableName}\"`));\n        return variableReference;\n      }\n      return variableValue;\n    });\n  }\n  return value;\n}\nfunction addVariableDefinition(parsed, attr, parentUrl) {\n  let variableList = parsed.variableList;\n  if (!variableList) {\n    parsed.variableList = variableList = {};\n  }\n  let NAME;\n  let VALUE;\n  if ('QUERYPARAM' in attr) {\n    NAME = attr.QUERYPARAM;\n    try {\n      const searchParams = new self.URL(parentUrl).searchParams;\n      if (searchParams.has(NAME)) {\n        VALUE = searchParams.get(NAME);\n      } else {\n        throw new Error(`\"${NAME}\" does not match any query parameter in URI: \"${parentUrl}\"`);\n      }\n    } catch (error) {\n      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));\n    }\n  } else {\n    NAME = attr.NAME;\n    VALUE = attr.VALUE;\n  }\n  if (NAME in variableList) {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: \"${NAME}\"`));\n  } else {\n    variableList[NAME] = VALUE || '';\n  }\n}\nfunction importVariableDefinition(parsed, attr, sourceVariableList) {\n  const IMPORT = attr.IMPORT;\n  if (sourceVariableList && IMPORT in sourceVariableList) {\n    let variableList = parsed.variableList;\n    if (!variableList) {\n      parsed.variableList = variableList = {};\n    }\n    variableList[IMPORT] = sourceVariableList[IMPORT];\n  } else {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \"${IMPORT}\"`));\n  }\n}\n\n/**\n * MediaSource helper\n */\n\nfunction getMediaSource() {\n  if (typeof self === 'undefined') return undefined;\n  return self.MediaSource || self.WebKitMediaSource;\n}\n\n// from http://mp4ra.org/codecs.html\nconst sampleEntryCodesISO = {\n  audio: {\n    a3ds: true,\n    'ac-3': true,\n    'ac-4': true,\n    alac: true,\n    alaw: true,\n    dra1: true,\n    'dts+': true,\n    'dts-': true,\n    dtsc: true,\n    dtse: true,\n    dtsh: true,\n    'ec-3': true,\n    enca: true,\n    g719: true,\n    g726: true,\n    m4ae: true,\n    mha1: true,\n    mha2: true,\n    mhm1: true,\n    mhm2: true,\n    mlpa: true,\n    mp4a: true,\n    'raw ': true,\n    Opus: true,\n    opus: true,\n    // browsers expect this to be lowercase despite MP4RA says 'Opus'\n    samr: true,\n    sawb: true,\n    sawp: true,\n    sevc: true,\n    sqcp: true,\n    ssmv: true,\n    twos: true,\n    ulaw: true\n  },\n  video: {\n    avc1: true,\n    avc2: true,\n    avc3: true,\n    avc4: true,\n    avcp: true,\n    av01: true,\n    drac: true,\n    dva1: true,\n    dvav: true,\n    dvh1: true,\n    dvhe: true,\n    encv: true,\n    hev1: true,\n    hvc1: true,\n    mjp2: true,\n    mp4v: true,\n    mvc1: true,\n    mvc2: true,\n    mvc3: true,\n    mvc4: true,\n    resv: true,\n    rv60: true,\n    s263: true,\n    svc1: true,\n    svc2: true,\n    'vc-1': true,\n    vp08: true,\n    vp09: true\n  },\n  text: {\n    stpp: true,\n    wvtt: true\n  }\n};\nconst MediaSource$2 = getMediaSource();\nfunction isCodecType(codec, type) {\n  const typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;\n}\nfunction isCodecSupportedInMp4(codec, type) {\n  var _MediaSource$isTypeSu;\n  return (_MediaSource$isTypeSu = MediaSource$2 == null ? void 0 : MediaSource$2.isTypeSupported(`${type || 'video'}/mp4;codecs=\"${codec}\"`)) != null ? _MediaSource$isTypeSu : false;\n}\n\nconst MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\nconst MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nconst IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\nconst LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n// duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/(?!#) *(\\S[\\S ]*)/.source,\n// segment URI, group 3 => the URI (note newline is not eaten)\n/#EXT-X-BYTERANGE:*(.+)/.source,\n// next segment's byterange, group 4 => range spec (x@y)\n/#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n// next segment's program date/time group 5 => the datetime spec\n/#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join('|'), 'g');\nconst LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\nclass M3U8Parser {\n  static findGroup(groups, mediaGroupId) {\n    for (let i = 0; i < groups.length; i++) {\n      const group = groups[i];\n      if (group.id === mediaGroupId) {\n        return group;\n      }\n    }\n  }\n  static convertAVC1ToAVCOTI(codec) {\n    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n    const avcdata = codec.split('.');\n    if (avcdata.length > 2) {\n      let result = avcdata.shift() + '.';\n      result += parseInt(avcdata.shift()).toString(16);\n      result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);\n      return result;\n    }\n    return codec;\n  }\n  static resolve(url, baseUrl) {\n    return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n      alwaysNormalize: true\n    });\n  }\n  static isMediaPlaylist(str) {\n    return IS_MEDIA_PLAYLIST.test(str);\n  }\n  static parseMasterPlaylist(string, baseurl) {\n    const hasVariableRefs = hasVariableReferences(string) ;\n    const parsed = {\n      contentSteering: null,\n      levels: [],\n      playlistParsingError: null,\n      sessionData: null,\n      sessionKeys: null,\n      startTimeOffset: null,\n      variableList: null,\n      hasVariableRefs\n    };\n    const levelsWithKnownCodecs = [];\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n    let result;\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      if (result[1]) {\n        var _level$unknownCodecs;\n        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n        const attrs = new AttrList(result[1]);\n        {\n          substituteVariablesInAttributes(parsed, attrs, ['CODECS', 'SUPPLEMENTAL-CODECS', 'ALLOWED-CPC', 'PATHWAY-ID', 'STABLE-VARIANT-ID', 'AUDIO', 'VIDEO', 'SUBTITLES', 'CLOSED-CAPTIONS', 'NAME']);\n        }\n        const uri = substituteVariables(parsed, result[2]) ;\n        const level = {\n          attrs,\n          bitrate: attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH'),\n          name: attrs.NAME,\n          url: M3U8Parser.resolve(uri, baseurl)\n        };\n        const resolution = attrs.decimalResolution('RESOLUTION');\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n        setCodecs((attrs.CODECS || '').split(/[ ,]+/).filter(c => c), level);\n        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {\n          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);\n        }\n        if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n          levelsWithKnownCodecs.push(level);\n        }\n        parsed.levels.push(level);\n      } else if (result[3]) {\n        const tag = result[3];\n        const attributes = result[4];\n        switch (tag) {\n          case 'SESSION-DATA':\n            {\n              // #EXT-X-SESSION-DATA\n              const sessionAttrs = new AttrList(attributes);\n              {\n                substituteVariablesInAttributes(parsed, sessionAttrs, ['DATA-ID', 'LANGUAGE', 'VALUE', 'URI']);\n              }\n              const dataId = sessionAttrs['DATA-ID'];\n              if (dataId) {\n                if (parsed.sessionData === null) {\n                  parsed.sessionData = {};\n                }\n                parsed.sessionData[dataId] = sessionAttrs;\n              }\n              break;\n            }\n          case 'SESSION-KEY':\n            {\n              // #EXT-X-SESSION-KEY\n              const sessionKey = parseKey(attributes, baseurl, parsed);\n              if (sessionKey.encrypted && sessionKey.isSupported()) {\n                if (parsed.sessionKeys === null) {\n                  parsed.sessionKeys = [];\n                }\n                parsed.sessionKeys.push(sessionKey);\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"${attributes}\"`);\n              }\n              break;\n            }\n          case 'DEFINE':\n            {\n              // #EXT-X-DEFINE\n              {\n                const variableAttributes = new AttrList(attributes);\n                substituteVariablesInAttributes(parsed, variableAttributes, ['NAME', 'VALUE', 'QUERYPARAM']);\n                addVariableDefinition(parsed, variableAttributes, baseurl);\n              }\n              break;\n            }\n          case 'CONTENT-STEERING':\n            {\n              // #EXT-X-CONTENT-STEERING\n              const contentSteeringAttributes = new AttrList(attributes);\n              {\n                substituteVariablesInAttributes(parsed, contentSteeringAttributes, ['SERVER-URI', 'PATHWAY-ID']);\n              }\n              parsed.contentSteering = {\n                uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n              };\n              break;\n            }\n          case 'START':\n            {\n              // #EXT-X-START\n              parsed.startTimeOffset = parseStartTimeOffset(attributes);\n              break;\n            }\n        }\n      }\n    }\n    // Filter out levels with unknown codecs if it does not remove all levels\n    const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n    parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n    if (parsed.levels.length === 0) {\n      parsed.playlistParsingError = new Error('no levels found in manifest');\n    }\n    return parsed;\n  }\n  static parseMasterPlaylistMedia(string, baseurl, parsed) {\n    let result;\n    const results = {};\n    const levels = parsed.levels;\n    const groupsByType = {\n      AUDIO: levels.map(level => ({\n        id: level.attrs.AUDIO,\n        audioCodec: level.audioCodec\n      })),\n      SUBTITLES: levels.map(level => ({\n        id: level.attrs.SUBTITLES,\n        textCodec: level.textCodec\n      })),\n      'CLOSED-CAPTIONS': []\n    };\n    let id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      const attrs = new AttrList(result[1]);\n      const type = attrs.TYPE;\n      if (type) {\n        const groups = groupsByType[type];\n        const medias = results[type] || [];\n        results[type] = medias;\n        {\n          substituteVariablesInAttributes(parsed, attrs, ['URI', 'GROUP-ID', 'LANGUAGE', 'ASSOC-LANGUAGE', 'STABLE-RENDITION-ID', 'NAME', 'INSTREAM-ID', 'CHARACTERISTICS', 'CHANNELS']);\n        }\n        const media = {\n          attrs,\n          bitrate: 0,\n          id: id++,\n          groupId: attrs['GROUP-ID'] || '',\n          instreamId: attrs['INSTREAM-ID'],\n          name: attrs.NAME || attrs.LANGUAGE || '',\n          type,\n          default: attrs.bool('DEFAULT'),\n          autoselect: attrs.bool('AUTOSELECT'),\n          forced: attrs.bool('FORCED'),\n          lang: attrs.LANGUAGE,\n          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n        };\n        if (groups != null && groups.length) {\n          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n          // If we don't find the track signalled, lets use the first audio groups codec we have\n          // Acting as a best guess\n          const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n          assignCodec(media, groupCodec, 'audioCodec');\n          assignCodec(media, groupCodec, 'textCodec');\n        }\n        medias.push(media);\n      }\n    }\n    return results;\n  }\n  static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n    const level = new LevelDetails(baseurl);\n    const fragments = level.fragments;\n    // The most recent init segment seen (applies to all subsequent segments)\n    let currentInitSegment = null;\n    let currentSN = 0;\n    let currentPart = 0;\n    let totalduration = 0;\n    let discontinuityCounter = 0;\n    let prevFrag = null;\n    let frag = new Fragment(type, baseurl);\n    let result;\n    let i;\n    let levelkeys;\n    let firstPdtIndex = -1;\n    let createNextFrag = false;\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n    level.m3u8 = string;\n    level.hasVariableRefs = hasVariableReferences(string) ;\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      if (createNextFrag) {\n        createNextFrag = false;\n        frag = new Fragment(type, baseurl);\n        // setup the next fragment for part loading\n        frag.start = totalduration;\n        frag.sn = currentSN;\n        frag.cc = discontinuityCounter;\n        frag.level = id;\n        if (currentInitSegment) {\n          frag.initSegment = currentInitSegment;\n          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n          currentInitSegment.rawProgramDateTime = null;\n        }\n      }\n      const duration = result[1];\n      if (duration) {\n        // INF\n        frag.duration = parseFloat(duration);\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n      } else if (result[3]) {\n        // url\n        if (isFiniteNumber(frag.duration)) {\n          frag.start = totalduration;\n          if (levelkeys) {\n            setFragLevelKeys(frag, levelkeys, level);\n          }\n          frag.sn = currentSN;\n          frag.level = id;\n          frag.cc = discontinuityCounter;\n          frag.urlId = levelUrlId;\n          fragments.push(frag);\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          const uri = (' ' + result[3]).slice(1);\n          frag.relurl = substituteVariables(level, uri) ;\n          assignProgramDateTime(frag, prevFrag);\n          prevFrag = frag;\n          totalduration += frag.duration;\n          currentSN++;\n          currentPart = 0;\n          createNextFrag = true;\n        }\n      } else if (result[4]) {\n        // X-BYTERANGE\n        const data = (' ' + result[4]).slice(1);\n        if (prevFrag) {\n          frag.setByteRange(data, prevFrag);\n        } else {\n          frag.setByteRange(data);\n        }\n      } else if (result[5]) {\n        // PROGRAM-DATE-TIME\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n        if (firstPdtIndex === -1) {\n          firstPdtIndex = fragments.length;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n        if (!result) {\n          logger.warn('No matches on slow regex match for level playlist!');\n          continue;\n        }\n        for (i = 1; i < result.length; i++) {\n          if (typeof result[i] !== 'undefined') {\n            break;\n          }\n        }\n\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const tag = (' ' + result[i]).slice(1);\n        const value1 = (' ' + result[i + 1]).slice(1);\n        const value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n        switch (tag) {\n          case 'PLAYLIST-TYPE':\n            level.type = value1.toUpperCase();\n            break;\n          case 'MEDIA-SEQUENCE':\n            currentSN = level.startSN = parseInt(value1);\n            break;\n          case 'SKIP':\n            {\n              const skipAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, skipAttrs, ['RECENTLY-REMOVED-DATERANGES']);\n              }\n              const skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n              if (isFiniteNumber(skippedSegments)) {\n                level.skippedSegments = skippedSegments;\n                // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                for (let _i = skippedSegments; _i--;) {\n                  fragments.unshift(null);\n                }\n                currentSN += skippedSegments;\n              }\n              const recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n              if (recentlyRemovedDateranges) {\n                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n              }\n              break;\n            }\n          case 'TARGETDURATION':\n            level.targetduration = Math.max(parseInt(value1), 1);\n            break;\n          case 'VERSION':\n            level.version = parseInt(value1);\n            break;\n          case 'EXTM3U':\n            break;\n          case 'ENDLIST':\n            level.live = false;\n            break;\n          case '#':\n            if (value1 || value2) {\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n            }\n            break;\n          case 'DISCONTINUITY':\n            discontinuityCounter++;\n            frag.tagList.push(['DIS']);\n            break;\n          case 'GAP':\n            frag.gap = true;\n            frag.tagList.push([tag]);\n            break;\n          case 'BITRATE':\n            frag.tagList.push([tag, value1]);\n            break;\n          case 'DATERANGE':\n            {\n              const dateRangeAttr = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, dateRangeAttr, ['ID', 'CLASS', 'START-DATE', 'END-DATE', 'SCTE35-CMD', 'SCTE35-OUT', 'SCTE35-IN']);\n                substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);\n              }\n              const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n              if (dateRange.isValid || level.skippedSegments) {\n                level.dateRanges[dateRange.id] = dateRange;\n              } else {\n                logger.warn(`Ignoring invalid DATERANGE tag: \"${value1}\"`);\n              }\n              // Add to fragment tag list for backwards compatibility (< v1.2.0)\n              frag.tagList.push(['EXT-X-DATERANGE', value1]);\n              break;\n            }\n          case 'DEFINE':\n            {\n              {\n                const variableAttributes = new AttrList(value1);\n                substituteVariablesInAttributes(level, variableAttributes, ['NAME', 'VALUE', 'IMPORT', 'QUERYPARAM']);\n                if ('IMPORT' in variableAttributes) {\n                  importVariableDefinition(level, variableAttributes, multivariantVariableList);\n                } else {\n                  addVariableDefinition(level, variableAttributes, baseurl);\n                }\n              }\n              break;\n            }\n          case 'DISCONTINUITY-SEQUENCE':\n            discontinuityCounter = parseInt(value1);\n            break;\n          case 'KEY':\n            {\n              const levelKey = parseKey(value1, baseurl, level);\n              if (levelKey.isSupported()) {\n                if (levelKey.method === 'NONE') {\n                  levelkeys = undefined;\n                  break;\n                }\n                if (!levelkeys) {\n                  levelkeys = {};\n                }\n                if (levelkeys[levelKey.keyFormat]) {\n                  levelkeys = _extends({}, levelkeys);\n                }\n                levelkeys[levelKey.keyFormat] = levelKey;\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: \"${value1}\"`);\n              }\n              break;\n            }\n          case 'START':\n            level.startTimeOffset = parseStartTimeOffset(value1);\n            break;\n          case 'MAP':\n            {\n              const mapAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, mapAttrs, ['BYTERANGE', 'URI']);\n              }\n              if (frag.duration) {\n                // Initial segment tag is after segment duration tag.\n                //   #EXTINF: 6.0\n                //   #EXT-X-MAP:URI=\"init.mp4\n                const init = new Fragment(type, baseurl);\n                setInitSegment(init, mapAttrs, id, levelkeys);\n                currentInitSegment = init;\n                frag.initSegment = currentInitSegment;\n                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                }\n              } else {\n                // Initial segment tag is before segment duration tag\n                setInitSegment(frag, mapAttrs, id, levelkeys);\n                currentInitSegment = frag;\n                createNextFrag = true;\n              }\n              break;\n            }\n          case 'SERVER-CONTROL':\n            {\n              const serverControlAttrs = new AttrList(value1);\n              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n              break;\n            }\n          case 'PART-INF':\n            {\n              const partInfAttrs = new AttrList(value1);\n              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n              break;\n            }\n          case 'PART':\n            {\n              let partList = level.partList;\n              if (!partList) {\n                partList = level.partList = [];\n              }\n              const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n              const index = currentPart++;\n              const partAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, partAttrs, ['BYTERANGE', 'URI']);\n              }\n              const part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);\n              partList.push(part);\n              frag.duration += part.duration;\n              break;\n            }\n          case 'PRELOAD-HINT':\n            {\n              const preloadHintAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, preloadHintAttrs, ['URI']);\n              }\n              level.preloadHint = preloadHintAttrs;\n              break;\n            }\n          case 'RENDITION-REPORT':\n            {\n              const renditionReportAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, renditionReportAttrs, ['URI']);\n              }\n              level.renditionReports = level.renditionReports || [];\n              level.renditionReports.push(renditionReportAttrs);\n              break;\n            }\n          default:\n            logger.warn(`line parsed but not handled: ${result}`);\n            break;\n        }\n      }\n    }\n    if (prevFrag && !prevFrag.relurl) {\n      fragments.pop();\n      totalduration -= prevFrag.duration;\n      if (level.partList) {\n        level.fragmentHint = prevFrag;\n      }\n    } else if (level.partList) {\n      assignProgramDateTime(frag, prevFrag);\n      frag.cc = discontinuityCounter;\n      level.fragmentHint = frag;\n      if (levelkeys) {\n        setFragLevelKeys(frag, levelkeys, level);\n      }\n    }\n    const fragmentLength = fragments.length;\n    const firstFragment = fragments[0];\n    const lastFragment = fragments[fragmentLength - 1];\n    totalduration += level.skippedSegments * level.targetduration;\n    if (totalduration > 0 && fragmentLength && lastFragment) {\n      level.averagetargetduration = totalduration / fragmentLength;\n      const lastSn = lastFragment.sn;\n      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n      if (!level.live) {\n        lastFragment.endList = true;\n      }\n      if (firstFragment) {\n        level.startCC = firstFragment.cc;\n      }\n    } else {\n      level.endSN = 0;\n      level.startCC = 0;\n    }\n    if (level.fragmentHint) {\n      totalduration += level.fragmentHint.duration;\n    }\n    level.totalduration = totalduration;\n    level.endCC = discontinuityCounter;\n\n    /**\n     * Backfill any missing PDT values\n     * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n     * one or more Media Segment URIs, the client SHOULD extrapolate\n     * backward from that tag (using EXTINF durations and/or media\n     * timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */\n    if (firstPdtIndex > 0) {\n      backfillProgramDateTimes(fragments, firstPdtIndex);\n    }\n    return level;\n  }\n}\nfunction parseKey(keyTagAttributes, baseurl, parsed) {\n  var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n  // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n  const keyAttrs = new AttrList(keyTagAttributes);\n  {\n    substituteVariablesInAttributes(parsed, keyAttrs, ['KEYFORMAT', 'KEYFORMATVERSIONS', 'URI', 'IV', 'URI']);\n  }\n  const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n  const decrypturi = keyAttrs.URI;\n  const decryptiv = keyAttrs.hexadecimalInteger('IV');\n  const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n  // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n  const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n  if (decrypturi && keyAttrs.IV && !decryptiv) {\n    logger.error(`Invalid IV: ${keyAttrs.IV}`);\n  }\n  // If decrypturi is a URI with a scheme, then baseurl will be ignored\n  // No uri is allowed when METHOD is NONE\n  const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n  const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n  return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n}\nfunction parseStartTimeOffset(startAttributes) {\n  const startAttrs = new AttrList(startAttributes);\n  const startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n  if (isFiniteNumber(startTimeOffset)) {\n    return startTimeOffset;\n  }\n  return null;\n}\nfunction setCodecs(codecs, level) {\n  ['video', 'audio', 'text'].forEach(type => {\n    const filtered = codecs.filter(codec => isCodecType(codec, type));\n    if (filtered.length) {\n      const preferred = filtered.filter(codec => {\n        return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;\n      });\n      level[`${type}Codec`] = preferred.length > 0 ? preferred[0] : filtered[0];\n\n      // remove from list\n      codecs = codecs.filter(codec => filtered.indexOf(codec) === -1);\n    }\n  });\n  level.unknownCodecs = codecs;\n}\nfunction assignCodec(media, groupItem, codecProperty) {\n  const codecValue = groupItem[codecProperty];\n  if (codecValue) {\n    media[codecProperty] = codecValue;\n  }\n}\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n  let fragPrev = fragments[firstPdtIndex];\n  for (let i = firstPdtIndex; i--;) {\n    const frag = fragments[i];\n    // Exit on delta-playlist skipped segments\n    if (!frag) {\n      return;\n    }\n    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n    fragPrev = frag;\n  }\n}\nfunction assignProgramDateTime(frag, prevFrag) {\n  if (frag.rawProgramDateTime) {\n    frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n  } else if (prevFrag != null && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n  if (!isFiniteNumber(frag.programDateTime)) {\n    frag.programDateTime = null;\n    frag.rawProgramDateTime = null;\n  }\n}\nfunction setInitSegment(frag, mapAttrs, id, levelkeys) {\n  frag.relurl = mapAttrs.URI;\n  if (mapAttrs.BYTERANGE) {\n    frag.setByteRange(mapAttrs.BYTERANGE);\n  }\n  frag.level = id;\n  frag.sn = 'initSegment';\n  if (levelkeys) {\n    frag.levelkeys = levelkeys;\n  }\n  frag.initSegment = null;\n}\nfunction setFragLevelKeys(frag, levelkeys, level) {\n  frag.levelkeys = levelkeys;\n  const {\n    encryptedFragments\n  } = level;\n  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(format => levelkeys[format].isCommonEncryption)) {\n    encryptedFragments.push(frag);\n  }\n}\n\nvar PlaylistContextType = {\n  MANIFEST: \"manifest\",\n  LEVEL: \"level\",\n  AUDIO_TRACK: \"audioTrack\",\n  SUBTITLE_TRACK: \"subtitleTrack\"\n};\nvar PlaylistLevelType = {\n  MAIN: \"main\",\n  AUDIO: \"audio\",\n  SUBTITLE: \"subtitle\"\n};\n\nfunction mapContextToLevelType(context) {\n  const {\n    type\n  } = context;\n  switch (type) {\n    case PlaylistContextType.AUDIO_TRACK:\n      return PlaylistLevelType.AUDIO;\n    case PlaylistContextType.SUBTITLE_TRACK:\n      return PlaylistLevelType.SUBTITLE;\n    default:\n      return PlaylistLevelType.MAIN;\n  }\n}\nfunction getResponseUrl(response, context) {\n  let url = response.url;\n  // responseURL not supported on some browsers (it is used to detect URL redirection)\n  // data-uri mode also not supported (but no need to detect redirection)\n  if (url === undefined || url.indexOf('data:') === 0) {\n    // fallback to initial URL\n    url = context.url;\n  }\n  return url;\n}\nclass PlaylistLoader {\n  constructor(hls) {\n    this.hls = void 0;\n    this.loaders = Object.create(null);\n    this.variableList = null;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.destroyInternalLoaders();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */\n  createInternalLoader(context) {\n    const config = this.hls.config;\n    const PLoader = config.pLoader;\n    const Loader = config.loader;\n    const InternalLoader = PLoader || Loader;\n    const loader = new InternalLoader(config);\n    this.loaders[context.type] = loader;\n    return loader;\n  }\n  getInternalLoader(context) {\n    return this.loaders[context.type];\n  }\n  resetInternalLoader(contextType) {\n    if (this.loaders[contextType]) {\n      delete this.loaders[contextType];\n    }\n  }\n\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */\n  destroyInternalLoaders() {\n    for (const contextType in this.loaders) {\n      const loader = this.loaders[contextType];\n      if (loader) {\n        loader.destroy();\n      }\n      this.resetInternalLoader(contextType);\n    }\n  }\n  destroy() {\n    this.variableList = null;\n    this.unregisterListeners();\n    this.destroyInternalLoaders();\n  }\n  onManifestLoading(event, data) {\n    const {\n      url\n    } = data;\n    this.variableList = null;\n    this.load({\n      id: null,\n      level: 0,\n      responseType: 'text',\n      type: PlaylistContextType.MANIFEST,\n      url,\n      deliveryDirectives: null\n    });\n  }\n  onLevelLoading(event, data) {\n    const {\n      id,\n      level,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      level,\n      responseType: 'text',\n      type: PlaylistContextType.LEVEL,\n      url,\n      deliveryDirectives\n    });\n  }\n  onAudioTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.AUDIO_TRACK,\n      url,\n      deliveryDirectives\n    });\n  }\n  onSubtitleTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.SUBTITLE_TRACK,\n      url,\n      deliveryDirectives\n    });\n  }\n  load(context) {\n    var _context$deliveryDire;\n    const config = this.hls.config;\n\n    // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n    // Check if a loader for this context already exists\n    let loader = this.getInternalLoader(context);\n    if (loader) {\n      const loaderContext = loader.context;\n      if (loaderContext && loaderContext.url === context.url) {\n        // same URL can't overlap\n        logger.trace('[playlist-loader]: playlist request ongoing');\n        return;\n      }\n      logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);\n      loader.abort();\n    }\n\n    // apply different configs for retries depending on\n    // context (manifest, level, audio/subs playlist)\n    let loadPolicy;\n    if (context.type === PlaylistContextType.MANIFEST) {\n      loadPolicy = config.manifestLoadPolicy.default;\n    } else {\n      loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n        timeoutRetry: null,\n        errorRetry: null\n      });\n    }\n    loader = this.createInternalLoader(context);\n\n    // Override level/track timeout for LL-HLS requests\n    // (the default of 10000ms is counter productive to blocking playlist reload requests)\n    if ((_context$deliveryDire = context.deliveryDirectives) != null && _context$deliveryDire.part) {\n      let levelDetails;\n      if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n        levelDetails = this.hls.levels[context.level].details;\n      } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n        levelDetails = this.hls.audioTracks[context.id].details;\n      } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n        levelDetails = this.hls.subtitleTracks[context.id].details;\n      }\n      if (levelDetails) {\n        const partTarget = levelDetails.partTarget;\n        const targetDuration = levelDetails.targetduration;\n        if (partTarget && targetDuration) {\n          const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n          loadPolicy = _extends({}, loadPolicy, {\n            maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n            maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n          });\n        }\n      }\n    }\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const loaderCallbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        const loader = this.getInternalLoader(context);\n        this.resetInternalLoader(context.type);\n        const string = response.data;\n\n        // Validate if it is an M3U8 at all\n        if (string.indexOf('#EXTM3U') !== 0) {\n          this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);\n          return;\n        }\n        stats.parsing.start = performance.now();\n        if (M3U8Parser.isMediaPlaylist(string)) {\n          this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n        } else {\n          this.handleMasterPlaylist(response, stats, context, networkDetails);\n        }\n      },\n      onError: (response, context, networkDetails, stats) => {\n        this.handleNetworkError(context, networkDetails, false, response, stats);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.handleNetworkError(context, networkDetails, true, undefined, stats);\n      }\n    };\n\n    // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n    loader.load(context, loaderConfig, loaderCallbacks);\n  }\n  handleMasterPlaylist(response, stats, context, networkDetails) {\n    const hls = this.hls;\n    const string = response.data;\n    const url = getResponseUrl(response, context);\n    const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n    if (parsedResult.playlistParsingError) {\n      this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n      return;\n    }\n    const {\n      contentSteering,\n      levels,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    } = parsedResult;\n    this.variableList = variableList;\n    const {\n      AUDIO: audioTracks = [],\n      SUBTITLES: subtitles,\n      'CLOSED-CAPTIONS': captions\n    } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);\n    if (audioTracks.length) {\n      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n      const embeddedAudioFound = audioTracks.some(audioTrack => !audioTrack.url);\n\n      // if no embedded audio track defined, but audio codec signaled in quality level,\n      // we need to signal this main audio track this could happen with playlists with\n      // alt audio rendition in which quality levels (main)\n      // contains both audio+video. but with mixed audio track not signaled\n      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n        logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n        audioTracks.unshift({\n          type: 'main',\n          name: 'main',\n          groupId: 'main',\n          default: false,\n          autoselect: false,\n          forced: false,\n          id: -1,\n          attrs: new AttrList({}),\n          bitrate: 0,\n          url: ''\n        });\n      }\n    }\n    hls.trigger(Events.MANIFEST_LOADED, {\n      levels,\n      audioTracks,\n      subtitles,\n      captions,\n      contentSteering,\n      url,\n      stats,\n      networkDetails,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    });\n  }\n  handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      id,\n      level,\n      type\n    } = context;\n    const url = getResponseUrl(response, context);\n    const levelUrlId = isFiniteNumber(id) ? id : 0;\n    const levelId = isFiniteNumber(level) ? level : levelUrlId;\n    const levelType = mapContextToLevelType(context);\n    const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);\n\n    // We have done our first request (Manifest-type) and receive\n    // not a master playlist but a chunk-list (track/level)\n    // We fire the manifest-loaded event anyway with the parsed level-details\n    // by creating a single-level structure for it.\n    if (type === PlaylistContextType.MANIFEST) {\n      const singleLevel = {\n        attrs: new AttrList({}),\n        bitrate: 0,\n        details: levelDetails,\n        name: '',\n        url\n      };\n      hls.trigger(Events.MANIFEST_LOADED, {\n        levels: [singleLevel],\n        audioTracks: [],\n        url,\n        stats,\n        networkDetails,\n        sessionData: null,\n        sessionKeys: null,\n        contentSteering: null,\n        startTimeOffset: null,\n        variableList: null\n      });\n    }\n\n    // save parsing time\n    stats.parsing.end = performance.now();\n\n    // extend the context with the new levelDetails property\n    context.levelDetails = levelDetails;\n    this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n  }\n  handleManifestParsingError(response, context, error, networkDetails, stats) {\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.NETWORK_ERROR,\n      details: ErrorDetails.MANIFEST_PARSING_ERROR,\n      fatal: context.type === PlaylistContextType.MANIFEST,\n      url: response.url,\n      err: error,\n      error,\n      reason: error.message,\n      response,\n      context,\n      networkDetails,\n      stats\n    });\n  }\n  handleNetworkError(context, networkDetails, timeout = false, response, stats) {\n    let message = `A network ${timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')} occurred while loading ${context.type}`;\n    if (context.type === PlaylistContextType.LEVEL) {\n      message += `: ${context.level} id: ${context.id}`;\n    } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n      message += ` id: ${context.id} group-id: \"${context.groupId}\"`;\n    }\n    const error = new Error(message);\n    logger.warn(`[playlist-loader]: ${message}`);\n    let details = ErrorDetails.UNKNOWN;\n    let fatal = false;\n    const loader = this.getInternalLoader(context);\n    switch (context.type) {\n      case PlaylistContextType.MANIFEST:\n        details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n        fatal = true;\n        break;\n      case PlaylistContextType.LEVEL:\n        details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n        fatal = false;\n        break;\n    }\n    if (loader) {\n      this.resetInternalLoader(context.type);\n    }\n    const errorData = {\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal,\n      url: context.url,\n      loader,\n      context,\n      error,\n      networkDetails,\n      stats\n    };\n    if (response) {\n      const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n      errorData.response = _objectSpread2({\n        url,\n        data: undefined\n      }, response);\n    }\n    this.hls.trigger(Events.ERROR, errorData);\n  }\n  handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      type,\n      level,\n      id,\n      groupId,\n      deliveryDirectives\n    } = context;\n    const url = getResponseUrl(response, context);\n    const parent = mapContextToLevelType(context);\n    const levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n    if (!levelDetails.fragments.length) {\n      const _error = new Error('No Segments found in Playlist');\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_EMPTY_ERROR,\n        fatal: false,\n        url,\n        error: _error,\n        reason: _error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (!levelDetails.targetduration) {\n      levelDetails.playlistParsingError = new Error('Missing Target Duration');\n    }\n    const error = levelDetails.playlistParsingError;\n    if (error) {\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_PARSING_ERROR,\n        fatal: false,\n        url,\n        error,\n        reason: error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (levelDetails.live && loader) {\n      if (loader.getCacheAge) {\n        levelDetails.ageHeader = loader.getCacheAge() || 0;\n      }\n      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n        levelDetails.ageHeader = 0;\n      }\n    }\n    switch (type) {\n      case PlaylistContextType.MANIFEST:\n      case PlaylistContextType.LEVEL:\n        hls.trigger(Events.LEVEL_LOADED, {\n          details: levelDetails,\n          level: levelIndex || 0,\n          id: id || 0,\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        hls.trigger(Events.AUDIO_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n    }\n  }\n}\n\nfunction sendAddTrackEvent(track, videoEl) {\n  let event;\n  try {\n    event = new Event('addtrack');\n  } catch (err) {\n    // for IE11\n    event = document.createEvent('Event');\n    event.initEvent('addtrack', false, false);\n  }\n  event.track = track;\n  videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n  // Sometimes there are cue overlaps on segmented vtts so the same\n  // cue can appear more than once in different vtt files.\n  // This avoid showing duplicated cues with same timecode and text.\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && !track.cues.getCueById(cue.id)) {\n    try {\n      track.addCue(cue);\n      if (!track.cues.getCueById(cue.id)) {\n        throw new Error(`addCue is failed for: ${cue}`);\n      }\n    } catch (err) {\n      logger.debug(`[texttrack-utils]: ${err}`);\n      try {\n        const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n        textTrackCue.id = cue.id;\n        track.addCue(textTrackCue);\n      } catch (err2) {\n        logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction clearCurrentCues(track) {\n  // When track.mode is disabled, track.cues will be null.\n  // To guarantee the removal of cues, we need to temporarily\n  // change the mode to hidden\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues) {\n    for (let i = track.cues.length; i--;) {\n      track.removeCue(track.cues[i]);\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && track.cues.length > 0) {\n    const cues = getCuesInRange(track.cues, start, end);\n    for (let i = 0; i < cues.length; i++) {\n      if (!predicate || predicate(cues[i])) {\n        track.removeCue(cues[i]);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\n\n// Find first cue starting after given time.\n// Modified version of binary search O(log(n)).\nfunction getFirstCueIndexAfterTime(cues, time) {\n  // If first cue starts after time, start there\n  if (time < cues[0].startTime) {\n    return 0;\n  }\n  // If the last cue ends before time there is no overlap\n  const len = cues.length - 1;\n  if (time > cues[len].endTime) {\n    return -1;\n  }\n  let left = 0;\n  let right = len;\n  while (left <= right) {\n    const mid = Math.floor((right + left) / 2);\n    if (time < cues[mid].startTime) {\n      right = mid - 1;\n    } else if (time > cues[mid].startTime && left < len) {\n      left = mid + 1;\n    } else {\n      // If it's not lower or higher, it must be equal.\n      return mid;\n    }\n  }\n  // At this point, left and right have swapped.\n  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n  return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\nfunction getCuesInRange(cues, start, end) {\n  const cuesFound = [];\n  const firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n  if (firstCueInRange > -1) {\n    for (let i = firstCueInRange, len = cues.length; i < len; i++) {\n      const cue = cues[i];\n      if (cue.startTime >= start && cue.endTime <= end) {\n        cuesFound.push(cue);\n      } else if (cue.startTime > end) {\n        return cuesFound;\n      }\n    }\n  }\n  return cuesFound;\n}\n\nvar MetadataSchema = {\n  audioId3: \"org.id3\",\n  dateRange: \"com.apple.quicktime.HLS\",\n  emsg: \"https://aomedia.org/emsg/ID3\"\n};\n\nconst MIN_CUE_DURATION = 0.25;\nfunction getCueClass() {\n  if (typeof self === 'undefined') return undefined;\n\n  // Attempt to recreate Safari functionality by creating\n  // WebKitDataCue objects when available and store the decoded\n  // ID3 data in the value property of the cue\n  return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;\n}\n\n// VTTCue latest draft allows an infinite duration, fallback\n// to MAX_VALUE if necessary\nconst MAX_CUE_ENDTIME = (() => {\n  const Cue = getCueClass();\n  try {\n    new Cue(0, Number.POSITIVE_INFINITY, '');\n  } catch (e) {\n    return Number.MAX_VALUE;\n  }\n  return Number.POSITIVE_INFINITY;\n})();\nfunction dateRangeDateToTimelineSeconds(date, offset) {\n  return date.getTime() / 1000 - offset;\n}\nfunction hexToArrayBuffer(str) {\n  return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n}\nclass ID3TrackController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    this.hls = hls;\n    this._registerListeners();\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    // @ts-ignore\n    this.hls = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n\n  // Add ID3 metatadata text track.\n  onMediaAttached(event, data) {\n    this.media = data.media;\n  }\n  onMediaDetaching() {\n    if (!this.id3Track) {\n      return;\n    }\n    clearCurrentCues(this.id3Track);\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n  }\n  onManifestLoading() {\n    this.dateRangeCuesAppended = {};\n  }\n  createTrack(media) {\n    const track = this.getID3Track(media.textTracks);\n    track.mode = 'hidden';\n    return track;\n  }\n  getID3Track(textTracks) {\n    if (!this.media) {\n      return;\n    }\n    for (let i = 0; i < textTracks.length; i++) {\n      const textTrack = textTracks[i];\n      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n        // send 'addtrack' when reusing the textTrack for metadata,\n        // same as what we do for captions\n        sendAddTrackEvent(textTrack, this.media);\n        return textTrack;\n      }\n    }\n    return this.media.addTextTrack('metadata', 'id3');\n  }\n  onFragParsingMetadata(event, data) {\n    if (!this.media) {\n      return;\n    }\n    const {\n      hls: {\n        config: {\n          enableEmsgMetadataCues,\n          enableID3MetadataCues\n        }\n      }\n    } = this;\n    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n      return;\n    }\n    const {\n      samples\n    } = data;\n\n    // create track dynamically\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const Cue = getCueClass();\n    for (let i = 0; i < samples.length; i++) {\n      const type = samples[i].type;\n      if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n        continue;\n      }\n      const frames = getID3Frames(samples[i].data);\n      if (frames) {\n        const startTime = samples[i].pts;\n        let endTime = startTime + samples[i].duration;\n        if (endTime > MAX_CUE_ENDTIME) {\n          endTime = MAX_CUE_ENDTIME;\n        }\n        const timeDiff = endTime - startTime;\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n        for (let j = 0; j < frames.length; j++) {\n          const frame = frames[j];\n          // Safari doesn't put the timestamp frame in the TextTrack\n          if (!isTimeStampFrame(frame)) {\n            // add a bounds to any unbounded cues\n            this.updateId3CueEnds(startTime, type);\n            const cue = new Cue(startTime, endTime, '');\n            cue.value = frame;\n            if (type) {\n              cue.type = type;\n            }\n            this.id3Track.addCue(cue);\n          }\n        }\n      }\n    }\n  }\n  updateId3CueEnds(startTime, type) {\n    var _this$id3Track;\n    const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n    if (cues) {\n      for (let i = cues.length; i--;) {\n        const cue = cues[i];\n        if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n          cue.endTime = startTime;\n        }\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    type\n  }) {\n    const {\n      id3Track,\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    const {\n      config: {\n        enableEmsgMetadataCues,\n        enableID3MetadataCues\n      }\n    } = hls;\n    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n      let predicate;\n      if (type === 'audio') {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n      } else if (type === 'video') {\n        predicate = cue => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      } else {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      }\n      removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n      return;\n    }\n    const {\n      dateRangeCuesAppended,\n      id3Track\n    } = this;\n    const {\n      dateRanges\n    } = details;\n    const ids = Object.keys(dateRanges);\n    // Remove cues from track not found in details.dateRanges\n    if (id3Track) {\n      const idsToRemove = Object.keys(dateRangeCuesAppended).filter(id => !ids.includes(id));\n      for (let i = idsToRemove.length; i--;) {\n        const id = idsToRemove[i];\n        Object.keys(dateRangeCuesAppended[id].cues).forEach(key => {\n          id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n        });\n        delete dateRangeCuesAppended[id];\n      }\n    }\n    // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n    const lastFragment = details.fragments[details.fragments.length - 1];\n    if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n      return;\n    }\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n    const Cue = getCueClass();\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const dateRange = dateRanges[id];\n      const appendedDateRangeCues = dateRangeCuesAppended[id];\n      const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n      let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n      const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n      let endTime = MAX_CUE_ENDTIME;\n      const endDate = dateRange.endDate;\n      if (endDate) {\n        endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n        durationKnown = true;\n      } else if (dateRange.endOnNext && !durationKnown) {\n        const nextDateRangeWithSameClass = ids.reduce((filterMapArray, id) => {\n          const candidate = dateRanges[id];\n          if (candidate.class === dateRange.class && candidate.id !== id && candidate.startDate > dateRange.startDate) {\n            filterMapArray.push(candidate);\n          }\n          return filterMapArray;\n        }, []).sort((a, b) => a.startDate.getTime() - b.startDate.getTime())[0];\n        if (nextDateRangeWithSameClass) {\n          endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n          durationKnown = true;\n        }\n      }\n      const attributes = Object.keys(dateRange.attr);\n      for (let j = 0; j < attributes.length; j++) {\n        const key = attributes[j];\n        if (!isDateRangeCueAttribute(key)) {\n          continue;\n        }\n        let cue = cues[key];\n        if (cue) {\n          if (durationKnown && !appendedDateRangeCues.durationKnown) {\n            cue.endTime = endTime;\n          }\n        } else {\n          let data = dateRange.attr[key];\n          cue = new Cue(startTime, endTime, '');\n          if (isSCTE35Attribute(key)) {\n            data = hexToArrayBuffer(data);\n          }\n          cue.value = {\n            key,\n            data\n          };\n          cue.type = MetadataSchema.dateRange;\n          cue.id = id;\n          this.id3Track.addCue(cue);\n          cues[key] = cue;\n        }\n      }\n      dateRangeCuesAppended[id] = {\n        cues,\n        dateRange,\n        durationKnown\n      };\n    }\n  }\n}\n\nclass LatencyController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.levelDetails = null;\n    this.currentTime = 0;\n    this.stallCount = 0;\n    this._latency = null;\n    this.timeupdateHandler = () => this.timeupdate();\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  get latency() {\n    return this._latency || 0;\n  }\n  get maxLatency() {\n    const {\n      config,\n      levelDetails\n    } = this;\n    if (config.liveMaxLatencyDuration !== undefined) {\n      return config.liveMaxLatencyDuration;\n    }\n    return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n  }\n  get targetLatency() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return null;\n    }\n    const {\n      holdBack,\n      partHoldBack,\n      targetduration\n    } = levelDetails;\n    const {\n      liveSyncDuration,\n      liveSyncDurationCount,\n      lowLatencyMode\n    } = this.config;\n    const userConfig = this.hls.userConfig;\n    let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n    if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n      targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n    }\n    const maxLiveSyncOnStallIncrease = targetduration;\n    const liveSyncOnStallIncrease = 1.0;\n    return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n  }\n  get liveSyncPosition() {\n    const liveEdge = this.estimateLiveEdge();\n    const targetLatency = this.targetLatency;\n    const levelDetails = this.levelDetails;\n    if (liveEdge === null || targetLatency === null || levelDetails === null) {\n      return null;\n    }\n    const edge = levelDetails.edge;\n    const syncPosition = liveEdge - targetLatency - this.edgeStalled;\n    const min = edge - levelDetails.totalduration;\n    const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n    return Math.min(Math.max(min, syncPosition), max);\n  }\n  get drift() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return 1;\n    }\n    return levelDetails.drift;\n  }\n  get edgeStalled() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return 0;\n    }\n    const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n    return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n  }\n  get forwardBufferLength() {\n    const {\n      media,\n      levelDetails\n    } = this;\n    if (!media || !levelDetails) {\n      return 0;\n    }\n    const bufferedRanges = media.buffered.length;\n    return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetaching();\n    this.levelDetails = null;\n    // @ts-ignore\n    this.hls = this.timeupdateHandler = null;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.off(Events.ERROR, this.onError, this);\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('timeupdate', this.timeupdateHandler);\n  }\n  onMediaDetaching() {\n    if (this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n      this.media = null;\n    }\n  }\n  onManifestLoading() {\n    this.levelDetails = null;\n    this._latency = null;\n    this.stallCount = 0;\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    this.levelDetails = details;\n    if (details.advanced) {\n      this.timeupdate();\n    }\n    if (!details.live && this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n    }\n  }\n  onError(event, data) {\n    var _this$levelDetails;\n    if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n      return;\n    }\n    this.stallCount++;\n    if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n      logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n    }\n  }\n  timeupdate() {\n    const {\n      media,\n      levelDetails\n    } = this;\n    if (!media || !levelDetails) {\n      return;\n    }\n    this.currentTime = media.currentTime;\n    const latency = this.computeLatency();\n    if (latency === null) {\n      return;\n    }\n    this._latency = latency;\n\n    // Adapt playbackRate to meet target latency in low-latency mode\n    const {\n      lowLatencyMode,\n      maxLiveSyncPlaybackRate\n    } = this.config;\n    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {\n      return;\n    }\n    const targetLatency = this.targetLatency;\n    if (targetLatency === null) {\n      return;\n    }\n    const distanceFromTarget = latency - targetLatency;\n    // Only adjust playbackRate when within one target duration of targetLatency\n    // and more than one second from under-buffering.\n    // Playback further than one target duration from target can be considered DVR playback.\n    const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n    const inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n    if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n      const max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n      const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n      media.playbackRate = Math.min(max, Math.max(1, rate));\n    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n      media.playbackRate = 1;\n    }\n  }\n  estimateLiveEdge() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return null;\n    }\n    return levelDetails.edge + levelDetails.age;\n  }\n  computeLatency() {\n    const liveEdge = this.estimateLiveEdge();\n    if (liveEdge === null) {\n      return null;\n    }\n    return liveEdge - this.currentTime;\n  }\n}\n\nconst HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\nvar HlsSkip = {\n  No: \"\",\n  Yes: \"YES\",\n  v2: \"v2\"\n};\nfunction getSkipValue(details, msn) {\n  const {\n    canSkipUntil,\n    canSkipDateRanges,\n    endSN\n  } = details;\n  const snChangeGoal = msn !== undefined ? msn - endSN : 0;\n  if (canSkipUntil && snChangeGoal < canSkipUntil) {\n    if (canSkipDateRanges) {\n      return HlsSkip.v2;\n    }\n    return HlsSkip.Yes;\n  }\n  return HlsSkip.No;\n}\nclass HlsUrlParameters {\n  constructor(msn, part, skip) {\n    this.msn = void 0;\n    this.part = void 0;\n    this.skip = void 0;\n    this.msn = msn;\n    this.part = part;\n    this.skip = skip;\n  }\n  addDirectives(uri) {\n    const url = new self.URL(uri);\n    if (this.msn !== undefined) {\n      url.searchParams.set('_HLS_msn', this.msn.toString());\n    }\n    if (this.part !== undefined) {\n      url.searchParams.set('_HLS_part', this.part.toString());\n    }\n    if (this.skip) {\n      url.searchParams.set('_HLS_skip', this.skip);\n    }\n    return url.href;\n  }\n}\nclass Level {\n  constructor(data) {\n    this._attrs = void 0;\n    this.audioCodec = void 0;\n    this.bitrate = void 0;\n    this.codecSet = void 0;\n    this.height = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.videoCodec = void 0;\n    this.width = void 0;\n    this.unknownCodecs = void 0;\n    this.audioGroupIds = void 0;\n    this.details = void 0;\n    this.fragmentError = 0;\n    this.loadError = 0;\n    this.loaded = void 0;\n    this.realBitrate = 0;\n    this.textGroupIds = void 0;\n    this.url = void 0;\n    this._urlId = 0;\n    this.url = [data.url];\n    this._attrs = [data.attrs];\n    this.bitrate = data.bitrate;\n    if (data.details) {\n      this.details = data.details;\n    }\n    this.id = data.id || 0;\n    this.name = data.name;\n    this.width = data.width || 0;\n    this.height = data.height || 0;\n    this.audioCodec = data.audioCodec;\n    this.videoCodec = data.videoCodec;\n    this.unknownCodecs = data.unknownCodecs;\n    this.codecSet = [data.videoCodec, data.audioCodec].filter(c => c).join(',').replace(/\\.[^.,]+/g, '');\n  }\n  get maxBitrate() {\n    return Math.max(this.realBitrate, this.bitrate);\n  }\n  get attrs() {\n    return this._attrs[this._urlId];\n  }\n  get pathwayId() {\n    return this.attrs['PATHWAY-ID'] || '.';\n  }\n  get uri() {\n    return this.url[this._urlId] || '';\n  }\n  get urlId() {\n    return this._urlId;\n  }\n  set urlId(value) {\n    const newValue = value % this.url.length;\n    if (this._urlId !== newValue) {\n      this.fragmentError = 0;\n      this.loadError = 0;\n      this.details = undefined;\n      this._urlId = newValue;\n    }\n  }\n  get audioGroupId() {\n    var _this$audioGroupIds;\n    return (_this$audioGroupIds = this.audioGroupIds) == null ? void 0 : _this$audioGroupIds[this.urlId];\n  }\n  get textGroupId() {\n    var _this$textGroupIds;\n    return (_this$textGroupIds = this.textGroupIds) == null ? void 0 : _this$textGroupIds[this.urlId];\n  }\n  addFallback(data) {\n    this.url.push(data.url);\n    this._attrs.push(data.attrs);\n  }\n}\n\nfunction updateFromToPTS(fragFrom, fragTo) {\n  const fragToPTS = fragTo.startPTS;\n  // if we know startPTS[toIdx]\n  if (isFiniteNumber(fragToPTS)) {\n    // update fragment duration.\n    // it helps to fix drifts between playlist reported duration and fragment real duration\n    let duration = 0;\n    let frag;\n    if (fragTo.sn > fragFrom.sn) {\n      duration = fragToPTS - fragFrom.start;\n      frag = fragFrom;\n    } else {\n      duration = fragFrom.start - fragToPTS;\n      frag = fragTo;\n    }\n    if (frag.duration !== duration) {\n      frag.duration = duration;\n    }\n    // we dont know startPTS[toIdx]\n  } else if (fragTo.sn > fragFrom.sn) {\n    const contiguous = fragFrom.cc === fragTo.cc;\n    // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n    if (contiguous && fragFrom.minEndPTS) {\n      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n    } else {\n      fragTo.start = fragFrom.start + fragFrom.duration;\n    }\n  } else {\n    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n  }\n}\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n  const parsedMediaDuration = endPTS - startPTS;\n  if (parsedMediaDuration <= 0) {\n    logger.warn('Fragment should have a positive duration', frag);\n    endPTS = startPTS + frag.duration;\n    endDTS = startDTS + frag.duration;\n  }\n  let maxStartPTS = startPTS;\n  let minEndPTS = endPTS;\n  const fragStartPts = frag.startPTS;\n  const fragEndPts = frag.endPTS;\n  if (isFiniteNumber(fragStartPts)) {\n    // delta PTS between audio and video\n    const deltaPTS = Math.abs(fragStartPts - startPTS);\n    if (!isFiniteNumber(frag.deltaPTS)) {\n      frag.deltaPTS = deltaPTS;\n    } else {\n      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n    }\n    maxStartPTS = Math.max(startPTS, fragStartPts);\n    startPTS = Math.min(startPTS, fragStartPts);\n    startDTS = Math.min(startDTS, frag.startDTS);\n    minEndPTS = Math.min(endPTS, fragEndPts);\n    endPTS = Math.max(endPTS, fragEndPts);\n    endDTS = Math.max(endDTS, frag.endDTS);\n  }\n  const drift = startPTS - frag.start;\n  if (frag.start !== 0) {\n    frag.start = startPTS;\n  }\n  frag.duration = endPTS - frag.start;\n  frag.startPTS = startPTS;\n  frag.maxStartPTS = maxStartPTS;\n  frag.startDTS = startDTS;\n  frag.endPTS = endPTS;\n  frag.minEndPTS = minEndPTS;\n  frag.endDTS = endDTS;\n  const sn = frag.sn; // 'initSegment'\n  // exit if sn out of range\n  if (!details || sn < details.startSN || sn > details.endSN) {\n    return 0;\n  }\n  let i;\n  const fragIdx = sn - details.startSN;\n  const fragments = details.fragments;\n  // update frag reference in fragments array\n  // rationale is that fragments array might not contain this frag object.\n  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n  // if we don't update frag, we won't be able to propagate PTS info on the playlist\n  // resulting in invalid sliding computation\n  fragments[fragIdx] = frag;\n  // adjust fragment PTS/duration from seqnum-1 to frag 0\n  for (i = fragIdx; i > 0; i--) {\n    updateFromToPTS(fragments[i], fragments[i - 1]);\n  }\n\n  // adjust fragment PTS/duration from seqnum to last frag\n  for (i = fragIdx; i < fragments.length - 1; i++) {\n    updateFromToPTS(fragments[i], fragments[i + 1]);\n  }\n  if (details.fragmentHint) {\n    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n  }\n  details.PTSKnown = details.alignedSliding = true;\n  return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n  // Track the last initSegment processed. Initialize it to the last one on the timeline.\n  let currentInitSegment = null;\n  const oldFragments = oldDetails.fragments;\n  for (let i = oldFragments.length - 1; i >= 0; i--) {\n    const oldInit = oldFragments[i].initSegment;\n    if (oldInit) {\n      currentInitSegment = oldInit;\n      break;\n    }\n  }\n  if (oldDetails.fragmentHint) {\n    // prevent PTS and duration from being adjusted on the next hint\n    delete oldDetails.fragmentHint.endPTS;\n  }\n  // check if old/new playlists have fragments in common\n  // loop through overlapping SN and update startPTS , cc, and duration if any found\n  let ccOffset = 0;\n  let PTSFrag;\n  mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag) => {\n    if (oldFrag.relurl) {\n      // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n      // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n      // of the playlist.\n      ccOffset = oldFrag.cc - newFrag.cc;\n    }\n    if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n      newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n      newFrag.startDTS = oldFrag.startDTS;\n      newFrag.maxStartPTS = oldFrag.maxStartPTS;\n      newFrag.endPTS = oldFrag.endPTS;\n      newFrag.endDTS = oldFrag.endDTS;\n      newFrag.minEndPTS = oldFrag.minEndPTS;\n      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n      if (newFrag.duration) {\n        PTSFrag = newFrag;\n      }\n\n      // PTS is known when any segment has startPTS and endPTS\n      newDetails.PTSKnown = newDetails.alignedSliding = true;\n    }\n    newFrag.elementaryStreams = oldFrag.elementaryStreams;\n    newFrag.loader = oldFrag.loader;\n    newFrag.stats = oldFrag.stats;\n    newFrag.urlId = oldFrag.urlId;\n    if (oldFrag.initSegment) {\n      newFrag.initSegment = oldFrag.initSegment;\n      currentInitSegment = oldFrag.initSegment;\n    }\n  });\n  if (currentInitSegment) {\n    const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    fragmentsToCheck.forEach(frag => {\n      var _currentInitSegment;\n      if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl)) {\n        frag.initSegment = currentInitSegment;\n      }\n    });\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.deltaUpdateFailed = newDetails.fragments.some(frag => !frag);\n    if (newDetails.deltaUpdateFailed) {\n      logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n      for (let i = newDetails.skippedSegments; i--;) {\n        newDetails.fragments.shift();\n      }\n      newDetails.startSN = newDetails.fragments[0].sn;\n      newDetails.startCC = newDetails.fragments[0].cc;\n    } else if (newDetails.canSkipDateRanges) {\n      newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n    }\n  }\n  const newFragments = newDetails.fragments;\n  if (ccOffset) {\n    logger.warn('discontinuity sliding from playlist, take drift into account');\n    for (let i = 0; i < newFragments.length; i++) {\n      newFragments[i].cc += ccOffset;\n    }\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.startCC = newDetails.fragments[0].cc;\n  }\n\n  // Merge parts\n  mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {\n    newPart.elementaryStreams = oldPart.elementaryStreams;\n    newPart.stats = oldPart.stats;\n  });\n\n  // if at least one fragment contains PTS info, recompute PTS information for all fragments\n  if (PTSFrag) {\n    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n  } else {\n    // ensure that delta is within oldFragments range\n    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n    // in that case we also need to adjust start offset of all fragments\n    adjustSliding(oldDetails, newDetails);\n  }\n  if (newFragments.length) {\n    newDetails.totalduration = newDetails.edge - newFragments[0].start;\n  }\n  newDetails.driftStartTime = oldDetails.driftStartTime;\n  newDetails.driftStart = oldDetails.driftStart;\n  const advancedDateTime = newDetails.advancedDateTime;\n  if (newDetails.advanced && advancedDateTime) {\n    const edge = newDetails.edge;\n    if (!newDetails.driftStart) {\n      newDetails.driftStartTime = advancedDateTime;\n      newDetails.driftStart = edge;\n    }\n    newDetails.driftEndTime = advancedDateTime;\n    newDetails.driftEnd = edge;\n  } else {\n    newDetails.driftEndTime = oldDetails.driftEndTime;\n    newDetails.driftEnd = oldDetails.driftEnd;\n    newDetails.advancedDateTime = oldDetails.advancedDateTime;\n  }\n}\nfunction mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n  const dateRanges = _extends({}, oldDateRanges);\n  if (recentlyRemovedDateranges) {\n    recentlyRemovedDateranges.forEach(id => {\n      delete dateRanges[id];\n    });\n  }\n  Object.keys(deltaDateRanges).forEach(id => {\n    const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n    if (dateRange.isValid) {\n      dateRanges[id] = dateRange;\n    } else {\n      logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: \"${JSON.stringify(deltaDateRanges[id].attr)}\"`);\n    }\n  });\n  return dateRanges;\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n  if (oldParts && newParts) {\n    let delta = 0;\n    for (let i = 0, len = oldParts.length; i <= len; i++) {\n      const oldPart = oldParts[i];\n      const newPart = newParts[i + delta];\n      if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {\n        intersectionFn(oldPart, newPart);\n      } else {\n        delta--;\n      }\n    }\n  }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n  const skippedSegments = newDetails.skippedSegments;\n  const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n  const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n  const delta = newDetails.startSN - oldDetails.startSN;\n  const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n  const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n  for (let i = start; i <= end; i++) {\n    const oldFrag = oldFrags[delta + i];\n    let newFrag = newFrags[i];\n    if (skippedSegments && !newFrag && i < skippedSegments) {\n      // Fill in skipped segments in delta playlist\n      newFrag = newDetails.fragments[i] = oldFrag;\n    }\n    if (oldFrag && newFrag) {\n      intersectionFn(oldFrag, newFrag);\n    }\n  }\n}\nfunction adjustSliding(oldDetails, newDetails) {\n  const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n  const oldFragments = oldDetails.fragments;\n  if (delta < 0 || delta >= oldFragments.length) {\n    return;\n  }\n  addSliding(newDetails, oldFragments[delta].start);\n}\nfunction addSliding(details, start) {\n  if (start) {\n    const fragments = details.fragments;\n    for (let i = details.skippedSegments; i < fragments.length; i++) {\n      fragments[i].start += start;\n    }\n    if (details.fragmentHint) {\n      details.fragmentHint.start += start;\n    }\n  }\n}\nfunction computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {\n  let reloadInterval = 1000 * newDetails.targetduration;\n  if (newDetails.updated) {\n    // Use last segment duration when shorter than target duration and near live edge\n    const fragments = newDetails.fragments;\n    const liveEdgeMaxTargetDurations = 4;\n    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n      const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n      if (lastSegmentDuration < reloadInterval) {\n        reloadInterval = lastSegmentDuration;\n      }\n    }\n  } else {\n    // estimate = 'miss half average';\n    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n    // changed then it MUST wait for a period of one-half the target\n    // duration before retrying.\n    reloadInterval /= 2;\n  }\n  return Math.round(reloadInterval);\n}\nfunction getFragmentWithSN(level, sn, fragCurrent) {\n  if (!(level != null && level.details)) {\n    return null;\n  }\n  const levelDetails = level.details;\n  let fragment = levelDetails.fragments[sn - levelDetails.startSN];\n  if (fragment) {\n    return fragment;\n  }\n  fragment = levelDetails.fragmentHint;\n  if (fragment && fragment.sn === sn) {\n    return fragment;\n  }\n  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n    return fragCurrent;\n  }\n  return null;\n}\nfunction getPartWith(level, sn, partIndex) {\n  var _level$details;\n  if (!(level != null && level.details)) {\n    return null;\n  }\n  return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);\n}\nfunction findPart(partList, sn, partIndex) {\n  if (partList) {\n    for (let i = partList.length; i--;) {\n      const part = partList[i];\n      if (part.index === partIndex && part.fragment.sn === sn) {\n        return part;\n      }\n    }\n  }\n  return null;\n}\n\nfunction isTimeoutError(error) {\n  switch (error.details) {\n    case ErrorDetails.FRAG_LOAD_TIMEOUT:\n    case ErrorDetails.KEY_LOAD_TIMEOUT:\n    case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n    case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n      return true;\n  }\n  return false;\n}\nfunction getRetryConfig(loadPolicy, error) {\n  const isTimeout = isTimeoutError(error);\n  return loadPolicy.default[`${isTimeout ? 'timeout' : 'error'}Retry`];\n}\nfunction getRetryDelay(retryConfig, retryCount) {\n  // exponential backoff capped to max retry delay\n  const backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n  return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n}\nfunction getLoaderConfigWithoutReties(loderConfig) {\n  return _objectSpread2(_objectSpread2({}, loderConfig), {\n    errorRetry: null,\n    timeoutRetry: null\n  });\n}\nfunction shouldRetry(retryConfig, retryCount, isTimeout, httpStatus) {\n  return !!retryConfig && retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n}\nfunction retryForHttpStatus(httpStatus) {\n  // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n  return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n}\n\nconst BinarySearch = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param list The array to search.\n   * @param comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @returns the object if found, otherwise returns null\n   */\n  search: function (list, comparisonFn) {\n    let minIndex = 0;\n    let maxIndex = list.length - 1;\n    let currentIndex = null;\n    let currentElement = null;\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentElement = list[currentIndex];\n      const comparisonResult = comparisonFn(currentElement);\n      if (comparisonResult > 0) {\n        minIndex = currentIndex + 1;\n      } else if (comparisonResult < 0) {\n        maxIndex = currentIndex - 1;\n      } else {\n        return currentElement;\n      }\n    }\n    return null;\n  }\n};\n\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n * @param fragments - The array of candidate fragments\n * @param PDTValue - The PDT value which must be exceeded\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n */\nfunction findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n    return null;\n  }\n\n  // if less than start\n  const startPDT = fragments[0].programDateTime;\n  if (PDTValue < (startPDT || 0)) {\n    return null;\n  }\n  const endPDT = fragments[fragments.length - 1].endProgramDateTime;\n  if (PDTValue >= (endPDT || 0)) {\n    return null;\n  }\n  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n  for (let seg = 0; seg < fragments.length; ++seg) {\n    const frag = fragments[seg];\n    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n      return frag;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param fragPrevious - The last frag successfully appended\n * @param fragments - The array of candidate fragments\n * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns a matching fragment or null\n */\nfunction findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0) {\n  let fragNext = null;\n  if (fragPrevious) {\n    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n  } else if (bufferEnd === 0 && fragments[0].start === 0) {\n    fragNext = fragments[0];\n  }\n  // Prefer the next fragment if it's within tolerance\n  if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n    return fragNext;\n  }\n  // We might be seeking past the tolerance so find the best match\n  const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n    return foundFragment;\n  }\n  // If no match was found return the next fragment after fragPrevious, or null\n  return fragNext;\n}\n\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param candidate - The fragment to test\n * @param bufferEnd - The end of the current buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns 0 if it matches, 1 if too low, -1 if too high\n */\nfunction fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {\n  // eagerly accept an accurate match (no tolerance)\n  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n    return 0;\n  }\n  // offset should be within fragment boundary - config.maxFragLookUpTolerance\n  // this is to cope with situations like\n  // bufferEnd = 9.991\n  // frag[] : [0,10]\n  // frag[1] : [10,20]\n  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n  //              frag start               frag start+duration\n  //                  |-----------------------------|\n  //              <--->                         <--->\n  //  ...--------><-----------------------------><---------....\n  // previous frag         matching fragment         next frag\n  //  return -1             return 0                 return 1\n  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n    return 1;\n  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param candidate - The fragment to test\n * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns true if contiguous, false otherwise\n */\nfunction pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n  // endProgramDateTime can be null, default to zero\n  const endProgramDateTime = candidate.endProgramDateTime || 0;\n  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findFragWithCC(fragments, cc) {\n  return BinarySearch.search(fragments, candidate => {\n    if (candidate.cc < cc) {\n      return 1;\n    } else if (candidate.cc > cc) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n}\n\nconst RENDITION_PENALTY_DURATION_MS = 300000;\nvar NetworkErrorAction = {\n  DoNothing: 0,\n  SendEndCallback: 1,\n  SendAlternateToPenaltyBox: 2,\n  RemoveAlternatePermanently: 3,\n  InsertDiscontinuity: 4,\n  RetryRequest: 5\n};\nvar ErrorActionFlags = {\n  None: 0,\n  MoveAllAlternatesMatchingHost: 1,\n  MoveAllAlternatesMatchingHDCP: 2,\n  SwitchToSDR: 4\n}; // Reserved for future use\nclass ErrorController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n    this.log = void 0;\n    this.warn = void 0;\n    this.error = void 0;\n    this.hls = hls;\n    this.log = logger.log.bind(logger, `[info]:`);\n    this.warn = logger.warn.bind(logger, `[warning]:`);\n    this.error = logger.error.bind(logger, `[error]:`);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.ERROR, this.onErrorOut, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    // @ts-ignore\n    this.hls = null;\n    this.penalizedRenditions = {};\n  }\n  startLoad(startPosition) {\n    this.playlistError = 0;\n  }\n  stopLoad() {}\n  getVariantLevelIndex(frag) {\n    return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n  }\n  onManifestLoading() {\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n  }\n  onLevelUpdated() {\n    this.playlistError = 0;\n  }\n  onError(event, data) {\n    var _data$frag, _data$level;\n    if (data.fatal) {\n      return;\n    }\n    const hls = this.hls;\n    const context = data.context;\n    switch (data.details) {\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        data.errorAction = this.getFragRetryOrSwitchAction(data);\n        return;\n      case ErrorDetails.FRAG_PARSING_ERROR:\n        // ignore empty segment errors marked as gap\n        if ((_data$frag = data.frag) != null && _data$frag.gap) {\n          data.errorAction = {\n            action: NetworkErrorAction.DoNothing,\n            flags: ErrorActionFlags.None\n          };\n          return;\n        }\n      // falls through\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n        {\n          // Switch level if possible, otherwise allow retry count to reach max error retries\n          data.errorAction = this.getFragRetryOrSwitchAction(data);\n          data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n          return;\n        }\n      case ErrorDetails.LEVEL_EMPTY_ERROR:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        {\n          var _data$context, _data$context$levelDe;\n          // Only retry when empty and live\n          const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n          if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n          } else {\n            // Escalate to fatal if not retrying or switching\n            data.levelRetry = false;\n            data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n          }\n        }\n        return;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        if (typeof (context == null ? void 0 : context.level) === 'number') {\n          data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n        }\n        return;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.SUBTITLE_LOAD_ERROR:\n      case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n        if (context) {\n          const level = hls.levels[hls.loadLevel];\n          if (level && (context.type === PlaylistContextType.AUDIO_TRACK && context.groupId === level.audioGroupId || context.type === PlaylistContextType.SUBTITLE_TRACK && context.groupId === level.textGroupId)) {\n            // Perform Pathway switch or Redundant failover if possible for fastest recovery\n            // otherwise allow playlist retry count to reach max error retries\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n            data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n            return;\n          }\n        }\n        return;\n      case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n        {\n          const level = hls.levels[hls.loadLevel];\n          const restrictedHdcpLevel = level == null ? void 0 : level.attrs['HDCP-LEVEL'];\n          if (restrictedHdcpLevel) {\n            data.errorAction = {\n              action: NetworkErrorAction.SendAlternateToPenaltyBox,\n              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n              hdcpLevel: restrictedHdcpLevel\n            };\n          }\n        }\n        return;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.REMUX_ALLOC_ERROR:\n        data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n        return;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n      case ErrorDetails.BUFFER_APPENDING_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n      case ErrorDetails.BUFFER_FULL_ERROR:\n      case ErrorDetails.LEVEL_SWITCH_ERROR:\n      case ErrorDetails.BUFFER_STALLED_ERROR:\n      case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n      case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n        data.errorAction = {\n          action: NetworkErrorAction.DoNothing,\n          flags: ErrorActionFlags.None\n        };\n        return;\n    }\n    if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n      const levelIndex = this.getVariantLevelIndex(data.frag);\n      // Do not retry level. Escalate to fatal if switching levels fails.\n      data.levelRetry = false;\n      data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n      return;\n    }\n  }\n  getPlaylistRetryOrSwitchAction(data, levelIndex) {\n    var _data$response;\n    const hls = this.hls;\n    const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n    const retryCount = this.playlistError++;\n    const httpStatus = (_data$response = data.response) == null ? void 0 : _data$response.code;\n    const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), httpStatus);\n    if (retry) {\n      return {\n        action: NetworkErrorAction.RetryRequest,\n        flags: ErrorActionFlags.None,\n        retryConfig,\n        retryCount\n      };\n    }\n    const errorAction = this.getLevelSwitchAction(data, levelIndex);\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = retryCount;\n    }\n    return errorAction;\n  }\n  getFragRetryOrSwitchAction(data) {\n    const hls = this.hls;\n    // Share fragment error count accross media options (main, audio, subs)\n    // This allows for level based rendition switching when media option assets fail\n    const variantLevelIndex = this.getVariantLevelIndex(data.frag);\n    const level = hls.levels[variantLevelIndex];\n    const {\n      fragLoadPolicy,\n      keyLoadPolicy\n    } = hls.config;\n    const retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);\n    const fragmentErrors = hls.levels.reduce((acc, level) => acc + level.fragmentError, 0);\n    // Switch levels when out of retried or level index out of bounds\n    if (level) {\n      var _data$response2;\n      if (data.details !== ErrorDetails.FRAG_GAP) {\n        level.fragmentError++;\n      }\n      const httpStatus = (_data$response2 = data.response) == null ? void 0 : _data$response2.code;\n      const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), httpStatus);\n      if (retry) {\n        return {\n          action: NetworkErrorAction.RetryRequest,\n          flags: ErrorActionFlags.None,\n          retryConfig,\n          retryCount: fragmentErrors\n        };\n      }\n    }\n    // Reach max retry count, or Missing level reference\n    // Switch to valid index\n    const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n    // Add retry details to allow skipping of FRAG_PARSING_ERROR\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = fragmentErrors;\n    }\n    return errorAction;\n  }\n  getLevelSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    if (levelIndex === null || levelIndex === undefined) {\n      levelIndex = hls.loadLevel;\n    }\n    const level = this.hls.levels[levelIndex];\n    if (level) {\n      level.loadError++;\n      if (hls.autoLevelEnabled) {\n        var _data$frag2, _data$context2;\n        // Search for next level to retry\n        let nextLevel = -1;\n        const {\n          levels,\n          loadLevel,\n          minAutoLevel,\n          maxAutoLevel\n        } = hls;\n        const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n        const {\n          type: playlistErrorType,\n          groupId: playlistErrorGroupId\n        } = (_data$context2 = data.context) != null ? _data$context2 : {};\n        for (let i = levels.length; i--;) {\n          const candidate = (i + loadLevel) % levels.length;\n          if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n            const levelCandidate = levels[candidate];\n            // Skip level switch if GAP tag is found in next level at same position\n            if (data.details === ErrorDetails.FRAG_GAP && data.frag) {\n              const levelDetails = levels[candidate].details;\n              if (levelDetails) {\n                const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n                if (fragCandidate != null && fragCandidate.gap) {\n                  continue;\n                }\n              }\n            } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && playlistErrorGroupId === levelCandidate.audioGroupId || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && playlistErrorGroupId === levelCandidate.textGroupId) {\n              // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n              continue;\n            } else if (fragErrorType === PlaylistLevelType.AUDIO && level.audioGroupId === levelCandidate.audioGroupId || fragErrorType === PlaylistLevelType.SUBTITLE && level.textGroupId === levelCandidate.textGroupId) {\n              // For audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n              continue;\n            }\n            nextLevel = candidate;\n            break;\n          }\n        }\n        if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n          data.levelRetry = true;\n          this.playlistError = 0;\n          return {\n            action: NetworkErrorAction.SendAlternateToPenaltyBox,\n            flags: ErrorActionFlags.None,\n            nextAutoLevel: nextLevel\n          };\n        }\n      }\n    }\n    // No levels to switch / Manual level selection / Level not found\n    // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n    return {\n      action: NetworkErrorAction.SendAlternateToPenaltyBox,\n      flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n    };\n  }\n  onErrorOut(event, data) {\n    var _data$errorAction;\n    switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n      case NetworkErrorAction.DoNothing:\n        break;\n      case NetworkErrorAction.SendAlternateToPenaltyBox:\n        this.sendAlternateToPenaltyBox(data);\n        if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n          data.fatal = true;\n        }\n        break;\n    }\n    if (data.fatal) {\n      this.hls.stopLoad();\n      return;\n    }\n  }\n  sendAlternateToPenaltyBox(data) {\n    const hls = this.hls;\n    const errorAction = data.errorAction;\n    if (!errorAction) {\n      return;\n    }\n    const {\n      flags,\n      hdcpLevel,\n      nextAutoLevel\n    } = errorAction;\n    switch (flags) {\n      case ErrorActionFlags.None:\n        this.switchLevel(data, nextAutoLevel);\n        break;\n      case ErrorActionFlags.MoveAllAlternatesMatchingHost:\n        {\n          // Handle Redundant Levels here. Pathway switching is handled by content-steering-controller\n          if (!errorAction.resolved) {\n            errorAction.resolved = this.redundantFailover(data);\n          }\n        }\n        break;\n      case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n        if (hdcpLevel) {\n          hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n          errorAction.resolved = true;\n        }\n        this.warn(`Restricting playback to HDCP-LEVEL of \"${hls.maxHdcpLevel}\" or lower`);\n        break;\n    }\n    // If not resolved by previous actions try to switch to next level\n    if (!errorAction.resolved) {\n      this.switchLevel(data, nextAutoLevel);\n    }\n  }\n  switchLevel(data, levelIndex) {\n    if (levelIndex !== undefined && data.errorAction) {\n      this.warn(`switching to level ${levelIndex} after ${data.details}`);\n      this.hls.nextAutoLevel = levelIndex;\n      data.errorAction.resolved = true;\n      // Stream controller is responsible for this but won't switch on false start\n      this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n    }\n  }\n  redundantFailover(data) {\n    const {\n      hls,\n      penalizedRenditions\n    } = this;\n    const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n    const level = hls.levels[levelIndex];\n    const redundantLevels = level.url.length;\n    const errorUrlId = data.frag ? data.frag.urlId : level.urlId;\n    if (level.urlId === errorUrlId && (!data.frag || level.details)) {\n      this.penalizeRendition(level, data);\n    }\n    for (let i = 1; i < redundantLevels; i++) {\n      const newUrlId = (errorUrlId + i) % redundantLevels;\n      const penalizedRendition = penalizedRenditions[newUrlId];\n      // Check if rendition is penalized and skip if it is a bad fit for failover\n      if (!penalizedRendition || checkExpired(penalizedRendition, data, penalizedRenditions[errorUrlId])) {\n        // delete penalizedRenditions[newUrlId];\n        // Update the url id of all levels so that we stay on the same set of variants when level switching\n        this.warn(`Switching to Redundant Stream ${newUrlId + 1}/${redundantLevels}: \"${level.url[newUrlId]}\" after ${data.details}`);\n        this.playlistError = 0;\n        hls.levels.forEach(lv => {\n          lv.urlId = newUrlId;\n        });\n        hls.nextLoadLevel = levelIndex;\n        return true;\n      }\n    }\n    return false;\n  }\n  penalizeRendition(level, data) {\n    const {\n      penalizedRenditions\n    } = this;\n    const penalizedRendition = penalizedRenditions[level.urlId] || {\n      lastErrorPerfMs: 0,\n      errors: [],\n      details: undefined\n    };\n    penalizedRendition.lastErrorPerfMs = performance.now();\n    penalizedRendition.errors.push(data);\n    penalizedRendition.details = level.details;\n    penalizedRenditions[level.urlId] = penalizedRendition;\n  }\n}\nfunction checkExpired(penalizedRendition, data, currentPenaltyState) {\n  // Expire penalty for switching back to rendition after RENDITION_PENALTY_DURATION_MS\n  if (performance.now() - penalizedRendition.lastErrorPerfMs > RENDITION_PENALTY_DURATION_MS) {\n    return true;\n  }\n  // Expire penalty on GAP tag error if rendition has no GAP at position (does not cover media tracks)\n  const lastErrorDetails = penalizedRendition.details;\n  if (data.details === ErrorDetails.FRAG_GAP && lastErrorDetails && data.frag) {\n    const position = data.frag.start;\n    const candidateFrag = findFragmentByPTS(null, lastErrorDetails.fragments, position);\n    if (candidateFrag && !candidateFrag.gap) {\n      return true;\n    }\n  }\n  // Expire penalty if there are more errors in currentLevel than in penalizedRendition\n  if (currentPenaltyState && penalizedRendition.errors.length < currentPenaltyState.errors.length) {\n    const lastCandidateError = penalizedRendition.errors[penalizedRendition.errors.length - 1];\n    if (lastErrorDetails && lastCandidateError.frag && data.frag && Math.abs(lastCandidateError.frag.start - data.frag.start) > lastErrorDetails.targetduration * 3) {\n      return true;\n    }\n  }\n  return false;\n}\n\nclass BasePlaylistController {\n  constructor(hls, logPrefix) {\n    this.hls = void 0;\n    this.timer = -1;\n    this.requestScheduled = -1;\n    this.canLoad = false;\n    this.log = void 0;\n    this.warn = void 0;\n    this.log = logger.log.bind(logger, `${logPrefix}:`);\n    this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n    this.hls = hls;\n  }\n  destroy() {\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.log = this.warn = null;\n  }\n  clearTimer() {\n    clearTimeout(this.timer);\n    this.timer = -1;\n  }\n  startLoad() {\n    this.canLoad = true;\n    this.requestScheduled = -1;\n    this.loadPlaylist();\n  }\n  stopLoad() {\n    this.canLoad = false;\n    this.clearTimer();\n  }\n  switchParams(playlistUri, previous) {\n    const renditionReports = previous == null ? void 0 : previous.renditionReports;\n    if (renditionReports) {\n      let foundIndex = -1;\n      for (let i = 0; i < renditionReports.length; i++) {\n        const attr = renditionReports[i];\n        let uri;\n        try {\n          uri = new self.URL(attr.URI, previous.url).href;\n        } catch (error) {\n          logger.warn(`Could not construct new URL for Rendition Report: ${error}`);\n          uri = attr.URI || '';\n        }\n        // Use exact match. Otherwise, the last partial match, if any, will be used\n        // (Playlist URI includes a query string that the Rendition Report does not)\n        if (uri === playlistUri) {\n          foundIndex = i;\n          break;\n        } else if (uri === playlistUri.substring(0, uri.length)) {\n          foundIndex = i;\n        }\n      }\n      if (foundIndex !== -1) {\n        const attr = renditionReports[foundIndex];\n        const msn = parseInt(attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);\n        let part = parseInt(attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);\n        if (this.hls.config.lowLatencyMode) {\n          const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n          if (part >= 0 && currentGoal > previous.partTarget) {\n            part += 1;\n          }\n        }\n        return new HlsUrlParameters(msn, part >= 0 ? part : undefined, HlsSkip.No);\n      }\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    if (this.requestScheduled === -1) {\n      this.requestScheduled = self.performance.now();\n    }\n    // Loading is handled by the subclasses\n  }\n\n  shouldLoadPlaylist(playlist) {\n    return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n  }\n  shouldReloadPlaylist(playlist) {\n    return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);\n  }\n  playlistLoaded(index, data, previousDetails) {\n    const {\n      details,\n      stats\n    } = data;\n\n    // Set last updated date-time\n    const now = self.performance.now();\n    const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n    details.advancedDateTime = Date.now() - elapsed;\n\n    // if current playlist is a live playlist, arm a timer to reload it\n    if (details.live || previousDetails != null && previousDetails.live) {\n      details.reloaded(previousDetails);\n      if (previousDetails) {\n        this.log(`live playlist ${index} ${details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : details.updated ? 'UPDATED' : 'MISSED'}`);\n      }\n      // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n      if (previousDetails && details.fragments.length > 0) {\n        mergeDetails(previousDetails, details);\n      }\n      if (!this.canLoad || !details.live) {\n        return;\n      }\n      let deliveryDirectives;\n      let msn = undefined;\n      let part = undefined;\n      if (details.canBlockReload && details.endSN && details.advanced) {\n        // Load level with LL-HLS delivery directives\n        const lowLatencyMode = this.hls.config.lowLatencyMode;\n        const lastPartSn = details.lastPartSn;\n        const endSn = details.endSN;\n        const lastPartIndex = details.lastPartIndex;\n        const hasParts = lastPartIndex !== -1;\n        const lastPart = lastPartSn === endSn;\n        // When low latency mode is disabled, we'll skip part requests once the last part index is found\n        const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n        if (hasParts) {\n          msn = lastPart ? endSn + 1 : lastPartSn;\n          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n        } else {\n          msn = endSn + 1;\n        }\n        // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n        // Update directives to obtain the Playlist that has the estimated additional duration of media\n        const lastAdvanced = details.age;\n        const cdnAge = lastAdvanced + details.ageHeader;\n        let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n        if (currentGoal > 0) {\n          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n            // If we attempted to get the next or latest playlist update, but currentGoal increased,\n            // then we either can't catchup, or the \"age\" header cannot be trusted.\n            this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);\n            currentGoal = 0;\n          } else {\n            const segments = Math.floor(currentGoal / details.targetduration);\n            msn += segments;\n            if (part !== undefined) {\n              const parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n              part += parts;\n            }\n            this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);\n          }\n          details.tuneInGoal = currentGoal;\n        }\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n        if (lowLatencyMode || !lastPart) {\n          this.loadPlaylist(deliveryDirectives);\n          return;\n        }\n      } else if (details.canBlockReload || details.canSkipUntil) {\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n      }\n      const bufferInfo = this.hls.mainForwardBufferInfo;\n      const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n      const distanceToLiveEdgeMs = (details.edge - position) * 1000;\n      const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n      if (details.updated && now > this.requestScheduled + reloadInterval) {\n        this.requestScheduled = stats.loading.start;\n      }\n      if (msn !== undefined && details.canBlockReload) {\n        this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n      } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {\n        this.requestScheduled = now;\n      } else if (this.requestScheduled - now <= 0) {\n        this.requestScheduled += reloadInterval;\n      }\n      let estimatedTimeUntilUpdate = this.requestScheduled - now;\n      estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n      this.log(`reload live playlist ${index} in ${Math.round(estimatedTimeUntilUpdate)} ms`);\n      // this.log(\n      //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n      // reload in ${estimatedTimeUntilUpdate / 1000}\n      // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n      // diff ${\n      //   (reloadInterval -\n      //     (estimatedTimeUntilUpdate +\n      //       stats.loading.end -\n      //       stats.loading.start)) /\n      //   1000\n      // }\n      // reload interval ${reloadInterval / 1000}\n      // target duration ${details.targetduration}\n      // distance to edge ${distanceToLiveEdgeMs / 1000}`\n      // );\n\n      this.timer = self.setTimeout(() => this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);\n    } else {\n      this.clearTimer();\n    }\n  }\n  getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n    let skip = getSkipValue(details, msn);\n    if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n      msn = previousDeliveryDirectives.msn;\n      part = previousDeliveryDirectives.part;\n      skip = HlsSkip.No;\n    }\n    return new HlsUrlParameters(msn, part, skip);\n  }\n  checkRetry(errorEvent) {\n    const errorDetails = errorEvent.details;\n    const isTimeout = isTimeoutError(errorEvent);\n    const errorAction = errorEvent.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n    if (retry) {\n      var _errorEvent$context;\n      this.requestScheduled = -1;\n      if (retryCount >= retryConfig.maxNumRetry) {\n        return false;\n      }\n      if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n        // The LL-HLS request already timed out so retry immediately\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" without delivery-directives`);\n        this.loadPlaylist();\n      } else {\n        const delay = getRetryDelay(retryConfig, retryCount);\n        // Schedule level/track reload\n        this.timer = self.setTimeout(() => this.loadPlaylist(), delay);\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" in ${delay}ms`);\n      }\n      // `levelRetry = true` used to inform other controllers that a retry is happening\n      errorEvent.levelRetry = true;\n      errorAction.resolved = true;\n    }\n    return retry;\n  }\n}\n\nlet chromeOrFirefox;\nclass LevelController extends BasePlaylistController {\n  constructor(hls, contentSteeringController) {\n    super(hls, '[level-controller]');\n    this._levels = [];\n    this._firstLevel = -1;\n    this._startLevel = void 0;\n    this.currentLevel = null;\n    this.currentLevelIndex = -1;\n    this.manualLevelIndex = -1;\n    this.steering = void 0;\n    this.onParsedComplete = void 0;\n    this.steering = contentSteeringController;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.steering = null;\n    this.resetLevels();\n    super.destroy();\n  }\n  startLoad() {\n    const levels = this._levels;\n\n    // clean up live level details to force reload them, and reset load errors\n    levels.forEach(level => {\n      level.loadError = 0;\n      level.fragmentError = 0;\n    });\n    super.startLoad();\n  }\n  resetLevels() {\n    this._startLevel = undefined;\n    this.manualLevelIndex = -1;\n    this.currentLevelIndex = -1;\n    this.currentLevel = null;\n    this._levels = [];\n  }\n  onManifestLoading(event, data) {\n    this.resetLevels();\n  }\n  onManifestLoaded(event, data) {\n    const levels = [];\n    const levelSet = {};\n    let levelFromSet;\n\n    // regroup redundant levels together\n    data.levels.forEach(levelParsed => {\n      var _levelParsed$audioCod;\n      const attributes = levelParsed.attrs;\n\n      // erase audio codec info if browser does not support mp4a.40.34.\n      // demuxer will autodetect codec and fallback to mpeg/audio\n      if (((_levelParsed$audioCod = levelParsed.audioCodec) == null ? void 0 : _levelParsed$audioCod.indexOf('mp4a.40.34')) !== -1) {\n        chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));\n        if (chromeOrFirefox) {\n          levelParsed.audioCodec = undefined;\n        }\n      }\n      const {\n        AUDIO,\n        CODECS,\n        'FRAME-RATE': FRAMERATE,\n        'PATHWAY-ID': PATHWAY,\n        RESOLUTION,\n        SUBTITLES\n      } = attributes;\n      const contentSteeringPrefix = `${PATHWAY || '.'}-` ;\n      const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}`;\n      levelFromSet = levelSet[levelKey];\n      if (!levelFromSet) {\n        levelFromSet = new Level(levelParsed);\n        levelSet[levelKey] = levelFromSet;\n        levels.push(levelFromSet);\n      } else {\n        levelFromSet.addFallback(levelParsed);\n      }\n      addGroupId(levelFromSet, 'audio', AUDIO);\n      addGroupId(levelFromSet, 'text', SUBTITLES);\n    });\n    this.filterAndSortMediaOptions(levels, data);\n  }\n  filterAndSortMediaOptions(unfilteredLevels, data) {\n    let audioTracks = [];\n    let subtitleTracks = [];\n    let resolutionFound = false;\n    let videoCodecFound = false;\n    let audioCodecFound = false;\n\n    // only keep levels with supported audio/video codecs\n    let levels = unfilteredLevels.filter(({\n      audioCodec,\n      videoCodec,\n      width,\n      height,\n      unknownCodecs\n    }) => {\n      resolutionFound || (resolutionFound = !!(width && height));\n      videoCodecFound || (videoCodecFound = !!videoCodec);\n      audioCodecFound || (audioCodecFound = !!audioCodec);\n      return !(unknownCodecs != null && unknownCodecs.length) && (!audioCodec || isCodecSupportedInMp4(audioCodec, 'audio')) && (!videoCodec || isCodecSupportedInMp4(videoCodec, 'video'));\n    });\n\n    // remove audio-only level if we also have levels with video codecs or RESOLUTION signalled\n    if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n      levels = levels.filter(({\n        videoCodec,\n        width,\n        height\n      }) => !!videoCodec || !!(width && height));\n    }\n    if (levels.length === 0) {\n      // Dispatch error after MANIFEST_LOADED is done propagating\n      Promise.resolve().then(() => {\n        if (this.hls) {\n          const error = new Error('no level with compatible codecs found in manifest');\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n            fatal: true,\n            url: data.url,\n            error,\n            reason: error.message\n          });\n        }\n      });\n      return;\n    }\n    if (data.audioTracks) {\n      audioTracks = data.audioTracks.filter(track => !track.audioCodec || isCodecSupportedInMp4(track.audioCodec, 'audio'));\n      // Assign ids after filtering as array indices by group-id\n      assignTrackIdsByGroup(audioTracks);\n    }\n    if (data.subtitles) {\n      subtitleTracks = data.subtitles;\n      assignTrackIdsByGroup(subtitleTracks);\n    }\n    // start bitrate is the first bitrate of the manifest\n    const unsortedLevels = levels.slice(0);\n    // sort levels from lowest to highest\n    levels.sort((a, b) => {\n      if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n        return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n      }\n      if (a.bitrate !== b.bitrate) {\n        return a.bitrate - b.bitrate;\n      }\n      if (a.attrs['FRAME-RATE'] !== b.attrs['FRAME-RATE']) {\n        return a.attrs.decimalFloatingPoint('FRAME-RATE') - b.attrs.decimalFloatingPoint('FRAME-RATE');\n      }\n      if (a.attrs.SCORE !== b.attrs.SCORE) {\n        return a.attrs.decimalFloatingPoint('SCORE') - b.attrs.decimalFloatingPoint('SCORE');\n      }\n      if (resolutionFound && a.height !== b.height) {\n        return a.height - b.height;\n      }\n      return 0;\n    });\n    let firstLevelInPlaylist = unsortedLevels[0];\n    if (this.steering) {\n      levels = this.steering.filterParsedLevels(levels);\n      if (levels.length !== unsortedLevels.length) {\n        for (let i = 0; i < unsortedLevels.length; i++) {\n          if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n            firstLevelInPlaylist = unsortedLevels[i];\n            break;\n          }\n        }\n      }\n    }\n    this._levels = levels;\n\n    // find index of first level in sorted levels\n    for (let i = 0; i < levels.length; i++) {\n      if (levels[i] === firstLevelInPlaylist) {\n        this._firstLevel = i;\n        this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelInPlaylist.bitrate}`);\n        break;\n      }\n    }\n\n    // Audio is only alternate if manifest include a URI along with the audio group tag,\n    // and this is not an audio-only stream where levels contain audio-only\n    const audioOnly = audioCodecFound && !videoCodecFound;\n    const edata = {\n      levels,\n      audioTracks,\n      subtitleTracks,\n      sessionData: data.sessionData,\n      sessionKeys: data.sessionKeys,\n      firstLevel: this._firstLevel,\n      stats: data.stats,\n      audio: audioCodecFound,\n      video: videoCodecFound,\n      altAudio: !audioOnly && audioTracks.some(t => !!t.url)\n    };\n    this.hls.trigger(Events.MANIFEST_PARSED, edata);\n\n    // Initiate loading after all controllers have received MANIFEST_PARSED\n    if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n      this.hls.startLoad(this.hls.config.startPosition);\n    }\n  }\n  get levels() {\n    if (this._levels.length === 0) {\n      return null;\n    }\n    return this._levels;\n  }\n  get level() {\n    return this.currentLevelIndex;\n  }\n  set level(newLevel) {\n    const levels = this._levels;\n    if (levels.length === 0) {\n      return;\n    }\n    // check if level idx is valid\n    if (newLevel < 0 || newLevel >= levels.length) {\n      // invalid level id given, trigger error\n      const error = new Error('invalid level idx');\n      const fatal = newLevel < 0;\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.LEVEL_SWITCH_ERROR,\n        level: newLevel,\n        fatal,\n        error,\n        reason: error.message\n      });\n      if (fatal) {\n        return;\n      }\n      newLevel = Math.min(newLevel, levels.length - 1);\n    }\n    const lastLevelIndex = this.currentLevelIndex;\n    const lastLevel = this.currentLevel;\n    const lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n    const level = levels[newLevel];\n    const pathwayId = level.attrs['PATHWAY-ID'];\n    this.currentLevelIndex = newLevel;\n    this.currentLevel = level;\n    if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {\n      return;\n    }\n    this.log(`Switching to level ${newLevel}${pathwayId ? ' with Pathway ' + pathwayId : ''} from level ${lastLevelIndex}${lastPathwayId ? ' with Pathway ' + lastPathwayId : ''}`);\n    const levelSwitchingData = _extends({}, level, {\n      level: newLevel,\n      maxBitrate: level.maxBitrate,\n      attrs: level.attrs,\n      uri: level.uri,\n      urlId: level.urlId\n    });\n    // @ts-ignore\n    delete levelSwitchingData._attrs;\n    // @ts-ignore\n    delete levelSwitchingData._urlId;\n    this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n    // check if we need to load playlist for this level\n    const levelDetails = level.details;\n    if (!levelDetails || levelDetails.live) {\n      // level not retrieved yet, or live playlist we need to (re)load it\n      const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);\n      this.loadPlaylist(hlsUrlParameters);\n    }\n  }\n  get manualLevel() {\n    return this.manualLevelIndex;\n  }\n  set manualLevel(newLevel) {\n    this.manualLevelIndex = newLevel;\n    if (this._startLevel === undefined) {\n      this._startLevel = newLevel;\n    }\n    if (newLevel !== -1) {\n      this.level = newLevel;\n    }\n  }\n  get firstLevel() {\n    return this._firstLevel;\n  }\n  set firstLevel(newLevel) {\n    this._firstLevel = newLevel;\n  }\n  get startLevel() {\n    // hls.startLevel takes precedence over config.startLevel\n    // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)\n    if (this._startLevel === undefined) {\n      const configStartLevel = this.hls.config.startLevel;\n      if (configStartLevel !== undefined) {\n        return configStartLevel;\n      } else {\n        return this._firstLevel;\n      }\n    } else {\n      return this._startLevel;\n    }\n  }\n  set startLevel(newLevel) {\n    this._startLevel = newLevel;\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n      this.checkRetry(data);\n    }\n  }\n\n  // reset errors on the successful load of a fragment\n  onFragLoaded(event, {\n    frag\n  }) {\n    if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n      const level = this._levels[frag.level];\n      if (level !== undefined) {\n        level.loadError = 0;\n      }\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _data$deliveryDirecti2;\n    const {\n      level,\n      details\n    } = data;\n    const curLevel = this._levels[level];\n    if (!curLevel) {\n      var _data$deliveryDirecti;\n      this.warn(`Invalid level index ${level}`);\n      if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n        details.deltaUpdateFailed = true;\n      }\n      return;\n    }\n\n    // only process level loaded events matching with expected level\n    if (level === this.currentLevelIndex) {\n      // reset level load error counter on successful level loaded only if there is no issues with fragments\n      if (curLevel.fragmentError === 0) {\n        curLevel.loadError = 0;\n      }\n      this.playlistLoaded(level, data, curLevel.details);\n    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n      // received a delta playlist update that cannot be merged\n      details.deltaUpdateFailed = true;\n    }\n  }\n  onAudioTrackSwitched(event, data) {\n    const currentLevel = this.currentLevel;\n    if (!currentLevel) {\n      return;\n    }\n    const audioGroupId = this.hls.audioTracks[data.id].groupId;\n    if (currentLevel.audioGroupIds && currentLevel.audioGroupId !== audioGroupId) {\n      let urlId = -1;\n      for (let i = 0; i < currentLevel.audioGroupIds.length; i++) {\n        if (currentLevel.audioGroupIds[i] === audioGroupId) {\n          urlId = i;\n          break;\n        }\n      }\n      if (urlId !== -1 && urlId !== currentLevel.urlId) {\n        currentLevel.urlId = urlId;\n        if (this.canLoad) {\n          this.startLoad();\n        }\n      }\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const currentLevelIndex = this.currentLevelIndex;\n    const currentLevel = this.currentLevel;\n    if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {\n      const id = currentLevel.urlId;\n      let url = currentLevel.uri;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      const pathwayId = currentLevel.attrs['PATHWAY-ID'];\n      this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''} with${pathwayId ? ' Pathway ' + pathwayId : ''} URI ${id + 1}/${currentLevel.url.length} ${url}`);\n\n      // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n      // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n      this.clearTimer();\n      this.hls.trigger(Events.LEVEL_LOADING, {\n        url,\n        level: currentLevelIndex,\n        id,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n  get nextLoadLevel() {\n    if (this.manualLevelIndex !== -1) {\n      return this.manualLevelIndex;\n    } else {\n      return this.hls.nextAutoLevel;\n    }\n  }\n  set nextLoadLevel(nextLevel) {\n    this.level = nextLevel;\n    if (this.manualLevelIndex === -1) {\n      this.hls.nextAutoLevel = nextLevel;\n    }\n  }\n  removeLevel(levelIndex, urlId) {\n    const filterLevelAndGroupByIdIndex = (url, id) => id !== urlId;\n    const levels = this._levels.filter((level, index) => {\n      if (index !== levelIndex) {\n        return true;\n      }\n      if (level.url.length > 1 && urlId !== undefined) {\n        level.url = level.url.filter(filterLevelAndGroupByIdIndex);\n        if (level.audioGroupIds) {\n          level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n        if (level.textGroupIds) {\n          level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n        level.urlId = 0;\n        return true;\n      }\n      if (this.steering) {\n        this.steering.removeLevel(level);\n      }\n      return false;\n    });\n    this.hls.trigger(Events.LEVELS_UPDATED, {\n      levels\n    });\n  }\n  onLevelsUpdated(event, {\n    levels\n  }) {\n    levels.forEach((level, index) => {\n      const {\n        details\n      } = level;\n      if (details != null && details.fragments) {\n        details.fragments.forEach(fragment => {\n          fragment.level = index;\n        });\n      }\n    });\n    this._levels = levels;\n  }\n}\nfunction addGroupId(level, type, id) {\n  if (!id) {\n    return;\n  }\n  if (type === 'audio') {\n    if (!level.audioGroupIds) {\n      level.audioGroupIds = [];\n    }\n    level.audioGroupIds[level.url.length - 1] = id;\n  } else if (type === 'text') {\n    if (!level.textGroupIds) {\n      level.textGroupIds = [];\n    }\n    level.textGroupIds[level.url.length - 1] = id;\n  }\n}\nfunction assignTrackIdsByGroup(tracks) {\n  const groups = {};\n  tracks.forEach(track => {\n    const groupId = track.groupId || '';\n    track.id = groups[groupId] = groups[groupId] || 0;\n    groups[groupId]++;\n  });\n}\n\nvar FragmentState = {\n  NOT_LOADED: \"NOT_LOADED\",\n  APPENDING: \"APPENDING\",\n  PARTIAL: \"PARTIAL\",\n  OK: \"OK\"\n};\nclass FragmentTracker {\n  constructor(hls) {\n    this.activePartLists = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.fragments = Object.create(null);\n    this.timeRanges = Object.create(null);\n    this.bufferPadding = 0.2;\n    this.hls = void 0;\n    this.hasGaps = false;\n    this.hls = hls;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    // @ts-ignore\n    this.fragments =\n    // @ts-ignore\n    this.activePartLists =\n    // @ts-ignore\n    this.endListFragments = this.timeRanges = null;\n  }\n\n  /**\n   * Return a Fragment or Part with an appended range that matches the position and levelType\n   * Otherwise, return null\n   */\n  getAppendedFrag(position, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (activeParts) {\n      for (let i = activeParts.length; i--;) {\n        const activePart = activeParts[i];\n        if (!activePart) {\n          break;\n        }\n        const appendedPTS = activePart.end;\n        if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n          return activePart;\n        }\n      }\n    }\n    return this.getBufferedFrag(position, levelType);\n  }\n\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */\n  getBufferedFrag(position, levelType) {\n    const {\n      fragments\n    } = this;\n    const keys = Object.keys(fragments);\n    for (let i = keys.length; i--;) {\n      const fragmentEntity = fragments[keys[i]];\n      if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n        const frag = fragmentEntity.body;\n        if (frag.start <= position && position <= frag.end) {\n          return frag;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */\n  detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {\n    if (this.timeRanges) {\n      this.timeRanges[elementaryStream] = timeRange;\n    }\n    // Check if any flagged fragments have been unloaded\n    // excluding anything newer than appendedPartSn\n    const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (appendedPartSn >= fragmentEntity.body.sn) {\n        return;\n      }\n      if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n        if (fragmentEntity.body.type === playlistType) {\n          this.removeFragment(fragmentEntity.body);\n        }\n        return;\n      }\n      const esData = fragmentEntity.range[elementaryStream];\n      if (!esData) {\n        return;\n      }\n      esData.time.some(time => {\n        const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n        if (isNotBuffered) {\n          // Unregister partial fragment as it needs to load again to be reused\n          this.removeFragment(fragmentEntity.body);\n        }\n        return isNotBuffered;\n      });\n    });\n  }\n\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */\n  detectPartialFragments(data) {\n    const timeRanges = this.timeRanges;\n    const {\n      frag,\n      part\n    } = data;\n    if (!timeRanges || frag.sn === 'initSegment') {\n      return;\n    }\n    const fragKey = getFragmentKey(frag);\n    const fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n      return;\n    }\n    const isFragHint = !frag.relurl;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const streamInfo = frag.elementaryStreams[elementaryStream];\n      if (!streamInfo) {\n        return;\n      }\n      const timeRange = timeRanges[elementaryStream];\n      const partial = isFragHint || streamInfo.partial === true;\n      fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);\n    });\n    fragmentEntity.loaded = null;\n    if (Object.keys(fragmentEntity.range).length) {\n      fragmentEntity.buffered = true;\n      const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;\n      if (endList) {\n        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n      }\n      if (!isPartial(fragmentEntity)) {\n        // Remove older fragment parts from lookup after frag is tracked as buffered\n        this.removeParts(frag.sn - 1, frag.type);\n      }\n    } else {\n      // remove fragment if nothing was appended\n      this.removeFragment(fragmentEntity.body);\n    }\n  }\n  removeParts(snToKeep, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (!activeParts) {\n      return;\n    }\n    this.activePartLists[levelType] = activeParts.filter(part => part.fragment.sn >= snToKeep);\n  }\n  fragBuffered(frag, force) {\n    const fragKey = getFragmentKey(frag);\n    let fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity && force) {\n      fragmentEntity = this.fragments[fragKey] = {\n        body: frag,\n        appendedPTS: null,\n        loaded: null,\n        buffered: false,\n        range: Object.create(null)\n      };\n      if (frag.gap) {\n        this.hasGaps = true;\n      }\n    }\n    if (fragmentEntity) {\n      fragmentEntity.loaded = null;\n      fragmentEntity.buffered = true;\n    }\n  }\n  getBufferedTimes(fragment, part, partial, timeRange) {\n    const buffered = {\n      time: [],\n      partial\n    };\n    const startPTS = fragment.start;\n    const endPTS = fragment.end;\n    const minEndPTS = fragment.minEndPTS || endPTS;\n    const maxStartPTS = fragment.maxStartPTS || startPTS;\n    for (let i = 0; i < timeRange.length; i++) {\n      const startTime = timeRange.start(i) - this.bufferPadding;\n      const endTime = timeRange.end(i) + this.bufferPadding;\n      if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n        // Fragment is entirely contained in buffer\n        // No need to check the other timeRange times since it's completely playable\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n        break;\n      } else if (startPTS < endTime && endPTS > startTime) {\n        buffered.partial = true;\n        // Check for intersection with buffer\n        // Get playable sections of the fragment\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n      } else if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        break;\n      }\n    }\n    return buffered;\n  }\n\n  /**\n   * Gets the partial fragment for a certain time\n   */\n  getPartialFragment(time) {\n    let bestFragment = null;\n    let timePadding;\n    let startTime;\n    let endTime;\n    let bestOverlap = 0;\n    const {\n      bufferPadding,\n      fragments\n    } = this;\n    Object.keys(fragments).forEach(key => {\n      const fragmentEntity = fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (isPartial(fragmentEntity)) {\n        startTime = fragmentEntity.body.start - bufferPadding;\n        endTime = fragmentEntity.body.end + bufferPadding;\n        if (time >= startTime && time <= endTime) {\n          // Use the fragment that has the most padding from start and end time\n          timePadding = Math.min(time - startTime, endTime - time);\n          if (bestOverlap <= timePadding) {\n            bestFragment = fragmentEntity.body;\n            bestOverlap = timePadding;\n          }\n        }\n      }\n    });\n    return bestFragment;\n  }\n  isEndListAppended(type) {\n    const lastFragmentEntity = this.endListFragments[type];\n    return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n  }\n  getState(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    const fragmentEntity = this.fragments[fragKey];\n    if (fragmentEntity) {\n      if (!fragmentEntity.buffered) {\n        return FragmentState.APPENDING;\n      } else if (isPartial(fragmentEntity)) {\n        return FragmentState.PARTIAL;\n      } else {\n        return FragmentState.OK;\n      }\n    }\n    return FragmentState.NOT_LOADED;\n  }\n  isTimeBuffered(startPTS, endPTS, timeRange) {\n    let startTime;\n    let endTime;\n    for (let i = 0; i < timeRange.length; i++) {\n      startTime = timeRange.start(i) - this.bufferPadding;\n      endTime = timeRange.end(i) + this.bufferPadding;\n      if (startPTS >= startTime && endPTS <= endTime) {\n        return true;\n      }\n      if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        return false;\n      }\n    }\n    return false;\n  }\n  onFragLoaded(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    // don't track initsegment (for which sn is not a number)\n    // don't track frags used for bitrateTest, they're irrelevant.\n    if (frag.sn === 'initSegment' || frag.bitrateTest) {\n      return;\n    }\n\n    // Fragment entity `loaded` FragLoadedData is null when loading parts\n    const loaded = part ? null : data;\n    const fragKey = getFragmentKey(frag);\n    this.fragments[fragKey] = {\n      body: frag,\n      appendedPTS: null,\n      loaded,\n      buffered: false,\n      range: Object.create(null)\n    };\n  }\n  onBufferAppended(event, data) {\n    const {\n      frag,\n      part,\n      timeRanges\n    } = data;\n    if (frag.sn === 'initSegment') {\n      return;\n    }\n    const playlistType = frag.type;\n    if (part) {\n      let activeParts = this.activePartLists[playlistType];\n      if (!activeParts) {\n        this.activePartLists[playlistType] = activeParts = [];\n      }\n      activeParts.push(part);\n    }\n    // Store the latest timeRanges loaded in the buffer\n    this.timeRanges = timeRanges;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const timeRange = timeRanges[elementaryStream];\n      this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);\n    });\n  }\n  onFragBuffered(event, data) {\n    this.detectPartialFragments(data);\n  }\n  hasFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    return !!this.fragments[fragKey];\n  }\n  hasParts(type) {\n    var _this$activePartLists;\n    return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n  }\n  removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n    if (withGapOnly && !this.hasGaps) {\n      return;\n    }\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      const frag = fragmentEntity.body;\n      if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n        return;\n      }\n      if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n        this.removeFragment(frag);\n      }\n    });\n  }\n  removeFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    fragment.stats.loaded = 0;\n    fragment.clearElementaryStreamInfo();\n    const activeParts = this.activePartLists[fragment.type];\n    if (activeParts) {\n      const snToRemove = fragment.sn;\n      this.activePartLists[fragment.type] = activeParts.filter(part => part.fragment.sn !== snToRemove);\n    }\n    delete this.fragments[fragKey];\n    if (fragment.endList) {\n      delete this.endListFragments[fragment.type];\n    }\n  }\n  removeAllFragments() {\n    this.fragments = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.activePartLists = Object.create(null);\n    this.hasGaps = false;\n  }\n}\nfunction isPartial(fragmentEntity) {\n  var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n  return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n}\nfunction getFragmentKey(fragment) {\n  return `${fragment.type}_${fragment.level}_${fragment.urlId}_${fragment.sn}`;\n}\n\nconst MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n\nclass FragmentLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.loader = null;\n    this.partLoadTimeout = -1;\n    this.config = config;\n  }\n  destroy() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  }\n  abort() {\n    if (this.loader) {\n      // Abort the loader for current fragment. Only one may load at any given time\n      this.loader.abort();\n    }\n  }\n  load(frag, onProgress) {\n    const url = frag.url;\n    if (!url) {\n      return Promise.reject(new LoadError({\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.FRAG_LOAD_ERROR,\n        fatal: false,\n        frag,\n        error: new Error(`Fragment does not have a ${url ? 'part list' : 'url'}`),\n        networkDetails: null\n      }));\n    }\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap) {\n        if (frag.tagList.some(tags => tags[0] === 'GAP')) {\n          reject(createGapLoadError(frag));\n          return;\n        } else {\n          // Reset temporary treatment as GAP tag\n          frag.gap = false;\n        }\n      }\n      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag);\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n      };\n      // Assign frag stats to the loader's stats reference\n      frag.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          let payload = response.data;\n          if (context.resetIV && frag.decryptdata) {\n            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n            payload = payload.slice(16);\n          }\n          resolve({\n            frag,\n            part: null,\n            payload,\n            networkDetails\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            response: _objectSpread2({\n              url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        },\n        onProgress: (stats, context, data, networkDetails) => {\n          if (onProgress) {\n            onProgress({\n              frag,\n              part: null,\n              payload: data,\n              networkDetails\n            });\n          }\n        }\n      });\n    });\n  }\n  loadPart(frag, part, onProgress) {\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap || part.gap) {\n        reject(createGapLoadError(frag, part));\n        return;\n      }\n      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag, part);\n      // Should we define another load policy for parts?\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: MIN_CHUNK_SIZE\n      };\n      // Assign part stats to the loader's stats reference\n      part.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          this.updateStatsFromPart(frag, part);\n          const partLoadedData = {\n            frag,\n            part,\n            payload: response.data,\n            networkDetails\n          };\n          onProgress(partLoadedData);\n          resolve(partLoadedData);\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            part,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          frag.stats.aborted = part.stats.aborted;\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            part,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            part,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        }\n      });\n    });\n  }\n  updateStatsFromPart(frag, part) {\n    const fragStats = frag.stats;\n    const partStats = part.stats;\n    const partTotal = partStats.total;\n    fragStats.loaded += partStats.loaded;\n    if (partTotal) {\n      const estTotalParts = Math.round(frag.duration / part.duration);\n      const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n      const estRemainingParts = estTotalParts - estLoadedParts;\n      const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n      fragStats.total = fragStats.loaded + estRemainingBytes;\n    } else {\n      fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n    }\n    const fragLoading = fragStats.loading;\n    const partLoading = partStats.loading;\n    if (fragLoading.start) {\n      // add to fragment loader latency\n      fragLoading.first += partLoading.first - partLoading.start;\n    } else {\n      fragLoading.start = partLoading.start;\n      fragLoading.first = partLoading.first;\n    }\n    fragLoading.end = partLoading.end;\n  }\n  resetLoader(frag, loader) {\n    frag.loader = null;\n    if (this.loader === loader) {\n      self.clearTimeout(this.partLoadTimeout);\n      this.loader = null;\n    }\n    loader.destroy();\n  }\n}\nfunction createLoaderContext(frag, part = null) {\n  const segment = part || frag;\n  const loaderContext = {\n    frag,\n    part,\n    responseType: 'arraybuffer',\n    url: segment.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  };\n  const start = segment.byteRangeStartOffset;\n  const end = segment.byteRangeEndOffset;\n  if (isFiniteNumber(start) && isFiniteNumber(end)) {\n    var _frag$decryptdata;\n    let byteRangeStart = start;\n    let byteRangeEnd = end;\n    if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === 'AES-128') {\n      // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n      // has the unencrypted size specified in the range.\n      // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n      const fragmentLen = end - start;\n      if (fragmentLen % 16) {\n        byteRangeEnd = end + (16 - fragmentLen % 16);\n      }\n      if (start !== 0) {\n        loaderContext.resetIV = true;\n        byteRangeStart = start - 16;\n      }\n    }\n    loaderContext.rangeStart = byteRangeStart;\n    loaderContext.rangeEnd = byteRangeEnd;\n  }\n  return loaderContext;\n}\nfunction createGapLoadError(frag, part) {\n  const error = new Error(`GAP ${frag.gap ? 'tag' : 'attribute'} found`);\n  const errorData = {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_GAP,\n    fatal: false,\n    frag,\n    error,\n    networkDetails: null\n  };\n  if (part) {\n    errorData.part = part;\n  }\n  (part ? part : frag).stats.aborted = true;\n  return new LoadError(errorData);\n}\nclass LoadError extends Error {\n  constructor(data) {\n    super(data.error.message);\n    this.data = void 0;\n    this.data = data;\n  }\n}\n\nclass KeyLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.keyUriToKeyInfo = {};\n    this.emeController = null;\n    this.config = config;\n  }\n  abort(type) {\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        if (type && type !== loader.context.frag.type) {\n          return;\n        }\n        loader.abort();\n      }\n    }\n  }\n  detach() {\n    for (const uri in this.keyUriToKeyInfo) {\n      const keyInfo = this.keyUriToKeyInfo[uri];\n      // Remove cached EME keys on detach\n      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n        delete this.keyUriToKeyInfo[uri];\n      }\n    }\n  }\n  destroy() {\n    this.detach();\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        loader.destroy();\n      }\n    }\n    this.keyUriToKeyInfo = {};\n  }\n  createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {\n    return new LoadError({\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal: false,\n      frag,\n      response,\n      error,\n      networkDetails\n    });\n  }\n  loadClear(loadingFrag, encryptedFragments) {\n    if (this.emeController && this.config.emeEnabled) {\n      // access key-system with nearest key on start (loaidng frag is unencrypted)\n      const {\n        sn,\n        cc\n      } = loadingFrag;\n      for (let i = 0; i < encryptedFragments.length; i++) {\n        const frag = encryptedFragments[i];\n        if (cc <= frag.cc && (sn === 'initSegment' || frag.sn === 'initSegment' || sn < frag.sn)) {\n          this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n            frag.setKeyFormat(keySystemFormat);\n          });\n          break;\n        }\n      }\n    }\n  }\n  load(frag) {\n    if (!frag.decryptdata && frag.encrypted && this.emeController) {\n      // Multiple keys, but none selected, resolve in eme-controller\n      return this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n        return this.loadInternal(frag, keySystemFormat);\n      });\n    }\n    return this.loadInternal(frag);\n  }\n  loadInternal(frag, keySystemFormat) {\n    var _keyInfo, _keyInfo2;\n    if (keySystemFormat) {\n      frag.setKeyFormat(keySystemFormat);\n    }\n    const decryptdata = frag.decryptdata;\n    if (!decryptdata) {\n      const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : 'Missing decryption data on fragment in onKeyLoading');\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n    }\n    const uri = decryptdata.uri;\n    if (!uri) {\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: \"${uri}\"`)));\n    }\n    let keyInfo = this.keyUriToKeyInfo[uri];\n    if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n      decryptdata.key = keyInfo.decryptdata.key;\n      return Promise.resolve({\n        frag,\n        keyInfo\n      });\n    }\n    // Return key load promise as long as it does not have a mediakey session with an unusable key status\n    if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n      var _keyInfo$mediaKeySess;\n      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n        case undefined:\n        case 'status-pending':\n        case 'usable':\n        case 'usable-in-future':\n          return keyInfo.keyLoadPromise.then(keyLoadedData => {\n            // Return the correct fragment with updated decryptdata key and loaded keyInfo\n            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n            return {\n              frag,\n              keyInfo\n            };\n          });\n      }\n      // If we have a key session and status and it is not pending or usable, continue\n      // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n    }\n\n    // Load the key or return the loading promise\n    keyInfo = this.keyUriToKeyInfo[uri] = {\n      decryptdata,\n      keyLoadPromise: null,\n      loader: null,\n      mediaKeySessionContext: null\n    };\n    switch (decryptdata.method) {\n      case 'ISO-23001-7':\n      case 'SAMPLE-AES':\n      case 'SAMPLE-AES-CENC':\n      case 'SAMPLE-AES-CTR':\n        if (decryptdata.keyFormat === 'identity') {\n          // loadKeyHTTP handles http(s) and data URLs\n          return this.loadKeyHTTP(keyInfo, frag);\n        }\n        return this.loadKeyEME(keyInfo, frag);\n      case 'AES-128':\n        return this.loadKeyHTTP(keyInfo, frag);\n      default:\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: \"${decryptdata.method}\"`)));\n    }\n  }\n  loadKeyEME(keyInfo, frag) {\n    const keyLoadedData = {\n      frag,\n      keyInfo\n    };\n    if (this.emeController && this.config.emeEnabled) {\n      const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n      if (keySessionContextPromise) {\n        return (keyInfo.keyLoadPromise = keySessionContextPromise.then(keySessionContext => {\n          keyInfo.mediaKeySessionContext = keySessionContext;\n          return keyLoadedData;\n        })).catch(error => {\n          // Remove promise for license renewal or retry\n          keyInfo.keyLoadPromise = null;\n          throw error;\n        });\n      }\n    }\n    return Promise.resolve(keyLoadedData);\n  }\n  loadKeyHTTP(keyInfo, frag) {\n    const config = this.config;\n    const Loader = config.loader;\n    const keyLoader = new Loader(config);\n    frag.keyLoader = keyInfo.loader = keyLoader;\n    return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {\n      const loaderContext = {\n        keyInfo,\n        frag,\n        responseType: 'arraybuffer',\n        url: keyInfo.decryptdata.uri\n      };\n\n      // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n      // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n      // this will also align retry logic with fragment-loader\n      const loadPolicy = config.keyLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          const {\n            frag,\n            keyInfo,\n            url: uri\n          } = context;\n          if (!frag.decryptdata || keyInfo !== this.keyUriToKeyInfo[uri]) {\n            return reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n          }\n          keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n          // detach fragment key loader on load success\n          frag.keyLoader = null;\n          keyInfo.loader = null;\n          resolve({\n            frag,\n            keyInfo\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({\n            url: loaderContext.url,\n            data: undefined\n          }, response)));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n        }\n      };\n      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  resetLoader(context) {\n    const {\n      frag,\n      keyInfo,\n      url: uri\n    } = context;\n    const loader = keyInfo.loader;\n    if (frag.keyLoader === loader) {\n      frag.keyLoader = null;\n      keyInfo.loader = null;\n    }\n    delete this.keyUriToKeyInfo[uri];\n    if (loader) {\n      loader.destroy();\n    }\n  }\n}\n\n/**\n * @ignore\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */\nclass TaskLoop {\n  constructor() {\n    this._boundTick = void 0;\n    this._tickTimer = null;\n    this._tickInterval = null;\n    this._tickCallCount = 0;\n    this._boundTick = this.tick.bind(this);\n  }\n  destroy() {\n    this.onHandlerDestroying();\n    this.onHandlerDestroyed();\n  }\n  onHandlerDestroying() {\n    // clear all timers before unregistering from event bus\n    this.clearNextTick();\n    this.clearInterval();\n  }\n  onHandlerDestroyed() {}\n  hasInterval() {\n    return !!this._tickInterval;\n  }\n  hasNextTick() {\n    return !!this._tickTimer;\n  }\n\n  /**\n   * @param millis - Interval time (ms)\n   * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n   */\n  setInterval(millis) {\n    if (!this._tickInterval) {\n      this._tickCallCount = 0;\n      this._tickInterval = self.setInterval(this._boundTick, millis);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when interval was cleared, false when none was set (no effect)\n   */\n  clearInterval() {\n    if (this._tickInterval) {\n      self.clearInterval(this._tickInterval);\n      this._tickInterval = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when timeout was cleared, false when none was set (no effect)\n   */\n  clearNextTick() {\n    if (this._tickTimer) {\n      self.clearTimeout(this._tickTimer);\n      this._tickTimer = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */\n  tick() {\n    this._tickCallCount++;\n    if (this._tickCallCount === 1) {\n      this.doTick();\n      // re-entrant call to tick from previous doTick call stack\n      // -> schedule a call on the next main loop iteration to process this task processing request\n      if (this._tickCallCount > 1) {\n        // make sure only one timer exists at any time at max\n        this.tickImmediate();\n      }\n      this._tickCallCount = 0;\n    }\n  }\n  tickImmediate() {\n    this.clearNextTick();\n    this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */\n  doTick() {}\n}\n\n/**\n * Provides methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */\n\nconst noopBuffered = {\n  length: 0,\n  start: () => 0,\n  end: () => 0\n};\nclass BufferHelper {\n  /**\n   * Return true if `media`'s buffered include `position`\n   */\n  static isBuffered(media, position) {\n    try {\n      if (media) {\n        const buffered = BufferHelper.getBuffered(media);\n        for (let i = 0; i < buffered.length; i++) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return false;\n  }\n  static bufferInfo(media, pos, maxHoleDuration) {\n    try {\n      if (media) {\n        const vbuffered = BufferHelper.getBuffered(media);\n        const buffered = [];\n        let i;\n        for (i = 0; i < vbuffered.length; i++) {\n          buffered.push({\n            start: vbuffered.start(i),\n            end: vbuffered.end(i)\n          });\n        }\n        return this.bufferedInfo(buffered, pos, maxHoleDuration);\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return {\n      len: 0,\n      start: pos,\n      end: pos,\n      nextStart: undefined\n    };\n  }\n  static bufferedInfo(buffered, pos, maxHoleDuration) {\n    pos = Math.max(0, pos);\n    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n    buffered.sort(function (a, b) {\n      const diff = a.start - b.start;\n      if (diff) {\n        return diff;\n      } else {\n        return b.end - a.end;\n      }\n    });\n    let buffered2 = [];\n    if (maxHoleDuration) {\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (let i = 0; i < buffered.length; i++) {\n        const buf2len = buffered2.length;\n        if (buf2len) {\n          const buf2end = buffered2[buf2len - 1].end;\n          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n    } else {\n      buffered2 = buffered;\n    }\n    let bufferLen = 0;\n\n    // bufferStartNext can possibly be undefined based on the conditional logic below\n    let bufferStartNext;\n\n    // bufferStart and bufferEnd are buffer boundaries around current video position\n    let bufferStart = pos;\n    let bufferEnd = pos;\n    for (let i = 0; i < buffered2.length; i++) {\n      const start = buffered2[i].start;\n      const end = buffered2[i].end;\n      // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n      if (pos + maxHoleDuration >= start && pos < end) {\n        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n        bufferStart = start;\n        bufferEnd = end;\n        bufferLen = bufferEnd - pos;\n      } else if (pos + maxHoleDuration < start) {\n        bufferStartNext = start;\n        break;\n      }\n    }\n    return {\n      len: bufferLen,\n      start: bufferStart || 0,\n      end: bufferEnd || 0,\n      nextStart: bufferStartNext\n    };\n  }\n\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */\n  static getBuffered(media) {\n    try {\n      return media.buffered;\n    } catch (e) {\n      logger.log('failed to get media.buffered', e);\n      return noopBuffered;\n    }\n  }\n}\n\nclass ChunkMetadata {\n  constructor(level, sn, id, size = 0, part = -1, partial = false) {\n    this.level = void 0;\n    this.sn = void 0;\n    this.part = void 0;\n    this.id = void 0;\n    this.size = void 0;\n    this.partial = void 0;\n    this.transmuxing = getNewPerformanceTiming();\n    this.buffering = {\n      audio: getNewPerformanceTiming(),\n      video: getNewPerformanceTiming(),\n      audiovideo: getNewPerformanceTiming()\n    };\n    this.level = level;\n    this.sn = sn;\n    this.id = id;\n    this.size = size;\n    this.part = part;\n    this.partial = partial;\n  }\n}\nfunction getNewPerformanceTiming() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\n\nfunction findFirstFragWithCC(fragments, cc) {\n  let firstFrag = null;\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    const currentFrag = fragments[i];\n    if (currentFrag && currentFrag.cc === cc) {\n      firstFrag = currentFrag;\n      break;\n    }\n  }\n  return firstFrag;\n}\nfunction shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {\n  if (lastLevel.details) {\n    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Find the first frag in the previous level which matches the CC of the first frag of the new level\nfunction findDiscontinuousReferenceFrag(prevDetails, curDetails, referenceIndex = 0) {\n  const prevFrags = prevDetails.fragments;\n  const curFrags = curDetails.fragments;\n  if (!curFrags.length || !prevFrags.length) {\n    logger.log('No fragments to align');\n    return;\n  }\n  const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n    logger.log('No frag in previous level to align on');\n    return;\n  }\n  return prevStartFrag;\n}\nfunction adjustFragmentStart(frag, sliding) {\n  if (frag) {\n    const start = frag.start + sliding;\n    frag.start = frag.startPTS = start;\n    frag.endPTS = start + frag.duration;\n  }\n}\nfunction adjustSlidingStart(sliding, details) {\n  // Update segments\n  const fragments = details.fragments;\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    adjustFragmentStart(fragments[i], sliding);\n  }\n  // Update LL-HLS parts at the end of the playlist\n  if (details.fragmentHint) {\n    adjustFragmentStart(details.fragmentHint, sliding);\n  }\n  details.alignedSliding = true;\n}\n\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastFrag\n * @param lastLevel\n * @param details\n */\nfunction alignStream(lastFrag, lastLevel, details) {\n  if (!lastLevel) {\n    return;\n  }\n  alignDiscontinuities(lastFrag, details, lastLevel);\n  if (!details.alignedSliding && lastLevel.details) {\n    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n    // discontinuity sequence.\n    alignPDT(details, lastLevel.details);\n  }\n  if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {\n    // Try to align on sn so that we pick a better start fragment.\n    // Do not perform this on playlists with delta updates as this is only to align levels on switch\n    // and adjustSliding only adjusts fragments after skippedSegments.\n    adjustSliding(lastLevel.details, details);\n  }\n}\n\n/**\n * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n * discontinuity sequence.\n * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */\nfunction alignDiscontinuities(lastFrag, details, lastLevel) {\n  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {\n    const referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);\n    if (referenceFrag && isFiniteNumber(referenceFrag.start)) {\n      logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);\n      adjustSlidingStart(referenceFrag.start, details);\n    }\n  }\n}\n\n/**\n * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.\n * @param details - The details of the new level\n * @param lastDetails - The details of the last loaded level\n */\nfunction alignPDT(details, lastDetails) {\n  // This check protects the unsafe \"!\" usage below for null program date time access.\n  if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {\n    return;\n  }\n  // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM\n  // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM\n  // then we can deduce that playlist B sliding is 1000+8 = 1008s\n  const lastPDT = lastDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.\n  const newPDT = details.fragments[0].programDateTime;\n  // date diff is in ms. frag.start is in seconds\n  const sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;\n  if (sliding && isFiniteNumber(sliding)) {\n    logger.log(`Adjusting PTS using programDateTime delta ${newPDT - lastPDT}ms, sliding:${sliding.toFixed(3)} ${details.url} `);\n    adjustSlidingStart(sliding, details);\n  }\n}\n\n/**\n * Ensures appropriate time-alignment between renditions based on PDT. Unlike `alignPDT`, which adjusts\n * the timeline based on the delta between PDTs of the 0th fragment of two playlists/`LevelDetails`,\n * this function assumes the timelines represented in `refDetails` are accurate, including the PDTs,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */\nfunction alignMediaPlaylistByPDT(details, refDetails) {\n  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n    return;\n  }\n  const fragments = details.fragments;\n  const refFragments = refDetails.fragments;\n  if (!fragments.length || !refFragments.length) {\n    return;\n  }\n\n  // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n  // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n  // If a fragment of the same discontinuity was not found use the middle fragment of both.\n  const middleFrag = Math.round(refFragments.length / 2) - 1;\n  const refFrag = refFragments[middleFrag];\n  const frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.round(fragments.length / 2) - 1];\n  const refPDT = refFrag.programDateTime;\n  const targetPDT = frag.programDateTime;\n  if (refPDT === null || targetPDT === null) {\n    return;\n  }\n  const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n  adjustSlidingStart(delta, details);\n}\n\nclass AESCrypto {\n  constructor(subtle, iv) {\n    this.subtle = void 0;\n    this.aesIV = void 0;\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n  decrypt(data, key) {\n    return this.subtle.decrypt({\n      name: 'AES-CBC',\n      iv: this.aesIV\n    }, key, data);\n  }\n}\n\nclass FastAESKey {\n  constructor(subtle, key) {\n    this.subtle = void 0;\n    this.key = void 0;\n    this.subtle = subtle;\n    this.key = key;\n  }\n  expandKey() {\n    return this.subtle.importKey('raw', this.key, {\n      name: 'AES-CBC'\n    }, false, ['encrypt', 'decrypt']);\n  }\n}\n\n// PKCS7\nfunction removePadding(array) {\n  const outputBytes = array.byteLength;\n  const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return sliceUint8(array, 0, outputBytes - paddingBytes);\n  }\n  return array;\n}\nclass AESDecryptor {\n  constructor() {\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n    this.key = new Uint32Array(0);\n    this.ksRows = 0;\n    this.keySize = 0;\n    this.keySchedule = void 0;\n    this.invKeySchedule = void 0;\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_(arrayBuffer) {\n    const view = new DataView(arrayBuffer);\n    const newArray = new Uint32Array(4);\n    for (let i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n    return newArray;\n  }\n  initTable() {\n    const sBox = this.sBox;\n    const invSBox = this.invSBox;\n    const subMix = this.subMix;\n    const subMix0 = subMix[0];\n    const subMix1 = subMix[1];\n    const subMix2 = subMix[2];\n    const subMix3 = subMix[3];\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const d = new Uint32Array(256);\n    let x = 0;\n    let xi = 0;\n    let i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = i << 1 ^ 0x11b;\n      }\n    }\n    for (i = 0; i < 256; i++) {\n      let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      const x2 = d[x];\n      const x4 = d[x2];\n      const x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      let t = d[sx] * 0x101 ^ sx * 0x1010100;\n      subMix0[x] = t << 24 | t >>> 8;\n      subMix1[x] = t << 16 | t >>> 16;\n      subMix2[x] = t << 8 | t >>> 24;\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      invSubMix0[sx] = t << 24 | t >>> 8;\n      invSubMix1[sx] = t << 16 | t >>> 16;\n      invSubMix2[sx] = t << 8 | t >>> 24;\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  }\n  expandKey(keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    const key = this.uint8ArrayToUint32Array_(keyBuffer);\n    let sameKey = true;\n    let offset = 0;\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n    if (sameKey) {\n      return;\n    }\n    this.key = key;\n    const keySize = this.keySize = key.length;\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n    const ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    let ksRow;\n    let invKsRow;\n    const keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    const sbox = this.sBox;\n    const rcon = this.rcon;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    let prev;\n    let t;\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = t << 8 | t >>> 24;\n\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[ksRow / keySize | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n      }\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap(word) {\n    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n  }\n  decrypt(inputArrayBuffer, offset, aesIV) {\n    const nRounds = this.keySize + 6;\n    const invKeySchedule = this.invKeySchedule;\n    const invSBOX = this.invSBox;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const initVector = this.uint8ArrayToUint32Array_(aesIV);\n    let initVector0 = initVector[0];\n    let initVector1 = initVector[1];\n    let initVector2 = initVector[2];\n    let initVector3 = initVector[3];\n    const inputInt32 = new Int32Array(inputArrayBuffer);\n    const outputInt32 = new Int32Array(inputInt32.length);\n    let t0, t1, t2, t3;\n    let s0, s1, s2, s3;\n    let inputWords0, inputWords1, inputWords2, inputWords3;\n    let ksRow, i;\n    const swapWord = this.networkToHostOrderSwap;\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n      offset = offset + 4;\n    }\n    return outputInt32.buffer;\n  }\n}\n\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nclass Decrypter {\n  constructor(config, {\n    removePKCS7Padding = true\n  } = {}) {\n    this.logEnabled = true;\n    this.removePKCS7Padding = void 0;\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n    this.useSoftware = void 0;\n    this.useSoftware = config.enableSoftwareAES;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        const browserCrypto = self.crypto;\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    if (this.subtle === null) {\n      this.useSoftware = true;\n    }\n  }\n  destroy() {\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n  }\n  isSync() {\n    return this.useSoftware;\n  }\n  flush() {\n    const {\n      currentResult,\n      remainderData\n    } = this;\n    if (!currentResult || remainderData) {\n      this.reset();\n      return null;\n    }\n    const data = new Uint8Array(currentResult);\n    this.reset();\n    if (this.removePKCS7Padding) {\n      return removePadding(data);\n    }\n    return data;\n  }\n  reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  }\n  decrypt(data, key, iv) {\n    if (this.useSoftware) {\n      return new Promise((resolve, reject) => {\n        this.softwareDecrypt(new Uint8Array(data), key, iv);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n          resolve(decryptResult.buffer);\n        } else {\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n        }\n      });\n    }\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n  }\n\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  softwareDecrypt(data, key, iv) {\n    const {\n      currentIV,\n      currentResult,\n      remainderData\n    } = this;\n    this.logOnce('JS AES decrypt');\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = appendUint8Array(remainderData, data);\n      this.remainderData = null;\n    }\n\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n    const currentChunk = this.getValidChunk(data);\n    if (!currentChunk.length) {\n      return null;\n    }\n    if (currentIV) {\n      iv = currentIV;\n    }\n    let softwareDecrypter = this.softwareDecrypter;\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n    }\n    softwareDecrypter.expandKey(key);\n    const result = currentResult;\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = sliceUint8(currentChunk, -16).buffer;\n    if (!result) {\n      return null;\n    }\n    return result;\n  }\n  webCryptoDecrypt(data, key, iv) {\n    const subtle = this.subtle;\n    if (this.key !== key || !this.fastAesKey) {\n      this.key = key;\n      this.fastAesKey = new FastAESKey(subtle, key);\n    }\n    return this.fastAesKey.expandKey().then(aesKey => {\n      // decrypt using web crypto\n      if (!subtle) {\n        return Promise.reject(new Error('web crypto not initialized'));\n      }\n      this.logOnce('WebCrypto AES decrypt');\n      const crypto = new AESCrypto(subtle, new Uint8Array(iv));\n      return crypto.decrypt(data.buffer, aesKey);\n    }).catch(err => {\n      logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);\n      return this.onWebCryptoError(data, key, iv);\n    });\n  }\n  onWebCryptoError(data, key, iv) {\n    this.useSoftware = true;\n    this.logEnabled = true;\n    this.softwareDecrypt(data, key, iv);\n    const decryptResult = this.flush();\n    if (decryptResult) {\n      return decryptResult.buffer;\n    }\n    throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\n  }\n  getValidChunk(data) {\n    let currentChunk = data;\n    const splitPoint = data.length - data.length % CHUNK_SIZE;\n    if (splitPoint !== data.length) {\n      currentChunk = sliceUint8(data, 0, splitPoint);\n      this.remainderData = sliceUint8(data, splitPoint);\n    }\n    return currentChunk;\n  }\n  logOnce(msg) {\n    if (!this.logEnabled) {\n      return;\n    }\n    logger.log(`[decrypter]: ${msg}`);\n    this.logEnabled = false;\n  }\n}\n\n/**\n *  TimeRanges to string helper\n */\n\nconst TimeRanges = {\n  toString: function (r) {\n    let log = '';\n    const len = r.length;\n    for (let i = 0; i < len; i++) {\n      log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;\n    }\n    return log;\n  }\n};\n\nconst State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n  WAITING_LEVEL: 'WAITING_LEVEL'\n};\nclass BaseStreamController extends TaskLoop {\n  constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n    super();\n    this.hls = void 0;\n    this.fragPrevious = null;\n    this.fragCurrent = null;\n    this.fragmentTracker = void 0;\n    this.transmuxer = null;\n    this._state = State.STOPPED;\n    this.playlistType = void 0;\n    this.media = null;\n    this.mediaBuffer = null;\n    this.config = void 0;\n    this.bitrateTest = false;\n    this.lastCurrentTime = 0;\n    this.nextLoadPosition = 0;\n    this.startPosition = 0;\n    this.startTimeOffset = null;\n    this.loadedmetadata = false;\n    this.retryDate = 0;\n    this.levels = null;\n    this.fragmentLoader = void 0;\n    this.keyLoader = void 0;\n    this.levelLastLoaded = null;\n    this.startFragRequested = false;\n    this.decrypter = void 0;\n    this.initPTS = [];\n    this.onvseeking = null;\n    this.onvended = null;\n    this.logPrefix = '';\n    this.log = void 0;\n    this.warn = void 0;\n    this.playlistType = playlistType;\n    this.logPrefix = logPrefix;\n    this.log = logger.log.bind(logger, `${logPrefix}:`);\n    this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n    this.hls = hls;\n    this.fragmentLoader = new FragmentLoader(hls.config);\n    this.keyLoader = keyLoader;\n    this.fragmentTracker = fragmentTracker;\n    this.config = hls.config;\n    this.decrypter = new Decrypter(hls.config);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  doTick() {\n    this.onTickEnd();\n  }\n  onTickEnd() {}\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.fragmentLoader.abort();\n    this.keyLoader.abort(this.playlistType);\n    const frag = this.fragCurrent;\n    if (frag != null && frag.loader) {\n      frag.abortRequests();\n      this.fragmentTracker.removeFragment(frag);\n    }\n    this.resetTransmuxer();\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.clearInterval();\n    this.clearNextTick();\n    this.state = State.STOPPED;\n  }\n  _streamEnded(bufferInfo, levelDetails) {\n    // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n    // of nothing loading/loaded return false\n    if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n      return false;\n    }\n    const partList = levelDetails.partList;\n    // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n    // check instead if the last part is buffered.\n    if (partList != null && partList.length) {\n      const lastPart = partList[partList.length - 1];\n\n      // Checking the midpoint of the part for potential margin of error and related issues.\n      // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n      // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n      // part mismatches for independent audio and video playlists/segments.\n      const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n      return lastPartBuffered;\n    }\n    const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n    return this.fragmentTracker.isEndListAppended(playlistType);\n  }\n  getLevelDetails() {\n    if (this.levels && this.levelLastLoaded !== null) {\n      var _this$levels$this$lev;\n      return (_this$levels$this$lev = this.levels[this.levelLastLoaded]) == null ? void 0 : _this$levels$this$lev.details;\n    }\n  }\n  onMediaAttached(event, data) {\n    const media = this.media = this.mediaBuffer = data.media;\n    this.onvseeking = this.onMediaSeeking.bind(this);\n    this.onvended = this.onMediaEnded.bind(this);\n    media.addEventListener('seeking', this.onvseeking);\n    media.addEventListener('ended', this.onvended);\n    const config = this.config;\n    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n      this.startLoad(config.startPosition);\n    }\n  }\n  onMediaDetaching() {\n    const media = this.media;\n    if (media != null && media.ended) {\n      this.log('MSE detaching and video ended, reset startPosition');\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n\n    // remove video listeners\n    if (media && this.onvseeking && this.onvended) {\n      media.removeEventListener('seeking', this.onvseeking);\n      media.removeEventListener('ended', this.onvended);\n      this.onvseeking = this.onvended = null;\n    }\n    if (this.keyLoader) {\n      this.keyLoader.detach();\n    }\n    this.media = this.mediaBuffer = null;\n    this.loadedmetadata = false;\n    this.fragmentTracker.removeAllFragments();\n    this.stopLoad();\n  }\n  onMediaSeeking() {\n    const {\n      config,\n      fragCurrent,\n      media,\n      mediaBuffer,\n      state\n    } = this;\n    const currentTime = media ? media.currentTime : 0;\n    const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n    this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    } else if (fragCurrent) {\n      // Seeking while frag load is in progress\n      const tolerance = config.maxFragLookUpTolerance;\n      const fragStartOffset = fragCurrent.start - tolerance;\n      const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n      // if seeking out of buffered range or into new one\n      if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n        const pastFragment = currentTime > fragEndOffset;\n        // if the seek position is outside the current fragment range\n        if (currentTime < fragStartOffset || pastFragment) {\n          if (pastFragment && fragCurrent.loader) {\n            this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n            fragCurrent.abortRequests();\n            this.resetLoadingState();\n          }\n          this.fragPrevious = null;\n        }\n      }\n    }\n    if (media) {\n      // Remove gap fragments\n      this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n      this.lastCurrentTime = currentTime;\n    }\n\n    // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n    if (!this.loadedmetadata && !bufferInfo.len) {\n      this.nextLoadPosition = this.startPosition = currentTime;\n    }\n\n    // Async tick to speed up processing\n    this.tickImmediate();\n  }\n  onMediaEnded() {\n    // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n    this.startPosition = this.lastCurrentTime = 0;\n  }\n  onManifestLoaded(event, data) {\n    this.startTimeOffset = data.startTimeOffset;\n    this.initPTS = [];\n  }\n  onHandlerDestroying() {\n    this.stopLoad();\n    super.onHandlerDestroying();\n  }\n  onHandlerDestroyed() {\n    this.state = State.STOPPED;\n    if (this.fragmentLoader) {\n      this.fragmentLoader.destroy();\n    }\n    if (this.keyLoader) {\n      this.keyLoader.destroy();\n    }\n    if (this.decrypter) {\n      this.decrypter.destroy();\n    }\n    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n    super.onHandlerDestroyed();\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    this._loadFragForPlayback(frag, level, targetBufferTime);\n  }\n  _loadFragForPlayback(frag, level, targetBufferTime) {\n    const progressCallback = data => {\n      if (this.fragContextChanged(frag)) {\n        this.warn(`Fragment ${frag.sn}${data.part ? ' p: ' + data.part.index : ''} of level ${frag.level} was dropped during download.`);\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      frag.stats.chunkCount++;\n      this._handleFragmentLoadProgress(data);\n    };\n    this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(data => {\n      if (!data) {\n        // if we're here we probably needed to backtrack or are waiting for more parts\n        return;\n      }\n      const state = this.state;\n      if (this.fragContextChanged(frag)) {\n        if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {\n          this.fragmentTracker.removeFragment(frag);\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      if ('payload' in data) {\n        this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);\n        this.hls.trigger(Events.FRAG_LOADED, data);\n      }\n\n      // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n      this._handleFragmentLoadComplete(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(reason);\n      this.resetFragmentLoading(frag);\n    });\n  }\n  clearTrackerIfNeeded(frag) {\n    var _this$mediaBuffer;\n    const {\n      fragmentTracker\n    } = this;\n    const fragState = fragmentTracker.getState(frag);\n    if (fragState === FragmentState.APPENDING) {\n      // Lower the buffer size and try again\n      const playlistType = frag.type;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n      if (this.reduceMaxBufferLength(minForwardBufferLength)) {\n        fragmentTracker.removeFragment(frag);\n      }\n    } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n      // Stop gap for bad tracker / buffer flush behavior\n      fragmentTracker.removeAllFragments();\n    } else if (fragmentTracker.hasParts(frag.type)) {\n      // In low latency mode, remove fragments for which only some parts were buffered\n      fragmentTracker.detectPartialFragments({\n        frag,\n        part: null,\n        stats: frag.stats,\n        id: frag.type\n      });\n      if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n        fragmentTracker.removeFragment(frag);\n      }\n    }\n  }\n  checkLiveUpdate(details) {\n    if (details.updated && !details.live) {\n      // Live stream ended, update fragment tracker\n      const lastFragment = details.fragments[details.fragments.length - 1];\n      this.fragmentTracker.detectPartialFragments({\n        frag: lastFragment,\n        part: null,\n        stats: lastFragment.stats,\n        id: lastFragment.type\n      });\n    }\n    if (!details.fragments[0]) {\n      details.deltaUpdateFailed = true;\n    }\n  }\n  flushMainBuffer(startOffset, endOffset, type = null) {\n    if (!(startOffset - endOffset)) {\n      return;\n    }\n    // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n    // passing a null type flushes both buffers\n    const flushScope = {\n      startOffset,\n      endOffset,\n      type\n    };\n    this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n  }\n  _loadInitSegment(frag, level) {\n    this._doFragLoad(frag, level).then(data => {\n      if (!data || this.fragContextChanged(frag) || !this.levels) {\n        throw new Error('init load aborted');\n      }\n      return data;\n    }).then(data => {\n      const {\n        hls\n      } = this;\n      const {\n        payload\n      } = data;\n      const decryptData = frag.decryptdata;\n\n      // check to see if the payload needs to be decrypted\n      if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n        const startTime = self.performance.now();\n        // decrypt init segment data\n        return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(err => {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_DECRYPT_ERROR,\n            fatal: false,\n            error: err,\n            reason: err.message,\n            frag\n          });\n          throw err;\n        }).then(decryptedData => {\n          const endTime = self.performance.now();\n          hls.trigger(Events.FRAG_DECRYPTED, {\n            frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n          data.payload = decryptedData;\n          return data;\n        });\n      }\n      return data;\n    }).then(data => {\n      const {\n        fragCurrent,\n        hls,\n        levels\n      } = this;\n      if (!levels) {\n        throw new Error('init load aborted, missing levels');\n      }\n      const stats = frag.stats;\n      this.state = State.IDLE;\n      level.fragmentError = 0;\n      frag.data = new Uint8Array(data.payload);\n      stats.parsing.start = stats.buffering.start = self.performance.now();\n      stats.parsing.end = stats.buffering.end = self.performance.now();\n\n      // Silence FRAG_BUFFERED event if fragCurrent is null\n      if (data.frag === fragCurrent) {\n        hls.trigger(Events.FRAG_BUFFERED, {\n          stats,\n          frag: fragCurrent,\n          part: null,\n          id: frag.type\n        });\n      }\n      this.tick();\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(reason);\n      this.resetFragmentLoading(frag);\n    });\n  }\n  fragContextChanged(frag) {\n    const {\n      fragCurrent\n    } = this;\n    return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;\n  }\n  fragBufferedComplete(frag, part) {\n    var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n    const media = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? ' part: ' + part.index : ''} of ${this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track'} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)'})`);\n    this.state = State.IDLE;\n    if (!media) {\n      return;\n    }\n    if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {\n      this.loadedmetadata = true;\n      this.seekToStartPos();\n    }\n    this.tick();\n  }\n  seekToStartPos() {}\n  _handleFragmentLoadComplete(fragLoadedEndData) {\n    const {\n      transmuxer\n    } = this;\n    if (!transmuxer) {\n      return;\n    }\n    const {\n      frag,\n      part,\n      partsLoaded\n    } = fragLoadedEndData;\n    // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n    const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(fragLoaded => !fragLoaded);\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n    transmuxer.flush(chunkMeta);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _handleFragmentLoadProgress(frag) {}\n  _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {\n    var _frag$decryptdata;\n    const details = level == null ? void 0 : level.details;\n    if (!this.levels || !details) {\n      throw new Error(`frag load aborted, missing level${details ? '' : ' detail'}s`);\n    }\n    let keyLoadingPromise = null;\n    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n      this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'} ${frag.level}`);\n      this.state = State.KEY_LOADING;\n      this.fragCurrent = frag;\n      keyLoadingPromise = this.keyLoader.load(frag).then(keyLoadedData => {\n        if (!this.fragContextChanged(keyLoadedData.frag)) {\n          this.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n          if (this.state === State.KEY_LOADING) {\n            this.state = State.IDLE;\n          }\n          return keyLoadedData;\n        }\n      });\n      this.hls.trigger(Events.KEY_LOADING, {\n        frag\n      });\n      if (this.fragCurrent === null) {\n        keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));\n      }\n    } else if (!frag.encrypted && details.encryptedFragments.length) {\n      this.keyLoader.loadClear(frag, details.encryptedFragments);\n    }\n    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n    if (this.config.lowLatencyMode && frag.sn !== 'initSegment') {\n      const partList = details.partList;\n      if (partList && progressCallback) {\n        if (targetBufferTime > frag.end && details.fragmentHint) {\n          frag = details.fragmentHint;\n        }\n        const partIndex = this.getNextPart(partList, frag, targetBufferTime);\n        if (partIndex > -1) {\n          const part = partList[partIndex];\n          this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n          this.nextLoadPosition = part.start + part.duration;\n          this.state = State.FRAG_LOADING;\n          let _result;\n          if (keyLoadingPromise) {\n            _result = keyLoadingPromise.then(keyLoadedData => {\n              if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {\n                return null;\n              }\n              return this.doFragPartsLoad(frag, part, level, progressCallback);\n            }).catch(error => this.handleFragLoadError(error));\n          } else {\n            _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(error => this.handleFragLoadError(error));\n          }\n          this.hls.trigger(Events.FRAG_LOADING, {\n            frag,\n            part,\n            targetBufferTime\n          });\n          if (this.fragCurrent === null) {\n            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));\n          }\n          return _result;\n        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n          // Fragment hint has no parts\n          return Promise.resolve(null);\n        }\n      }\n    }\n    this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : ''}${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n    // Don't update nextLoadPosition for fragments which are not buffered\n    if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n      this.nextLoadPosition = frag.start + frag.duration;\n    }\n    this.state = State.FRAG_LOADING;\n\n    // Load key before streaming fragment data\n    const dataOnProgress = this.config.progressive;\n    let result;\n    if (dataOnProgress && keyLoadingPromise) {\n      result = keyLoadingPromise.then(keyLoadedData => {\n        if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n          return null;\n        }\n        return this.fragmentLoader.load(frag, progressCallback);\n      }).catch(error => this.handleFragLoadError(error));\n    } else {\n      // load unencrypted fragment data with progress event,\n      // or handle fragment result after key and fragment are finished loading\n      result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(([fragLoadedData]) => {\n        if (!dataOnProgress && fragLoadedData && progressCallback) {\n          progressCallback(fragLoadedData);\n        }\n        return fragLoadedData;\n      }).catch(error => this.handleFragLoadError(error));\n    }\n    this.hls.trigger(Events.FRAG_LOADING, {\n      frag,\n      targetBufferTime\n    });\n    if (this.fragCurrent === null) {\n      return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));\n    }\n    return result;\n  }\n  doFragPartsLoad(frag, fromPart, level, progressCallback) {\n    return new Promise((resolve, reject) => {\n      var _level$details;\n      const partsLoaded = [];\n      const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n      const loadPart = part => {\n        this.fragmentLoader.loadPart(frag, part, progressCallback).then(partLoadedData => {\n          partsLoaded[part.index] = partLoadedData;\n          const loadedPart = partLoadedData.part;\n          this.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n          const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n          if (nextPart) {\n            loadPart(nextPart);\n          } else {\n            return resolve({\n              frag,\n              part: loadedPart,\n              partsLoaded\n            });\n          }\n        }).catch(reject);\n      };\n      loadPart(fromPart);\n    });\n  }\n  handleFragLoadError(error) {\n    if ('data' in error) {\n      const data = error.data;\n      if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n        this.handleFragLoadAborted(data.frag, data.part);\n      } else {\n        this.hls.trigger(Events.ERROR, data);\n      }\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERNAL_EXCEPTION,\n        err: error,\n        error,\n        fatal: true\n      });\n    }\n    return null;\n  }\n  _handleTransmuxerFlush(chunkMeta) {\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context || this.state !== State.PARSING) {\n      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const now = self.performance.now();\n    frag.stats.parsing.end = now;\n    if (part) {\n      part.stats.parsing.end = now;\n    }\n    this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n  }\n  getCurrentContext(chunkMeta) {\n    const {\n      levels,\n      fragCurrent\n    } = this;\n    const {\n      level: levelIndex,\n      sn,\n      part: partIndex\n    } = chunkMeta;\n    if (!(levels != null && levels[levelIndex])) {\n      this.warn(`Levels object was unset while buffering fragment ${sn} of level ${levelIndex}. The current chunk will not be buffered.`);\n      return null;\n    }\n    const level = levels[levelIndex];\n    const part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;\n    const frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);\n    if (!frag) {\n      return null;\n    }\n    if (fragCurrent && fragCurrent !== frag) {\n      frag.stats = fragCurrent.stats;\n    }\n    return {\n      frag,\n      part,\n      level\n    };\n  }\n  bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n    var _buffer;\n    if (!data || this.state !== State.PARSING) {\n      return;\n    }\n    const {\n      data1,\n      data2\n    } = data;\n    let buffer = data1;\n    if (data1 && data2) {\n      // Combine the moof + mdat so that we buffer with a single append\n      buffer = appendUint8Array(data1, data2);\n    }\n    if (!((_buffer = buffer) != null && _buffer.length)) {\n      return;\n    }\n    const segment = {\n      type: data.type,\n      frag,\n      part,\n      chunkMeta,\n      parent: frag.type,\n      data: buffer\n    };\n    this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    if (data.dropped && data.independent && !part) {\n      if (noBacktracking) {\n        return;\n      }\n      // Clear buffer so that we reload previous segments sequentially if required\n      this.flushBufferGap(frag);\n    }\n  }\n  flushBufferGap(frag) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n    if (!BufferHelper.isBuffered(media, media.currentTime)) {\n      this.flushMainBuffer(0, frag.start);\n      return;\n    }\n    // Remove back-buffer without interrupting playback to allow back tracking\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const fragDuration = frag.duration;\n    const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n    const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n    if (frag.start - start > segmentFraction) {\n      this.flushMainBuffer(start, frag.start);\n    }\n  }\n  getFwdBufferInfo(bufferable, type) {\n    const pos = this.getLoadPosition();\n    if (!isFiniteNumber(pos)) {\n      return null;\n    }\n    return this.getFwdBufferInfoAtPos(bufferable, pos, type);\n  }\n  getFwdBufferInfoAtPos(bufferable, pos, type) {\n    const {\n      config: {\n        maxBufferHole\n      }\n    } = this;\n    const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n    // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n      const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n        return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));\n      }\n    }\n    return bufferInfo;\n  }\n  getMaxBufferLength(levelBitrate) {\n    const {\n      config\n    } = this;\n    let maxBufLen;\n    if (levelBitrate) {\n      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n    } else {\n      maxBufLen = config.maxBufferLength;\n    }\n    return Math.min(maxBufLen, config.maxMaxBufferLength);\n  }\n  reduceMaxBufferLength(threshold) {\n    const config = this.config;\n    const minLength = threshold || config.maxBufferLength;\n    if (config.maxMaxBufferLength >= minLength) {\n      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n      config.maxMaxBufferLength /= 2;\n      this.warn(`Reduce max buffer length to ${config.maxMaxBufferLength}s`);\n      return true;\n    }\n    return false;\n  }\n  getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {\n    const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);\n    if (fragOrPart && 'fragment' in fragOrPart) {\n      return fragOrPart.fragment;\n    }\n    return fragOrPart;\n  }\n  getNextFragment(pos, levelDetails) {\n    const fragments = levelDetails.fragments;\n    const fragLen = fragments.length;\n    if (!fragLen) {\n      return null;\n    }\n\n    // find fragment index, contiguous with end of buffer position\n    const {\n      config\n    } = this;\n    const start = fragments[0].start;\n    let frag;\n    if (levelDetails.live) {\n      const initialLiveManifestSize = config.initialLiveManifestSize;\n      if (fragLen < initialLiveManifestSize) {\n        this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);\n        return null;\n      }\n      // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n      // In order to discover the range, we load the best matching fragment for that level and demux it.\n      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n      // we get the fragment matching that start time\n      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {\n        frag = this.getInitialLiveFragment(levelDetails, fragments);\n        this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n      }\n    } else if (pos <= start) {\n      // VoD playlist: if loadPosition before start of playlist, load first fragment\n      frag = fragments[0];\n    }\n\n    // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n    if (!frag) {\n      const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n      frag = this.getFragmentAtPosition(pos, end, levelDetails);\n    }\n    return this.mapToInitFragWhenRequired(frag);\n  }\n  isLoopLoading(frag, targetBufferTime) {\n    const trackerState = this.fragmentTracker.getState(frag);\n    return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n  }\n  getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n    const gapStart = frag.gap;\n    const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n    if (nextFragment === null) {\n      return nextFragment;\n    }\n    frag = nextFragment;\n    if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {\n      // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n      const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);\n      if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n        // Returning here might result in not finding an audio and video candiate to skip to\n        this.log(`buffer full after gaps in \"${playlistType}\" playlist starting at sn: ${frag.sn}`);\n        return null;\n      }\n    }\n    return frag;\n  }\n  mapToInitFragWhenRequired(frag) {\n    // If an initSegment is present, it must be buffered first\n    if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n      return frag.initSegment;\n    }\n    return frag;\n  }\n  getNextPart(partList, frag, targetBufferTime) {\n    let nextPart = -1;\n    let contiguous = false;\n    let independentAttrOmitted = true;\n    for (let i = 0, len = partList.length; i < len; i++) {\n      const part = partList[i];\n      independentAttrOmitted = independentAttrOmitted && !part.independent;\n      if (nextPart > -1 && targetBufferTime < part.start) {\n        break;\n      }\n      const loaded = part.loaded;\n      if (loaded) {\n        nextPart = -1;\n      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n        nextPart = i;\n      }\n      contiguous = loaded;\n    }\n    return nextPart;\n  }\n  loadedEndOfParts(partList, targetBufferTime) {\n    const lastPart = partList[partList.length - 1];\n    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n  }\n\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */\n  getInitialLiveFragment(levelDetails, fragments) {\n    const fragPrevious = this.fragPrevious;\n    let frag = null;\n    if (fragPrevious) {\n      if (levelDetails.hasProgramDateTime) {\n        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n        this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);\n        frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n      }\n      if (!frag) {\n        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n        const targetSN = fragPrevious.sn + 1;\n        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n          const fragNext = fragments[targetSN - levelDetails.startSN];\n          // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n          if (fragPrevious.cc === fragNext.cc) {\n            frag = fragNext;\n            this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);\n          }\n        }\n        // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n        // will have the wrong start times\n        if (!frag) {\n          frag = findFragWithCC(fragments, fragPrevious.cc);\n          if (frag) {\n            this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);\n          }\n        }\n      }\n    } else {\n      // Find a new start fragment when fragPrevious is null\n      const liveStart = this.hls.liveSyncPosition;\n      if (liveStart !== null) {\n        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n      }\n    }\n    return frag;\n  }\n\n  /*\n  This method finds the best matching fragment given the provided position.\n   */\n  getFragmentAtPosition(bufferEnd, end, levelDetails) {\n    const {\n      config\n    } = this;\n    let {\n      fragPrevious\n    } = this;\n    let {\n      fragments,\n      endSN\n    } = levelDetails;\n    const {\n      fragmentHint\n    } = levelDetails;\n    const tolerance = config.maxFragLookUpTolerance;\n    const partList = levelDetails.partList;\n    const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);\n    if (loadingParts && fragmentHint && !this.bitrateTest) {\n      // Include incomplete fragment with parts at end\n      fragments = fragments.concat(fragmentHint);\n      endSN = fragmentHint.sn;\n    }\n    let frag;\n    if (bufferEnd < end) {\n      const lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;\n      // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n      frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n    } else {\n      // reach end of playlist\n      frag = fragments[fragments.length - 1];\n    }\n    if (frag) {\n      const curSNIdx = frag.sn - levelDetails.startSN;\n      // Move fragPrevious forward to support forcing the next fragment to load\n      // when the buffer catches up to a previously buffered range.\n      const fragState = this.fragmentTracker.getState(frag);\n      if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n        fragPrevious = frag;\n      }\n      if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {\n        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n        // non-uniform fragment durations\n        const sameLevel = fragPrevious && frag.level === fragPrevious.level;\n        if (sameLevel) {\n          const nextFrag = fragments[curSNIdx + 1];\n          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n            frag = nextFrag;\n          } else {\n            frag = null;\n          }\n        }\n      }\n    }\n    return frag;\n  }\n  synchronizeToLiveEdge(levelDetails) {\n    const {\n      config,\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const liveSyncPosition = this.hls.liveSyncPosition;\n    const currentTime = media.currentTime;\n    const start = levelDetails.fragments[0].start;\n    const end = levelDetails.edge;\n    const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n    // Continue if we can seek forward to sync position or if current time is outside of sliding window\n    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n      // Continue if buffer is starving or if current time is behind max latency\n      const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n        if (!this.loadedmetadata) {\n          this.nextLoadPosition = liveSyncPosition;\n        }\n        // Only seek if ready and there is not a significant forward buffer available for playback\n        if (media.readyState) {\n          this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);\n          media.currentTime = liveSyncPosition;\n        }\n      }\n    }\n  }\n  alignPlaylists(details, previousDetails) {\n    const {\n      levels,\n      levelLastLoaded,\n      fragPrevious\n    } = this;\n    const lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null;\n\n    // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n    //  this could all go in level-helper mergeDetails()\n    const length = details.fragments.length;\n    if (!length) {\n      this.warn(`No fragments in live playlist`);\n      return 0;\n    }\n    const slidingStart = details.fragments[0].start;\n    const firstLevelLoad = !previousDetails;\n    const aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n    if (firstLevelLoad || !aligned && !slidingStart) {\n      alignStream(fragPrevious, lastLevel, details);\n      const alignedSlidingStart = details.fragments[0].start;\n      this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : 'na'}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : 'na'} fragments: ${length}`);\n      return alignedSlidingStart;\n    }\n    return slidingStart;\n  }\n  waitForCdnTuneIn(details) {\n    // Wait for Low-Latency CDN Tune-in to get an updated playlist\n    const advancePartLimit = 3;\n    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n  }\n  setStartPosition(details, sliding) {\n    // compute start position if set to -1. use it straight away if value is defined\n    let startPosition = this.startPosition;\n    if (startPosition < sliding) {\n      startPosition = -1;\n    }\n    if (startPosition === -1 || this.lastCurrentTime === -1) {\n      // Use Playlist EXT-X-START:TIME-OFFSET when set\n      // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n      const offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n      const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n      if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n        startPosition = sliding + startTimeOffset;\n        if (startTimeOffset < 0) {\n          startPosition += details.totalduration;\n        }\n        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n        this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? 'multivariant' : 'media'} playlist, adjust startPosition to ${startPosition}`);\n        this.startPosition = startPosition;\n      } else if (details.live) {\n        // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n        // not been specified via the config or an as an argument to startLoad (#3736).\n        startPosition = this.hls.liveSyncPosition || sliding;\n      } else {\n        this.startPosition = startPosition = 0;\n      }\n      this.lastCurrentTime = startPosition;\n    }\n    this.nextLoadPosition = startPosition;\n  }\n  getLoadPosition() {\n    const {\n      media\n    } = this;\n    // if we have not yet loaded any fragment, start loading from start position\n    let pos = 0;\n    if (this.loadedmetadata && media) {\n      pos = media.currentTime;\n    } else if (this.nextLoadPosition) {\n      pos = this.nextLoadPosition;\n    }\n    return pos;\n  }\n  handleFragLoadAborted(frag, part) {\n    if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n      this.warn(`Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} was aborted`);\n      this.resetFragmentLoading(frag);\n    }\n  }\n  resetFragmentLoading(frag) {\n    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n      this.state = State.IDLE;\n    }\n  }\n  onFragmentOrKeyLoadError(filterType, data) {\n    if (data.chunkMeta && !data.frag) {\n      const context = this.getCurrentContext(data.chunkMeta);\n      if (context) {\n        data.frag = context.frag;\n      }\n    }\n    const frag = data.frag;\n    // Handle frag error related to caller's filterType\n    if (!frag || frag.type !== filterType || !this.levels) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      var _this$fragCurrent2;\n      this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url}`);\n      return;\n    }\n    const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n    if (gapTagEncountered) {\n      this.fragmentTracker.fragBuffered(frag, true);\n    }\n    // keep retrying until the limit will be reached\n    const errorAction = data.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {\n      var _this$levelLastLoaded;\n      this.resetStartWhenNotLoaded((_this$levelLastLoaded = this.levelLastLoaded) != null ? _this$levelLastLoaded : frag.level);\n      const delay = getRetryDelay(retryConfig, retryCount);\n      this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);\n      errorAction.resolved = true;\n      this.retryDate = self.performance.now() + delay;\n      this.state = State.FRAG_LOADING_WAITING_RETRY;\n    } else if (retryConfig && errorAction) {\n      this.resetFragmentErrors(filterType);\n      if (retryCount < retryConfig.maxNumRetry) {\n        // Network retry is skipped when level switch is preferred\n        if (!gapTagEncountered) {\n          errorAction.resolved = true;\n        }\n      } else {\n        logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);\n      }\n    } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {\n      this.state = State.WAITING_LEVEL;\n    } else {\n      this.state = State.ERROR;\n    }\n    // Perform next async tick sooner to speed up error action resolution\n    this.tickImmediate();\n  }\n  reduceLengthAndFlushBuffer(data) {\n    // if in appending state\n    if (this.state === State.PARSING || this.state === State.PARSED) {\n      const playlistType = data.parent;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n      // reduce max buf len if current position is buffered\n      const buffered = bufferedInfo && bufferedInfo.len > 0.5;\n      if (buffered) {\n        this.reduceMaxBufferLength(bufferedInfo.len);\n      }\n      const flushBuffer = !buffered;\n      if (flushBuffer) {\n        // current position is not buffered, but browser is still complaining about buffer full error\n        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n        // in that case flush the whole audio buffer to recover\n        this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);\n      }\n      if (data.frag) {\n        this.fragmentTracker.removeFragment(data.frag);\n        this.nextLoadPosition = data.frag.start;\n      }\n      this.resetLoadingState();\n      return flushBuffer;\n    }\n    return false;\n  }\n  resetFragmentErrors(filterType) {\n    if (filterType === PlaylistLevelType.AUDIO) {\n      // Reset current fragment since audio track audio is essential and may not have a fail-over track\n      this.fragCurrent = null;\n    }\n    // Fragment errors that result in a level switch or redundant fail-over\n    // should reset the stream controller state to idle\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n    }\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n  }\n  afterBufferFlushed(media, bufferType, playlistType) {\n    if (!media) {\n      return;\n    }\n    // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n    // (so that we will check against video.buffered ranges in case of alt audio track)\n    const bufferedTimeRanges = BufferHelper.getBuffered(media);\n    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    }\n  }\n  resetLoadingState() {\n    this.log('Reset loading state');\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.state = State.IDLE;\n  }\n  resetStartWhenNotLoaded(level) {\n    // if loadedmetadata is not set, it means that first frag request failed\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      const details = this.levels ? this.levels[level].details : null;\n      if (details != null && details.live) {\n        // Update the start position and return to IDLE to recover live start\n        this.startPosition = -1;\n        this.setStartPosition(details, 0);\n        this.resetLoadingState();\n      } else {\n        this.nextLoadPosition = this.startPosition;\n      }\n    }\n  }\n  resetWhenMissingContext(chunkMeta) {\n    var _this$levelLastLoaded2;\n    this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);\n    this.removeUnbufferedFrags();\n    this.resetStartWhenNotLoaded((_this$levelLastLoaded2 = this.levelLastLoaded) != null ? _this$levelLastLoaded2 : chunkMeta.level);\n    this.resetLoadingState();\n  }\n  removeUnbufferedFrags(start = 0) {\n    this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n  }\n  updateLevelTiming(frag, part, level, partial) {\n    var _this$transmuxer;\n    const details = level.details;\n    if (!details) {\n      this.warn('level.details undefined');\n      return;\n    }\n    const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {\n      const info = frag.elementaryStreams[type];\n      if (info) {\n        const parsedDuration = info.endPTS - info.startPTS;\n        if (parsedDuration <= 0) {\n          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n          // The new transmuxer will be configured with a time offset matching the next fragment start,\n          // preventing the timeline from shifting.\n          this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);\n          return result || false;\n        }\n        const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n        this.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n          details,\n          level,\n          drift,\n          type,\n          frag,\n          start: info.startPTS,\n          end: info.endPTS\n        });\n        return true;\n      }\n      return result;\n    }, false);\n    if (parsed) {\n      level.fragmentError = 0;\n    } else if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n      const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);\n      if (level.fragmentError === 0) {\n        // Mark and track the odd empty segment as a gap to avoid reloading\n        level.fragmentError++;\n        frag.gap = true;\n        this.fragmentTracker.removeFragment(frag);\n        this.fragmentTracker.fragBuffered(frag, true);\n      }\n      this.warn(error.message);\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        error,\n        frag,\n        reason: `Found no media in msn ${frag.sn} of level \"${level.url}\"`\n      });\n      if (!this.hls) {\n        return;\n      }\n      this.resetTransmuxer();\n      // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n    }\n\n    this.state = State.PARSED;\n    this.hls.trigger(Events.FRAG_PARSED, {\n      frag,\n      part\n    });\n  }\n  resetTransmuxer() {\n    if (this.transmuxer) {\n      this.transmuxer.destroy();\n      this.transmuxer = null;\n    }\n  }\n  recoverWorkerError(data) {\n    if (data.event === 'demuxerWorker') {\n      var _ref, _this$levelLastLoaded3, _this$fragCurrent3;\n      this.fragmentTracker.removeAllFragments();\n      this.resetTransmuxer();\n      this.resetStartWhenNotLoaded((_ref = (_this$levelLastLoaded3 = this.levelLastLoaded) != null ? _this$levelLastLoaded3 : (_this$fragCurrent3 = this.fragCurrent) == null ? void 0 : _this$fragCurrent3.level) != null ? _ref : 0);\n      this.resetLoadingState();\n    }\n  }\n  set state(nextState) {\n    const previousState = this._state;\n    if (previousState !== nextState) {\n      this._state = nextState;\n      this.log(`${previousState}->${nextState}`);\n    }\n  }\n  get state() {\n    return this._state;\n  }\n}\n\nfunction getSourceBuffer() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\n\n/**\n * @ignore\n */\nfunction isSupported() {\n  const mediaSource = getMediaSource();\n  if (!mediaSource) {\n    return false;\n  }\n  const sourceBuffer = getSourceBuffer();\n  const isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n\n  // if SourceBuffer is exposed ensure its API is valid\n  // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n  const sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n  return !!isTypeSupported && !!sourceBufferValidAPI;\n}\n\n/**\n * @ignore\n */\nfunction changeTypeSupported() {\n  var _sourceBuffer$prototy;\n  const sourceBuffer = getSourceBuffer();\n  return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n}\n\n// ensure the worker ends up in the bundle\n// If the worker should not be included this gets aliased to empty.js\nfunction hasUMDWorker() {\n  return typeof __HLS_WORKER_BUNDLE__ === 'function';\n}\nfunction injectWorker() {\n  const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {\n    type: 'text/javascript'\n  });\n  const objectURL = self.URL.createObjectURL(blob);\n  const worker = new self.Worker(objectURL);\n  return {\n    worker,\n    objectURL\n  };\n}\nfunction loadWorker(path) {\n  const scriptURL = new self.URL(path, self.location.href).href;\n  const worker = new self.Worker(scriptURL);\n  return {\n    worker,\n    scriptURL\n  };\n}\n\nfunction dummyTrack(type = '', inputTimeScale = 90000) {\n  return {\n    type,\n    id: -1,\n    pid: -1,\n    inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\n\nclass BaseAudioDemuxer {\n  constructor() {\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this.frameIndex = 0;\n    this.cachedData = null;\n    this.basePTS = null;\n    this.initPTS = null;\n    this.lastPTS = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  }\n  resetTimeStamp(deaultTimestamp) {\n    this.initPTS = deaultTimestamp;\n    this.resetContiguity();\n  }\n  resetContiguity() {\n    this.basePTS = null;\n    this.lastPTS = null;\n    this.frameIndex = 0;\n  }\n  canParse(data, offset) {\n    return false;\n  }\n  appendFrame(track, data, offset) {}\n\n  // feed incoming data to the front of the parsing pipeline\n  demux(data, timeOffset) {\n    if (this.cachedData) {\n      data = appendUint8Array(this.cachedData, data);\n      this.cachedData = null;\n    }\n    let id3Data = getID3Data(data, 0);\n    let offset = id3Data ? id3Data.length : 0;\n    let lastDataIndex;\n    const track = this._audioTrack;\n    const id3Track = this._id3Track;\n    const timestamp = id3Data ? getTimeStamp(id3Data) : undefined;\n    const length = data.length;\n    if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n      this.lastPTS = this.basePTS;\n    }\n    if (this.lastPTS === null) {\n      this.lastPTS = this.basePTS;\n    }\n\n    // more expressive than alternative: id3Data?.length\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: id3Data,\n        type: MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      });\n    }\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        const frame = this.appendFrame(track, data, offset);\n        if (frame) {\n          this.frameIndex++;\n          this.lastPTS = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (canParse$2(data, offset)) {\n        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n        id3Data = getID3Data(data, offset);\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n      if (offset === length && lastDataIndex !== length) {\n        const partialData = sliceUint8(data, lastDataIndex);\n        if (this.cachedData) {\n          this.cachedData = appendUint8Array(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n    return {\n      audioTrack: track,\n      videoTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));\n  }\n  flush(timeOffset) {\n    // Parse cache in case of remaining frames.\n    const cachedData = this.cachedData;\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n    return {\n      audioTrack: this._audioTrack,\n      videoTrack: dummyTrack(),\n      id3Track: this._id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  destroy() {}\n}\n\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\nconst initPTSFn = (timestamp, timeOffset, initPTS) => {\n  if (isFiniteNumber(timestamp)) {\n    return timestamp * 90;\n  }\n  const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n  return timeOffset * 90000 + init90kHz;\n};\n\n/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */\nfunction getAudioConfig(observer, data, offset, audioCodec) {\n  let adtsObjectType;\n  let adtsExtensionSamplingIndex;\n  let adtsChannelConfig;\n  let config;\n  const userAgent = navigator.userAgent.toLowerCase();\n  const manifestCodec = audioCodec;\n  const adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  // byte 2\n  adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n  const adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n  if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n    observer.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: true,\n      reason: `invalid ADTS sampling index:${adtsSamplingIndex}`\n    });\n    return;\n  }\n  adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n  // byte 3\n  adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n  logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);\n  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n  if (/firefox/i.test(userAgent)) {\n    if (adtsSamplingIndex >= 6) {\n      adtsObjectType = 5;\n      config = new Array(4);\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      adtsObjectType = 2;\n      config = new Array(2);\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n    // Android : always use AAC\n  } else if (userAgent.indexOf('android') !== -1) {\n    adtsObjectType = 2;\n    config = new Array(2);\n    adtsExtensionSamplingIndex = adtsSamplingIndex;\n  } else {\n    /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */\n    adtsObjectType = 5;\n    config = new Array(4);\n    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n      }\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n  }\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n  config[0] = adtsObjectType << 3;\n  // samplingFrequencyIndex\n  config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n  config[1] |= (adtsSamplingIndex & 0x01) << 7;\n  // channelConfiguration\n  config[1] |= adtsChannelConfig << 3;\n  if (adtsObjectType === 5) {\n    // adtsExtensionSamplingIndex\n    config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n    config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n    config[2] |= 2 << 2;\n    config[3] = 0;\n  }\n  return {\n    config,\n    samplerate: adtsSamplingRates[adtsSamplingIndex],\n    channelCount: adtsChannelConfig,\n    codec: 'mp4a.40.' + adtsObjectType,\n    manifestCodec\n  };\n}\nfunction isHeaderPattern$1(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n  return offset + 5 < data.length;\n}\nfunction isHeader$1(data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n}\nfunction canParse$1(data, offset) {\n  return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe$1(data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader$1(data, offset)) {\n    // ADTS header Length\n    const headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength >= data.length) {\n      return false;\n    }\n    // ADTS frame Length\n    const frameLength = getFullFrameLength(data, offset);\n    if (frameLength <= headerLength) {\n      return false;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader$1(data, newOffset);\n  }\n  return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    const config = getAudioConfig(observer, data, offset, audioCodec);\n    if (!config) {\n      return;\n    }\n    track.config = config.config;\n    track.samplerate = config.samplerate;\n    track.channelCount = config.channelCount;\n    track.codec = config.codec;\n    track.manifestCodec = config.manifestCodec;\n    logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);\n  }\n}\nfunction getFrameDuration(samplerate) {\n  return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  const headerLength = getHeaderLength(data, offset);\n  if (offset + headerLength <= data.length) {\n    // retrieve frame size\n    const frameLength = getFullFrameLength(data, offset) - headerLength;\n    if (frameLength > 0) {\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n      return {\n        headerLength,\n        frameLength\n      };\n    }\n  }\n}\nfunction appendFrame$1(track, data, offset, pts, frameIndex) {\n  const frameDuration = getFrameDuration(track.samplerate);\n  const stamp = pts + frameIndex * frameDuration;\n  const header = parseFrameHeader(data, offset);\n  let unit;\n  if (header) {\n    const {\n      frameLength,\n      headerLength\n    } = header;\n    const _length = headerLength + frameLength;\n    const missing = Math.max(0, offset + _length - data.length);\n    // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n    if (missing) {\n      unit = new Uint8Array(_length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + _length);\n    }\n    const _sample = {\n      unit,\n      pts: stamp\n    };\n    if (!missing) {\n      track.samples.push(_sample);\n    }\n    return {\n      sample: _sample,\n      length: _length,\n      missing\n    };\n  }\n  // overflow incomplete header\n  const length = data.length - offset;\n  unit = new Uint8Array(length);\n  unit.set(data.subarray(offset, data.length), 0);\n  const sample = {\n    unit,\n    pts: stamp\n  };\n  return {\n    sample,\n    length,\n    missing: -1\n  };\n}\n\n/**\n * AAC demuxer\n */\nclass AACDemuxer extends BaseAudioDemuxer {\n  constructor(observer, config) {\n    super();\n    this.observer = void 0;\n    this.config = void 0;\n    this.observer = observer;\n    this.config = config;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'aac',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    const id3Data = getID3Data(data, 0) || [];\n    let offset = id3Data.length;\n    for (let length = data.length; offset < length; offset++) {\n      if (probe$1(data, offset)) {\n        logger.log('ADTS sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse$1(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n    const frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  }\n}\n\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\nclass MP4Demuxer {\n  constructor(observer, config) {\n    this.remainderData = null;\n    this.timeOffset = 0;\n    this.config = void 0;\n    this.videoTrack = void 0;\n    this.audioTrack = void 0;\n    this.id3Track = void 0;\n    this.txtTrack = void 0;\n    this.config = config;\n  }\n  resetTimeStamp() {}\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    const videoTrack = this.videoTrack = dummyTrack('video', 1);\n    const audioTrack = this.audioTrack = dummyTrack('audio', 1);\n    const captionTrack = this.txtTrack = dummyTrack('text', 1);\n    this.id3Track = dummyTrack('id3', 1);\n    this.timeOffset = 0;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      return;\n    }\n    const initData = parseInitSegment(initSegment);\n    if (initData.video) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.video;\n      videoTrack.id = id;\n      videoTrack.timescale = captionTrack.timescale = timescale;\n      videoTrack.codec = codec;\n    }\n    if (initData.audio) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.audio;\n      audioTrack.id = id;\n      audioTrack.timescale = timescale;\n      audioTrack.codec = codec;\n    }\n    captionTrack.id = RemuxerTrackIdConfig.text;\n    videoTrack.sampleDuration = 0;\n    videoTrack.duration = audioTrack.duration = trackDuration;\n  }\n  resetContiguity() {\n    this.remainderData = null;\n  }\n  static probe(data) {\n    // ensure we find a moof box in the first 16 kB\n    data = data.length > 16384 ? data.subarray(0, 16384) : data;\n    return findBox(data, ['moof']).length > 0;\n  }\n  demux(data, timeOffset) {\n    this.timeOffset = timeOffset;\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n    let videoSamples = data;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        videoSamples = appendUint8Array(this.remainderData, data);\n      }\n      const segmentedData = segmentValidRange(videoSamples);\n      this.remainderData = segmentedData.remainder;\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      videoTrack.samples = videoSamples;\n    }\n    const id3Track = this.extractID3Track(videoTrack, timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: this.audioTrack,\n      id3Track,\n      textTrack: this.txtTrack\n    };\n  }\n  flush() {\n    const timeOffset = this.timeOffset;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    videoTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  extractID3Track(videoTrack, timeOffset) {\n    const id3Track = this.id3Track;\n    if (videoTrack.samples.length) {\n      const emsgs = findBox(videoTrack.samples, ['emsg']);\n      if (emsgs) {\n        emsgs.forEach(data => {\n          const emsgInfo = parseEmsg(data);\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n            const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n            let duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n            // Safari takes anything <= 0.001 seconds and maps it to Infinity\n            if (duration <= 0.001) {\n              duration = Number.POSITIVE_INFINITY;\n            }\n            const payload = emsgInfo.payload;\n            id3Track.samples.push({\n              data: payload,\n              len: payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.emsg,\n              duration: duration\n            });\n          }\n        });\n      }\n    }\n    return id3Track;\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n  }\n  destroy() {}\n}\n\n/**\n *  MPEG parser helper\n */\n\nlet chromeVersion$1 = null;\nconst BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\nconst SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\nconst SamplesCoefficients = [\n// MPEG 2.5\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// Reserved\n[0,\n// Reserved\n0,\n// Layer3\n0,\n// Layer2\n0 // Layer1\n],\n// MPEG 2\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// MPEG 1\n[0,\n// Reserved\n144,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n]];\n\nconst BytesInSlot = [0,\n// Reserved\n1,\n// Layer3\n1,\n// Layer2\n4 // Layer1\n];\n\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n  const header = parseHeader(data, offset);\n  if (header && offset + header.frameLength <= data.length) {\n    const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n    const stamp = pts + frameIndex * frameDuration;\n    const sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n    return {\n      sample,\n      length: header.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction parseHeader(data, offset) {\n  const mpegVersion = data[offset + 1] >> 3 & 3;\n  const mpegLayer = data[offset + 1] >> 1 & 3;\n  const bitRateIndex = data[offset + 2] >> 4 & 15;\n  const sampleRateIndex = data[offset + 2] >> 2 & 3;\n  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n    const paddingBit = data[offset + 2] >> 1 & 1;\n    const channelMode = data[offset + 3] >> 6;\n    const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    const bytesInSlot = BytesInSlot[mpegLayer];\n    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n    if (chromeVersion$1 === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion$1 = result ? parseInt(result[1]) : 0;\n    }\n    const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n    return {\n      sampleRate,\n      channelCount,\n      frameLength,\n      samplesPerFrame\n    };\n  }\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  const headerSize = 4;\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    const headerLength = 4;\n    // MPEG frame Length\n    const header = parseHeader(data, offset);\n    let frameLength = headerLength;\n    if (header != null && header.frameLength) {\n      frameLength = header.frameLength;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\nclass ExpGolomb {\n  constructor(data) {\n    this.data = void 0;\n    this.bytesAvailable = void 0;\n    this.word = void 0;\n    this.bitsAvailable = void 0;\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n  loadWord() {\n    const data = this.data;\n    const bytesAvailable = this.bytesAvailable;\n    const position = data.byteLength - bytesAvailable;\n    const workingBytes = new Uint8Array(4);\n    const availableBytes = Math.min(4, bytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\n    // track the amount of this.data that has been processed\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  }\n\n  // (count:int):void\n  skipBits(count) {\n    let skipBytes; // :int\n    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes << 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  }\n\n  // (size:int):uint\n  readBits(size) {\n    let bits = Math.min(this.bitsAvailable, size); // :uint\n    const valu = this.word >>> 32 - bits; // :uint\n    if (size > 32) {\n      logger.error('Cannot read more than 32 bits at a time');\n    }\n    this.bitsAvailable -= bits;\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    } else {\n      throw new Error('no bits available');\n    }\n    bits = size - bits;\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  // ():uint\n  skipLZ() {\n    let leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    // we exhausted word and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  }\n\n  // ():void\n  skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():void\n  skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():uint\n  readUEG() {\n    const clz = this.skipLZ(); // :uint\n    return this.readBits(clz + 1) - 1;\n  }\n\n  // ():int\n  readEG() {\n    const valu = this.readUEG(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  }\n\n  // Some convenience functions\n  // :Boolean\n  readBoolean() {\n    return this.readBits(1) === 1;\n  }\n\n  // ():int\n  readUByte() {\n    return this.readBits(8);\n  }\n\n  // ():int\n  readUShort() {\n    return this.readBits(16);\n  }\n\n  // ():int\n  readUInt() {\n    return this.readBits(32);\n  }\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList(count) {\n    let lastScale = 8;\n    let nextScale = 8;\n    let deltaScale;\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSPS() {\n    let frameCropLeftOffset = 0;\n    let frameCropRightOffset = 0;\n    let frameCropTopOffset = 0;\n    let frameCropBottomOffset = 0;\n    let numRefFramesInPicOrderCntCycle;\n    let scalingListCount;\n    let i;\n    const readUByte = this.readUByte.bind(this);\n    const readBits = this.readBits.bind(this);\n    const readUEG = this.readUEG.bind(this);\n    const readBoolean = this.readBoolean.bind(this);\n    const skipBits = this.skipBits.bind(this);\n    const skipEG = this.skipEG.bind(this);\n    const skipUEG = this.skipUEG.bind(this);\n    const skipScalingList = this.skipScalingList.bind(this);\n    readUByte();\n    const profileIdc = readUByte(); // profile_idc\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n    skipBits(3); // reserved_zero_3bits u(3),\n    readUByte(); // level_idc u(8)\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n      const chromaFormatIdc = readUEG();\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n      skipUEG(); // bit_depth_luma_minus8\n      skipUEG(); // bit_depth_chroma_minus8\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16);\n            } else {\n              skipScalingList(64);\n            }\n          }\n        }\n      }\n    }\n    skipUEG(); // log2_max_frame_num_minus4\n    const picOrderCntType = readUEG();\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n      skipEG(); // offset_for_non_ref_pic\n      skipEG(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = readUEG();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n    }\n\n    skipUEG(); // max_num_ref_frames\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    const picWidthInMbsMinus1 = readUEG();\n    const picHeightInMapUnitsMinus1 = readUEG();\n    const frameMbsOnlyFlag = readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n    skipBits(1); // direct_8x8_inference_flag\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n    let pixelRatio = [1, 1];\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        const aspectRatioIdc = readUByte();\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n          case 255:\n            {\n              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n              break;\n            }\n        }\n      }\n    }\n    return {\n      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio\n    };\n  }\n  readSliceType() {\n    // skip NALu type\n    this.readUByte();\n    // discard first_mb_in_slice\n    this.readUEG();\n    // return slice_type\n    return this.readUEG();\n  }\n}\n\n/**\n * SAMPLE-AES decrypter\n */\n\nclass SampleAesDecrypter {\n  constructor(observer, config, keyData) {\n    this.keyData = void 0;\n    this.decrypter = void 0;\n    this.keyData = keyData;\n    this.decrypter = new Decrypter(config, {\n      removePKCS7Padding: false\n    });\n  }\n  decryptBuffer(encryptedData) {\n    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n  }\n\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  decryptAacSample(samples, sampleIndex, callback) {\n    const curUnit = samples[sampleIndex].unit;\n    if (curUnit.length <= 16) {\n      // No encrypted portion in this sample (first 16 bytes is not\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n      return;\n    }\n    const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n    this.decryptBuffer(encryptedBuffer).then(decryptedBuffer => {\n      const decryptedData = new Uint8Array(decryptedBuffer);\n      curUnit.set(decryptedData, 16);\n      if (!this.decrypter.isSync()) {\n        this.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  }\n  decryptAacSamples(samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n      this.decryptAacSample(samples, sampleIndex, callback);\n      if (!this.decrypter.isSync()) {\n        return;\n      }\n    }\n  }\n\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  getAvcEncryptedData(decodedData) {\n    const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    const encryptedData = new Int8Array(encryptedDataLen);\n    let outputPos = 0;\n    for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return encryptedData;\n  }\n  getAvcDecryptedUnit(decodedData, decryptedData) {\n    const uint8DecryptedData = new Uint8Array(decryptedData);\n    let inputPos = 0;\n    for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return decodedData;\n  }\n  decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n    const decodedData = discardEPB(curUnit.data);\n    const encryptedData = this.getAvcEncryptedData(decodedData);\n    this.decryptBuffer(encryptedData.buffer).then(decryptedBuffer => {\n      curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n      if (!this.decrypter.isSync()) {\n        this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  }\n  decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      const curUnits = samples[sampleIndex].units;\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n        const curUnit = curUnits[unitIndex];\n        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n          continue;\n        }\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n  }\n}\n\nconst PACKET_LENGTH = 188;\nclass TSDemuxer {\n  constructor(observer, config, typeSupported) {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.sampleAes = null;\n    this.pmtParsed = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this._duration = 0;\n    this._pmtId = -1;\n    this._avcTrack = void 0;\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this._txtTrack = void 0;\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n  }\n  static probe(data) {\n    const syncOffset = TSDemuxer.syncOffset(data);\n    if (syncOffset > 0) {\n      logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);\n    }\n    return syncOffset !== -1;\n  }\n  static syncOffset(data) {\n    const length = data.length;\n    let scanwindow = Math.min(PACKET_LENGTH * 5, data.length - PACKET_LENGTH) + 1;\n    let i = 0;\n    while (i < scanwindow) {\n      // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n      let foundPat = false;\n      let packetStart = -1;\n      let tsPackets = 0;\n      for (let j = i; j < length; j += PACKET_LENGTH) {\n        if (data[j] === 0x47) {\n          tsPackets++;\n          if (packetStart === -1) {\n            packetStart = j;\n            // First sync word found at offset, increase scan length (#5251)\n            if (packetStart !== 0) {\n              scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n            }\n          }\n          if (!foundPat) {\n            foundPat = parsePID(data, j) === 0;\n          }\n          // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n          if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n            return packetStart;\n          }\n        } else if (tsPackets) {\n          // Exit if sync word found, but does not contain contiguous packets (#5501)\n          return -1;\n        } else {\n          break;\n        }\n      }\n      i++;\n    }\n    return -1;\n  }\n\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */\n  static createTrack(type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type,\n      id: RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n    this._avcTrack = TSDemuxer.createTrack('video');\n    this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n    this._id3Track = TSDemuxer.createTrack('id3');\n    this._txtTrack = TSDemuxer.createTrack('text');\n    this._audioTrack.segmentCodec = 'aac';\n\n    // flush any partial content\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this._duration = trackDuration;\n  }\n  resetTimeStamp() {}\n  resetContiguity() {\n    const {\n      _audioTrack,\n      _avcTrack,\n      _id3Track\n    } = this;\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n    if (_avcTrack) {\n      _avcTrack.pesData = null;\n    }\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n  }\n  demux(data, timeOffset, isSampleAes = false, flush = false) {\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n    let pes;\n    const videoTrack = this._avcTrack;\n    const audioTrack = this._audioTrack;\n    const id3Track = this._id3Track;\n    const textTrack = this._txtTrack;\n    let avcId = videoTrack.pid;\n    let avcData = videoTrack.pesData;\n    let audioId = audioTrack.pid;\n    let id3Id = id3Track.pid;\n    let audioData = audioTrack.pesData;\n    let id3Data = id3Track.pesData;\n    let unknownPID = null;\n    let pmtParsed = this.pmtParsed;\n    let pmtId = this._pmtId;\n    let len = data.length;\n    if (this.remainderData) {\n      data = appendUint8Array(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n    if (len < PACKET_LENGTH && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack,\n        videoTrack,\n        id3Track,\n        textTrack\n      };\n    }\n    const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len - syncOffset) % PACKET_LENGTH;\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n    }\n\n    // loop through TS packets\n    let tsPacketErrors = 0;\n    for (let start = syncOffset; start < len; start += PACKET_LENGTH) {\n      if (data[start] === 0x47) {\n        const stt = !!(data[start + 1] & 0x40);\n        const pid = parsePID(data, start);\n        const atf = (data[start + 3] & 0x30) >> 4;\n\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n        let offset;\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === start + PACKET_LENGTH) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n          case avcId:\n            if (stt) {\n              if (avcData && (pes = parsePES(avcData))) {\n                this.parseAVCPES(videoTrack, textTrack, pes, false);\n              }\n              avcData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (avcData) {\n              avcData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              avcData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case audioId:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData))) {\n                switch (audioTrack.segmentCodec) {\n                  case 'aac':\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                  case 'mp3':\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                }\n              }\n              audioData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              audioData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case id3Id:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data))) {\n                this.parseID3PES(id3Track, pes);\n              }\n              id3Data = {\n                data: [],\n                size: 0\n              };\n            }\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              id3Data.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n            pmtId = this._pmtId = parsePAT(data, offset);\n            // logger.log('PMT PID:'  + this._pmtId);\n            break;\n          case pmtId:\n            {\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);\n\n              // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              // NOTE this is only the PID of the track as found in TS,\n              // but we are not using this for MP4 track IDs.\n              avcId = parsedPIDs.avc;\n              if (avcId > 0) {\n                videoTrack.pid = avcId;\n              }\n              audioId = parsedPIDs.audio;\n              if (audioId > 0) {\n                audioTrack.pid = audioId;\n                audioTrack.segmentCodec = parsedPIDs.segmentCodec;\n              }\n              id3Id = parsedPIDs.id3;\n              if (id3Id > 0) {\n                id3Track.pid = id3Id;\n              }\n              if (unknownPID !== null && !pmtParsed) {\n                logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);\n                unknownPID = null;\n                // we set it to -188, the += 188 in the for loop will reset start to 0\n                start = syncOffset - 188;\n              }\n              pmtParsed = this.pmtParsed = true;\n              break;\n            }\n          case 0x11:\n          case 0x1fff:\n            break;\n          default:\n            unknownPID = pid;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n    if (tsPacketErrors > 0) {\n      const error = new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`);\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        error,\n        reason: error.message\n      });\n    }\n    videoTrack.pesData = avcData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n    const demuxResult = {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    };\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n    return demuxResult;\n  }\n  flush() {\n    const {\n      remainderData\n    } = this;\n    this.remainderData = null;\n    let result;\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        videoTrack: this._avcTrack,\n        audioTrack: this._audioTrack,\n        id3Track: this._id3Track,\n        textTrack: this._txtTrack\n      };\n    }\n    this.extractRemainingSamples(result);\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n    return result;\n  }\n  extractRemainingSamples(demuxResult) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const avcData = videoTrack.pesData;\n    const audioData = audioTrack.pesData;\n    const id3Data = id3Track.pesData;\n    // try to parse last PES packets\n    let pes;\n    if (avcData && (pes = parsePES(avcData))) {\n      this.parseAVCPES(videoTrack, textTrack, pes, true);\n      videoTrack.pesData = null;\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      videoTrack.pesData = avcData;\n    }\n    if (audioData && (pes = parsePES(audioData))) {\n      switch (audioTrack.segmentCodec) {\n        case 'aac':\n          this.parseAACPES(audioTrack, pes);\n          break;\n        case 'mp3':\n          this.parseMPEGPES(audioTrack, pes);\n          break;\n      }\n      audioTrack.pesData = null;\n    } else {\n      if (audioData != null && audioData.size) {\n        logger.log('last AAC PES packet truncated,might overlap between fragments');\n      }\n\n      // either audioData null or PES truncated, keep it for next frag parsing\n      audioTrack.pesData = audioData;\n    }\n    if (id3Data && (pes = parsePES(id3Data))) {\n      this.parseID3PES(id3Track, pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n    const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n    return this.decrypt(demuxResult, sampleAes);\n  }\n  decrypt(demuxResult, sampleAes) {\n    return new Promise(resolve => {\n      const {\n        audioTrack,\n        videoTrack\n      } = demuxResult;\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {\n          if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n              resolve(demuxResult);\n            });\n          } else {\n            resolve(demuxResult);\n          }\n        });\n      } else if (videoTrack.samples) {\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n          resolve(demuxResult);\n        });\n      }\n    });\n  }\n  destroy() {\n    this._duration = 0;\n  }\n  parseAVCPES(track, textTrack, pes, last) {\n    const units = this.parseAVCNALu(track, pes.data);\n    let avcSample = this.avcSample;\n    let push;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (avcSample && units.length && !track.audFound) {\n      pushAccessUnit(avcSample, track);\n      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n    }\n    units.forEach(unit => {\n      var _avcSample2;\n      switch (unit.type) {\n        // NDR\n        case 1:\n          {\n            let iskey = false;\n            push = true;\n            const data = unit.data;\n            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n            if (spsfound && data.length > 4) {\n              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n              const sliceType = new ExpGolomb(data).readSliceType();\n              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              // if (sliceType === 2 || sliceType === 7) {\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                iskey = true;\n              }\n            }\n            if (iskey) {\n              var _avcSample;\n              // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n              if ((_avcSample = avcSample) != null && _avcSample.frame && !avcSample.key) {\n                pushAccessUnit(avcSample, track);\n                avcSample = this.avcSample = null;\n              }\n            }\n            if (!avcSample) {\n              avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n            }\n            avcSample.frame = true;\n            avcSample.key = iskey;\n            break;\n            // IDR\n          }\n\n        case 5:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n          if ((_avcSample2 = avcSample) != null && _avcSample2.frame && !avcSample.key) {\n            pushAccessUnit(avcSample, track);\n            avcSample = this.avcSample = null;\n          }\n          if (!avcSample) {\n            avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n          }\n          avcSample.key = true;\n          avcSample.frame = true;\n          break;\n        // SEI\n        case 6:\n          {\n            push = true;\n            parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n            break;\n            // SPS\n          }\n\n        case 7:\n          push = true;\n          spsfound = true;\n          if (!track.sps) {\n            const sps = unit.data;\n            const expGolombDecoder = new ExpGolomb(sps);\n            const config = expGolombDecoder.readSPS();\n            track.width = config.width;\n            track.height = config.height;\n            track.pixelRatio = config.pixelRatio;\n            track.sps = [sps];\n            track.duration = this._duration;\n            const codecarray = sps.subarray(1, 4);\n            let codecstring = 'avc1.';\n            for (let i = 0; i < 3; i++) {\n              let h = codecarray[i].toString(16);\n              if (h.length < 2) {\n                h = '0' + h;\n              }\n              codecstring += h;\n            }\n            track.codec = codecstring;\n          }\n          break;\n        // PPS\n        case 8:\n          push = true;\n          if (!track.pps) {\n            track.pps = [unit.data];\n          }\n          break;\n        // AUD\n        case 9:\n          push = false;\n          track.audFound = true;\n          if (avcSample) {\n            pushAccessUnit(avcSample, track);\n          }\n          avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n          break;\n        // Filler Data\n        case 12:\n          push = true;\n          break;\n        default:\n          push = false;\n          if (avcSample) {\n            avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n          }\n          break;\n      }\n      if (avcSample && push) {\n        const units = avcSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (last && avcSample) {\n      pushAccessUnit(avcSample, track);\n      this.avcSample = null;\n    }\n  }\n  getLastNalUnit(samples) {\n    var _avcSample3;\n    let avcSample = this.avcSample;\n    let lastUnit;\n    // try to fallback to previous sample if current one is empty\n    if (!avcSample || avcSample.units.length === 0) {\n      avcSample = samples[samples.length - 1];\n    }\n    if ((_avcSample3 = avcSample) != null && _avcSample3.units) {\n      const units = avcSample.units;\n      lastUnit = units[units.length - 1];\n    }\n    return lastUnit;\n  }\n  parseAVCNALu(track, array) {\n    const len = array.byteLength;\n    let state = track.naluState || 0;\n    const lastState = state;\n    const units = [];\n    let i = 0;\n    let value;\n    let overflow;\n    let unitType;\n    let lastUnitStart = -1;\n    let lastUnitType = 0;\n    // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0;\n      // NALu type is value read from offset 0\n      lastUnitType = array[0] & 0x1f;\n      state = 0;\n      i = 1;\n    }\n    while (i < len) {\n      value = array[i++];\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      }\n      // here we have state either equal to 2 or 3\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        if (lastUnitStart >= 0) {\n          const unit = {\n            data: array.subarray(lastUnitStart, i - state - 1),\n            type: lastUnitType\n          };\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          const lastUnit = this.getLastNalUnit(track.samples);\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            }\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n            overflow = i - state - 1;\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              const tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n              tmp.set(lastUnit.data, 0);\n              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n              lastUnit.data = tmp;\n              lastUnit.state = 0;\n            }\n          }\n        }\n        // check if we can read unit type\n        if (i < len) {\n          unitType = array[i] & 0x1f;\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n    if (lastUnitStart >= 0 && state >= 0) {\n      const unit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state\n      };\n      units.push(unit);\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    }\n    // no NALu found\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      const lastUnit = this.getLastNalUnit(track.samples);\n      if (lastUnit) {\n        const tmp = new Uint8Array(lastUnit.data.byteLength + array.byteLength);\n        tmp.set(lastUnit.data, 0);\n        tmp.set(array, lastUnit.data.byteLength);\n        lastUnit.data = tmp;\n      }\n    }\n    track.naluState = state;\n    return units;\n  }\n  parseAACPES(track, pes) {\n    let startOffset = 0;\n    const aacOverFlow = this.aacOverFlow;\n    let data = pes.data;\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      const frameMissingBytes = aacOverFlow.missing;\n      const sampleLength = aacOverFlow.sample.unit.byteLength;\n      // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n      if (frameMissingBytes === -1) {\n        const tmp = new Uint8Array(sampleLength + data.byteLength);\n        tmp.set(aacOverFlow.sample.unit, 0);\n        tmp.set(data, sampleLength);\n        data = tmp;\n      } else {\n        const frameOverflowBytes = sampleLength - frameMissingBytes;\n        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n        track.samples.push(aacOverFlow.sample);\n        startOffset = aacOverFlow.missing;\n      }\n    }\n    // look for ADTS header (0xFFFx)\n    let offset;\n    let len;\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (isHeader$1(data, offset)) {\n        break;\n      }\n    }\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n    if (offset !== startOffset) {\n      let reason;\n      const recoverable = offset < len - 1;\n      if (recoverable) {\n        reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n      } else {\n        reason = 'No ADTS header found in AAC PES';\n      }\n      const error = new Error(reason);\n      logger.warn(`parsing error: ${reason}`);\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        levelRetry: recoverable,\n        error,\n        reason\n      });\n      if (!recoverable) {\n        return;\n      }\n    }\n    initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n    let pts;\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      const frameDuration = getFrameDuration(track.samplerate);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    }\n\n    // scan for aac samples\n    let frameIndex = 0;\n    let frame;\n    while (offset < len) {\n      frame = appendFrame$1(track, data, offset, pts, frameIndex);\n      offset += frame.length;\n      if (!frame.missing) {\n        frameIndex++;\n        for (; offset < len - 1; offset++) {\n          if (isHeader$1(data, offset)) {\n            break;\n          }\n        }\n      } else {\n        this.aacOverFlow = frame;\n        break;\n      }\n    }\n  }\n  parseMPEGPES(track, pes) {\n    const data = pes.data;\n    const length = data.length;\n    let frameIndex = 0;\n    let offset = 0;\n    const pts = pes.pts;\n    if (pts === undefined) {\n      logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n    while (offset < length) {\n      if (isHeader(data, offset)) {\n        const frame = appendFrame(track, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  }\n  parseID3PES(id3Track, pes) {\n    if (pes.pts === undefined) {\n      logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n    const id3Sample = _extends({}, pes, {\n      type: this._avcTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n      duration: Number.POSITIVE_INFINITY\n    });\n    id3Track.samples.push(id3Sample);\n  }\n}\nfunction createAVCSample(key, pts, dts, debug) {\n  return {\n    key,\n    frame: false,\n    pts,\n    dts,\n    units: [],\n    debug,\n    length: 0\n  };\n}\nfunction parsePID(data, offset) {\n  // pid is a 13-bit field starting at the last bit of TS[1]\n  return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\nfunction parsePAT(data, offset) {\n  // skip the PSI header and parse the first PMT entry\n  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n}\nfunction parsePMT(data, offset, typeSupported, isSampleAes) {\n  const result = {\n    audio: -1,\n    avc: -1,\n    id3: -1,\n    segmentCodec: 'aac'\n  };\n  const sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n  const tableEnd = offset + 3 + sectionLength - 4;\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  const programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n  // advance the offset to the first entry in the mapping table\n  offset += 12 + programInfoLength;\n  while (offset < tableEnd) {\n    const pid = parsePID(data, offset);\n    switch (data[offset]) {\n      case 0xcf:\n        // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          logger.log('ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream');\n          break;\n        }\n      /* falls through */\n      case 0x0f:\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audio === -1) {\n          result.audio = pid;\n        }\n        break;\n\n      // Packetized metadata (ID3)\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3 === -1) {\n          result.id3 = pid;\n        }\n        break;\n      case 0xdb:\n        // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          logger.log('H.264 with AES-128-CBC slice encryption found in unencrypted stream');\n          break;\n        }\n      /* falls through */\n      case 0x1b:\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.avc === -1) {\n          result.avc = pid;\n        }\n        break;\n\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {\n          logger.log('MPEG audio found, not supported in this browser');\n        } else if (result.audio === -1) {\n          result.audio = pid;\n          result.segmentCodec = 'mp3';\n        }\n        break;\n      case 0x24:\n        logger.warn('Unsupported HEVC stream type found');\n        break;\n    }\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += ((data[offset + 3] & 0x0f) << 8 | data[offset + 4]) + 5;\n  }\n  return result;\n}\nfunction parsePES(stream) {\n  let i = 0;\n  let frag;\n  let pesLen;\n  let pesHdrLen;\n  let pesPts;\n  let pesDts;\n  const data = stream.data;\n  // safety check\n  if (!stream || stream.size === 0) {\n    return null;\n  }\n\n  // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n  while (data[0].length < 19 && data.length > 1) {\n    const newData = new Uint8Array(data[0].length + data[1].length);\n    newData.set(data[0]);\n    newData.set(data[1], data[0].length);\n    data[0] = newData;\n    data.splice(1, 1);\n  }\n  // retrieve PTS/DTS from first fragment\n  frag = data[0];\n  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5];\n    // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n    const pesFlags = frag[7];\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts = (frag[9] & 0x0e) * 536870912 +\n      // 1 << 29\n      (frag[10] & 0xff) * 4194304 +\n      // 1 << 22\n      (frag[11] & 0xfe) * 16384 +\n      // 1 << 14\n      (frag[12] & 0xff) * 128 +\n      // 1 << 7\n      (frag[13] & 0xfe) / 2;\n      if (pesFlags & 0x40) {\n        pesDts = (frag[14] & 0x0e) * 536870912 +\n        // 1 << 29\n        (frag[15] & 0xff) * 4194304 +\n        // 1 << 22\n        (frag[16] & 0xfe) * 16384 +\n        // 1 << 14\n        (frag[17] & 0xff) * 128 +\n        // 1 << 7\n        (frag[18] & 0xfe) / 2;\n        if (pesPts - pesDts > 60 * 90000) {\n          logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n    pesHdrLen = frag[8];\n    // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n    let payloadStartOffset = pesHdrLen + 9;\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n    stream.size -= payloadStartOffset;\n    // reassemble PES packet\n    const pesData = new Uint8Array(stream.size);\n    for (let j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      let len = frag.byteLength;\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n      pesData.set(frag, i);\n      i += len;\n    }\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n    return {\n      data: pesData,\n      pts: pesPts,\n      dts: pesDts,\n      len: pesLen\n    };\n  }\n  return null;\n}\nfunction pushAccessUnit(avcSample, avcTrack) {\n  if (avcSample.units.length && avcSample.frame) {\n    // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n    if (avcSample.pts === undefined) {\n      const samples = avcTrack.samples;\n      const nbSamples = samples.length;\n      if (nbSamples) {\n        const lastSample = samples[nbSamples - 1];\n        avcSample.pts = lastSample.pts;\n        avcSample.dts = lastSample.dts;\n      } else {\n        // dropping samples, no timestamp found\n        avcTrack.dropped++;\n        return;\n      }\n    }\n    avcTrack.samples.push(avcSample);\n  }\n  if (avcSample.debug.length) {\n    logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);\n  }\n}\n\n/**\n * MP3 demuxer\n */\nclass MP3Demuxer extends BaseAudioDemuxer {\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    const id3Data = getID3Data(data, 0) || [];\n    let offset = id3Data.length;\n    for (let length = data.length; offset < length; offset++) {\n      if (probe(data, offset)) {\n        logger.log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    if (this.basePTS === null) {\n      return;\n    }\n    return appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n  }\n}\n\n/**\n *  AAC helper\n */\n\nclass AAC {\n  static getSilentFrame(codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n        break;\n    }\n    return undefined;\n  }\n}\n\n/**\n * Generate MP4 Box\n */\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\nclass MP4 {\n  static init() {\n    MP4.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    let i;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n    const videoHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x76, 0x69, 0x64, 0x65,\n    // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n\n    const audioHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x73, 0x6f, 0x75, 0x6e,\n    // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr\n    };\n    const dref = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01,\n    // entry_count\n    0x00, 0x00, 0x00, 0x0c,\n    // entry_size\n    0x75, 0x72, 0x6c, 0x20,\n    // 'url' type\n    0x00,\n    // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n\n    const stco = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n    MP4.STSZ = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n\n    MP4.VMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x01,\n    // flags\n    0x00, 0x00,\n    // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n\n    MP4.SMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00,\n    // balance\n    0x00, 0x00 // reserved\n    ]);\n\n    MP4.STSD = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01]); // entry_count\n\n    const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    const minorVersion = new Uint8Array([0, 0, 0, 1]);\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  }\n  static box(type, ...payload) {\n    let size = 8;\n    let i = payload.length;\n    const len = i;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n    const result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n  static hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  }\n  static mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n  static mdhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n    // 'und' language (undetermined)\n    0x00, 0x00]));\n  }\n  static mdia(track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n  }\n  static mfhd(sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n    // flags\n    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n    ]));\n  }\n\n  static minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  }\n  static moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n  static moov(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n  }\n  static mvex(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);\n  }\n  static mvhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    const bytes = new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n    // 1.0 rate\n    0x01, 0x00,\n    // 1.0 volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n\n    return MP4.box(MP4.types.mvhd, bytes);\n  }\n  static sdtp(track) {\n    const samples = track.samples || [];\n    const bytes = new Uint8Array(4 + samples.length);\n    let i;\n    let flags;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n    return MP4.box(MP4.types.sdtp, bytes);\n  }\n  static stbl(track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  }\n  static avc1(track) {\n    let sps = [];\n    let pps = [];\n    let i;\n    let data;\n    let len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push(len >>> 8 & 0xff);\n      sps.push(len & 0xff);\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push(len >>> 8 & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n    const avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n    // version\n    sps[3],\n    // profile\n    sps[4],\n    // profile compat\n    sps[5],\n    // level\n    0xfc | 3,\n    // lengthSizeMinusOne, hard-coded to 4 bytes\n    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n    ]).concat(pps))); // \"PPS\"\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    width >> 8 & 0xff, width & 0xff,\n    // width\n    height >> 8 & 0xff, height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c,\n    // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11]),\n    // pre_defined = -1\n    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])),\n    // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n    // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n    // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  }\n  static esds(track) {\n    const configlen = track.config.length;\n    return new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n\n    0x03,\n    // descriptor_type\n    0x17 + configlen,\n    // length\n    0x00, 0x01,\n    // es_id\n    0x00,\n    // stream_priority\n\n    0x04,\n    // descriptor_type\n    0x0f + configlen,\n    // length\n    0x40,\n    // codec : mpeg4_audio\n    0x15,\n    // stream_type\n    0x00, 0x00, 0x00,\n    // buffer_size\n    0x00, 0x00, 0x00, 0x00,\n    // maxBitrate\n    0x00, 0x00, 0x00, 0x00,\n    // avgBitrate\n\n    0x05 // descriptor_type\n    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n  }\n\n  static mp4a(track) {\n    const samplerate = track.samplerate;\n    return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n  }\n  static mp3(track) {\n    const samplerate = track.samplerate;\n    return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]));\n  }\n  static stsd(track) {\n    if (track.type === 'audio') {\n      if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n    }\n  }\n  static tkhd(track) {\n    const id = track.id;\n    const duration = track.duration * track.timescale;\n    const width = track.width;\n    const height = track.height;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x07,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00,\n    // layer\n    0x00, 0x00,\n    // alternate_group\n    0x00, 0x00,\n    // non-audio track volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n    // width\n    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n    ]));\n  }\n\n  static traf(track, baseMediaDecodeTime) {\n    const sampleDependencyTable = MP4.sdtp(track);\n    const id = track.id;\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n    // tfhd\n    20 +\n    // tfdt\n    8 +\n    // traf header\n    16 +\n    // mfhd\n    8 +\n    // moof header\n    8),\n    // mdat header\n    sampleDependencyTable);\n  }\n\n  /**\n   * Generate a track box.\n   * @param track a track definition\n   */\n  static trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  }\n  static trex(track) {\n    const id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x01,\n    // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_duration\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  }\n\n  static trun(track, offset) {\n    const samples = track.samples || [];\n    const len = samples.length;\n    const arraylen = 12 + 16 * len;\n    const array = new Uint8Array(arraylen);\n    let i;\n    let sample;\n    let duration;\n    let size;\n    let flags;\n    let cts;\n    offset += 8 + arraylen;\n    array.set([track.type === 'video' ? 0x01 : 0x00,\n    // version 1 for video with signed-int sample_composition_time_offset\n    0x00, 0x0f, 0x01,\n    // flags\n    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n    // sample_count\n    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n    ], 0);\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n      // sample_duration\n      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n      // sample_size\n      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n      // sample_flags\n      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n    return MP4.box(MP4.types.trun, array);\n  }\n  static initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n    const movie = MP4.moov(tracks);\n    const result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n    result.set(MP4.FTYP);\n    result.set(movie, MP4.FTYP.byteLength);\n    return result;\n  }\n}\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\n\nconst MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {\n  const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n  return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {\n  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(baseTime, round = false) {\n  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(baseTime, srcScale = 1) {\n  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nlet chromeVersion = null;\nlet safariWebkitVersion = null;\nclass MP4Remuxer {\n  constructor(observer, config, typeSupported, vendor = '') {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.ISGenerated = false;\n    this._initPTS = null;\n    this._initDTS = null;\n    this.nextAvcDts = null;\n    this.nextAudioPts = null;\n    this.videoSampleDuration = null;\n    this.isAudioContiguous = false;\n    this.isVideoContiguous = false;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    if (safariWebkitVersion === null) {\n      const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      safariWebkitVersion = result ? parseInt(result[1]) : 0;\n    }\n  }\n  destroy() {}\n  resetTimeStamp(defaultTimeStamp) {\n    logger.log('[mp4-remuxer]: initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  }\n  resetNextTimestamp() {\n    logger.log('[mp4-remuxer]: reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  }\n  resetInitSegment() {\n    logger.log('[mp4-remuxer]: ISGenerated flag reset');\n    this.ISGenerated = false;\n  }\n  getVideoStartPts(videoSamples) {\n    let rolloverDetected = false;\n    const startPTS = videoSamples.reduce((minPTS, sample) => {\n      const delta = sample.pts - minPTS;\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        return normalizePts(minPTS, sample.pts);\n      } else if (delta > 0) {\n        return minPTS;\n      } else {\n        return sample.pts;\n      }\n    }, videoSamples[0].pts);\n    if (rolloverDetected) {\n      logger.debug('PTS rollover detected');\n    }\n    return startPTS;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n    let video;\n    let audio;\n    let initSegment;\n    let text;\n    let id3;\n    let independent;\n    let audioTimeOffset = timeOffset;\n    let videoTimeOffset = timeOffset;\n\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n    const hasAudio = audioTrack.pid > -1;\n    const hasVideo = videoTrack.pid > -1;\n    const length = videoTrack.samples.length;\n    const enoughAudioSamples = audioTrack.samples.length > 0;\n    const enoughVideoSamples = flush && length > 0 || length > 1;\n    const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n    if (canRemuxAvc) {\n      if (!this.ISGenerated) {\n        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n      }\n      const isVideoContiguous = this.isVideoContiguous;\n      let firstKeyFrameIndex = -1;\n      let firstKeyFramePTS;\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n          if (firstKeyFrameIndex > 0) {\n            logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);\n            const startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);\n            independent = false;\n          }\n        }\n      }\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          const startPTS = this.getVideoStartPts(videoTrack.samples);\n          const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        }\n\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            logger.warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n          }\n          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n          if (enoughVideoSamples) {\n            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n            // if initSegment was generated without video samples, regenerate it again\n            if (!videoTrack.inputTimeScale) {\n              logger.warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n        }\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    }\n\n    // Allow ID3 and text to remux, even if more audio/video samples are required\n    if (this.ISGenerated && this._initPTS && this._initDTS) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n      }\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n      }\n    }\n    return {\n      audio,\n      video,\n      initSegment,\n      independent,\n      text,\n      id3\n    };\n  }\n  generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n    const audioSamples = audioTrack.samples;\n    const videoSamples = videoTrack.samples;\n    const typeSupported = this.typeSupported;\n    const tracks = {};\n    const _initPTS = this._initPTS;\n    let computePTSDTS = !_initPTS || accurateTimeOffset;\n    let container = 'audio/mp4';\n    let initPTS;\n    let initDTS;\n    let timescale;\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n          break;\n      }\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n      if (computePTSDTS) {\n        timescale = audioTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: MP4.initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n      if (computePTSDTS) {\n        timescale = videoTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          const startPTS = this.getVideoStartPts(videoSamples);\n          const startOffset = Math.round(timescale * timeOffset);\n          initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n          initPTS = Math.min(initPTS, startPTS - startOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        this._initPTS = {\n          baseTime: initPTS,\n          timescale: timescale\n        };\n        this._initDTS = {\n          baseTime: initDTS,\n          timescale: timescale\n        };\n      } else {\n        initPTS = timescale = undefined;\n      }\n      return {\n        tracks,\n        initPTS,\n        timescale\n      };\n    }\n  }\n  remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n    const timeScale = track.inputTimeScale;\n    const inputSamples = track.samples;\n    const outputSamples = [];\n    const nbSamples = inputSamples.length;\n    const initPTS = this._initPTS;\n    let nextAvcDts = this.nextAvcDts;\n    let offset = 8;\n    let mp4SampleDuration = this.videoSampleDuration;\n    let firstDTS;\n    let lastDTS;\n    let minPTS = Number.POSITIVE_INFINITY;\n    let maxPTS = Number.NEGATIVE_INFINITY;\n    let sortSamples = false;\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    if (!contiguous || nextAvcDts === null) {\n      const pts = timeOffset * timeScale;\n      const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n      // if not contiguous, let's use target timeOffset\n      nextAvcDts = pts - cts;\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    const initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n    for (let i = 0; i < nbSamples; i++) {\n      const sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n      sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    }\n\n    // sort video samples by DTS then PTS then demux id order\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        const deltadts = a.dts - b.dts;\n        const deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    }\n\n    // Get first/last DTS\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    const inputDuration = lastDTS - firstDTS;\n    const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      const delta = firstDTS - nextAvcDts;\n      const foundHole = delta > averageSampleDuration;\n      const foundOverlap = delta < -1;\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected, filling it`);\n        } else {\n          logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected`);\n        }\n        if (!foundOverlap || nextAvcDts >= inputSamples[0].pts) {\n          firstDTS = nextAvcDts;\n          const firstPTS = inputSamples[0].pts - delta;\n          inputSamples[0].dts = firstDTS;\n          inputSamples[0].pts = firstPTS;\n          logger.log(`Video: First PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);\n        }\n      }\n    }\n    firstDTS = Math.max(0, firstDTS);\n    let nbNalu = 0;\n    let naluLen = 0;\n    for (let i = 0; i < nbSamples; i++) {\n      // compute total/avc sample length and nb of NAL units\n      const sample = inputSamples[i];\n      const units = sample.units;\n      const nbUnits = units.length;\n      let sampleLen = 0;\n      for (let j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      sample.length = sampleLen;\n\n      // ensure sample monotonic DTS\n      sample.dts = Math.max(sample.dts, firstDTS);\n      minPTS = Math.min(sample.pts, minPTS);\n      maxPTS = Math.max(sample.pts, maxPTS);\n    }\n    lastDTS = inputSamples[nbSamples - 1].dts;\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    const mdatSize = naluLen + 4 * nbNalu + 8;\n    let mdat;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MUX_ERROR,\n        details: ErrorDetails.REMUX_ALLOC_ERROR,\n        fatal: false,\n        error: err,\n        bytes: mdatSize,\n        reason: `fail allocating video mdat ${mdatSize}`\n      });\n      return;\n    }\n    const view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(MP4.types.mdat, 4);\n    let stretchedLastFrame = false;\n    let minDtsDelta = Number.POSITIVE_INFINITY;\n    let minPtsDelta = Number.POSITIVE_INFINITY;\n    let maxDtsDelta = Number.NEGATIVE_INFINITY;\n    let maxPtsDelta = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < nbSamples; i++) {\n      const avcSample = inputSamples[i];\n      const avcSampleUnits = avcSample.units;\n      let mp4SampleLength = 0;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (let j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {\n        const unit = avcSampleUnits[j];\n        const unitData = unit.data;\n        const unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\n      let ptsDelta;\n      if (i < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[i + 1].dts - avcSample.dts;\n        ptsDelta = inputSamples[i + 1].pts - avcSample.pts;\n      } else {\n        const config = this.config;\n        const lastFrameDuration = i > 0 ? avcSample.dts - inputSamples[i - 1].dts : averageSampleDuration;\n        ptsDelta = i > 0 ? avcSample.pts - inputSamples[i - 1].pts : averageSampleDuration;\n        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n            logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n      const compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n      outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n    }\n    if (outputSamples.length) {\n      if (chromeVersion) {\n        if (chromeVersion < 70) {\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n          // https://code.google.com/p/chromium/issues/detail?id=229412\n          const flags = outputSamples[0].flags;\n          flags.dependsOn = 2;\n          flags.isNonSync = 0;\n        }\n      } else if (safariWebkitVersion) {\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n          logger.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n          let dts = firstDTS;\n          for (let i = 0, len = outputSamples.length; i < len; i++) {\n            const nextDts = dts + outputSamples[i].duration;\n            const pts = dts + outputSamples[i].cts;\n            if (i < len - 1) {\n              const nextPts = nextDts + outputSamples[i + 1].cts;\n              outputSamples[i].duration = nextPts - pts;\n            } else {\n              outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;\n            }\n            outputSamples[i].cts = 0;\n            dts = nextDts;\n          }\n        }\n      }\n    }\n    // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n      samples: outputSamples\n    }));\n    const type = 'video';\n    const data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: minPTS / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n      startDTS: firstDTS / timeScale,\n      endDTS: nextAvcDts / timeScale,\n      type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped\n    };\n    track.samples = [];\n    track.dropped = 0;\n    return data;\n  }\n  remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const mp4SampleDuration = track.segmentCodec === 'aac' ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;\n    const inputSampleDuration = mp4SampleDuration * scaleFactor;\n    const initPTS = this._initPTS;\n    const rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    const outputSamples = [];\n    const alignedWithVideo = videoTimeOffset !== undefined;\n    let inputSamples = track.samples;\n    let offset = rawMPEG ? 0 : 8;\n    let nextAudioPts = this.nextAudioPts || -1;\n\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    const timeOffsetMpegTS = timeOffset * inputTimeScale;\n    const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n    });\n    if (!contiguous || nextAudioPts < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter(sample => sample.pts >= 0);\n\n      // in case all samples have negative PTS, and have been filtered out, return now\n      if (!inputSamples.length) {\n        return;\n      }\n      if (videoTimeOffset === 0) {\n        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioPts = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioPts = Math.max(0, timeOffsetMpegTS);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioPts = inputSamples[0].pts;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.segmentCodec === 'aac') {\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        const sample = inputSamples[i];\n        const pts = sample.pts;\n        const delta = pts - nextPts;\n        const duration = Math.abs(1000 * delta / inputTimeScale);\n\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n          if (i === 0) {\n            logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1000 * delta / inputTimeScale)} ms.`);\n            this.nextAudioPts = nextAudioPts = nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n          let missing = Math.round(delta / inputSampleDuration);\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n          nextPts = pts - missing * inputSampleDuration;\n          if (nextPts < 0) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n          if (i === 0) {\n            this.nextAudioPts = nextAudioPts = nextPts;\n          }\n          logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);\n          for (let j = 0; j < missing; j++) {\n            const newStamp = Math.max(nextPts, 0);\n            let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              logger.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: newStamp\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n    let firstPTS = null;\n    let lastPTS = null;\n    let mdat;\n    let mdatSize = 0;\n    let sampleLength = inputSamples.length;\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n    for (let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++) {\n      const audioSample = inputSamples[j];\n      const unit = audioSample.unit;\n      let pts = audioSample.pts;\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        const prevSample = outputSamples[j - 1];\n        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          pts = nextAudioPts;\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = pts;\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MUX_ERROR,\n              details: ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: false,\n              error: err,\n              bytes: mdatSize,\n              reason: `fail allocating audio mdat ${mdatSize}`\n            });\n            return;\n          }\n          if (!rawMPEG) {\n            const view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(MP4.types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n      mdat.set(unit, offset);\n      const unitLen = unit.byteLength;\n      offset += unitLen;\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = pts;\n    }\n\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n    const nbSamples = outputSamples.length;\n    if (!nbSamples) {\n      return;\n    }\n\n    // The next audio sample PTS should be equal to last sample PTS + duration\n    const lastSample = outputSamples[outputSamples.length - 1];\n    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n\n    // Set the track samples from inputSamples to outputSamples before remuxing\n    const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n      samples: outputSamples\n    }));\n\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n    track.samples = [];\n    const start = firstPTS / inputTimeScale;\n    const end = nextAudioPts / inputTimeScale;\n    const type = 'audio';\n    const audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples\n    };\n    this.isAudioContiguous = true;\n    return audioData;\n  }\n  remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const nextAudioPts = this.nextAudioPts;\n    // sync with video's timestamp\n    const initDTS = this._initDTS;\n    const init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;\n    const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;\n    const endDTS = videoData.endDTS * inputTimeScale + init90kHz;\n    // one sample's duration value\n    const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n    // samples count of this segment's duration\n    const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n    // silent frame\n    const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n    logger.warn('[mp4-remuxer]: remux empty Audio');\n    // Can't remux if we can't generate a silent frame...\n    if (!silentFrame) {\n      logger.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n      return;\n    }\n    const samples = [];\n    for (let i = 0; i < nbSamples; i++) {\n      const stamp = startDTS + i * frameDuration;\n      samples.push({\n        unit: silentFrame,\n        pts: stamp,\n        dts: stamp\n      });\n    }\n    track.samples = samples;\n    return this.remuxAudio(track, timeOffset, contiguous, false);\n  }\n}\nfunction normalizePts(value, reference) {\n  let offset;\n  if (reference === null) {\n    return value;\n  }\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n  return value;\n}\nfunction findKeyframeIndex(samples) {\n  for (let i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  track.samples.sort((a, b) => a.pts - b.pts);\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nclass Mp4Sample {\n  constructor(isKeyframe, duration, size, cts) {\n    this.size = void 0;\n    this.duration = void 0;\n    this.cts = void 0;\n    this.flags = void 0;\n    this.duration = duration;\n    this.size = size;\n    this.cts = cts;\n    this.flags = new Mp4SampleFlags(isKeyframe);\n  }\n}\nclass Mp4SampleFlags {\n  constructor(isKeyframe) {\n    this.isLeading = 0;\n    this.isDependedOn = 0;\n    this.hasRedundancy = 0;\n    this.degradPrio = 0;\n    this.dependsOn = 1;\n    this.isNonSync = 1;\n    this.dependsOn = isKeyframe ? 2 : 1;\n    this.isNonSync = isKeyframe ? 0 : 1;\n  }\n}\n\nclass PassThroughRemuxer {\n  constructor() {\n    this.emitInitSegment = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initData = void 0;\n    this.initPTS = null;\n    this.initTracks = void 0;\n    this.lastEndTime = null;\n  }\n  destroy() {}\n  resetTimeStamp(defaultInitPTS) {\n    this.initPTS = defaultInitPTS;\n    this.lastEndTime = null;\n  }\n  resetNextTimestamp() {\n    this.lastEndTime = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n    this.emitInitSegment = true;\n  }\n  generateInitSegment(initSegment) {\n    let {\n      audioCodec,\n      videoCodec\n    } = this;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n    const initData = this.initData = parseInitSegment(initSegment);\n\n    // Get codec from initSegment or fallback to default\n    if (!audioCodec) {\n      audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);\n    }\n    if (!videoCodec) {\n      videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);\n    }\n    const tracks = {};\n    if (initData.audio && initData.video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        initSegment,\n        id: 'main'\n      };\n    } else if (initData.audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        initSegment,\n        id: 'audio'\n      };\n    } else if (initData.video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        initSegment,\n        id: 'main'\n      };\n    } else {\n      logger.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n    }\n    this.initTracks = tracks;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n    var _initData, _initData2;\n    let {\n      initPTS,\n      lastEndTime\n    } = this;\n    const result = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined\n    };\n\n    // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n    if (!isFiniteNumber(lastEndTime)) {\n      lastEndTime = this.lastEndTime = timeOffset || 0;\n    }\n\n    // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n    const data = videoTrack.samples;\n    if (!(data != null && data.length)) {\n      return result;\n    }\n    const initSegment = {\n      initPTS: undefined,\n      timescale: 1\n    };\n    let initData = this.initData;\n    if (!((_initData = initData) != null && _initData.length)) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n    if (!((_initData2 = initData) != null && _initData2.length)) {\n      // We can't remux if the initSegment could not be generated\n      logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n      return result;\n    }\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n    const duration = getDuration(data, initData);\n    const startDTS = getStartDTS(initData, data);\n    const decodeTime = startDTS === null ? timeOffset : startDTS;\n    if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {\n      initSegment.initPTS = decodeTime - timeOffset;\n      if (initPTS && initPTS.timescale === 1) {\n        logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);\n      }\n      this.initPTS = initPTS = {\n        baseTime: initSegment.initPTS,\n        timescale: 1\n      };\n    }\n    const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n    const endTime = startTime + duration;\n    offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\n    if (duration > 0) {\n      this.lastEndTime = endTime;\n    } else {\n      logger.warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n    const hasAudio = !!initData.audio;\n    const hasVideo = !!initData.video;\n    let type = '';\n    if (hasAudio) {\n      type += 'audio';\n    }\n    if (hasVideo) {\n      type += 'video';\n    }\n    const track = {\n      data1: data,\n      startPTS: startTime,\n      startDTS: startTime,\n      endPTS: endTime,\n      endDTS: endTime,\n      type,\n      hasAudio,\n      hasVideo,\n      nb: 1,\n      dropped: 0\n    };\n    result.audio = track.type === 'audio' ? track : undefined;\n    result.video = track.type !== 'audio' ? track : undefined;\n    result.initSegment = initSegment;\n    result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n    if (textTrack.samples.length) {\n      result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n    }\n    return result;\n  }\n}\nfunction isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n  if (initPTS === null) {\n    return true;\n  }\n  // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n  const minDuration = Math.max(duration, 1);\n  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n  return Math.abs(startTime - timeOffset) > minDuration;\n}\nfunction getParsedTrackCodec(track, type) {\n  const parsedCodec = track == null ? void 0 : track.codec;\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  }\n  // Since mp4-tools cannot parse full codec string (see 'TODO: Parse codec details'... in mp4-tools)\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n  if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\n    return 'hvc1.1.6.L120.90';\n  }\n  if (parsedCodec === 'av01') {\n    return 'av01.0.04M.08';\n  }\n  if (parsedCodec === 'avc1' || type === ElementaryStreamTypes.VIDEO) {\n    return 'avc1.42e01e';\n  }\n  return 'mp4a.40.5';\n}\n\nlet now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  logger.debug('Unable to use Performance API on this environment');\n  now = typeof self !== 'undefined' && self.Date.now;\n}\nconst muxConfig = [{\n  demux: MP4Demuxer,\n  remux: PassThroughRemuxer\n}, {\n  demux: TSDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: AACDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: MP3Demuxer,\n  remux: MP4Remuxer\n}];\nclass Transmuxer {\n  constructor(observer, typeSupported, config, vendor, id) {\n    this.async = false;\n    this.observer = void 0;\n    this.typeSupported = void 0;\n    this.config = void 0;\n    this.vendor = void 0;\n    this.id = void 0;\n    this.demuxer = void 0;\n    this.remuxer = void 0;\n    this.decrypter = void 0;\n    this.probe = void 0;\n    this.decryptionPromise = null;\n    this.transmuxConfig = void 0;\n    this.currentTransmuxState = void 0;\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.vendor = vendor;\n    this.id = id;\n  }\n  configure(transmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  }\n  push(data, decryptdata, chunkMeta, state) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    let uintData = new Uint8Array(data);\n    const {\n      currentTransmuxState,\n      transmuxConfig\n    } = this;\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n    const {\n      contiguous,\n      discontinuity,\n      trackSwitch,\n      accurateTimeOffset,\n      timeOffset,\n      initSegmentChange\n    } = state || currentTransmuxState;\n    const {\n      audioCodec,\n      videoCodec,\n      defaultInitPts,\n      duration,\n      initSegmentData\n    } = transmuxConfig;\n    const keyData = getEncryptionType(uintData, decryptdata);\n    if (keyData && keyData.method === 'AES-128') {\n      const decrypter = this.getDecrypter();\n      // Software decryption is synchronous; webCrypto is not\n      if (decrypter.isSync()) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n        const loadingParts = chunkMeta.part > -1;\n        if (loadingParts) {\n          decryptedData = decrypter.flush();\n        }\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(decryptedData => {\n          // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n          // the decrypted data has been transmuxed\n          const result = this.push(decryptedData, null, chunkMeta);\n          this.decryptionPromise = null;\n          return result;\n        });\n        return this.decryptionPromise;\n      }\n    }\n    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n    if (resetMuxers) {\n      const error = this.configureTransmuxer(uintData);\n      if (error) {\n        logger.warn(`[transmuxer] ${error.message}`);\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          reason: error.message\n        });\n        stats.executeEnd = now();\n        return emptyResult(chunkMeta);\n      }\n    }\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n    }\n    if (discontinuity || initSegmentChange || resetMuxers) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n    const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    const currentState = this.currentTransmuxState;\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n    stats.executeEnd = now();\n    return result;\n  }\n\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  flush(chunkMeta) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    const {\n      decrypter,\n      currentTransmuxState,\n      decryptionPromise\n    } = this;\n    if (decryptionPromise) {\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(() => {\n        return this.flush(chunkMeta);\n      });\n    }\n    const transmuxResults = [];\n    const {\n      timeOffset\n    } = currentTransmuxState;\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      const decryptedData = decrypter.flush();\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n      }\n    }\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      // If probing failed, then Hls.js has been given content its not able to handle\n      stats.executeEnd = now();\n      return [emptyResult(chunkMeta)];\n    }\n    const demuxResultOrPromise = demuxer.flush(timeOffset);\n    if (isPromise(demuxResultOrPromise)) {\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then(demuxResult => {\n        this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n        return transmuxResults;\n      });\n    }\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    return transmuxResults;\n  }\n  flushRemux(transmuxResults, demuxResult, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const {\n      accurateTimeOffset,\n      timeOffset\n    } = this.currentTransmuxState;\n    logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : ''} of level ${chunkMeta.level}`);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n    transmuxResults.push({\n      remuxResult,\n      chunkMeta\n    });\n    chunkMeta.transmuxing.executeEnd = now();\n  }\n  resetInitialTimestamp(defaultInitPts) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  }\n  resetContiguity() {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  }\n  resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n  }\n  destroy() {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  }\n  transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n    let result;\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    } else {\n      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n    }\n    return result;\n  }\n  transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n    return {\n      remuxResult,\n      chunkMeta\n    };\n  }\n  transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(demuxResult => {\n      const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);\n      return {\n        remuxResult,\n        chunkMeta\n      };\n    });\n  }\n  configureTransmuxer(data) {\n    const {\n      config,\n      observer,\n      typeSupported,\n      vendor\n    } = this;\n    // probe for content type\n    let mux;\n    for (let i = 0, len = muxConfig.length; i < len; i++) {\n      if (muxConfig[i].demux.probe(data)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n    if (!mux) {\n      return new Error('Failed to find demuxer by probing fragment data');\n    }\n    // so let's check that current remuxer and demuxer are still valid\n    const demuxer = this.demuxer;\n    const remuxer = this.remuxer;\n    const Remuxer = mux.remux;\n    const Demuxer = mux.demux;\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n    }\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported);\n      this.probe = Demuxer.probe;\n    }\n  }\n  needsProbing(discontinuity, trackSwitch) {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  }\n  getDecrypter() {\n    let decrypter = this.decrypter;\n    if (!decrypter) {\n      decrypter = this.decrypter = new Decrypter(this.config);\n    }\n    return decrypter;\n  }\n}\nfunction getEncryptionType(data, decryptData) {\n  let encryptionType = null;\n  if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {\n    encryptionType = decryptData;\n  }\n  return encryptionType;\n}\nconst emptyResult = chunkMeta => ({\n  remuxResult: {},\n  chunkMeta\n});\nfunction isPromise(p) {\n  return 'then' in p && p.then instanceof Function;\n}\nclass TransmuxConfig {\n  constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initSegmentData = void 0;\n    this.duration = void 0;\n    this.defaultInitPts = void 0;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  }\n}\nclass TransmuxState {\n  constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n    this.discontinuity = void 0;\n    this.contiguous = void 0;\n    this.accurateTimeOffset = void 0;\n    this.trackSwitch = void 0;\n    this.timeOffset = void 0;\n    this.initSegmentChange = void 0;\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  }\n}\n\nvar eventemitter3 = {exports: {}};\n\n(function (module) {\n\n\tvar has = Object.prototype.hasOwnProperty\n\t  , prefix = '~';\n\n\t/**\n\t * Constructor to create a storage for our `EE` objects.\n\t * An `Events` instance is a plain object whose properties are event names.\n\t *\n\t * @constructor\n\t * @private\n\t */\n\tfunction Events() {}\n\n\t//\n\t// We try to not inherit from `Object.prototype`. In some engines creating an\n\t// instance in this way is faster than calling `Object.create(null)` directly.\n\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t// character to make sure that the built-in object properties are not\n\t// overridden or used as an attack vector.\n\t//\n\tif (Object.create) {\n\t  Events.prototype = Object.create(null);\n\n\t  //\n\t  // This hack is needed because the `__proto__` property is still inherited in\n\t  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n\t  //\n\t  if (!new Events().__proto__) prefix = false;\n\t}\n\n\t/**\n\t * Representation of a single event listener.\n\t *\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n\t * @constructor\n\t * @private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\n\t/**\n\t * Add a listener for a given event.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} once Specify if the listener is a one-time listener.\n\t * @returns {EventEmitter}\n\t * @private\n\t */\n\tfunction addListener(emitter, event, fn, context, once) {\n\t  if (typeof fn !== 'function') {\n\t    throw new TypeError('The listener must be a function');\n\t  }\n\n\t  var listener = new EE(fn, context || emitter, once)\n\t    , evt = prefix ? prefix + event : event;\n\n\t  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n\t  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n\t  else emitter._events[evt] = [emitter._events[evt], listener];\n\n\t  return emitter;\n\t}\n\n\t/**\n\t * Clear event by name.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} evt The Event name.\n\t * @private\n\t */\n\tfunction clearEvent(emitter, evt) {\n\t  if (--emitter._eventsCount === 0) emitter._events = new Events();\n\t  else delete emitter._events[evt];\n\t}\n\n\t/**\n\t * Minimal `EventEmitter` interface that is molded against the Node.js\n\t * `EventEmitter` interface.\n\t *\n\t * @constructor\n\t * @public\n\t */\n\tfunction EventEmitter() {\n\t  this._events = new Events();\n\t  this._eventsCount = 0;\n\t}\n\n\t/**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t *\n\t * @returns {Array}\n\t * @public\n\t */\n\tEventEmitter.prototype.eventNames = function eventNames() {\n\t  var names = []\n\t    , events\n\t    , name;\n\n\t  if (this._eventsCount === 0) return names;\n\n\t  for (name in (events = this._events)) {\n\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n\t  }\n\n\t  if (Object.getOwnPropertySymbols) {\n\t    return names.concat(Object.getOwnPropertySymbols(events));\n\t  }\n\n\t  return names;\n\t};\n\n\t/**\n\t * Return the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Array} The registered listeners.\n\t * @public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event) {\n\t  var evt = prefix ? prefix + event : event\n\t    , handlers = this._events[evt];\n\n\t  if (!handlers) return [];\n\t  if (handlers.fn) return [handlers.fn];\n\n\t  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = handlers[i].fn;\n\t  }\n\n\t  return ee;\n\t};\n\n\t/**\n\t * Return the number of listeners listening to a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Number} The number of listeners.\n\t * @public\n\t */\n\tEventEmitter.prototype.listenerCount = function listenerCount(event) {\n\t  var evt = prefix ? prefix + event : event\n\t    , listeners = this._events[evt];\n\n\t  if (!listeners) return 0;\n\t  if (listeners.fn) return 1;\n\t  return listeners.length;\n\t};\n\n\t/**\n\t * Calls each of the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Boolean} `true` if the event had listeners, else `false`.\n\t * @public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  var evt = prefix ? prefix + event : event;\n\n\t  if (!this._events[evt]) return false;\n\n\t  var listeners = this._events[evt]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\n\t  if (listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\n\t  return true;\n\t};\n\n\t/**\n\t * Add a listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  return addListener(this, event, fn, context, false);\n\t};\n\n\t/**\n\t * Add a one-time listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  return addListener(this, event, fn, context, true);\n\t};\n\n\t/**\n\t * Remove the listeners of a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn Only remove the listeners that match this function.\n\t * @param {*} context Only remove the listeners that have this context.\n\t * @param {Boolean} once Only remove one-time listeners.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t  var evt = prefix ? prefix + event : event;\n\n\t  if (!this._events[evt]) return this;\n\t  if (!fn) {\n\t    clearEvent(this, evt);\n\t    return this;\n\t  }\n\n\t  var listeners = this._events[evt];\n\n\t  if (listeners.fn) {\n\t    if (\n\t      listeners.fn === fn &&\n\t      (!once || listeners.once) &&\n\t      (!context || listeners.context === context)\n\t    ) {\n\t      clearEvent(this, evt);\n\t    }\n\t  } else {\n\t    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n\t      if (\n\t        listeners[i].fn !== fn ||\n\t        (once && !listeners[i].once) ||\n\t        (context && listeners[i].context !== context)\n\t      ) {\n\t        events.push(listeners[i]);\n\t      }\n\t    }\n\n\t    //\n\t    // Reset the array, or remove it completely if we have no more listeners.\n\t    //\n\t    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n\t    else clearEvent(this, evt);\n\t  }\n\n\t  return this;\n\t};\n\n\t/**\n\t * Remove all listeners, or those of the specified event.\n\t *\n\t * @param {(String|Symbol)} [event] The event name.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  var evt;\n\n\t  if (event) {\n\t    evt = prefix ? prefix + event : event;\n\t    if (this._events[evt]) clearEvent(this, evt);\n\t  } else {\n\t    this._events = new Events();\n\t    this._eventsCount = 0;\n\t  }\n\n\t  return this;\n\t};\n\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n\t//\n\t// Expose the prefix.\n\t//\n\tEventEmitter.prefixed = prefix;\n\n\t//\n\t// Allow `EventEmitter` to be imported as module namespace.\n\t//\n\tEventEmitter.EventEmitter = EventEmitter;\n\n\t//\n\t// Expose the module.\n\t//\n\t{\n\t  module.exports = EventEmitter;\n\t} \n} (eventemitter3));\n\nvar eventemitter3Exports = eventemitter3.exports;\nvar EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\n\nconst MediaSource$1 = getMediaSource() || {\n  isTypeSupported: () => false\n};\nclass TransmuxerInterface {\n  constructor(hls, id, onTransmuxComplete, onFlush) {\n    this.error = null;\n    this.hls = void 0;\n    this.id = void 0;\n    this.observer = void 0;\n    this.frag = null;\n    this.part = null;\n    this.useWorker = void 0;\n    this.workerContext = null;\n    this.onwmsg = void 0;\n    this.transmuxer = null;\n    this.onTransmuxComplete = void 0;\n    this.onFlush = void 0;\n    const config = hls.config;\n    this.hls = hls;\n    this.id = id;\n    this.useWorker = !!config.enableWorker;\n    this.onTransmuxComplete = onTransmuxComplete;\n    this.onFlush = onFlush;\n    const forwardMessage = (ev, data) => {\n      data = data || {};\n      data.frag = this.frag;\n      data.id = this.id;\n      if (ev === Events.ERROR) {\n        this.error = data.error;\n      }\n      this.hls.trigger(ev, data);\n    };\n\n    // forward events to main thread\n    this.observer = new EventEmitter();\n    this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n    this.observer.on(Events.ERROR, forwardMessage);\n    const typeSupported = {\n      mp4: MediaSource$1.isTypeSupported('video/mp4'),\n      mpeg: MediaSource$1.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource$1.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n    };\n    // navigator.vendor is not always available in Web Worker\n    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n    const vendor = navigator.vendor;\n    if (this.useWorker && typeof Worker !== 'undefined') {\n      const canCreateWorker = config.workerPath || hasUMDWorker();\n      if (canCreateWorker) {\n        try {\n          if (config.workerPath) {\n            logger.log(`loading Web Worker ${config.workerPath} for \"${id}\"`);\n            this.workerContext = loadWorker(config.workerPath);\n          } else {\n            logger.log(`injecting Web Worker for \"${id}\"`);\n            this.workerContext = injectWorker();\n          }\n          this.onwmsg = ev => this.onWorkerMessage(ev);\n          const {\n            worker\n          } = this.workerContext;\n          worker.addEventListener('message', this.onwmsg);\n          worker.onerror = event => {\n            const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);\n            config.enableWorker = false;\n            logger.warn(`Error in \"${id}\" Web Worker, fallback to inline`);\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.INTERNAL_EXCEPTION,\n              fatal: false,\n              event: 'demuxerWorker',\n              error\n            });\n          };\n          worker.postMessage({\n            cmd: 'init',\n            typeSupported: typeSupported,\n            vendor: vendor,\n            id: id,\n            config: JSON.stringify(config)\n          });\n        } catch (err) {\n          logger.warn(`Error setting up \"${id}\" Web Worker, fallback to inline`, err);\n          this.resetWorker();\n          this.error = null;\n          this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);\n        }\n        return;\n      }\n    }\n    this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);\n  }\n  resetWorker() {\n    if (this.workerContext) {\n      const {\n        worker,\n        objectURL\n      } = this.workerContext;\n      if (objectURL) {\n        // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n        self.URL.revokeObjectURL(objectURL);\n      }\n      worker.removeEventListener('message', this.onwmsg);\n      worker.onerror = null;\n      worker.terminate();\n      this.workerContext = null;\n    }\n  }\n  destroy() {\n    if (this.workerContext) {\n      this.resetWorker();\n      this.onwmsg = undefined;\n    } else {\n      const transmuxer = this.transmuxer;\n      if (transmuxer) {\n        transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    }\n    const observer = this.observer;\n    if (observer) {\n      observer.removeAllListeners();\n    }\n    this.frag = null;\n    // @ts-ignore\n    this.observer = null;\n    // @ts-ignore\n    this.hls = null;\n  }\n  push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n    var _frag$initSegment, _lastFrag$initSegment;\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      transmuxer\n    } = this;\n    const timeOffset = part ? part.start : frag.start;\n    // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n    const decryptdata = frag.decryptdata;\n    const lastFrag = this.frag;\n    const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n    const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n    const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n    const partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n    const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n    const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n    const now = self.performance.now();\n    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n      frag.stats.parsing.start = now;\n    }\n    if (part && (partDiff || !contiguous)) {\n      part.stats.parsing.start = now;\n    }\n    const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n    const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n    if (!contiguous || discontinuity || initSegmentChange) {\n      logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}\n        discontinuity: ${discontinuity}\n        trackSwitch: ${trackSwitch}\n        contiguous: ${contiguous}\n        accurateTimeOffset: ${accurateTimeOffset}\n        timeOffset: ${timeOffset}\n        initSegmentChange: ${initSegmentChange}`);\n      const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n      this.configureTransmuxer(config);\n    }\n    this.frag = frag;\n    this.part = part;\n\n    // Frags with sn of 'initSegment' are not transmuxed\n    if (this.workerContext) {\n      // post fragment payload as transferable objects for ArrayBuffer (no copy)\n      this.workerContext.worker.postMessage({\n        cmd: 'demux',\n        data,\n        decryptdata,\n        chunkMeta,\n        state\n      }, data instanceof ArrayBuffer ? [data] : []);\n    } else if (transmuxer) {\n      const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n      if (isPromise(transmuxResult)) {\n        transmuxer.async = true;\n        transmuxResult.then(data => {\n          this.handleTransmuxComplete(data);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n        });\n      } else {\n        transmuxer.async = false;\n        this.handleTransmuxComplete(transmuxResult);\n      }\n    }\n  }\n  flush(chunkMeta) {\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        cmd: 'flush',\n        chunkMeta\n      });\n    } else if (transmuxer) {\n      let transmuxResult = transmuxer.flush(chunkMeta);\n      const asyncFlush = isPromise(transmuxResult);\n      if (asyncFlush || transmuxer.async) {\n        if (!isPromise(transmuxResult)) {\n          transmuxResult = Promise.resolve(transmuxResult);\n        }\n        transmuxResult.then(data => {\n          this.handleFlushResult(data, chunkMeta);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n        });\n      } else {\n        this.handleFlushResult(transmuxResult, chunkMeta);\n      }\n    }\n  }\n  transmuxerError(error, chunkMeta, reason) {\n    if (!this.hls) {\n      return;\n    }\n    this.error = error;\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      chunkMeta,\n      fatal: false,\n      error,\n      err: error,\n      reason\n    });\n  }\n  handleFlushResult(results, chunkMeta) {\n    results.forEach(result => {\n      this.handleTransmuxComplete(result);\n    });\n    this.onFlush(chunkMeta);\n  }\n  onWorkerMessage(ev) {\n    const data = ev.data;\n    const hls = this.hls;\n    switch (data.event) {\n      case 'init':\n        {\n          var _this$workerContext;\n          const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;\n          if (objectURL) {\n            // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n            self.URL.revokeObjectURL(objectURL);\n          }\n          break;\n        }\n      case 'transmuxComplete':\n        {\n          this.handleTransmuxComplete(data.data);\n          break;\n        }\n      case 'flush':\n        {\n          this.onFlush(data.data);\n          break;\n        }\n\n      // pass logs from the worker thread to the main logger\n      case 'workerLog':\n        if (logger[data.data.logType]) {\n          logger[data.data.logType](data.data.message);\n        }\n        break;\n      default:\n        {\n          data.data = data.data || {};\n          data.data.frag = this.frag;\n          data.data.id = this.id;\n          hls.trigger(data.event, data.data);\n          break;\n        }\n    }\n  }\n  configureTransmuxer(config) {\n    const {\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        cmd: 'configure',\n        config\n      });\n    } else if (transmuxer) {\n      transmuxer.configure(config);\n    }\n  }\n  handleTransmuxComplete(result) {\n    result.chunkMeta.transmuxing.end = self.performance.now();\n    this.onTransmuxComplete(result);\n  }\n}\n\nconst STALL_MINIMUM_DURATION_MS = 250;\nconst MAX_START_GAP_JUMP = 2.0;\nconst SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nconst SKIP_BUFFER_RANGE_START = 0.05;\nclass GapController {\n  constructor(config, media, fragmentTracker, hls) {\n    this.config = void 0;\n    this.media = null;\n    this.fragmentTracker = void 0;\n    this.hls = void 0;\n    this.nudgeRetry = 0;\n    this.stallReported = false;\n    this.stalled = null;\n    this.moved = false;\n    this.seeking = false;\n    this.config = config;\n    this.media = media;\n    this.fragmentTracker = fragmentTracker;\n    this.hls = hls;\n  }\n  destroy() {\n    this.media = null;\n    // @ts-ignore\n    this.hls = this.fragmentTracker = null;\n  }\n\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param lastCurrentTime - Previously read playhead position\n   */\n  poll(lastCurrentTime, activeFrag) {\n    const {\n      config,\n      media,\n      stalled\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const {\n      currentTime,\n      seeking\n    } = media;\n    const seeked = this.seeking && !seeking;\n    const beginSeek = !this.seeking && seeking;\n    this.seeking = seeking;\n\n    // The playhead is moving, no-op\n    if (currentTime !== lastCurrentTime) {\n      this.moved = true;\n      if (stalled !== null) {\n        // The playhead is now moving, but was previously stalled\n        if (this.stallReported) {\n          const _stalledDuration = self.performance.now() - stalled;\n          logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);\n          this.stallReported = false;\n        }\n        this.stalled = null;\n        this.nudgeRetry = 0;\n      }\n      return;\n    }\n\n    // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n    if (beginSeek || seeked) {\n      this.stalled = null;\n      return;\n    }\n\n    // The playhead should not be moving\n    if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {\n      return;\n    }\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const isBuffered = bufferInfo.len > 0;\n    const nextStart = bufferInfo.nextStart || 0;\n\n    // There is no playable buffer (seeked, waiting for buffer)\n    if (!isBuffered && !nextStart) {\n      return;\n    }\n    if (seeking) {\n      // Waiting for seeking in a buffered range to complete\n      const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n      // Next buffered range is too far ahead to jump to while still seeking\n      const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n      if (hasEnoughBuffer || noBufferGap) {\n        return;\n      }\n      // Reset moved state when seeking to a point in or before a gap\n      this.moved = false;\n    }\n\n    // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n    // The addition poll gives the browser a chance to jump the gap for us\n    if (!this.moved && this.stalled !== null) {\n      var _level$details;\n      // Jump start gaps within jump threshold\n      const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n      // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n      // that begins over 1 target duration after the video start position.\n      const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n      const isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;\n      const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n      const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);\n      if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n        this._trySkipBufferHole(partialOrGap);\n        return;\n      }\n    }\n\n    // Start tracking stall time\n    const tnow = self.performance.now();\n    if (stalled === null) {\n      this.stalled = tnow;\n      return;\n    }\n    const stalledDuration = tnow - stalled;\n    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n      // Report stalling after trying to fix\n      this._reportStall(bufferInfo);\n      if (!this.media) {\n        return;\n      }\n    }\n    const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n  }\n\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */\n  _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n    const {\n      config,\n      fragmentTracker,\n      media\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    const partial = fragmentTracker.getPartialFragment(currentTime);\n    if (partial) {\n      // Try to skip over the buffer hole caused by a partial fragment\n      // This method isn't limited by the size of the gap between buffered ranges\n      const targetTime = this._trySkipBufferHole(partial);\n      // we return here in this case, meaning\n      // the branch below only executes when we haven't seeked to a new position\n      if (targetTime || !this.media) {\n        return;\n      }\n    }\n\n    // if we haven't had to skip over a buffer hole of a partial fragment\n    // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n    // needs to cross some sort of threshold covering all source-buffers content\n    // to start playing properly.\n    if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n      logger.warn('Trying to nudge playhead over buffer-hole');\n      // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n      // We only try to jump the hole if it's under the configured size\n      // Reset stalled so to rearm watchdog timer\n      this.stalled = null;\n      this._tryNudgeBuffer();\n    }\n  }\n\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */\n  _reportStall(bufferInfo) {\n    const {\n      hls,\n      media,\n      stallReported\n    } = this;\n    if (!stallReported && media) {\n      // Report stalled error once\n      this.stallReported = true;\n      const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);\n      logger.warn(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: false,\n        error,\n        buffer: bufferInfo.len\n      });\n    }\n  }\n\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */\n  _trySkipBufferHole(partial) {\n    const {\n      config,\n      hls,\n      media\n    } = this;\n    if (media === null) {\n      return 0;\n    }\n\n    // Check if currentTime is between unbuffered regions of partial fragments\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n    if (startTime) {\n      const bufferStarved = bufferInfo.len <= config.maxBufferHole;\n      const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n      const gapLength = startTime - currentTime;\n      if (gapLength > 0 && (bufferStarved || waiting)) {\n        // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n        if (gapLength > config.maxBufferHole) {\n          const {\n            fragmentTracker\n          } = this;\n          let startGap = false;\n          if (currentTime === 0) {\n            const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n            if (startFrag && startTime < startFrag.end) {\n              startGap = true;\n            }\n          }\n          if (!startGap) {\n            const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n            if (startProvisioned) {\n              let moreToLoad = false;\n              let pos = startProvisioned.end;\n              while (pos < startTime) {\n                const provisioned = fragmentTracker.getPartialFragment(pos);\n                if (provisioned) {\n                  pos += provisioned.duration;\n                } else {\n                  moreToLoad = true;\n                  break;\n                }\n              }\n              if (moreToLoad) {\n                return 0;\n              }\n            }\n          }\n        }\n        const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n        logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);\n        this.moved = true;\n        this.stalled = null;\n        media.currentTime = targetTime;\n        if (partial && !partial.gap) {\n          const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n            fatal: false,\n            error,\n            reason: error.message,\n            frag: partial\n          });\n        }\n        return targetTime;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */\n  _tryNudgeBuffer() {\n    const {\n      config,\n      hls,\n      media,\n      nudgeRetry\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    this.nudgeRetry++;\n    if (nudgeRetry < config.nudgeMaxRetry) {\n      const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n      // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n      const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);\n      logger.warn(error.message);\n      media.currentTime = targetTime;\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n        error,\n        fatal: false\n      });\n    } else {\n      const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);\n      logger.error(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        error,\n        fatal: true\n      });\n    }\n  }\n}\n\nconst TICK_INTERVAL$2 = 100; // how often to tick in ms\n\nclass StreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[stream-controller]', PlaylistLevelType.MAIN);\n    this.audioCodecSwap = false;\n    this.gapController = null;\n    this.level = -1;\n    this._forceStartLoad = false;\n    this.altAudio = false;\n    this.audioOnly = false;\n    this.fragPlaying = null;\n    this.onvplaying = null;\n    this.onvseeked = null;\n    this.fragLastKbps = 0;\n    this.couldBacktrack = false;\n    this.backtrackFragment = null;\n    this.audioCodecSwitch = false;\n    this.videoBuffer = null;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    this.onMediaDetaching();\n  }\n  startLoad(startPosition) {\n    if (this.levels) {\n      const {\n        lastCurrentTime,\n        hls\n      } = this;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL$2);\n      this.level = -1;\n      if (!this.startFragRequested) {\n        // determine load level\n        let startLevel = hls.startLevel;\n        if (startLevel === -1) {\n          if (hls.config.testBandwidth && this.levels.length > 1) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          } else {\n            startLevel = hls.nextAutoLevel;\n          }\n        }\n        // set new level to playlist loader : this will trigger start level load\n        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n        this.level = hls.nextLoadLevel = startLevel;\n        this.loadedmetadata = false;\n      }\n      // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n      if (lastCurrentTime > 0 && startPosition === -1) {\n        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n        startPosition = lastCurrentTime;\n      }\n      this.state = State.IDLE;\n      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n      this.tick();\n    } else {\n      this._forceStartLoad = true;\n      this.state = State.STOPPED;\n    }\n  }\n  stopLoad() {\n    this._forceStartLoad = false;\n    super.stopLoad();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.WAITING_LEVEL:\n        {\n          var _levels$level;\n          const {\n            levels,\n            level\n          } = this;\n          const details = levels == null ? void 0 : (_levels$level = levels[level]) == null ? void 0 : _levels$level.details;\n          if (details && (!details.live || this.levelLastLoaded === this.level)) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.IDLE;\n            break;\n          } else if (this.hls.nextLoadLevel !== this.level) {\n            this.state = State.IDLE;\n            break;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = self.performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            this.resetStartWhenNotLoaded(this.level);\n            this.state = State.IDLE;\n          }\n        }\n        break;\n    }\n    if (this.state === State.IDLE) {\n      this.doTickIdle();\n    }\n    this.onTickEnd();\n  }\n  onTickEnd() {\n    super.onTickEnd();\n    this.checkBuffer();\n    this.checkFragmentChanged();\n  }\n  doTickIdle() {\n    const {\n      hls,\n      levelLastLoaded,\n      levels,\n      media\n    } = this;\n    const {\n      config,\n      nextLoadLevel: level\n    } = hls;\n\n    // if start level not parsed yet OR\n    // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n    if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    }\n\n    // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n    if (this.altAudio && this.audioOnly) {\n      return;\n    }\n    if (!(levels != null && levels[level])) {\n      return;\n    }\n    const levelInfo = levels[level];\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null) {\n      return;\n    }\n    const lastDetails = this.getLevelDetails();\n    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n      const data = {};\n      if (this.altAudio) {\n        data.type = 'video';\n      }\n      this.hls.trigger(Events.BUFFER_EOS, data);\n      this.state = State.ENDED;\n      return;\n    }\n\n    // set next load level : this will trigger a playlist load if needed\n    if (hls.loadLevel !== level && hls.manualLevel === -1) {\n      this.log(`Adapting to level ${level} from level ${this.level}`);\n    }\n    this.level = hls.nextLoadLevel = level;\n    const levelDetails = levelInfo.details;\n    // if level info not retrieved yet, switch state and wait for level retrieval\n    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n    if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {\n      this.level = level;\n      this.state = State.WAITING_LEVEL;\n      return;\n    }\n    const bufferLen = bufferInfo.len;\n\n    // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n    const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n    // Stay idle if we are still with buffer margins\n    if (bufferLen >= maxBufLen) {\n      return;\n    }\n    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n      this.backtrackFragment = null;\n    }\n    const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n    let frag = this.getNextFragment(targetBufferTime, levelDetails);\n    // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n      var _this$backtrackFragme;\n      const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n      const fragIdx = backtrackSn - levelDetails.startSN;\n      const backtrackFrag = levelDetails.fragments[fragIdx - 1];\n      if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n        frag = backtrackFrag;\n        this.fragmentTracker.removeFragment(backtrackFrag);\n      }\n    } else if (this.backtrackFragment && bufferInfo.len) {\n      this.backtrackFragment = null;\n    }\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      const gapStart = frag.gap;\n      if (!gapStart) {\n        // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n        const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n        if (mediaBuffer) {\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        }\n      }\n      frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      return;\n    }\n    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n      frag = frag.initSegment;\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    // Check if fragment is not loaded\n    const fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n    if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, level);\n      } else if (this.bitrateTest) {\n        this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);\n        this._loadBitrateTestFrag(frag, level);\n      } else {\n        this.startFragRequested = true;\n        super.loadFragment(frag, level, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  getBufferedFrag(position) {\n    return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n  }\n  followingBufferedFrag(frag) {\n    if (frag) {\n      // try to get range of next fragment (500ms after this range)\n      return this.getBufferedFrag(frag.end + 0.5);\n    }\n    return null;\n  }\n\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */\n  immediateLevelSwitch() {\n    this.abortCurrentFrag();\n    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */\n  nextLevelSwitch() {\n    const {\n      levels,\n      media\n    } = this;\n    // ensure that media is defined and that metadata are available (to retrieve currentTime)\n    if (media != null && media.readyState) {\n      let fetchdelay;\n      const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n        // flush buffer preceding current fragment (flush until current fragment start offset)\n        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n      }\n      const levelDetails = this.getLevelDetails();\n      if (levelDetails != null && levelDetails.live) {\n        const bufferInfo = this.getMainFwdBufferInfo();\n        // Do not flush in live stream with low buffer\n        if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n          return;\n        }\n      }\n      if (!media.paused && levels) {\n        // add a safety delay of 1s\n        const nextLevelId = this.hls.nextLoadLevel;\n        const nextLevel = levels[nextLevelId];\n        const fragLastKbps = this.fragLastKbps;\n        if (fragLastKbps && this.fragCurrent) {\n          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n        } else {\n          fetchdelay = 0;\n        }\n      } else {\n        fetchdelay = 0;\n      }\n      // this.log('fetchdelay:'+fetchdelay);\n      // find buffer range that will be reached once new fragment will be fetched\n      const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n      if (bufferedFrag) {\n        // we can flush buffer range following this one without stalling playback\n        const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n        if (nextBufferedFrag) {\n          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n          this.abortCurrentFrag();\n          // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n          const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n          const fragDuration = nextBufferedFrag.duration;\n          const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));\n          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  }\n  abortCurrentFrag() {\n    const fragCurrent = this.fragCurrent;\n    this.fragCurrent = null;\n    this.backtrackFragment = null;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.fragmentTracker.removeFragment(fragCurrent);\n    }\n    switch (this.state) {\n      case State.KEY_LOADING:\n      case State.FRAG_LOADING:\n      case State.FRAG_LOADING_WAITING_RETRY:\n      case State.PARSING:\n      case State.PARSED:\n        this.state = State.IDLE;\n        break;\n    }\n    this.nextLoadPosition = this.getLoadPosition();\n  }\n  flushMainBuffer(startOffset, endOffset) {\n    super.flushMainBuffer(startOffset, endOffset, this.altAudio ? 'video' : null);\n  }\n  onMediaAttached(event, data) {\n    super.onMediaAttached(event, data);\n    const media = data.media;\n    this.onvplaying = this.onMediaPlaying.bind(this);\n    this.onvseeked = this.onMediaSeeked.bind(this);\n    media.addEventListener('playing', this.onvplaying);\n    media.addEventListener('seeked', this.onvseeked);\n    this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);\n  }\n  onMediaDetaching() {\n    const {\n      media\n    } = this;\n    if (media && this.onvplaying && this.onvseeked) {\n      media.removeEventListener('playing', this.onvplaying);\n      media.removeEventListener('seeked', this.onvseeked);\n      this.onvplaying = this.onvseeked = null;\n      this.videoBuffer = null;\n    }\n    this.fragPlaying = null;\n    if (this.gapController) {\n      this.gapController.destroy();\n      this.gapController = null;\n    }\n    super.onMediaDetaching();\n  }\n  onMediaPlaying() {\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  }\n  onMediaSeeked() {\n    const media = this.media;\n    const currentTime = media ? media.currentTime : null;\n    if (isFiniteNumber(currentTime)) {\n      this.log(`Media seeked to ${currentTime.toFixed(3)}`);\n    }\n\n    // If seeked was issued before buffer was appended do not tick immediately\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null || bufferInfo.len === 0) {\n      this.warn(`Main forward buffer length on \"seeked\" event ${bufferInfo ? bufferInfo.len : 'empty'})`);\n      return;\n    }\n\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  }\n  onManifestLoading() {\n    // reset buffer on manifest loading\n    this.log('Trigger BUFFER_RESET');\n    this.hls.trigger(Events.BUFFER_RESET, undefined);\n    this.fragmentTracker.removeAllFragments();\n    this.couldBacktrack = false;\n    this.startPosition = this.lastCurrentTime = 0;\n    this.levels = this.fragPlaying = this.backtrackFragment = null;\n    this.altAudio = this.audioOnly = false;\n  }\n  onManifestParsed(event, data) {\n    let aac = false;\n    let heaac = false;\n    let codec;\n    data.levels.forEach(level => {\n      // detect if we have different kind of audio codecs used amongst playlists\n      codec = level.audioCodec;\n      if (codec) {\n        if (codec.indexOf('mp4a.40.2') !== -1) {\n          aac = true;\n        }\n        if (codec.indexOf('mp4a.40.5') !== -1) {\n          heaac = true;\n        }\n      }\n    });\n    this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n    if (this.audioCodecSwitch) {\n      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n    }\n    this.levels = data.levels;\n    this.startFragRequested = false;\n  }\n  onLevelLoading(event, data) {\n    const {\n      levels\n    } = this;\n    if (!levels || this.state !== State.IDLE) {\n      return;\n    }\n    const level = levels[data.level];\n    if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {\n      this.state = State.WAITING_LEVEL;\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _curLevel$details;\n    const {\n      levels\n    } = this;\n    const newLevelId = data.level;\n    const newDetails = data.details;\n    const duration = newDetails.totalduration;\n    if (!levels) {\n      this.warn(`Levels were reset while loading level ${newLevelId}`);\n      return;\n    }\n    this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);\n    const curLevel = levels[newLevelId];\n    const fragCurrent = this.fragCurrent;\n    if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n      if ((fragCurrent.level !== data.level || fragCurrent.urlId !== curLevel.urlId) && fragCurrent.loader) {\n        this.abortCurrentFrag();\n      }\n    }\n    let sliding = 0;\n    if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n      this.checkLiveUpdate(newDetails);\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      sliding = this.alignPlaylists(newDetails, curLevel.details);\n    }\n    // override level info\n    curLevel.details = newDetails;\n    this.levelLastLoaded = newLevelId;\n    this.hls.trigger(Events.LEVEL_UPDATED, {\n      details: newDetails,\n      level: newLevelId\n    });\n\n    // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n    if (this.state === State.WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(newDetails)) {\n        // Wait for Low-Latency CDN Tune-in\n        return;\n      }\n      this.state = State.IDLE;\n    }\n    if (!this.startFragRequested) {\n      this.setStartPosition(newDetails, sliding);\n    } else if (newDetails.live) {\n      this.synchronizeToLiveEdge(newDetails);\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      part,\n      payload\n    } = data;\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const currentLevel = levels[frag.level];\n    const details = currentLevel.details;\n    if (!details) {\n      this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    const videoCodec = currentLevel.videoCodec;\n\n    // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n    const accurateTimeOffset = details.PTSKnown || !details.live;\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    const audioCodec = this._getAudioCodec(currentLevel);\n\n    // transmux the MPEG-TS data to ISO-BMFF segments\n    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n    const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    const partIndex = part ? part.index : -1;\n    const partial = partIndex !== -1;\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n    const initPTS = this.initPTS[frag.cc];\n    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n  }\n  onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    const fromAltAudio = this.altAudio;\n    const altAudio = !!data.url;\n    // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n    // don't do anything if we switch to alt audio: audio stream controller is handling it.\n    // we will just have to change buffer scheduling on audioTrackSwitched\n    if (!altAudio) {\n      if (this.mediaBuffer !== this.media) {\n        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n        this.mediaBuffer = this.media;\n        const fragCurrent = this.fragCurrent;\n        // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n        if (fragCurrent) {\n          this.log('Switching to main audio track, cancel main fragment load');\n          fragCurrent.abortRequests();\n          this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        // destroy transmuxer to force init segment generation (following audio switch)\n        this.resetTransmuxer();\n        // switch to IDLE state to load new fragment\n        this.resetLoadingState();\n      } else if (this.audioOnly) {\n        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n        this.resetTransmuxer();\n      }\n      const hls = this.hls;\n      // If switching from alt to main audio, flush all audio and trigger track switched\n      if (fromAltAudio) {\n        hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: null\n        });\n        this.fragmentTracker.removeAllFragments();\n      }\n      hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n    }\n  }\n  onAudioTrackSwitched(event, data) {\n    const trackId = data.id;\n    const altAudio = !!this.hls.audioTracks[trackId].url;\n    if (altAudio) {\n      const videoBuffer = this.videoBuffer;\n      // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n      if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n        this.mediaBuffer = videoBuffer;\n      }\n    }\n    this.altAudio = altAudio;\n    this.tick();\n  }\n  onBufferCreated(event, data) {\n    const tracks = data.tracks;\n    let mediaTrack;\n    let name;\n    let alternate = false;\n    for (const type in tracks) {\n      const track = tracks[type];\n      if (track.id === 'main') {\n        name = type;\n        mediaTrack = track;\n        // keep video source buffer reference\n        if (type === 'video') {\n          const videoTrack = tracks[type];\n          if (videoTrack) {\n            this.videoBuffer = videoTrack.buffer;\n          }\n        }\n      } else {\n        alternate = true;\n      }\n    }\n    if (alternate && mediaTrack) {\n      this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);\n      this.mediaBuffer = mediaTrack.buffer;\n    } else {\n      this.mediaBuffer = this.media;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    if (frag && frag.type !== PlaylistLevelType.MAIN) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE, since that will interfere with a level switch\n      this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);\n      if (this.state === State.PARSED) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const stats = part ? part.stats : frag.stats;\n    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n    }\n    this.fragBufferedComplete(frag, part);\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n        break;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (!data.parent || data.parent !== 'main') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n\n  // Checks the health of the buffer and attempts to resolve playback stalls.\n  checkBuffer() {\n    const {\n      media,\n      gapController\n    } = this;\n    if (!media || !gapController || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {\n      // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n      const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;\n      gapController.poll(this.lastCurrentTime, activeFrag);\n    }\n    this.lastCurrentTime = media.currentTime;\n  }\n  onFragLoadEmergencyAborted() {\n    this.state = State.IDLE;\n    // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      this.nextLoadPosition = this.startPosition;\n    }\n    this.tickImmediate();\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n      const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n    }\n  }\n  onLevelsUpdated(event, data) {\n    this.levels = data.levels;\n  }\n  swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */\n  seekToStartPos() {\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    let startPosition = this.startPosition;\n    // only adjust currentTime if different from startPosition or if startPosition not buffered\n    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n    if (startPosition >= 0 && currentTime < startPosition) {\n      if (media.seeking) {\n        this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);\n        return;\n      }\n      const buffered = BufferHelper.getBuffered(media);\n      const bufferStart = buffered.length ? buffered.start(0) : 0;\n      const delta = bufferStart - startPosition;\n      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n        this.log(`adjusting start position by ${delta} to match buffer start`);\n        startPosition += delta;\n        this.startPosition = startPosition;\n      }\n      this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);\n      media.currentTime = startPosition;\n    }\n  }\n  _getAudioCodec(currentLevel) {\n    let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n    if (this.audioCodecSwap && audioCodec) {\n      this.log('Swapping audio codec');\n      if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n        audioCodec = 'mp4a.40.2';\n      } else {\n        audioCodec = 'mp4a.40.5';\n      }\n    }\n    return audioCodec;\n  }\n  _loadBitrateTestFrag(frag, level) {\n    frag.bitrateTest = true;\n    this._doFragLoad(frag, level).then(data => {\n      const {\n        hls\n      } = this;\n      if (!data || this.fragContextChanged(frag)) {\n        return;\n      }\n      level.fragmentError = 0;\n      this.state = State.IDLE;\n      this.startFragRequested = false;\n      this.bitrateTest = false;\n      const stats = frag.stats;\n      // Bitrate tests fragments are neither parsed nor buffered\n      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n      hls.trigger(Events.FRAG_LOADED, data);\n      frag.bitrateTest = false;\n    });\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = 'main';\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      video,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n    const {\n      details\n    } = level;\n    // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n    const audio = this.altAudio ? undefined : remuxResult.audio;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag)) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (initSegment) {\n      if (initSegment != null && initSegment.tracks) {\n        const mapFragment = frag.initSegment || frag;\n        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n          frag: mapFragment,\n          id,\n          tracks: initSegment.tracks\n        });\n      }\n\n      // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n      const initPTS = initSegment.initPTS;\n      const timescale = initSegment.timescale;\n      if (isFiniteNumber(initPTS)) {\n        this.initPTS[frag.cc] = {\n          baseTime: initPTS,\n          timescale\n        };\n        hls.trigger(Events.INIT_PTS_FOUND, {\n          frag,\n          id,\n          initPTS,\n          timescale\n        });\n      }\n    }\n\n    // Avoid buffering if backtracking this fragment\n    if (video && details && frag.sn !== 'initSegment') {\n      const prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n      const isFirstFragment = frag.sn === details.startSN;\n      const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n      if (remuxResult.independent !== false) {\n        const {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        } = video;\n        if (part) {\n          part.elementaryStreams[video.type] = {\n            startPTS,\n            endPTS,\n            startDTS,\n            endDTS\n          };\n        } else {\n          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n            this.couldBacktrack = true;\n          }\n          if (video.dropped && video.independent) {\n            // Backtrack if dropped frames create a gap after currentTime\n\n            const bufferInfo = this.getMainFwdBufferInfo();\n            const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n            const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n            if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n              this.backtrack(frag);\n              return;\n            } else if (isFirstInDiscontinuity) {\n              // Mark segment with a gap to avoid loop loading\n              frag.gap = true;\n            }\n            // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n          }\n        }\n        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n        if (this.backtrackFragment) {\n          this.backtrackFragment = frag;\n        }\n        this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n      } else if (isFirstFragment || isFirstInDiscontinuity) {\n        // Mark segment with a gap to avoid loop loading\n        frag.gap = true;\n      } else {\n        this.backtrack(frag);\n        return;\n      }\n    }\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = {\n        id,\n        frag,\n        details,\n        samples: id3.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (details && text) {\n      const emittedText = {\n        id,\n        frag,\n        details,\n        samples: text.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    this.audioOnly = !!tracks.audio && !tracks.video;\n\n    // if audio track is expected to come from audio stream controller, discard any coming from main\n    if (this.altAudio && !this.audioOnly) {\n      delete tracks.audio;\n    }\n    // include levelCodec in audio and video tracks\n    const {\n      audio,\n      video,\n      audiovideo\n    } = tracks;\n    if (audio) {\n      let audioCodec = currentLevel.audioCodec;\n      const ua = navigator.userAgent.toLowerCase();\n      if (this.audioCodecSwitch) {\n        if (audioCodec) {\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n        // force HE-AAC, as it seems that most browsers prefers it.\n        // don't force HE-AAC if mono stream, or in Firefox\n        if (audio.metadata.channelCount !== 1 && ua.indexOf('firefox') === -1) {\n          audioCodec = 'mp4a.40.5';\n        }\n      }\n      // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n      if (ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n        // Exclude mpeg audio\n        audioCodec = 'mp4a.40.2';\n        this.log(`Android: force audio codec to ${audioCodec}`);\n      }\n      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n        this.log(`Swapping manifest audio codec \"${currentLevel.audioCodec}\" for \"${audioCodec}\"`);\n      }\n      audio.levelCodec = audioCodec;\n      audio.id = 'main';\n      this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ''}/${currentLevel.audioCodec || ''}/${audio.codec}]`);\n    }\n    if (video) {\n      video.levelCodec = currentLevel.videoCodec;\n      video.id = 'main';\n      this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ''}/${video.codec}]`);\n    }\n    if (audiovideo) {\n      this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.attrs.CODECS || ''}/${audiovideo.codec}]`);\n    }\n    this.hls.trigger(Events.BUFFER_CODECS, tracks);\n    // loop through tracks that are going to be provided to bufferController\n    Object.keys(tracks).forEach(trackName => {\n      const track = tracks[trackName];\n      const initSegment = track.initSegment;\n      if (initSegment != null && initSegment.byteLength) {\n        this.hls.trigger(Events.BUFFER_APPENDING, {\n          type: trackName,\n          data: initSegment,\n          frag,\n          part: null,\n          chunkMeta,\n          parent: frag.type\n        });\n      }\n    });\n    // trigger handler right now\n    this.tick();\n  }\n  getMainFwdBufferInfo() {\n    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);\n  }\n  backtrack(frag) {\n    this.couldBacktrack = true;\n    // Causes findFragments to backtrack through fragments to find the keyframe\n    this.backtrackFragment = frag;\n    this.resetTransmuxer();\n    this.flushBufferGap(frag);\n    this.fragmentTracker.removeFragment(frag);\n    this.fragPrevious = null;\n    this.nextLoadPosition = frag.start;\n    this.state = State.IDLE;\n  }\n  checkFragmentChanged() {\n    const video = this.media;\n    let fragPlayingCurrent = null;\n    if (video && video.readyState > 1 && video.seeking === false) {\n      const currentTime = video.currentTime;\n      /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */\n\n      if (BufferHelper.isBuffered(video, currentTime)) {\n        fragPlayingCurrent = this.getAppendedFrag(currentTime);\n      } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n        /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */\n        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n      }\n      if (fragPlayingCurrent) {\n        this.backtrackFragment = null;\n        const fragPlaying = this.fragPlaying;\n        const fragCurrentLevel = fragPlayingCurrent.level;\n        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {\n          this.fragPlaying = fragPlayingCurrent;\n          this.hls.trigger(Events.FRAG_CHANGED, {\n            frag: fragPlayingCurrent\n          });\n          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n            this.hls.trigger(Events.LEVEL_SWITCHED, {\n              level: fragCurrentLevel\n            });\n          }\n        }\n      }\n    }\n  }\n  get nextLevel() {\n    const frag = this.nextBufferedFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get currentFrag() {\n    const media = this.media;\n    if (media) {\n      return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n    }\n    return null;\n  }\n  get currentProgramDateTime() {\n    const media = this.media;\n    if (media) {\n      const currentTime = media.currentTime;\n      const frag = this.currentFrag;\n      if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {\n        const epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n        return new Date(epocMs);\n      }\n    }\n    return null;\n  }\n  get currentLevel() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get nextBufferedFrag() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return this.followingBufferedFrag(frag);\n    }\n    return null;\n  }\n  get forceStartLoad() {\n    return this._forceStartLoad;\n  }\n}\n\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\n\nclass EWMA {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  constructor(halfLife, estimate = 0, weight = 0) {\n    this.halfLife = void 0;\n    this.alpha_ = void 0;\n    this.estimate_ = void 0;\n    this.totalWeight_ = void 0;\n    this.halfLife = halfLife;\n    // Larger values of alpha expire historical data more slowly.\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = estimate;\n    this.totalWeight_ = weight;\n  }\n  sample(weight, value) {\n    const adjAlpha = Math.pow(this.alpha_, weight);\n    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n    this.totalWeight_ += weight;\n  }\n  getTotalWeight() {\n    return this.totalWeight_;\n  }\n  getEstimate() {\n    if (this.alpha_) {\n      const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n      if (zeroFactor) {\n        return this.estimate_ / zeroFactor;\n      }\n    }\n    return this.estimate_;\n  }\n}\n\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */\n\nclass EwmaBandWidthEstimator {\n  constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {\n    this.defaultEstimate_ = void 0;\n    this.minWeight_ = void 0;\n    this.minDelayMs_ = void 0;\n    this.slow_ = void 0;\n    this.fast_ = void 0;\n    this.defaultTTFB_ = void 0;\n    this.ttfb_ = void 0;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new EWMA(slow);\n    this.fast_ = new EWMA(fast);\n    this.defaultTTFB_ = defaultTTFB;\n    this.ttfb_ = new EWMA(slow);\n  }\n  update(slow, fast) {\n    const {\n      slow_,\n      fast_,\n      ttfb_\n    } = this;\n    if (slow_.halfLife !== slow) {\n      this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n    }\n    if (fast_.halfLife !== fast) {\n      this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n    }\n    if (ttfb_.halfLife !== slow) {\n      this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n    }\n  }\n  sample(durationMs, numBytes) {\n    durationMs = Math.max(durationMs, this.minDelayMs_);\n    const numBits = 8 * numBytes;\n    // weight is duration in seconds\n    const durationS = durationMs / 1000;\n    // value is bandwidth in bits/s\n    const bandwidthInBps = numBits / durationS;\n    this.fast_.sample(durationS, bandwidthInBps);\n    this.slow_.sample(durationS, bandwidthInBps);\n  }\n  sampleTTFB(ttfb) {\n    // weight is frequency curve applied to TTFB in seconds\n    // (longer times have less weight with expected input under 1 second)\n    const seconds = ttfb / 1000;\n    const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n    this.ttfb_.sample(weight, Math.max(ttfb, 5));\n  }\n  canEstimate() {\n    return this.fast_.getTotalWeight() >= this.minWeight_;\n  }\n  getEstimate() {\n    if (this.canEstimate()) {\n      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n      // Take the minimum of these two estimates.  This should have the effect of\n      // adapting down quickly, but up more slowly.\n      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n    } else {\n      return this.defaultEstimate_;\n    }\n  }\n  getEstimateTTFB() {\n    if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n      return this.ttfb_.getEstimate();\n    } else {\n      return this.defaultTTFB_;\n    }\n  }\n  destroy() {}\n}\n\nclass AbrController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.lastLevelLoadSec = 0;\n    this.lastLoadedFragLevel = 0;\n    this._nextAutoLevel = -1;\n    this.timer = -1;\n    this.onCheck = this._abandonRulesCheck.bind(this);\n    this.fragCurrent = null;\n    this.partCurrent = null;\n    this.bitrateTestDelay = 0;\n    this.bwEstimator = void 0;\n    this.hls = hls;\n    const config = hls.config;\n    this.bwEstimator = new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.onCheck = null;\n    this.fragCurrent = this.partCurrent = null;\n  }\n  onFragLoading(event, data) {\n    var _data$part;\n    const frag = data.frag;\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    this.fragCurrent = frag;\n    this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n    this.clearTimer();\n    this.timer = self.setInterval(this.onCheck, 100);\n  }\n  onLevelSwitching(event, data) {\n    this.clearTimer();\n  }\n  getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n    const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n    const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;\n    return fragLoadSec + playlistLoadSec;\n  }\n  onLevelLoaded(event, data) {\n    const config = this.hls.config;\n    const {\n      total,\n      bwEstimate\n    } = data.stats;\n    // Total is the bytelength and bwEstimate in bits/sec\n    if (isFiniteNumber(total) && isFiniteNumber(bwEstimate)) {\n      this.lastLevelLoadSec = 8 * total / bwEstimate;\n    }\n    if (data.details.live) {\n      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n    } else {\n      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n    }\n  }\n\n  /*\n      This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n      quickly enough to prevent underbuffering\n    */\n  _abandonRulesCheck() {\n    const {\n      fragCurrent: frag,\n      partCurrent: part,\n      hls\n    } = this;\n    const {\n      autoLevelEnabled,\n      media\n    } = hls;\n    if (!frag || !media) {\n      return;\n    }\n    const now = performance.now();\n    const stats = part ? part.stats : frag.stats;\n    const duration = part ? part.duration : frag.duration;\n    const timeLoading = now - stats.loading.start;\n    // If frag loading is aborted, complete, or from lowest level, stop timer and return\n    if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level === 0) {\n      this.clearTimer();\n      // reset forced auto level value so that next level will be selected\n      this._nextAutoLevel = -1;\n      return;\n    }\n\n    // This check only runs if we're in ABR mode and actually playing\n    if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n      return;\n    }\n    const bufferInfo = hls.mainForwardBufferInfo;\n    if (bufferInfo === null) {\n      return;\n    }\n    const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n    const playbackRate = Math.abs(media.playbackRate);\n    // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n    if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n      return;\n    }\n\n    // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n    const bufferStarvationDelay = bufferInfo.len / playbackRate;\n    // Only downswitch if less than 2 fragment lengths are buffered\n    if (bufferStarvationDelay >= 2 * duration / playbackRate) {\n      return;\n    }\n    const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n    const loadedFirstByte = stats.loaded && ttfb > -1;\n    const bwEstimate = this.bwEstimator.getEstimate();\n    const {\n      levels,\n      minAutoLevel\n    } = hls;\n    const level = levels[frag.level];\n    const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));\n    let timeStreaming = timeLoading - ttfb;\n    if (timeStreaming < 1 && loadedFirstByte) {\n      timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n    }\n    const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n    // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n    const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;\n    // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n    if (fragLoadedDelay <= bufferStarvationDelay) {\n      return;\n    }\n    const bwe = loadRate ? loadRate * 8 : bwEstimate;\n    let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n    let nextLoadLevel;\n    // Iterate through lower level and try to find the largest one that avoids rebuffering\n    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n      // compute time to load next fragment at lower level\n      // 8 = bits per byte (bps/Bps)\n      const levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n      fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);\n      if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n        break;\n      }\n    }\n    // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n    // to load the current one\n    if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n      return;\n    }\n\n    // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n    if (fragLevelNextLoadedDelay > duration * 10) {\n      return;\n    }\n    hls.nextLoadLevel = nextLoadLevel;\n    if (loadedFirstByte) {\n      // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n      this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n    } else {\n      // If there has been no loading progress, sample TTFB\n      this.bwEstimator.sampleTTFB(timeLoading);\n    }\n    this.clearTimer();\n    logger.warn(`[abr] Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} is loading too slowly;\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s\n      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s\n      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s\n      TTFB estimate: ${ttfb}\n      Current BW estimate: ${isFiniteNumber(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : 'Unknown'} Kb/s\n      New BW estimate: ${(this.bwEstimator.getEstimate() / 1024).toFixed(3)} Kb/s\n      Aborting and switching to level ${nextLoadLevel}`);\n    if (frag.loader) {\n      this.fragCurrent = this.partCurrent = null;\n      frag.abortRequests();\n    }\n    hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n      frag,\n      part,\n      stats\n    });\n  }\n  onFragLoaded(event, {\n    frag,\n    part\n  }) {\n    const stats = part ? part.stats : frag.stats;\n    if (frag.type === PlaylistLevelType.MAIN) {\n      this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // stop monitoring bw once frag loaded\n    this.clearTimer();\n    // store level id after successful fragment load\n    this.lastLoadedFragLevel = frag.level;\n    // reset forced auto level value so that next level will be selected\n    this._nextAutoLevel = -1;\n\n    // compute level average bitrate\n    if (this.hls.config.abrMaxWithRealBitrate) {\n      const duration = part ? part.duration : frag.duration;\n      const level = this.hls.levels[frag.level];\n      const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n      const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n      level.loaded = {\n        bytes: loadedBytes,\n        duration: loadedDuration\n      };\n      level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n    }\n    if (frag.bitrateTest) {\n      const fragBufferedData = {\n        stats,\n        frag,\n        part,\n        id: frag.type\n      };\n      this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n      frag.bitrateTest = false;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n    if (stats.aborted) {\n      return;\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n    // is used. If we used buffering in that case, our BW estimate sample will be very large.\n    const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n    this.bwEstimator.sample(processingMs, stats.loaded);\n    stats.bwEstimate = this.bwEstimator.getEstimate();\n    if (frag.bitrateTest) {\n      this.bitrateTestDelay = processingMs / 1000;\n    } else {\n      this.bitrateTestDelay = 0;\n    }\n  }\n  ignoreFragment(frag) {\n    // Only count non-alt-audio frags which were actually buffered in our BW calculations\n    return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n  }\n  clearTimer() {\n    self.clearInterval(this.timer);\n  }\n\n  // return next auto level\n  get nextAutoLevel() {\n    const forcedAutoLevel = this._nextAutoLevel;\n    const bwEstimator = this.bwEstimator;\n    // in case next auto level has been forced, and bw not available or not reliable, return forced value\n    if (forcedAutoLevel !== -1 && !bwEstimator.canEstimate()) {\n      return forcedAutoLevel;\n    }\n\n    // compute next level using ABR logic\n    let nextABRAutoLevel = this.getNextABRAutoLevel();\n    // use forced auto level when ABR selected level has errored\n    if (forcedAutoLevel !== -1) {\n      const levels = this.hls.levels;\n      if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n        return forcedAutoLevel;\n      }\n    }\n    // if forced auto level has been defined, use it to cap ABR computed quality level\n    if (forcedAutoLevel !== -1) {\n      nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);\n    }\n    return nextABRAutoLevel;\n  }\n  getNextABRAutoLevel() {\n    const {\n      fragCurrent,\n      partCurrent,\n      hls\n    } = this;\n    const {\n      maxAutoLevel,\n      config,\n      minAutoLevel,\n      media\n    } = hls;\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n\n    // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n    // if we're playing back at the normal rate.\n    const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n    const avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;\n    // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n    const bufferInfo = hls.mainForwardBufferInfo;\n    const bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n\n    // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n    let bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);\n    if (bestLevel >= 0) {\n      return bestLevel;\n    }\n    logger.trace(`[abr] ${bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty'}, finding optimal quality level`);\n    // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering\n    // if no matching level found, logic will return 0\n    let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n    let bwFactor = config.abrBandWidthFactor;\n    let bwUpFactor = config.abrBandWidthUpFactor;\n    if (!bufferStarvationDelay) {\n      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n      const bitrateTestDelay = this.bitrateTestDelay;\n      if (bitrateTestDelay) {\n        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n        // max video loading delay used in  automatic start level selection :\n        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n        const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n        logger.trace(`[abr] bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);\n        // don't use conservative factor on bitrate test\n        bwFactor = bwUpFactor = 1;\n      }\n    }\n    bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);\n    return Math.max(bestLevel, 0);\n  }\n  findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {\n    var _level$details;\n    const {\n      fragCurrent,\n      partCurrent,\n      lastLoadedFragLevel: currentLevel\n    } = this;\n    const {\n      levels\n    } = this.hls;\n    const level = levels[currentLevel];\n    const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);\n    const currentCodecSet = level == null ? void 0 : level.codecSet;\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n    let levelSkippedMin = minAutoLevel;\n    let levelSkippedMax = -1;\n    for (let i = maxAutoLevel; i >= minAutoLevel; i--) {\n      const levelInfo = levels[i];\n      if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {\n        if (levelInfo) {\n          levelSkippedMin = Math.min(i, levelSkippedMin);\n          levelSkippedMax = Math.max(i, levelSkippedMax);\n        }\n        continue;\n      }\n      if (levelSkippedMax !== -1) {\n        logger.trace(`[abr] Skipped level(s) ${levelSkippedMin}-${levelSkippedMax} with CODECS:\"${levels[levelSkippedMax].attrs.CODECS}\"; not compatible with \"${level.attrs.CODECS}\"`);\n      }\n      const levelDetails = levelInfo.details;\n      const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n      let adjustedbw;\n      // follow algorithm captured from stagefright :\n      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n      // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n      // consider only 80% of the available bandwidth, but if we are switching up,\n      // be even more conservative (70%) to avoid overestimating and immediately\n      // switching back.\n      if (i <= currentLevel) {\n        adjustedbw = bwFactor * currentBw;\n      } else {\n        adjustedbw = bwUpFactor * currentBw;\n      }\n      const bitrate = levels[i].maxBitrate;\n      const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n      logger.trace(`[abr] level:${i} adjustedbw-bitrate:${Math.round(adjustedbw - bitrate)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)}`);\n      // if adjusted bw is greater than level bitrate AND\n      if (adjustedbw > bitrate && (\n      // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n      fetchDuration === 0 || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {\n        // as we are looping from highest to lowest, this will return the best achievable quality level\n        return i;\n      }\n    }\n    // not enough time budget even with quality level 0 ... rebuffering might happen\n    return -1;\n  }\n  set nextAutoLevel(nextLevel) {\n    this._nextAutoLevel = nextLevel;\n  }\n}\n\nclass ChunkCache {\n  constructor() {\n    this.chunks = [];\n    this.dataLength = 0;\n  }\n  push(chunk) {\n    this.chunks.push(chunk);\n    this.dataLength += chunk.length;\n  }\n  flush() {\n    const {\n      chunks,\n      dataLength\n    } = this;\n    let result;\n    if (!chunks.length) {\n      return new Uint8Array(0);\n    } else if (chunks.length === 1) {\n      result = chunks[0];\n    } else {\n      result = concatUint8Arrays(chunks, dataLength);\n    }\n    this.reset();\n    return result;\n  }\n  reset() {\n    this.chunks.length = 0;\n    this.dataLength = 0;\n  }\n}\nfunction concatUint8Arrays(chunks, dataLength) {\n  const result = new Uint8Array(dataLength);\n  let offset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i];\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return result;\n}\n\nconst TICK_INTERVAL$1 = 100; // how often to tick in ms\n\nclass AudioStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[audio-stream-controller]', PlaylistLevelType.AUDIO);\n    this.videoBuffer = null;\n    this.videoTrackCC = -1;\n    this.waitingVideoCC = -1;\n    this.bufferedTrack = null;\n    this.switchingTrack = null;\n    this.trackId = -1;\n    this.waitingData = null;\n    this.mainDetails = null;\n    this.bufferFlushed = false;\n    this.cachedTrackLoadedData = null;\n    this._registerListeners();\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    this.mainDetails = null;\n    this.bufferedTrack = null;\n    this.switchingTrack = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n\n  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    // Always update the new INIT PTS\n    // Can change due level switch\n    if (id === 'main') {\n      const cc = frag.cc;\n      this.initPTS[frag.cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n      this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}`);\n      this.videoTrackCC = cc;\n      // If we are waiting, tick immediately to unblock audio fragment transmuxing\n      if (this.state === State.WAITING_INIT_PTS) {\n        this.tick();\n      }\n    }\n  }\n  startLoad(startPosition) {\n    if (!this.levels) {\n      this.startPosition = startPosition;\n      this.state = State.STOPPED;\n      return;\n    }\n    const lastCurrentTime = this.lastCurrentTime;\n    this.stopLoad();\n    this.setInterval(TICK_INTERVAL$1);\n    if (lastCurrentTime > 0 && startPosition === -1) {\n      this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n      startPosition = lastCurrentTime;\n      this.state = State.IDLE;\n    } else {\n      this.loadedmetadata = false;\n      this.state = State.WAITING_TRACK;\n    }\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.IDLE:\n        this.doTickIdle();\n        break;\n      case State.WAITING_TRACK:\n        {\n          var _levels$trackId;\n          const {\n            levels,\n            trackId\n          } = this;\n          const details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;\n          if (details) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.WAITING_INIT_PTS;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            this.log('RetryDate reached, switch back to IDLE state');\n            this.resetStartWhenNotLoaded(this.trackId);\n            this.state = State.IDLE;\n          }\n          break;\n        }\n      case State.WAITING_INIT_PTS:\n        {\n          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n          const waitingData = this.waitingData;\n          if (waitingData) {\n            const {\n              frag,\n              part,\n              cache,\n              complete\n            } = waitingData;\n            if (this.initPTS[frag.cc] !== undefined) {\n              this.waitingData = null;\n              this.waitingVideoCC = -1;\n              this.state = State.FRAG_LOADING;\n              const payload = cache.flush();\n              const data = {\n                frag,\n                part,\n                payload,\n                networkDetails: null\n              };\n              this._handleFragmentLoadProgress(data);\n              if (complete) {\n                super._handleFragmentLoadComplete(data);\n              }\n            } else if (this.videoTrackCC !== this.waitingVideoCC) {\n              // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n              this.log(`Waiting fragment cc (${frag.cc}) cancelled because video is at cc ${this.videoTrackCC}`);\n              this.clearWaitingFragment();\n            } else {\n              // Drop waiting fragment if an earlier fragment is needed\n              const pos = this.getLoadPosition();\n              const bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);\n              const waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);\n              if (waitingFragmentAtPosition < 0) {\n                this.log(`Waiting fragment cc (${frag.cc}) @ ${frag.start} cancelled because another fragment at ${bufferInfo.end} is needed`);\n                this.clearWaitingFragment();\n              }\n            }\n          } else {\n            this.state = State.IDLE;\n          }\n        }\n    }\n    this.onTickEnd();\n  }\n  clearWaitingFragment() {\n    const waitingData = this.waitingData;\n    if (waitingData) {\n      this.fragmentTracker.removeFragment(waitingData.frag);\n      this.waitingData = null;\n      this.waitingVideoCC = -1;\n      this.state = State.IDLE;\n    }\n  }\n  resetLoadingState() {\n    this.clearWaitingFragment();\n    super.resetLoadingState();\n  }\n  onTickEnd() {\n    const {\n      media\n    } = this;\n    if (!(media != null && media.readyState)) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    this.lastCurrentTime = media.currentTime;\n  }\n  doTickIdle() {\n    const {\n      hls,\n      levels,\n      media,\n      trackId\n    } = this;\n    const config = hls.config;\n    if (!(levels != null && levels[trackId])) {\n      return;\n    }\n\n    // if video not attached AND\n    // start fragment already requested OR start frag prefetch not enabled\n    // exit loop\n    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n    if (!media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    }\n    const levelInfo = levels[trackId];\n    const trackDetails = levelInfo.details;\n    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== trackId || this.waitForCdnTuneIn(trackDetails)) {\n      this.state = State.WAITING_TRACK;\n      return;\n    }\n    const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n    if (this.bufferFlushed && bufferable) {\n      this.bufferFlushed = false;\n      this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);\n    }\n    const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);\n    if (bufferInfo === null) {\n      return;\n    }\n    const {\n      bufferedTrack,\n      switchingTrack\n    } = this;\n    if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {\n      hls.trigger(Events.BUFFER_EOS, {\n        type: 'audio'\n      });\n      this.state = State.ENDED;\n      return;\n    }\n    const mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);\n    const bufferLen = bufferInfo.len;\n    const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n    if (bufferLen >= maxBufLen && !switchingTrack) {\n      return;\n    }\n    const fragments = trackDetails.fragments;\n    const start = fragments[0].start;\n    let targetBufferTime = bufferInfo.end;\n    if (switchingTrack && media) {\n      const pos = this.getLoadPosition();\n      if (bufferedTrack && switchingTrack.attrs !== bufferedTrack.attrs) {\n        targetBufferTime = pos;\n      }\n      // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n      if (trackDetails.PTSKnown && pos < start) {\n        // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n        if (bufferInfo.end > start || bufferInfo.nextStart) {\n          this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n          media.currentTime = start + 0.05;\n        }\n      }\n    }\n    let frag = this.getNextFragment(targetBufferTime, trackDetails);\n    let atGap = false;\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      atGap = !!frag.gap;\n      frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      this.bufferFlushed = true;\n      return;\n    }\n\n    // Buffer audio up to one target duration ahead of main buffer\n    const atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;\n    if (atBufferSyncLimit ||\n    // Or wait for main buffer after buffing some audio\n    !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {\n      // Check fragment-tracker for main fragments since GAP segments do not show up in bufferInfo\n      const mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);\n      if (mainFrag === null) {\n        return;\n      }\n      // Bridge gaps in main buffer\n      atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);\n      if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {\n        return;\n      }\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  getMaxBufferLength(mainBufferLength) {\n    const maxConfigBuffer = super.getMaxBufferLength();\n    if (!mainBufferLength) {\n      return maxConfigBuffer;\n    }\n    return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);\n  }\n  onMediaDetaching() {\n    this.videoBuffer = null;\n    super.onMediaDetaching();\n  }\n  onAudioTracksUpdated(event, {\n    audioTracks\n  }) {\n    this.resetTransmuxer();\n    this.levels = audioTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n  }\n  onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    const altAudio = !!data.url;\n    this.trackId = data.id;\n    const {\n      fragCurrent\n    } = this;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.removeUnbufferedFrags(fragCurrent.start);\n    }\n    this.resetLoadingState();\n    // destroy useless transmuxer when switching audio to main\n    if (!altAudio) {\n      this.resetTransmuxer();\n    } else {\n      // switching to audio track, start timer if not already started\n      this.setInterval(TICK_INTERVAL$1);\n    }\n\n    // should we switch tracks ?\n    if (altAudio) {\n      this.switchingTrack = data;\n      // main audio track are handled by stream-controller, just do something if switching to alt audio track\n      this.state = State.IDLE;\n    } else {\n      this.switchingTrack = null;\n      this.bufferedTrack = data;\n      this.state = State.STOPPED;\n    }\n    this.tick();\n  }\n  onManifestLoading() {\n    this.fragmentTracker.removeAllFragments();\n    this.startPosition = this.lastCurrentTime = 0;\n    this.bufferFlushed = false;\n    this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;\n    this.startFragRequested = false;\n    this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n    if (this.cachedTrackLoadedData !== null) {\n      this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);\n      this.cachedTrackLoadedData = null;\n    }\n  }\n  onAudioTrackLoaded(event, data) {\n    var _track$details;\n    if (this.mainDetails == null) {\n      this.cachedTrackLoadedData = data;\n      return;\n    }\n    const {\n      levels\n    } = this;\n    const {\n      details: newDetails,\n      id: trackId\n    } = data;\n    if (!levels) {\n      this.warn(`Audio tracks were reset while loading level ${trackId}`);\n      return;\n    }\n    this.log(`Track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);\n    const track = levels[trackId];\n    let sliding = 0;\n    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n      this.checkLiveUpdate(newDetails);\n      const mainDetails = this.mainDetails;\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n      if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n        // Make sure our audio rendition is aligned with the \"main\" rendition, using\n        // pdt as our reference times.\n        alignMediaPlaylistByPDT(newDetails, mainDetails);\n        sliding = newDetails.fragments[0].start;\n      } else {\n        sliding = this.alignPlaylists(newDetails, track.details);\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = trackId;\n\n    // compute start position if we are aligned with the main playlist\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(track.details, sliding);\n    }\n    // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n    if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n      this.state = State.IDLE;\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      part,\n      payload\n    } = data;\n    const {\n      config,\n      trackId,\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const track = levels[trackId];\n    if (!track) {\n      this.warn('Audio track is undefined on fragment load progress');\n      return;\n    }\n    const details = track.details;\n    if (!details) {\n      this.warn('Audio track details undefined on fragment load progress');\n      this.removeUnbufferedFrags(frag.start);\n      return;\n    }\n    const audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n    let transmuxer = this.transmuxer;\n    if (!transmuxer) {\n      transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    }\n\n    // Check if we have video initPTS\n    // If not we need to wait for it\n    const initPTS = this.initPTS[frag.cc];\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    if (initPTS !== undefined) {\n      // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      const accurateTimeOffset = false; // details.PTSKnown || !details.live;\n      const partIndex = part ? part.index : -1;\n      const partial = partIndex !== -1;\n      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    } else {\n      this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      const {\n        cache\n      } = this.waitingData = this.waitingData || {\n        frag,\n        part,\n        cache: new ChunkCache(),\n        complete: false\n      };\n      cache.push(new Uint8Array(payload));\n      this.waitingVideoCC = this.videoTrackCC;\n      this.state = State.WAITING_INIT_PTS;\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    if (this.waitingData) {\n      this.waitingData.complete = true;\n      return;\n    }\n    super._handleFragmentLoadComplete(fragLoadedData);\n  }\n  onBufferReset( /* event: Events.BUFFER_RESET */\n  ) {\n    // reset reference to sourcebuffers\n    this.mediaBuffer = this.videoBuffer = null;\n    this.loadedmetadata = false;\n  }\n  onBufferCreated(event, data) {\n    const audioTrack = data.tracks.audio;\n    if (audioTrack) {\n      this.mediaBuffer = audioTrack.buffer || null;\n    }\n    if (data.tracks.video) {\n      this.videoBuffer = data.tracks.video.buffer || null;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    if (frag.type !== PlaylistLevelType.AUDIO) {\n      if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {\n        const bufferable = this.videoBuffer || this.media;\n        if (bufferable) {\n          const bufferedTimeRanges = BufferHelper.getBuffered(bufferable);\n          if (bufferedTimeRanges.length) {\n            this.loadedmetadata = true;\n          }\n        }\n      }\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n      this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : 'false'}`);\n      return;\n    }\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n      const track = this.switchingTrack;\n      if (track) {\n        this.bufferedTrack = track;\n        this.switchingTrack = null;\n        this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));\n      }\n    }\n    this.fragBufferedComplete(frag, part);\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);\n        break;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (!data.parent || data.parent !== 'audio') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.bufferedTrack = null;\n          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type === ElementaryStreamTypes.AUDIO) {\n      this.bufferFlushed = true;\n      if (this.state === State.ENDED) {\n        this.state = State.IDLE;\n      }\n    }\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = 'audio';\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      details\n    } = level;\n    const {\n      audio,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag) || !details) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (this.switchingTrack && audio) {\n      this.completeAudioSwitch(this.switchingTrack);\n    }\n    if (initSegment != null && initSegment.tracks) {\n      const mapFragment = frag.initSegment || frag;\n      this._bufferInitSegment(initSegment.tracks, mapFragment, chunkMeta);\n      hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n        frag: mapFragment,\n        id,\n        tracks: initSegment.tracks\n      });\n      // Only flush audio from old audio tracks when PTS is known on new audio track\n    }\n\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = _extends({\n        id,\n        frag,\n        details\n      }, id3);\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (text) {\n      const emittedText = _extends({\n        id,\n        frag,\n        details\n      }, text);\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  _bufferInitSegment(tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    // delete any video track found on audio transmuxer\n    if (tracks.video) {\n      delete tracks.video;\n    }\n\n    // include levelCodec in audio and video tracks\n    const track = tracks.audio;\n    if (!track) {\n      return;\n    }\n    track.levelCodec = track.codec;\n    track.id = 'audio';\n    this.log(`Init audio buffer, container:${track.container}, codecs[parsed]=[${track.codec}]`);\n    this.hls.trigger(Events.BUFFER_CODECS, tracks);\n    const initSegment = track.initSegment;\n    if (initSegment != null && initSegment.byteLength) {\n      const segment = {\n        type: 'audio',\n        frag,\n        part: null,\n        chunkMeta,\n        parent: frag.type,\n        data: initSegment\n      };\n      this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    }\n    // trigger handler right now\n    this.tick();\n  }\n  loadFragment(frag, track, targetBufferTime) {\n    // only load if fragment is not loaded or if in audio switch\n    const fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n\n    // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n    if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      var _track$details2;\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, track);\n      } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {\n        this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);\n        this.state = State.WAITING_INIT_PTS;\n      } else {\n        this.startFragRequested = true;\n        super.loadFragment(frag, track, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  completeAudioSwitch(switchingTrack) {\n    const {\n      hls,\n      media,\n      bufferedTrack\n    } = this;\n    const bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;\n    const switchAttributes = switchingTrack.attrs;\n    if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedAttributes.NAME !== switchAttributes.NAME || bufferedAttributes.LANGUAGE !== switchAttributes.LANGUAGE)) {\n      this.log('Switching audio track : flushing all audio');\n      super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n    }\n    this.bufferedTrack = switchingTrack;\n    this.switchingTrack = null;\n    hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));\n  }\n}\n\nclass AudioTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, '[audio-track-controller]');\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.currentTrack = null;\n    super.destroy();\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n  }\n  onManifestParsed(event, data) {\n    this.tracks = data.audioTracks || [];\n  }\n  onAudioTrackLoaded(event, data) {\n    const {\n      id,\n      groupId,\n      details\n    } = data;\n    const trackInActiveGroup = this.tracksInGroup[id];\n    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n      this.warn(`Track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup.groupId}`);\n      return;\n    }\n    const curDetails = trackInActiveGroup.details;\n    trackInActiveGroup.details = data.details;\n    this.log(`audio-track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!(levelInfo != null && levelInfo.audioGroupIds)) {\n      return;\n    }\n    const audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];\n    if (this.groupId !== audioGroupId) {\n      this.groupId = audioGroupId || null;\n      const audioTracks = this.tracks.filter(track => !audioGroupId || track.groupId === audioGroupId);\n\n      // Disable selectDefaultTrack if there are no default tracks\n      if (this.selectDefaultTrack && !audioTracks.some(track => track.default)) {\n        this.selectDefaultTrack = false;\n      }\n      this.tracksInGroup = audioTracks;\n      const audioTracksUpdated = {\n        audioTracks\n      };\n      this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group:${audioGroupId}`);\n      this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n      this.selectInitialTrack();\n    } else if (this.shouldReloadPlaylist(this.currentTrack)) {\n      // Retry playlist loading if no playlist is or has been loaded yet\n      this.setAudioTrack(this.trackId);\n    }\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.requestScheduled = -1;\n      this.checkRetry(data);\n    }\n  }\n  get audioTracks() {\n    return this.tracksInGroup;\n  }\n  get audioTrack() {\n    return this.trackId;\n  }\n  set audioTrack(newId) {\n    // If audio track is selected from API then don't choose from the manifest default track\n    this.selectDefaultTrack = false;\n    this.setAudioTrack(newId);\n  }\n  setAudioTrack(newId) {\n    const tracks = this.tracksInGroup;\n\n    // check if level idx is valid\n    if (newId < 0 || newId >= tracks.length) {\n      this.warn('Invalid id passed to audio-track controller');\n      return;\n    }\n\n    // stopping live reloading timer if any\n    this.clearTimer();\n    const lastTrack = this.currentTrack;\n    tracks[this.trackId];\n    const track = tracks[newId];\n    const {\n      groupId,\n      name\n    } = track;\n    this.log(`Switching to audio-track ${newId} \"${name}\" lang:${track.lang} group:${groupId}`);\n    this.trackId = newId;\n    this.currentTrack = track;\n    this.selectDefaultTrack = false;\n    this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));\n    // Do not reload track unless live\n    if (track.details && !track.details.live) {\n      return;\n    }\n    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);\n    this.loadPlaylist(hlsUrlParameters);\n  }\n  selectInitialTrack() {\n    const audioTracks = this.tracksInGroup;\n    const trackId = this.findTrackId(this.currentTrack) | this.findTrackId(null);\n    if (trackId !== -1) {\n      this.setAudioTrack(trackId);\n    } else {\n      const error = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ${audioTracks.length}`);\n      this.warn(error.message);\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n        fatal: true,\n        error\n      });\n    }\n  }\n  findTrackId(currentTrack) {\n    const audioTracks = this.tracksInGroup;\n    for (let i = 0; i < audioTracks.length; i++) {\n      const track = audioTracks[i];\n      if (!this.selectDefaultTrack || track.default) {\n        if (!currentTrack || currentTrack.attrs['STABLE-RENDITION-ID'] !== undefined && currentTrack.attrs['STABLE-RENDITION-ID'] === track.attrs['STABLE-RENDITION-ID']) {\n          return track.id;\n        }\n        if (currentTrack.name === track.name && currentTrack.lang === track.lang) {\n          return track.id;\n        }\n      }\n    }\n    return -1;\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const audioTrack = this.tracksInGroup[this.trackId];\n    if (this.shouldLoadPlaylist(audioTrack)) {\n      const id = audioTrack.id;\n      const groupId = audioTrack.groupId;\n      let url = audioTrack.url;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      // track not retrieved yet, or live playlist we need to (re)load it\n      this.log(`loading audio-track playlist ${id} \"${audioTrack.name}\" lang:${audioTrack.lang} group:${groupId}`);\n      this.clearTimer();\n      this.hls.trigger(Events.AUDIO_TRACK_LOADING, {\n        url,\n        id,\n        groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n}\n\nfunction subtitleOptionsIdentical(trackList1, trackList2) {\n  if (trackList1.length !== trackList2.length) {\n    return false;\n  }\n  for (let i = 0; i < trackList1.length; i++) {\n    if (!subtitleAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction subtitleAttributesIdentical(attrs1, attrs2) {\n  // Media options with the same rendition ID must be bit identical\n  const stableRenditionId = attrs1['STABLE-RENDITION-ID'];\n  if (stableRenditionId) {\n    return stableRenditionId === attrs2['STABLE-RENDITION-ID'];\n  }\n  // When rendition ID is not present, compare attributes\n  return !['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED'].some(subtitleAttribute => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);\n}\n\nconst TICK_INTERVAL = 500; // how often to tick in ms\n\nclass SubtitleStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[subtitle-stream-controller]', PlaylistLevelType.SUBTITLE);\n    this.levels = [];\n    this.currentTrackId = -1;\n    this.tracksBuffered = [];\n    this.mainDetails = null;\n    this._registerListeners();\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    this.mainDetails = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  startLoad(startPosition) {\n    this.stopLoad();\n    this.state = State.IDLE;\n    this.setInterval(TICK_INTERVAL);\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  }\n  onManifestLoading() {\n    this.mainDetails = null;\n    this.fragmentTracker.removeAllFragments();\n  }\n  onMediaDetaching() {\n    this.tracksBuffered = [];\n    super.onMediaDetaching();\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n  }\n  onSubtitleFragProcessed(event, data) {\n    const {\n      frag,\n      success\n    } = data;\n    this.fragPrevious = frag;\n    this.state = State.IDLE;\n    if (!success) {\n      return;\n    }\n    const buffered = this.tracksBuffered[this.currentTrackId];\n    if (!buffered) {\n      return;\n    }\n\n    // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n    // so we can re-use the logic used to detect how much has been buffered\n    let timeRange;\n    const fragStart = frag.start;\n    for (let i = 0; i < buffered.length; i++) {\n      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n        timeRange = buffered[i];\n        break;\n      }\n    }\n    const fragEnd = frag.start + frag.duration;\n    if (timeRange) {\n      timeRange.end = fragEnd;\n    } else {\n      timeRange = {\n        start: fragStart,\n        end: fragEnd\n      };\n      buffered.push(timeRange);\n    }\n    this.fragmentTracker.fragBuffered(frag);\n  }\n  onBufferFlushing(event, data) {\n    const {\n      startOffset,\n      endOffset\n    } = data;\n    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n      const endOffsetSubtitles = endOffset - 1;\n      if (endOffsetSubtitles <= 0) {\n        return;\n      }\n      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n      this.tracksBuffered.forEach(buffered => {\n        for (let i = 0; i < buffered.length;) {\n          if (buffered[i].end <= endOffsetSubtitles) {\n            buffered.shift();\n            continue;\n          } else if (buffered[i].start < endOffsetSubtitles) {\n            buffered[i].start = endOffsetSubtitles;\n          } else {\n            break;\n          }\n          i++;\n        }\n      });\n      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);\n    }\n  }\n  onFragBuffered(event, data) {\n    if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {\n      var _this$media;\n      if ((_this$media = this.media) != null && _this$media.buffered.length) {\n        this.loadedmetadata = true;\n      }\n    }\n  }\n\n  // If something goes wrong, proceed to next frag, if we were processing one.\n  onError(event, data) {\n    const frag = data.frag;\n    if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {\n      if (this.fragCurrent) {\n        this.fragCurrent.abortRequests();\n      }\n      if (this.state !== State.STOPPED) {\n        this.state = State.IDLE;\n      }\n    }\n  }\n\n  // Got all new subtitle levels.\n  onSubtitleTracksUpdated(event, {\n    subtitleTracks\n  }) {\n    if (subtitleOptionsIdentical(this.levels, subtitleTracks)) {\n      this.levels = subtitleTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n      return;\n    }\n    this.tracksBuffered = [];\n    this.levels = subtitleTracks.map(mediaPlaylist => {\n      const level = new Level(mediaPlaylist);\n      this.tracksBuffered[level.id] = [];\n      return level;\n    });\n    this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);\n    this.fragPrevious = null;\n    this.mediaBuffer = null;\n  }\n  onSubtitleTrackSwitch(event, data) {\n    this.currentTrackId = data.id;\n    if (!this.levels.length || this.currentTrackId === -1) {\n      this.clearInterval();\n      return;\n    }\n\n    // Check if track has the necessary details to load fragments\n    const currentTrack = this.levels[this.currentTrackId];\n    if (currentTrack != null && currentTrack.details) {\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n    } else {\n      this.mediaBuffer = null;\n    }\n    if (currentTrack) {\n      this.setInterval(TICK_INTERVAL);\n    }\n  }\n\n  // Got a new set of subtitle fragments.\n  onSubtitleTrackLoaded(event, data) {\n    var _track$details;\n    const {\n      details: newDetails,\n      id: trackId\n    } = data;\n    const {\n      currentTrackId,\n      levels\n    } = this;\n    if (!levels.length) {\n      return;\n    }\n    const track = levels[currentTrackId];\n    if (trackId >= levels.length || trackId !== currentTrackId || !track) {\n      return;\n    }\n    this.mediaBuffer = this.mediaBufferTimeRanges;\n    let sliding = 0;\n    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n      const mainDetails = this.mainDetails;\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n      const mainSlidingStartFragment = mainDetails.fragments[0];\n      if (!track.details) {\n        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n          alignMediaPlaylistByPDT(newDetails, mainDetails);\n          sliding = newDetails.fragments[0].start;\n        } else if (mainSlidingStartFragment) {\n          // line up live playlist with main so that fragments in range are loaded\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      } else {\n        sliding = this.alignPlaylists(newDetails, track.details);\n        if (sliding === 0 && mainSlidingStartFragment) {\n          // realign with main when there is no overlap with last refresh\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = trackId;\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(track.details, sliding);\n    }\n\n    // trigger handler right now\n    this.tick();\n\n    // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n    if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {\n      const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);\n      if (!foundFrag) {\n        this.warn('Subtitle playlist not aligned with playback');\n        track.details = undefined;\n      }\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    const {\n      frag,\n      payload\n    } = fragLoadedData;\n    const decryptData = frag.decryptdata;\n    const hls = this.hls;\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n    // check to see if the payload needs to be decrypted\n    if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n      const startTime = performance.now();\n      // decrypt the subtitles\n      this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(err => {\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_DECRYPT_ERROR,\n          fatal: false,\n          error: err,\n          reason: err.message,\n          frag\n        });\n        throw err;\n      }).then(decryptedData => {\n        const endTime = performance.now();\n        hls.trigger(Events.FRAG_DECRYPTED, {\n          frag,\n          payload: decryptedData,\n          stats: {\n            tstart: startTime,\n            tdecrypt: endTime\n          }\n        });\n      }).catch(err => {\n        this.warn(`${err.name}: ${err.message}`);\n        this.state = State.IDLE;\n      });\n    }\n  }\n  doTick() {\n    if (!this.media) {\n      this.state = State.IDLE;\n      return;\n    }\n    if (this.state === State.IDLE) {\n      const {\n        currentTrackId,\n        levels\n      } = this;\n      const track = levels[currentTrackId];\n      if (!levels.length || !track || !track.details) {\n        return;\n      }\n      const {\n        config\n      } = this;\n      const currentTime = this.getLoadPosition();\n      const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);\n      const {\n        end: targetBufferTime,\n        len: bufferLen\n      } = bufferedInfo;\n      const mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);\n      const trackDetails = track.details;\n      const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;\n      if (bufferLen > maxBufLen) {\n        return;\n      }\n      const fragments = trackDetails.fragments;\n      const fragLen = fragments.length;\n      const end = trackDetails.edge;\n      let foundFrag = null;\n      const fragPrevious = this.fragPrevious;\n      if (targetBufferTime < end) {\n        const tolerance = config.maxFragLookUpTolerance;\n        const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;\n        foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);\n        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n          foundFrag = fragments[0];\n        }\n      } else {\n        foundFrag = fragments[fragLen - 1];\n      }\n      if (!foundFrag) {\n        return;\n      }\n      foundFrag = this.mapToInitFragWhenRequired(foundFrag);\n      if (foundFrag.sn !== 'initSegment') {\n        // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment\n        const curSNIdx = foundFrag.sn - trackDetails.startSN;\n        const prevFrag = fragments[curSNIdx - 1];\n        if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {\n          foundFrag = prevFrag;\n        }\n      }\n      if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {\n        // only load if fragment is not loaded\n        this.loadFragment(foundFrag, track, targetBufferTime);\n      }\n    }\n  }\n  getMaxBufferLength(mainBufferLength) {\n    const maxConfigBuffer = super.getMaxBufferLength();\n    if (!mainBufferLength) {\n      return maxConfigBuffer;\n    }\n    return Math.max(maxConfigBuffer, mainBufferLength);\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    this.fragCurrent = frag;\n    if (frag.sn === 'initSegment') {\n      this._loadInitSegment(frag, level);\n    } else {\n      this.startFragRequested = true;\n      super.loadFragment(frag, level, targetBufferTime);\n    }\n  }\n  get mediaBufferTimeRanges() {\n    return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n  }\n}\nclass BufferableInstance {\n  constructor(timeranges) {\n    this.buffered = void 0;\n    const getRange = (name, index, length) => {\n      index = index >>> 0;\n      if (index > length - 1) {\n        throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);\n      }\n      return timeranges[index][name];\n    };\n    this.buffered = {\n      get length() {\n        return timeranges.length;\n      },\n      end(index) {\n        return getRange('end', index, timeranges.length);\n      },\n      start(index) {\n        return getRange('start', index, timeranges.length);\n      }\n    };\n  }\n}\n\nclass SubtitleTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, '[subtitle-track-controller]');\n    this.media = null;\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n    this.queuedDefaultTrack = -1;\n    this.trackChangeListener = () => this.onTextTracksChanged();\n    this.asyncPollTrackChange = () => this.pollTrackChange(0);\n    this.useTextTrackPolling = false;\n    this.subtitlePollingInterval = -1;\n    this._subtitleDisplay = true;\n    this.registerListeners();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.trackChangeListener = this.asyncPollTrackChange = null;\n    super.destroy();\n  }\n  get subtitleDisplay() {\n    return this._subtitleDisplay;\n  }\n  set subtitleDisplay(value) {\n    this._subtitleDisplay = value;\n    if (this.trackId > -1) {\n      this.toggleTrackModes(this.trackId);\n    }\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n\n  // Listen for subtitle track change, then extract the current track ID.\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    if (!this.media) {\n      return;\n    }\n    if (this.queuedDefaultTrack > -1) {\n      this.subtitleTrack = this.queuedDefaultTrack;\n      this.queuedDefaultTrack = -1;\n    }\n    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n    if (this.useTextTrackPolling) {\n      this.pollTrackChange(500);\n    } else {\n      this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n    }\n  }\n  pollTrackChange(timeout) {\n    self.clearInterval(this.subtitlePollingInterval);\n    this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, timeout);\n  }\n  onMediaDetaching() {\n    if (!this.media) {\n      return;\n    }\n    self.clearInterval(this.subtitlePollingInterval);\n    if (!this.useTextTrackPolling) {\n      this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n    }\n    if (this.trackId > -1) {\n      this.queuedDefaultTrack = this.trackId;\n    }\n    const textTracks = filterSubtitleTracks(this.media.textTracks);\n    // Clear loaded cues on media detachment from tracks\n    textTracks.forEach(track => {\n      clearCurrentCues(track);\n    });\n    // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n    this.subtitleTrack = -1;\n    this.media = null;\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n  }\n\n  // Fired whenever a new manifest is loaded.\n  onManifestParsed(event, data) {\n    this.tracks = data.subtitleTracks;\n  }\n  onSubtitleTrackLoaded(event, data) {\n    const {\n      id,\n      details\n    } = data;\n    const {\n      trackId\n    } = this;\n    const currentTrack = this.tracksInGroup[trackId];\n    if (!currentTrack) {\n      this.warn(`Invalid subtitle track id ${id}`);\n      return;\n    }\n    const curDetails = currentTrack.details;\n    currentTrack.details = data.details;\n    this.log(`subtitle track ${id} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!(levelInfo != null && levelInfo.textGroupIds)) {\n      return;\n    }\n    const textGroupId = levelInfo.textGroupIds[levelInfo.urlId];\n    const lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n    if (this.groupId !== textGroupId) {\n      const subtitleTracks = this.tracks.filter(track => !textGroupId || track.groupId === textGroupId);\n      this.tracksInGroup = subtitleTracks;\n      const initialTrackId = this.findTrackId(lastTrack == null ? void 0 : lastTrack.name) || this.findTrackId();\n      this.groupId = textGroupId || null;\n      const subtitleTracksUpdated = {\n        subtitleTracks\n      };\n      this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in \"${textGroupId}\" group-id`);\n      this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n      if (initialTrackId !== -1) {\n        this.setSubtitleTrack(initialTrackId, lastTrack);\n      }\n    } else if (this.shouldReloadPlaylist(lastTrack)) {\n      // Retry playlist loading if no playlist is or has been loaded yet\n      this.setSubtitleTrack(this.trackId, lastTrack);\n    }\n  }\n  findTrackId(name) {\n    const textTracks = this.tracksInGroup;\n    for (let i = 0; i < textTracks.length; i++) {\n      const track = textTracks[i];\n      if (!this.selectDefaultTrack || track.default) {\n        if (!name || name === track.name) {\n          return track.id;\n        }\n      }\n    }\n    return -1;\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.checkRetry(data);\n    }\n  }\n\n  /** get alternate subtitle tracks list from playlist **/\n  get subtitleTracks() {\n    return this.tracksInGroup;\n  }\n\n  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n  get subtitleTrack() {\n    return this.trackId;\n  }\n  set subtitleTrack(newId) {\n    this.selectDefaultTrack = false;\n    const lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n    this.setSubtitleTrack(newId, lastTrack);\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const currentTrack = this.tracksInGroup[this.trackId];\n    if (this.shouldLoadPlaylist(currentTrack)) {\n      const id = currentTrack.id;\n      const groupId = currentTrack.groupId;\n      let url = currentTrack.url;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      this.log(`Loading subtitle playlist for id ${id}`);\n      this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {\n        url,\n        id,\n        groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n\n  /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */\n  toggleTrackModes(newId) {\n    const {\n      media,\n      trackId\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = filterSubtitleTracks(media.textTracks);\n    const groupTracks = textTracks.filter(track => track.groupId === this.groupId);\n    if (newId === -1) {\n      [].slice.call(textTracks).forEach(track => {\n        track.mode = 'disabled';\n      });\n    } else {\n      const oldTrack = groupTracks[trackId];\n      if (oldTrack) {\n        oldTrack.mode = 'disabled';\n      }\n    }\n    const nextTrack = groupTracks[newId];\n    if (nextTrack) {\n      nextTrack.mode = this.subtitleDisplay ? 'showing' : 'hidden';\n    }\n  }\n\n  /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */\n  setSubtitleTrack(newId, lastTrack) {\n    var _tracks$newId;\n    const tracks = this.tracksInGroup;\n\n    // setting this.subtitleTrack will trigger internal logic\n    // if media has not been attached yet, it will fail\n    // we keep a reference to the default track id\n    // and we'll set subtitleTrack when onMediaAttached is triggered\n    if (!this.media) {\n      this.queuedDefaultTrack = newId;\n      return;\n    }\n    if (this.trackId !== newId) {\n      this.toggleTrackModes(newId);\n    }\n\n    // exit if track id as already set or invalid\n    if (this.trackId === newId && (newId === -1 || (_tracks$newId = tracks[newId]) != null && _tracks$newId.details) || newId < -1 || newId >= tracks.length) {\n      return;\n    }\n\n    // stopping live reloading timer if any\n    this.clearTimer();\n    const track = tracks[newId];\n    this.log(`Switching to subtitle-track ${newId}` + (track ? ` \"${track.name}\" lang:${track.lang} group:${track.groupId}` : ''));\n    this.trackId = newId;\n    if (track) {\n      const {\n        id,\n        groupId = '',\n        name,\n        type,\n        url\n      } = track;\n      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id,\n        groupId,\n        name,\n        type,\n        url\n      });\n      const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);\n      this.loadPlaylist(hlsUrlParameters);\n    } else {\n      // switch to -1\n      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id: newId\n      });\n    }\n  }\n  onTextTracksChanged() {\n    if (!this.useTextTrackPolling) {\n      self.clearInterval(this.subtitlePollingInterval);\n    }\n    // Media is undefined when switching streams via loadSource()\n    if (!this.media || !this.hls.config.renderTextTracksNatively) {\n      return;\n    }\n    let trackId = -1;\n    const tracks = filterSubtitleTracks(this.media.textTracks);\n    for (let id = 0; id < tracks.length; id++) {\n      if (tracks[id].mode === 'hidden') {\n        // Do not break in case there is a following track with showing.\n        trackId = id;\n      } else if (tracks[id].mode === 'showing') {\n        trackId = id;\n        break;\n      }\n    }\n\n    // Setting current subtitleTrack will invoke code.\n    if (this.subtitleTrack !== trackId) {\n      this.subtitleTrack = trackId;\n    }\n  }\n}\nfunction filterSubtitleTracks(textTrackList) {\n  const tracks = [];\n  for (let i = 0; i < textTrackList.length; i++) {\n    const track = textTrackList[i];\n    // Edge adds a track without a label; we don't want to use it\n    if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {\n      tracks.push(textTrackList[i]);\n    }\n  }\n  return tracks;\n}\n\nclass BufferOperationQueue {\n  constructor(sourceBufferReference) {\n    this.buffers = void 0;\n    this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    };\n    this.buffers = sourceBufferReference;\n  }\n  append(operation, type) {\n    const queue = this.queues[type];\n    queue.push(operation);\n    if (queue.length === 1 && this.buffers[type]) {\n      this.executeNext(type);\n    }\n  }\n  insertAbort(operation, type) {\n    const queue = this.queues[type];\n    queue.unshift(operation);\n    this.executeNext(type);\n  }\n  appendBlocker(type) {\n    let execute;\n    const promise = new Promise(resolve => {\n      execute = resolve;\n    });\n    const operation = {\n      execute,\n      onStart: () => {},\n      onComplete: () => {},\n      onError: () => {}\n    };\n    this.append(operation, type);\n    return promise;\n  }\n  executeNext(type) {\n    const {\n      buffers,\n      queues\n    } = this;\n    const sb = buffers[type];\n    const queue = queues[type];\n    if (queue.length) {\n      const operation = queue[0];\n      try {\n        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n        // which do not end with this event must call _onSBUpdateEnd manually\n        operation.execute();\n      } catch (e) {\n        logger.warn('[buffer-operation-queue]: Unhandled exception executing the current operation');\n        operation.onError(e);\n\n        // Only shift the current operation off, otherwise the updateend handler will do this for us\n        if (!(sb != null && sb.updating)) {\n          queue.shift();\n          this.executeNext(type);\n        }\n      }\n    }\n  }\n  shiftAndExecuteNext(type) {\n    this.queues[type].shift();\n    this.executeNext(type);\n  }\n  current(type) {\n    return this.queues[type][0];\n  }\n}\n\nconst MediaSource = getMediaSource();\nconst VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\\.[^.,]+)+/;\nclass BufferController {\n  // The level details used to determine duration, target-duration and live\n\n  // cache the self generated object url to detect hijack of video tag\n\n  // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n\n  // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n\n  // The number of BUFFER_CODEC events received before any sourceBuffers are created\n\n  // The total number of BUFFER_CODEC events received\n\n  // A reference to the attached media element\n\n  // A reference to the active media source\n\n  // Last MP3 audio chunk appended\n\n  // counters\n\n  constructor(hls) {\n    this.details = null;\n    this._objectUrl = null;\n    this.operationQueue = void 0;\n    this.listeners = void 0;\n    this.hls = void 0;\n    this.bufferCodecEventsExpected = 0;\n    this._bufferCodecEventsTotal = 0;\n    this.media = null;\n    this.mediaSource = null;\n    this.lastMpegAudioChunk = null;\n    this.appendError = 0;\n    this.tracks = {};\n    this.pendingTracks = {};\n    this.sourceBuffer = void 0;\n    // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n    this._onMediaSourceOpen = () => {\n      const {\n        media,\n        mediaSource\n      } = this;\n      logger.log('[buffer-controller]: Media source opened');\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        this.updateMediaElementDuration();\n        this.hls.trigger(Events.MEDIA_ATTACHED, {\n          media\n        });\n      }\n      if (mediaSource) {\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      }\n      this.checkPendingTracks();\n    };\n    this._onMediaSourceClose = () => {\n      logger.log('[buffer-controller]: Media source closed');\n    };\n    this._onMediaSourceEnded = () => {\n      logger.log('[buffer-controller]: Media source ended');\n    };\n    this._onMediaEmptied = () => {\n      const {\n        media,\n        _objectUrl\n      } = this;\n      if (media && media.src !== _objectUrl) {\n        logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${media.src})`);\n      }\n    };\n    this.hls = hls;\n    this._initSourceBuffer();\n    this.registerListeners();\n  }\n  hasSourceTypes() {\n    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.details = null;\n    this.lastMpegAudioChunk = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n  }\n  _initSourceBuffer() {\n    this.sourceBuffer = {};\n    this.operationQueue = new BufferOperationQueue(this.sourceBuffer);\n    this.listeners = {\n      audio: [],\n      video: [],\n      audiovideo: []\n    };\n    this.lastMpegAudioChunk = null;\n  }\n  onManifestLoading() {\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;\n    this.details = null;\n  }\n  onManifestParsed(event, data) {\n    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n    // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n    // it will contain the expected nb of source buffers, no need to compute it\n    let codecEvents = 2;\n    if (data.audio && !data.video || !data.altAudio || !true) {\n      codecEvents = 1;\n    }\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n    logger.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);\n  }\n  onMediaAttaching(event, data) {\n    const media = this.media = data.media;\n    if (media && MediaSource) {\n      const ms = this.mediaSource = new MediaSource();\n      // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n      ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n      ms.addEventListener('sourceended', this._onMediaSourceEnded);\n      ms.addEventListener('sourceclose', this._onMediaSourceClose);\n      // link video and media Source\n      media.src = self.URL.createObjectURL(ms);\n      // cache the locally generated object url\n      this._objectUrl = media.src;\n      media.addEventListener('emptied', this._onMediaEmptied);\n    }\n  }\n  onMediaDetaching() {\n    const {\n      media,\n      mediaSource,\n      _objectUrl\n    } = this;\n    if (mediaSource) {\n      logger.log('[buffer-controller]: media source detaching');\n      if (mediaSource.readyState === 'open') {\n        try {\n          // endOfStream could trigger exception if any sourcebuffer is in updating state\n          // we don't really care about checking sourcebuffer state here,\n          // as we are anyway detaching the MediaSource\n          // let's just avoid this exception to propagate\n          mediaSource.endOfStream();\n        } catch (err) {\n          logger.warn(`[buffer-controller]: onMediaDetaching: ${err.message} while calling endOfStream`);\n        }\n      }\n      // Clean up the SourceBuffers by invoking onBufferReset\n      this.onBufferReset();\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n\n      // Detach properly the MediaSource from the HTMLMediaElement as\n      // suggested in https://github.com/w3c/media-source/issues/53.\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        if (_objectUrl) {\n          self.URL.revokeObjectURL(_objectUrl);\n        }\n\n        // clean up video tag src only if it's our own url. some external libraries might\n        // hijack the video tag and change its 'src' without destroying the Hls instance first\n        if (media.src === _objectUrl) {\n          media.removeAttribute('src');\n          media.load();\n        } else {\n          logger.warn('[buffer-controller]: media.src was changed by a third party - skip cleanup');\n        }\n      }\n      this.mediaSource = null;\n      this.media = null;\n      this._objectUrl = null;\n      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n      this.pendingTracks = {};\n      this.tracks = {};\n    }\n    this.hls.trigger(Events.MEDIA_DETACHED, undefined);\n  }\n  onBufferReset() {\n    this.getSourceBufferTypes().forEach(type => {\n      const sb = this.sourceBuffer[type];\n      try {\n        if (sb) {\n          this.removeBufferListeners(type);\n          if (this.mediaSource) {\n            this.mediaSource.removeSourceBuffer(sb);\n          }\n          // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n          // accessing it\n          this.sourceBuffer[type] = undefined;\n        }\n      } catch (err) {\n        logger.warn(`[buffer-controller]: Failed to reset the ${type} buffer`, err);\n      }\n    });\n    this._initSourceBuffer();\n  }\n  onBufferCodecs(event, data) {\n    const sourceBufferCount = this.getSourceBufferTypes().length;\n    Object.keys(data).forEach(trackName => {\n      if (sourceBufferCount) {\n        // check if SourceBuffer codec needs to change\n        const track = this.tracks[trackName];\n        if (track && typeof track.buffer.changeType === 'function') {\n          const {\n            id,\n            codec,\n            levelCodec,\n            container,\n            metadata\n          } = data[trackName];\n          const currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n          const nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n          if (currentCodec !== nextCodec) {\n            const mimeType = `${container};codecs=${levelCodec || codec}`;\n            this.appendChangeType(trackName, mimeType);\n            logger.log(`[buffer-controller]: switching codec ${currentCodec} to ${nextCodec}`);\n            this.tracks[trackName] = {\n              buffer: track.buffer,\n              codec,\n              container,\n              levelCodec,\n              metadata,\n              id\n            };\n          }\n        }\n      } else {\n        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n        this.pendingTracks[trackName] = data[trackName];\n      }\n    });\n\n    // if sourcebuffers already created, do nothing ...\n    if (sourceBufferCount) {\n      return;\n    }\n    this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n    if (this.mediaSource && this.mediaSource.readyState === 'open') {\n      this.checkPendingTracks();\n    }\n  }\n  appendChangeType(type, mimeType) {\n    const {\n      operationQueue\n    } = this;\n    const operation = {\n      execute: () => {\n        const sb = this.sourceBuffer[type];\n        if (sb) {\n          logger.log(`[buffer-controller]: changing ${type} sourceBuffer type to ${mimeType}`);\n          sb.changeType(mimeType);\n        }\n        operationQueue.shiftAndExecuteNext(type);\n      },\n      onStart: () => {},\n      onComplete: () => {},\n      onError: e => {\n        logger.warn(`[buffer-controller]: Failed to change ${type} SourceBuffer type`, e);\n      }\n    };\n    operationQueue.append(operation, type);\n  }\n  onBufferAppending(event, eventData) {\n    const {\n      hls,\n      operationQueue,\n      tracks\n    } = this;\n    const {\n      data,\n      type,\n      frag,\n      part,\n      chunkMeta\n    } = eventData;\n    const chunkStats = chunkMeta.buffering[type];\n    const bufferAppendingStart = self.performance.now();\n    chunkStats.start = bufferAppendingStart;\n    const fragBuffering = frag.stats.buffering;\n    const partBuffering = part ? part.stats.buffering : null;\n    if (fragBuffering.start === 0) {\n      fragBuffering.start = bufferAppendingStart;\n    }\n    if (partBuffering && partBuffering.start === 0) {\n      partBuffering.start = bufferAppendingStart;\n    }\n\n    // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n    const audioTrack = tracks.audio;\n    let checkTimestampOffset = false;\n    if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n      this.lastMpegAudioChunk = chunkMeta;\n    }\n    const fragStart = frag.start;\n    const operation = {\n      execute: () => {\n        chunkStats.executeStart = self.performance.now();\n        if (checkTimestampOffset) {\n          const sb = this.sourceBuffer[type];\n          if (sb) {\n            const delta = fragStart - sb.timestampOffset;\n            if (Math.abs(delta) >= 0.1) {\n              logger.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);\n              sb.timestampOffset = fragStart;\n            }\n          }\n        }\n        this.appendExecutor(data, type);\n      },\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n        const end = self.performance.now();\n        chunkStats.executeEnd = chunkStats.end = end;\n        if (fragBuffering.first === 0) {\n          fragBuffering.first = end;\n        }\n        if (partBuffering && partBuffering.first === 0) {\n          partBuffering.first = end;\n        }\n        const {\n          sourceBuffer\n        } = this;\n        const timeRanges = {};\n        for (const type in sourceBuffer) {\n          timeRanges[type] = BufferHelper.getBuffered(sourceBuffer[type]);\n        }\n        this.appendError = 0;\n        this.hls.trigger(Events.BUFFER_APPENDED, {\n          type,\n          frag,\n          part,\n          chunkMeta,\n          parent: frag.type,\n          timeRanges\n        });\n      },\n      onError: err => {\n        // in case any error occured while appending, put back segment in segments table\n        logger.error(`[buffer-controller]: Error encountered while trying to append to the ${type} SourceBuffer`, err);\n        const event = {\n          type: ErrorTypes.MEDIA_ERROR,\n          parent: frag.type,\n          details: ErrorDetails.BUFFER_APPEND_ERROR,\n          frag,\n          part,\n          chunkMeta,\n          error: err,\n          err,\n          fatal: false\n        };\n        if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {\n          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n          // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n          event.details = ErrorDetails.BUFFER_FULL_ERROR;\n        } else {\n          this.appendError++;\n          event.details = ErrorDetails.BUFFER_APPEND_ERROR;\n          /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */\n          if (this.appendError > hls.config.appendErrorMaxRetry) {\n            logger.error(`[buffer-controller]: Failed ${hls.config.appendErrorMaxRetry} times to append segment in sourceBuffer`);\n            event.fatal = true;\n          }\n        }\n        hls.trigger(Events.ERROR, event);\n      }\n    };\n    operationQueue.append(operation, type);\n  }\n  onBufferFlushing(event, data) {\n    const {\n      operationQueue\n    } = this;\n    const flushOperation = type => ({\n      execute: this.removeExecutor.bind(this, type, data.startOffset, data.endOffset),\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        this.hls.trigger(Events.BUFFER_FLUSHED, {\n          type\n        });\n      },\n      onError: e => {\n        logger.warn(`[buffer-controller]: Failed to remove from ${type} SourceBuffer`, e);\n      }\n    });\n    if (data.type) {\n      operationQueue.append(flushOperation(data.type), data.type);\n    } else {\n      this.getSourceBufferTypes().forEach(type => {\n        operationQueue.append(flushOperation(type), type);\n      });\n    }\n  }\n  onFragParsed(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const buffersAppendedTo = [];\n    const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n    if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n      buffersAppendedTo.push('audiovideo');\n    } else {\n      if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n        buffersAppendedTo.push('audio');\n      }\n      if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n        buffersAppendedTo.push('video');\n      }\n    }\n    const onUnblocked = () => {\n      const now = self.performance.now();\n      frag.stats.buffering.end = now;\n      if (part) {\n        part.stats.buffering.end = now;\n      }\n      const stats = part ? part.stats : frag.stats;\n      this.hls.trigger(Events.FRAG_BUFFERED, {\n        frag,\n        part,\n        stats,\n        id: frag.type\n      });\n    };\n    if (buffersAppendedTo.length === 0) {\n      logger.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);\n    }\n    this.blockBuffers(onUnblocked, buffersAppendedTo);\n  }\n  onFragChanged(event, data) {\n    this.flushBackBuffer();\n  }\n\n  // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n  // an undefined data.type will mark all buffers as EOS.\n  onBufferEos(event, data) {\n    const ended = this.getSourceBufferTypes().reduce((acc, type) => {\n      const sb = this.sourceBuffer[type];\n      if (sb && (!data.type || data.type === type)) {\n        sb.ending = true;\n        if (!sb.ended) {\n          sb.ended = true;\n          logger.log(`[buffer-controller]: ${type} sourceBuffer now EOS`);\n        }\n      }\n      return acc && !!(!sb || sb.ended);\n    }, true);\n    if (ended) {\n      logger.log(`[buffer-controller]: Queueing mediaSource.endOfStream()`);\n      this.blockBuffers(() => {\n        this.getSourceBufferTypes().forEach(type => {\n          const sb = this.sourceBuffer[type];\n          if (sb) {\n            sb.ending = false;\n          }\n        });\n        const {\n          mediaSource\n        } = this;\n        if (!mediaSource || mediaSource.readyState !== 'open') {\n          if (mediaSource) {\n            logger.info(`[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);\n          }\n          return;\n        }\n        logger.log(`[buffer-controller]: Calling mediaSource.endOfStream()`);\n        // Allow this to throw and be caught by the enqueueing function\n        mediaSource.endOfStream();\n      });\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!details.fragments.length) {\n      return;\n    }\n    this.details = details;\n    if (this.getSourceBufferTypes().length) {\n      this.blockBuffers(this.updateMediaElementDuration.bind(this));\n    } else {\n      this.updateMediaElementDuration();\n    }\n  }\n  flushBackBuffer() {\n    const {\n      hls,\n      details,\n      media,\n      sourceBuffer\n    } = this;\n    if (!media || details === null) {\n      return;\n    }\n    const sourceBufferTypes = this.getSourceBufferTypes();\n    if (!sourceBufferTypes.length) {\n      return;\n    }\n\n    // Support for deprecated liveBackBufferLength\n    const backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;\n    if (!isFiniteNumber(backBufferLength) || backBufferLength < 0) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    const targetDuration = details.levelTargetDuration;\n    const maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n    const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n    sourceBufferTypes.forEach(type => {\n      const sb = sourceBuffer[type];\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        // when target buffer start exceeds actual buffer start\n        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n          hls.trigger(Events.BACK_BUFFER_REACHED, {\n            bufferEnd: targetBackBufferPosition\n          });\n\n          // Support for deprecated event:\n          if (details.live) {\n            hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n          } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n            logger.info(`[buffer-controller]: Cannot flush ${type} back buffer while SourceBuffer is in ended state`);\n            return;\n          }\n          hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: targetBackBufferPosition,\n            type\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */\n  updateMediaElementDuration() {\n    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n      return;\n    }\n    const {\n      details,\n      hls,\n      media,\n      mediaSource\n    } = this;\n    const levelDuration = details.fragments[0].start + details.totalduration;\n    const mediaDuration = media.duration;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n    if (details.live && hls.config.liveDurationInfinity) {\n      // Override duration to Infinity\n      logger.log('[buffer-controller]: Media Source duration is set to Infinity');\n      mediaSource.duration = Infinity;\n      this.updateSeekableRange(details);\n    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {\n      // levelDuration was the last value we set.\n      // not using mediaSource.duration as the browser may tweak this value\n      // only update Media Source duration if its value increase, this is to avoid\n      // flushing already buffered portion when switching between quality level\n      logger.log(`[buffer-controller]: Updating Media Source duration to ${levelDuration.toFixed(3)}`);\n      mediaSource.duration = levelDuration;\n    }\n  }\n  updateSeekableRange(levelDetails) {\n    const mediaSource = this.mediaSource;\n    const fragments = levelDetails.fragments;\n    const len = fragments.length;\n    if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {\n      const start = Math.max(0, fragments[0].start);\n      const end = Math.max(start, start + levelDetails.totalduration);\n      mediaSource.setLiveSeekableRange(start, end);\n    }\n  }\n  checkPendingTracks() {\n    const {\n      bufferCodecEventsExpected,\n      operationQueue,\n      pendingTracks\n    } = this;\n\n    // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n    // data has been appended to existing ones.\n    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n    const pendingTracksCount = Object.keys(pendingTracks).length;\n    if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {\n      // ok, let's create them now !\n      this.createSourceBuffers(pendingTracks);\n      this.pendingTracks = {};\n      // append any pending segments now !\n      const buffers = this.getSourceBufferTypes();\n      if (buffers.length) {\n        this.hls.trigger(Events.BUFFER_CREATED, {\n          tracks: this.tracks\n        });\n        buffers.forEach(type => {\n          operationQueue.executeNext(type);\n        });\n      } else {\n        const error = new Error('could not create source buffer for media codec(s)');\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n          fatal: true,\n          error,\n          reason: error.message\n        });\n      }\n    }\n  }\n  createSourceBuffers(tracks) {\n    const {\n      sourceBuffer,\n      mediaSource\n    } = this;\n    if (!mediaSource) {\n      throw Error('createSourceBuffers called when mediaSource was null');\n    }\n    for (const trackName in tracks) {\n      if (!sourceBuffer[trackName]) {\n        const track = tracks[trackName];\n        if (!track) {\n          throw Error(`source buffer exists for track ${trackName}, however track does not`);\n        }\n        // use levelCodec as first priority\n        const codec = track.levelCodec || track.codec;\n        const mimeType = `${track.container};codecs=${codec}`;\n        logger.log(`[buffer-controller]: creating sourceBuffer(${mimeType})`);\n        try {\n          const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n          const sbName = trackName;\n          this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);\n          this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);\n          this.addBufferListener(sbName, 'error', this._onSBUpdateError);\n          this.tracks[trackName] = {\n            buffer: sb,\n            codec: codec,\n            container: track.container,\n            levelCodec: track.levelCodec,\n            metadata: track.metadata,\n            id: track.id\n          };\n        } catch (err) {\n          logger.error(`[buffer-controller]: error while trying to add sourceBuffer: ${err.message}`);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n            fatal: false,\n            error: err,\n            mimeType: mimeType\n          });\n        }\n      }\n    }\n  }\n  _onSBUpdateStart(type) {\n    const {\n      operationQueue\n    } = this;\n    const operation = operationQueue.current(type);\n    operation.onStart();\n  }\n  _onSBUpdateEnd(type) {\n    const {\n      operationQueue\n    } = this;\n    const operation = operationQueue.current(type);\n    operation.onComplete();\n    operationQueue.shiftAndExecuteNext(type);\n  }\n  _onSBUpdateError(type, event) {\n    const error = new Error(`${type} SourceBuffer error`);\n    logger.error(`[buffer-controller]: ${error}`, event);\n    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.BUFFER_APPENDING_ERROR,\n      error,\n      fatal: false\n    });\n    // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n    const operation = this.operationQueue.current(type);\n    if (operation) {\n      operation.onError(event);\n    }\n  }\n\n  // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n  removeExecutor(type, startOffset, endOffset) {\n    const {\n      media,\n      mediaSource,\n      operationQueue,\n      sourceBuffer\n    } = this;\n    const sb = sourceBuffer[type];\n    if (!media || !mediaSource || !sb) {\n      logger.warn(`[buffer-controller]: Attempting to remove from the ${type} SourceBuffer, but it does not exist`);\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n    const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n    const removeStart = Math.max(0, startOffset);\n    const removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n    if (removeEnd > removeStart && !sb.ending) {\n      sb.ended = false;\n      logger.log(`[buffer-controller]: Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);\n      sb.remove(removeStart, removeEnd);\n    } else {\n      // Cycle the queue\n      operationQueue.shiftAndExecuteNext(type);\n    }\n  }\n\n  // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n  appendExecutor(data, type) {\n    const {\n      operationQueue,\n      sourceBuffer\n    } = this;\n    const sb = sourceBuffer[type];\n    if (!sb) {\n      logger.warn(`[buffer-controller]: Attempting to append to the ${type} SourceBuffer, but it does not exist`);\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n    sb.ended = false;\n    sb.appendBuffer(data);\n  }\n\n  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {\n    if (!buffers.length) {\n      logger.log('[buffer-controller]: Blocking operation requested, but no SourceBuffers exist');\n      Promise.resolve().then(onUnblocked);\n      return;\n    }\n    const {\n      operationQueue\n    } = this;\n\n    // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n    const blockingOperations = buffers.map(type => operationQueue.appendBlocker(type));\n    Promise.all(blockingOperations).then(() => {\n      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n      onUnblocked();\n      buffers.forEach(type => {\n        const sb = this.sourceBuffer[type];\n        // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n        // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n        // While this is a workaround, it's probably useful to have around\n        if (!(sb != null && sb.updating)) {\n          operationQueue.shiftAndExecuteNext(type);\n        }\n      });\n    });\n  }\n  getSourceBufferTypes() {\n    return Object.keys(this.sourceBuffer);\n  }\n  addBufferListener(type, event, fn) {\n    const buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    const listener = fn.bind(this, type);\n    this.listeners[type].push({\n      event,\n      listener\n    });\n    buffer.addEventListener(event, listener);\n  }\n  removeBufferListeners(type) {\n    const buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    this.listeners[type].forEach(l => {\n      buffer.removeEventListener(l.event, l.listener);\n    });\n  }\n}\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nconst specialCea608CharsCodes = {\n  0x2a: 0xe1,\n  // lowercase a, acute accent\n  0x5c: 0xe9,\n  // lowercase e, acute accent\n  0x5e: 0xed,\n  // lowercase i, acute accent\n  0x5f: 0xf3,\n  // lowercase o, acute accent\n  0x60: 0xfa,\n  // lowercase u, acute accent\n  0x7b: 0xe7,\n  // lowercase c with cedilla\n  0x7c: 0xf7,\n  // division symbol\n  0x7d: 0xd1,\n  // uppercase N tilde\n  0x7e: 0xf1,\n  // lowercase n tilde\n  0x7f: 0x2588,\n  // Full block\n  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n  // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n  0x80: 0xae,\n  // Registered symbol (R)\n  0x81: 0xb0,\n  // degree sign\n  0x82: 0xbd,\n  // 1/2 symbol\n  0x83: 0xbf,\n  // Inverted (open) question mark\n  0x84: 0x2122,\n  // Trademark symbol (TM)\n  0x85: 0xa2,\n  // Cents symbol\n  0x86: 0xa3,\n  // Pounds sterling\n  0x87: 0x266a,\n  // Music 8'th note\n  0x88: 0xe0,\n  // lowercase a, grave accent\n  0x89: 0x20,\n  // transparent space (regular)\n  0x8a: 0xe8,\n  // lowercase e, grave accent\n  0x8b: 0xe2,\n  // lowercase a, circumflex accent\n  0x8c: 0xea,\n  // lowercase e, circumflex accent\n  0x8d: 0xee,\n  // lowercase i, circumflex accent\n  0x8e: 0xf4,\n  // lowercase o, circumflex accent\n  0x8f: 0xfb,\n  // lowercase u, circumflex accent\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n  0x90: 0xc1,\n  // capital letter A with acute\n  0x91: 0xc9,\n  // capital letter E with acute\n  0x92: 0xd3,\n  // capital letter O with acute\n  0x93: 0xda,\n  // capital letter U with acute\n  0x94: 0xdc,\n  // capital letter U with diaresis\n  0x95: 0xfc,\n  // lowercase letter U with diaeresis\n  0x96: 0x2018,\n  // opening single quote\n  0x97: 0xa1,\n  // inverted exclamation mark\n  0x98: 0x2a,\n  // asterisk\n  0x99: 0x2019,\n  // closing single quote\n  0x9a: 0x2501,\n  // box drawings heavy horizontal\n  0x9b: 0xa9,\n  // copyright sign\n  0x9c: 0x2120,\n  // Service mark\n  0x9d: 0x2022,\n  // (round) bullet\n  0x9e: 0x201c,\n  // Left double quotation mark\n  0x9f: 0x201d,\n  // Right double quotation mark\n  0xa0: 0xc0,\n  // uppercase A, grave accent\n  0xa1: 0xc2,\n  // uppercase A, circumflex\n  0xa2: 0xc7,\n  // uppercase C with cedilla\n  0xa3: 0xc8,\n  // uppercase E, grave accent\n  0xa4: 0xca,\n  // uppercase E, circumflex\n  0xa5: 0xcb,\n  // capital letter E with diaresis\n  0xa6: 0xeb,\n  // lowercase letter e with diaresis\n  0xa7: 0xce,\n  // uppercase I, circumflex\n  0xa8: 0xcf,\n  // uppercase I, with diaresis\n  0xa9: 0xef,\n  // lowercase i, with diaresis\n  0xaa: 0xd4,\n  // uppercase O, circumflex\n  0xab: 0xd9,\n  // uppercase U, grave accent\n  0xac: 0xf9,\n  // lowercase u, grave accent\n  0xad: 0xdb,\n  // uppercase U, circumflex\n  0xae: 0xab,\n  // left-pointing double angle quotation mark\n  0xaf: 0xbb,\n  // right-pointing double angle quotation mark\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n  0xb0: 0xc3,\n  // Uppercase A, tilde\n  0xb1: 0xe3,\n  // Lowercase a, tilde\n  0xb2: 0xcd,\n  // Uppercase I, acute accent\n  0xb3: 0xcc,\n  // Uppercase I, grave accent\n  0xb4: 0xec,\n  // Lowercase i, grave accent\n  0xb5: 0xd2,\n  // Uppercase O, grave accent\n  0xb6: 0xf2,\n  // Lowercase o, grave accent\n  0xb7: 0xd5,\n  // Uppercase O, tilde\n  0xb8: 0xf5,\n  // Lowercase o, tilde\n  0xb9: 0x7b,\n  // Open curly brace\n  0xba: 0x7d,\n  // Closing curly brace\n  0xbb: 0x5c,\n  // Backslash\n  0xbc: 0x5e,\n  // Caret\n  0xbd: 0x5f,\n  // Underscore\n  0xbe: 0x7c,\n  // Pipe (vertical line)\n  0xbf: 0x223c,\n  // Tilde operator\n  0xc0: 0xc4,\n  // Uppercase A, umlaut\n  0xc1: 0xe4,\n  // Lowercase A, umlaut\n  0xc2: 0xd6,\n  // Uppercase O, umlaut\n  0xc3: 0xf6,\n  // Lowercase o, umlaut\n  0xc4: 0xdf,\n  // Esszett (sharp S)\n  0xc5: 0xa5,\n  // Yen symbol\n  0xc6: 0xa4,\n  // Generic currency sign\n  0xc7: 0x2503,\n  // Box drawings heavy vertical\n  0xc8: 0xc5,\n  // Uppercase A, ring\n  0xc9: 0xe5,\n  // Lowercase A, ring\n  0xca: 0xd8,\n  // Uppercase O, stroke\n  0xcb: 0xf8,\n  // Lowercase o, strok\n  0xcc: 0x250f,\n  // Box drawings heavy down and right\n  0xcd: 0x2513,\n  // Box drawings heavy down and left\n  0xce: 0x2517,\n  // Box drawings heavy up and right\n  0xcf: 0x251b // Box drawings heavy up and left\n};\n\n/**\n * Utils\n */\nconst getCharForByte = function getCharForByte(byte) {\n  let charCode = byte;\n  if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n    charCode = specialCea608CharsCodes[byte];\n  }\n  return String.fromCharCode(charCode);\n};\nconst NR_ROWS = 15;\nconst NR_COLS = 100;\n// Tables to look up row from PAC data\nconst rowsLowCh1 = {\n  0x11: 1,\n  0x12: 3,\n  0x15: 5,\n  0x16: 7,\n  0x17: 9,\n  0x10: 11,\n  0x13: 12,\n  0x14: 14\n};\nconst rowsHighCh1 = {\n  0x11: 2,\n  0x12: 4,\n  0x15: 6,\n  0x16: 8,\n  0x17: 10,\n  0x13: 13,\n  0x14: 15\n};\nconst rowsLowCh2 = {\n  0x19: 1,\n  0x1a: 3,\n  0x1d: 5,\n  0x1e: 7,\n  0x1f: 9,\n  0x18: 11,\n  0x1b: 12,\n  0x1c: 14\n};\nconst rowsHighCh2 = {\n  0x19: 2,\n  0x1a: 4,\n  0x1d: 6,\n  0x1e: 8,\n  0x1f: 10,\n  0x1b: 13,\n  0x1c: 15\n};\nconst backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\nclass CaptionsLogger {\n  constructor() {\n    this.time = null;\n    this.verboseLevel = 0;\n  }\n  log(severity, msg) {\n    if (this.verboseLevel >= severity) {\n      const m = typeof msg === 'function' ? msg() : msg;\n      logger.log(`${this.time} [${severity}] ${m}`);\n    }\n  }\n}\nconst numArrayToHexArray = function numArrayToHexArray(numArray) {\n  const hexArray = [];\n  for (let j = 0; j < numArray.length; j++) {\n    hexArray.push(numArray[j].toString(16));\n  }\n  return hexArray;\n};\nclass PenState {\n  constructor(foreground, underline, italics, background, flash) {\n    this.foreground = void 0;\n    this.underline = void 0;\n    this.italics = void 0;\n    this.background = void 0;\n    this.flash = void 0;\n    this.foreground = foreground || 'white';\n    this.underline = underline || false;\n    this.italics = italics || false;\n    this.background = background || 'black';\n    this.flash = flash || false;\n  }\n  reset() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  }\n  setStyles(styles) {\n    const attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n    for (let i = 0; i < attribs.length; i++) {\n      const style = attribs[i];\n      if (styles.hasOwnProperty(style)) {\n        this[style] = styles[style];\n      }\n    }\n  }\n  isDefault() {\n    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n  }\n  equals(other) {\n    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n  }\n  copy(newPenState) {\n    this.foreground = newPenState.foreground;\n    this.underline = newPenState.underline;\n    this.italics = newPenState.italics;\n    this.background = newPenState.background;\n    this.flash = newPenState.flash;\n  }\n  toString() {\n    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n  }\n}\n\n/**\n * Unicode character with styling and background.\n * @constructor\n */\nclass StyledUnicodeChar {\n  constructor(uchar, foreground, underline, italics, background, flash) {\n    this.uchar = void 0;\n    this.penState = void 0;\n    this.uchar = uchar || ' '; // unicode character\n    this.penState = new PenState(foreground, underline, italics, background, flash);\n  }\n  reset() {\n    this.uchar = ' ';\n    this.penState.reset();\n  }\n  setChar(uchar, newPenState) {\n    this.uchar = uchar;\n    this.penState.copy(newPenState);\n  }\n  setPenState(newPenState) {\n    this.penState.copy(newPenState);\n  }\n  equals(other) {\n    return this.uchar === other.uchar && this.penState.equals(other.penState);\n  }\n  copy(newChar) {\n    this.uchar = newChar.uchar;\n    this.penState.copy(newChar.penState);\n  }\n  isEmpty() {\n    return this.uchar === ' ' && this.penState.isDefault();\n  }\n}\n\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\nclass Row {\n  constructor(logger) {\n    this.chars = void 0;\n    this.pos = void 0;\n    this.currPenState = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chars = [];\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n    this.logger = logger;\n    this.pos = 0;\n    this.currPenState = new PenState();\n  }\n  equals(other) {\n    let equal = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].equals(other.chars[i])) {\n        equal = false;\n        break;\n      }\n    }\n    return equal;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars[i].copy(other.chars[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n\n  /**\n   *  Set the cursor to a valid column.\n   */\n  setCursor(absPos) {\n    if (this.pos !== absPos) {\n      this.pos = absPos;\n    }\n    if (this.pos < 0) {\n      this.logger.log(3, 'Negative cursor position ' + this.pos);\n      this.pos = 0;\n    } else if (this.pos > NR_COLS) {\n      this.logger.log(3, 'Too large cursor position ' + this.pos);\n      this.pos = NR_COLS;\n    }\n  }\n\n  /**\n   * Move the cursor relative to current position.\n   */\n  moveCursor(relPos) {\n    const newPos = this.pos + relPos;\n    if (relPos > 1) {\n      for (let i = this.pos + 1; i < newPos + 1; i++) {\n        this.chars[i].setPenState(this.currPenState);\n      }\n    }\n    this.setCursor(newPos);\n  }\n\n  /**\n   * Backspace, move one step back and clear character.\n   */\n  backSpace() {\n    this.moveCursor(-1);\n    this.chars[this.pos].setChar(' ', this.currPenState);\n  }\n  insertChar(byte) {\n    if (byte >= 0x90) {\n      // Extended char\n      this.backSpace();\n    }\n    const char = getCharForByte(byte);\n    if (this.pos >= NR_COLS) {\n      this.logger.log(0, () => 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');\n      return;\n    }\n    this.chars[this.pos].setChar(char, this.currPenState);\n    this.moveCursor(1);\n  }\n  clearFromPos(startPos) {\n    let i;\n    for (i = startPos; i < NR_COLS; i++) {\n      this.chars[i].reset();\n    }\n  }\n  clear() {\n    this.clearFromPos(0);\n    this.pos = 0;\n    this.currPenState.reset();\n  }\n  clearToEndOfRow() {\n    this.clearFromPos(this.pos);\n  }\n  getTextString() {\n    const chars = [];\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      const char = this.chars[i].uchar;\n      if (char !== ' ') {\n        empty = false;\n      }\n      chars.push(char);\n    }\n    if (empty) {\n      return '';\n    } else {\n      return chars.join('');\n    }\n  }\n  setPenStyles(styles) {\n    this.currPenState.setStyles(styles);\n    const currChar = this.chars[this.pos];\n    currChar.setPenState(this.currPenState);\n  }\n}\n\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */\nclass CaptionScreen {\n  constructor(logger) {\n    this.rows = void 0;\n    this.currRow = void 0;\n    this.nrRollUpRows = void 0;\n    this.lastOutputScreen = void 0;\n    this.logger = void 0;\n    this.rows = [];\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row(logger));\n    } // Note that we use zero-based numbering (0-14)\n\n    this.logger = logger;\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.lastOutputScreen = null;\n    this.reset();\n  }\n  reset() {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].clear();\n    }\n    this.currRow = NR_ROWS - 1;\n  }\n  equals(other) {\n    let equal = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].equals(other.rows[i])) {\n        equal = false;\n        break;\n      }\n    }\n    return equal;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].copy(other.rows[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n  backSpace() {\n    const row = this.rows[this.currRow];\n    row.backSpace();\n  }\n  clearToEndOfRow() {\n    const row = this.rows[this.currRow];\n    row.clearToEndOfRow();\n  }\n\n  /**\n   * Insert a character (without styling) in the current row.\n   */\n  insertChar(char) {\n    const row = this.rows[this.currRow];\n    row.insertChar(char);\n  }\n  setPen(styles) {\n    const row = this.rows[this.currRow];\n    row.setPenStyles(styles);\n  }\n  moveCursor(relPos) {\n    const row = this.rows[this.currRow];\n    row.moveCursor(relPos);\n  }\n  setCursor(absPos) {\n    this.logger.log(2, 'setCursor: ' + absPos);\n    const row = this.rows[this.currRow];\n    row.setCursor(absPos);\n  }\n  setPAC(pacData) {\n    this.logger.log(2, () => 'pacData = ' + JSON.stringify(pacData));\n    let newRow = pacData.row - 1;\n    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n      newRow = this.nrRollUpRows - 1;\n    }\n\n    // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n    if (this.nrRollUpRows && this.currRow !== newRow) {\n      // clear all rows first\n      for (let i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n\n      // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n      // topRowIndex - the start of rows to copy (inclusive index)\n      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      // We only copy if the last position was already shown.\n      // We use the cueStartTime value to check this.\n      const lastOutputScreen = this.lastOutputScreen;\n      if (lastOutputScreen) {\n        const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n        const time = this.logger.time;\n        if (prevLineTime && time !== null && prevLineTime < time) {\n          for (let i = 0; i < this.nrRollUpRows; i++) {\n            this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);\n          }\n        }\n      }\n    }\n    this.currRow = newRow;\n    const row = this.rows[this.currRow];\n    if (pacData.indent !== null) {\n      const indent = pacData.indent;\n      const prevPos = Math.max(indent - 1, 0);\n      row.setCursor(pacData.indent);\n      pacData.color = row.chars[prevPos].penState.foreground;\n    }\n    const styles = {\n      foreground: pacData.color,\n      underline: pacData.underline,\n      italics: pacData.italics,\n      background: 'black',\n      flash: false\n    };\n    this.setPen(styles);\n  }\n\n  /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */\n  setBkgData(bkgData) {\n    this.logger.log(2, () => 'bkgData = ' + JSON.stringify(bkgData));\n    this.backSpace();\n    this.setPen(bkgData);\n    this.insertChar(0x20); // Space\n  }\n\n  setRollUpRows(nrRows) {\n    this.nrRollUpRows = nrRows;\n  }\n  rollUp() {\n    if (this.nrRollUpRows === null) {\n      this.logger.log(3, 'roll_up but nrRollUpRows not set yet');\n      return; // Not properly setup\n    }\n\n    this.logger.log(1, () => this.getDisplayText());\n    const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n    const topRow = this.rows.splice(topRowIndex, 1)[0];\n    topRow.clear();\n    this.rows.splice(this.currRow, 0, topRow);\n    this.logger.log(2, 'Rolling up');\n    // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n  }\n\n  /**\n   * Get all non-empty rows with as unicode text.\n   */\n  getDisplayText(asOneRow) {\n    asOneRow = asOneRow || false;\n    const displayText = [];\n    let text = '';\n    let rowNr = -1;\n    for (let i = 0; i < NR_ROWS; i++) {\n      const rowText = this.rows[i].getTextString();\n      if (rowText) {\n        rowNr = i + 1;\n        if (asOneRow) {\n          displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n        } else {\n          displayText.push(rowText.trim());\n        }\n      }\n    }\n    if (displayText.length > 0) {\n      if (asOneRow) {\n        text = '[' + displayText.join(' | ') + ']';\n      } else {\n        text = displayText.join('\\n');\n      }\n    }\n    return text;\n  }\n  getTextAndFormat() {\n    return this.rows;\n  }\n}\n\n// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n\nclass Cea608Channel {\n  constructor(channelNumber, outputFilter, logger) {\n    this.chNr = void 0;\n    this.outputFilter = void 0;\n    this.mode = void 0;\n    this.verbose = void 0;\n    this.displayedMemory = void 0;\n    this.nonDisplayedMemory = void 0;\n    this.lastOutputScreen = void 0;\n    this.currRollUpRow = void 0;\n    this.writeScreen = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen(logger);\n    this.nonDisplayedMemory = new CaptionScreen(logger);\n    this.lastOutputScreen = new CaptionScreen(logger);\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n    this.logger = logger;\n  }\n  reset() {\n    this.mode = null;\n    this.displayedMemory.reset();\n    this.nonDisplayedMemory.reset();\n    this.lastOutputScreen.reset();\n    this.outputFilter.reset();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null;\n  }\n  getHandler() {\n    return this.outputFilter;\n  }\n  setHandler(newHandler) {\n    this.outputFilter = newHandler;\n  }\n  setPAC(pacData) {\n    this.writeScreen.setPAC(pacData);\n  }\n  setBkgData(bkgData) {\n    this.writeScreen.setBkgData(bkgData);\n  }\n  setMode(newMode) {\n    if (newMode === this.mode) {\n      return;\n    }\n    this.mode = newMode;\n    this.logger.log(2, () => 'MODE=' + newMode);\n    if (this.mode === 'MODE_POP-ON') {\n      this.writeScreen = this.nonDisplayedMemory;\n    } else {\n      this.writeScreen = this.displayedMemory;\n      this.writeScreen.reset();\n    }\n    if (this.mode !== 'MODE_ROLL-UP') {\n      this.displayedMemory.nrRollUpRows = null;\n      this.nonDisplayedMemory.nrRollUpRows = null;\n    }\n    this.mode = newMode;\n  }\n  insertChars(chars) {\n    for (let i = 0; i < chars.length; i++) {\n      this.writeScreen.insertChar(chars[i]);\n    }\n    const screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n    this.logger.log(2, () => screen + ': ' + this.writeScreen.getDisplayText(true));\n    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n      this.logger.log(1, () => 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));\n      this.outputDataUpdate();\n    }\n  }\n  ccRCL() {\n    // Resume Caption Loading (switch mode to Pop On)\n    this.logger.log(2, 'RCL - Resume Caption Loading');\n    this.setMode('MODE_POP-ON');\n  }\n  ccBS() {\n    // BackSpace\n    this.logger.log(2, 'BS - BackSpace');\n    if (this.mode === 'MODE_TEXT') {\n      return;\n    }\n    this.writeScreen.backSpace();\n    if (this.writeScreen === this.displayedMemory) {\n      this.outputDataUpdate();\n    }\n  }\n  ccAOF() {\n    // Reserved (formerly Alarm Off)\n  }\n  ccAON() {\n    // Reserved (formerly Alarm On)\n  }\n  ccDER() {\n    // Delete to End of Row\n    this.logger.log(2, 'DER- Delete to End of Row');\n    this.writeScreen.clearToEndOfRow();\n    this.outputDataUpdate();\n  }\n  ccRU(nrRows) {\n    // Roll-Up Captions-2,3,or 4 Rows\n    this.logger.log(2, 'RU(' + nrRows + ') - Roll Up');\n    this.writeScreen = this.displayedMemory;\n    this.setMode('MODE_ROLL-UP');\n    this.writeScreen.setRollUpRows(nrRows);\n  }\n  ccFON() {\n    // Flash On\n    this.logger.log(2, 'FON - Flash On');\n    this.writeScreen.setPen({\n      flash: true\n    });\n  }\n  ccRDC() {\n    // Resume Direct Captioning (switch mode to PaintOn)\n    this.logger.log(2, 'RDC - Resume Direct Captioning');\n    this.setMode('MODE_PAINT-ON');\n  }\n  ccTR() {\n    // Text Restart in text mode (not supported, however)\n    this.logger.log(2, 'TR');\n    this.setMode('MODE_TEXT');\n  }\n  ccRTD() {\n    // Resume Text Display in Text mode (not supported, however)\n    this.logger.log(2, 'RTD');\n    this.setMode('MODE_TEXT');\n  }\n  ccEDM() {\n    // Erase Displayed Memory\n    this.logger.log(2, 'EDM - Erase Displayed Memory');\n    this.displayedMemory.reset();\n    this.outputDataUpdate(true);\n  }\n  ccCR() {\n    // Carriage Return\n    this.logger.log(2, 'CR - Carriage Return');\n    this.writeScreen.rollUp();\n    this.outputDataUpdate(true);\n  }\n  ccENM() {\n    // Erase Non-Displayed Memory\n    this.logger.log(2, 'ENM - Erase Non-displayed Memory');\n    this.nonDisplayedMemory.reset();\n  }\n  ccEOC() {\n    // End of Caption (Flip Memories)\n    this.logger.log(2, 'EOC - End Of Caption');\n    if (this.mode === 'MODE_POP-ON') {\n      const tmp = this.displayedMemory;\n      this.displayedMemory = this.nonDisplayedMemory;\n      this.nonDisplayedMemory = tmp;\n      this.writeScreen = this.nonDisplayedMemory;\n      this.logger.log(1, () => 'DISP: ' + this.displayedMemory.getDisplayText());\n    }\n    this.outputDataUpdate(true);\n  }\n  ccTO(nrCols) {\n    // Tab Offset 1,2, or 3 columns\n    this.logger.log(2, 'TO(' + nrCols + ') - Tab Offset');\n    this.writeScreen.moveCursor(nrCols);\n  }\n  ccMIDROW(secondByte) {\n    // Parse MIDROW command\n    const styles = {\n      flash: false\n    };\n    styles.underline = secondByte % 2 === 1;\n    styles.italics = secondByte >= 0x2e;\n    if (!styles.italics) {\n      const colorIndex = Math.floor(secondByte / 2) - 0x10;\n      const colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n      styles.foreground = colors[colorIndex];\n    } else {\n      styles.foreground = 'white';\n    }\n    this.logger.log(2, 'MIDROW: ' + JSON.stringify(styles));\n    this.writeScreen.setPen(styles);\n  }\n  outputDataUpdate(dispatch = false) {\n    const time = this.logger.time;\n    if (time === null) {\n      return;\n    }\n    if (this.outputFilter) {\n      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n        // Start of a new cue\n        this.cueStartTime = time;\n      } else {\n        if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n          if (dispatch && this.outputFilter.dispatchCue) {\n            this.outputFilter.dispatchCue();\n          }\n          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n        }\n      }\n      this.lastOutputScreen.copy(this.displayedMemory);\n    }\n  }\n  cueSplitAtTime(t) {\n    if (this.outputFilter) {\n      if (!this.displayedMemory.isEmpty()) {\n        if (this.outputFilter.newCue) {\n          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n        }\n        this.cueStartTime = t;\n      }\n    }\n  }\n}\n\n// Will be 1 or 2 when parsing captions\n\nclass Cea608Parser {\n  constructor(field, out1, out2) {\n    this.channels = void 0;\n    this.currentChannel = 0;\n    this.cmdHistory = void 0;\n    this.logger = void 0;\n    const logger = new CaptionsLogger();\n    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n    this.cmdHistory = createCmdHistory();\n    this.logger = logger;\n  }\n  getHandler(channel) {\n    return this.channels[channel].getHandler();\n  }\n  setHandler(channel, newHandler) {\n    this.channels[channel].setHandler(newHandler);\n  }\n\n  /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */\n  addData(time, byteList) {\n    let cmdFound;\n    let a;\n    let b;\n    let charsFound = false;\n    this.logger.time = time;\n    for (let i = 0; i < byteList.length; i += 2) {\n      a = byteList[i] & 0x7f;\n      b = byteList[i + 1] & 0x7f;\n      if (a === 0 && b === 0) {\n        continue;\n      } else {\n        this.logger.log(3, '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n      }\n      cmdFound = this.parseCmd(a, b);\n      if (!cmdFound) {\n        cmdFound = this.parseMidrow(a, b);\n      }\n      if (!cmdFound) {\n        cmdFound = this.parsePAC(a, b);\n      }\n      if (!cmdFound) {\n        cmdFound = this.parseBackgroundAttributes(a, b);\n      }\n      if (!cmdFound) {\n        charsFound = this.parseChars(a, b);\n        if (charsFound) {\n          const currChNr = this.currentChannel;\n          if (currChNr && currChNr > 0) {\n            const channel = this.channels[currChNr];\n            channel.insertChars(charsFound);\n          } else {\n            this.logger.log(2, 'No channel found yet. TEXT-MODE?');\n          }\n        }\n      }\n      if (!cmdFound && !charsFound) {\n        this.logger.log(2, \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n      }\n    }\n  }\n\n  /**\n   * Parse Command.\n   * @returns True if a command was found\n   */\n  parseCmd(a, b) {\n    const {\n      cmdHistory\n    } = this;\n    const cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n    const cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n    if (!(cond1 || cond2)) {\n      return false;\n    }\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      this.logger.log(3, 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n      return true;\n    }\n    const chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n      if (b === 0x20) {\n        channel.ccRCL();\n      } else if (b === 0x21) {\n        channel.ccBS();\n      } else if (b === 0x22) {\n        channel.ccAOF();\n      } else if (b === 0x23) {\n        channel.ccAON();\n      } else if (b === 0x24) {\n        channel.ccDER();\n      } else if (b === 0x25) {\n        channel.ccRU(2);\n      } else if (b === 0x26) {\n        channel.ccRU(3);\n      } else if (b === 0x27) {\n        channel.ccRU(4);\n      } else if (b === 0x28) {\n        channel.ccFON();\n      } else if (b === 0x29) {\n        channel.ccRDC();\n      } else if (b === 0x2a) {\n        channel.ccTR();\n      } else if (b === 0x2b) {\n        channel.ccRTD();\n      } else if (b === 0x2c) {\n        channel.ccEDM();\n      } else if (b === 0x2d) {\n        channel.ccCR();\n      } else if (b === 0x2e) {\n        channel.ccENM();\n      } else if (b === 0x2f) {\n        channel.ccEOC();\n      }\n    } else {\n      // a == 0x17 || a == 0x1F\n      channel.ccTO(b - 0x20);\n    }\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Parse midrow styling command\n   */\n  parseMidrow(a, b) {\n    let chNr = 0;\n    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n      if (a === 0x11) {\n        chNr = 1;\n      } else {\n        chNr = 2;\n      }\n      if (chNr !== this.currentChannel) {\n        this.logger.log(0, 'Mismatch channel in midrow parsing');\n        return false;\n      }\n      const channel = this.channels[chNr];\n      if (!channel) {\n        return false;\n      }\n      channel.ccMIDROW(b);\n      this.logger.log(3, 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */\n  parsePAC(a, b) {\n    let row;\n    const cmdHistory = this.cmdHistory;\n    const case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n    const case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      return true; // Repeated commands are dropped (once)\n    }\n\n    const chNr = a <= 0x17 ? 1 : 2;\n    if (b >= 0x40 && b <= 0x5f) {\n      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n    } else {\n      // 0x60 <= b <= 0x7F\n      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n    }\n    const channel = this.channels[chNr];\n    if (!channel) {\n      return false;\n    }\n    channel.setPAC(this.interpretPAC(row, b));\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns pacData with style parameters\n   */\n  interpretPAC(row, byte) {\n    let pacIndex;\n    const pacData = {\n      color: null,\n      italics: false,\n      indent: null,\n      underline: false,\n      row: row\n    };\n    if (byte > 0x5f) {\n      pacIndex = byte - 0x60;\n    } else {\n      pacIndex = byte - 0x40;\n    }\n    pacData.underline = (pacIndex & 1) === 1;\n    if (pacIndex <= 0xd) {\n      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n    } else if (pacIndex <= 0xf) {\n      pacData.italics = true;\n      pacData.color = 'white';\n    } else {\n      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n    }\n    return pacData; // Note that row has zero offset. The spec uses 1.\n  }\n\n  /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */\n  parseChars(a, b) {\n    let channelNr;\n    let charCodes = null;\n    let charCode1 = null;\n    if (a >= 0x19) {\n      channelNr = 2;\n      charCode1 = a - 8;\n    } else {\n      channelNr = 1;\n      charCode1 = a;\n    }\n    if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n      // Special character\n      let oneCode;\n      if (charCode1 === 0x11) {\n        oneCode = b + 0x50;\n      } else if (charCode1 === 0x12) {\n        oneCode = b + 0x70;\n      } else {\n        oneCode = b + 0x90;\n      }\n      this.logger.log(2, \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n      charCodes = [oneCode];\n    } else if (a >= 0x20 && a <= 0x7f) {\n      charCodes = b === 0 ? [a] : [a, b];\n    }\n    if (charCodes) {\n      const hexCodes = numArrayToHexArray(charCodes);\n      this.logger.log(3, 'Char codes =  ' + hexCodes.join(','));\n      setLastCmd(a, b, this.cmdHistory);\n    }\n    return charCodes;\n  }\n\n  /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns True if background attributes are found\n   */\n  parseBackgroundAttributes(a, b) {\n    const case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n    const case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    let index;\n    const bkgData = {};\n    if (a === 0x10 || a === 0x18) {\n      index = Math.floor((b - 0x20) / 2);\n      bkgData.background = backgroundColors[index];\n      if (b % 2 === 1) {\n        bkgData.background = bkgData.background + '_semi';\n      }\n    } else if (b === 0x2d) {\n      bkgData.background = 'transparent';\n    } else {\n      bkgData.foreground = 'black';\n      if (b === 0x2f) {\n        bkgData.underline = true;\n      }\n    }\n    const chNr = a <= 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    channel.setBkgData(bkgData);\n    setLastCmd(a, b, this.cmdHistory);\n    return true;\n  }\n\n  /**\n   * Reset state of parser and its channels.\n   */\n  reset() {\n    for (let i = 0; i < Object.keys(this.channels).length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.reset();\n      }\n    }\n    this.cmdHistory = createCmdHistory();\n  }\n\n  /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */\n  cueSplitAtTime(t) {\n    for (let i = 0; i < this.channels.length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.cueSplitAtTime(t);\n      }\n    }\n  }\n}\nfunction setLastCmd(a, b, cmdHistory) {\n  cmdHistory.a = a;\n  cmdHistory.b = b;\n}\nfunction hasCmdRepeated(a, b, cmdHistory) {\n  return cmdHistory.a === a && cmdHistory.b === b;\n}\nfunction createCmdHistory() {\n  return {\n    a: null,\n    b: null\n  };\n}\n\nclass OutputFilter {\n  constructor(timelineController, trackName) {\n    this.timelineController = void 0;\n    this.cueRanges = [];\n    this.trackName = void 0;\n    this.startTime = null;\n    this.endTime = null;\n    this.screen = null;\n    this.timelineController = timelineController;\n    this.trackName = trackName;\n  }\n  dispatchCue() {\n    if (this.startTime === null) {\n      return;\n    }\n    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n    this.startTime = null;\n  }\n  newCue(startTime, endTime, screen) {\n    if (this.startTime === null || this.startTime > startTime) {\n      this.startTime = startTime;\n    }\n    this.endTime = endTime;\n    this.screen = screen;\n    this.timelineController.createCaptionsTrack(this.trackName);\n  }\n  reset() {\n    this.cueRanges = [];\n    this.startTime = null;\n  }\n}\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar VTTCue = (function () {\n  if (typeof self !== 'undefined' && self.VTTCue) {\n    return self.VTTCue;\n  }\n  const AllowedDirections = ['', 'lr', 'rl'];\n  const AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n  function isAllowedValue(allowed, value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    // necessary for assuring the generic conforms to the Array interface\n    if (!Array.isArray(allowed)) {\n      return false;\n    }\n    // reset the type so that the next narrowing works well\n    const lcValue = value.toLowerCase();\n    // use the allow list to narrow the type to a specific subset of strings\n    if (~allowed.indexOf(lcValue)) {\n      return lcValue;\n    }\n    return false;\n  }\n  function findDirectionSetting(value) {\n    return isAllowedValue(AllowedDirections, value);\n  }\n  function findAlignSetting(value) {\n    return isAllowedValue(AllowedAlignments, value);\n  }\n  function extend(obj, ...rest) {\n    let i = 1;\n    for (; i < arguments.length; i++) {\n      const cobj = arguments[i];\n      for (const p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n    return obj;\n  }\n  function VTTCue(startTime, endTime, text) {\n    const cue = this;\n    const baseObj = {\n      enumerable: true\n    };\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    cue.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    let _id = '';\n    let _pauseOnExit = false;\n    let _startTime = startTime;\n    let _endTime = endTime;\n    let _text = text;\n    let _region = null;\n    let _vertical = '';\n    let _snapToLines = true;\n    let _line = 'auto';\n    let _lineAlign = 'start';\n    let _position = 50;\n    let _positionAlign = 'middle';\n    let _size = 50;\n    let _align = 'middle';\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function () {\n        return _id;\n      },\n      set: function (value) {\n        _id = '' + value;\n      }\n    }));\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function () {\n        return _pauseOnExit;\n      },\n      set: function (value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function () {\n        return _startTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function () {\n        return _endTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function () {\n        return _text;\n      },\n      set: function (value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    // todo: implement VTTRegion polyfill?\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function () {\n        return _region;\n      },\n      set: function (value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function () {\n        return _vertical;\n      },\n      set: function (value) {\n        const setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function () {\n        return _snapToLines;\n      },\n      set: function (value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function () {\n        return _line;\n      },\n      set: function (value) {\n        if (typeof value !== 'number' && value !== 'auto') {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function () {\n        return _lineAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function () {\n        return _position;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function () {\n        return _positionAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function () {\n        return _size;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function () {\n        return _align;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    cue.displayState = undefined;\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    const WebVTT = self.WebVTT;\n    return WebVTT.convertCueToDOMTree(self, this.text);\n  };\n  // this is a polyfill hack\n  return VTTCue;\n})();\n\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */\n\nclass StringDecoder {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  decode(data, options) {\n    if (!data) {\n      return '';\n    }\n    if (typeof data !== 'string') {\n      throw new Error('Error - expected string data.');\n    }\n    return decodeURIComponent(encodeURIComponent(data));\n  }\n}\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n  }\n  const m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n  if (!m) {\n    return null;\n  }\n  if (parseFloat(m[2]) > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[2], m[3], 0, m[4]);\n  }\n  // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n  return computeSeconds(m[1], m[2], m[3], m[4]);\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nclass Settings {\n  constructor() {\n    this.values = Object.create(null);\n  }\n  // Only accept the first assignment to any key.\n  set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  }\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  }\n  // Check whether we have a value for a key.\n  has(k) {\n    return k in this.values;\n  }\n  // Accept a setting if its one of the given alternatives.\n  alt(k, v, a) {\n    for (let n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  }\n  // Accept a setting if its a valid (signed) integer.\n  integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  }\n  // Accept a setting if its a valid percentage.\n  percent(k, v) {\n    if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n      const percent = parseFloat(v);\n      if (percent >= 0 && percent <= 100) {\n        this.set(k, percent);\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  const groups = groupDelim ? input.split(groupDelim) : [input];\n  for (const i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n    const kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    const k = kv[0];\n    const v = kv[1];\n    callback(k, v);\n  }\n}\nconst defaults = new VTTCue(0, 0, '');\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\nconst center = defaults.align === 'middle' ? 'middle' : 'center';\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  const oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    const ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    }\n\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    const settings = new Settings();\n    parseOptions(input, function (k, v) {\n      let vals;\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (let i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n        case 'line':\n          vals = v.split(',');\n          settings.integer(k, vals[0]);\n          if (settings.percent(k, vals[0])) {\n            settings.set('snapToLines', false);\n          }\n          settings.alt(k, vals[0], ['auto']);\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n          break;\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n          break;\n        case 'size':\n          settings.percent(k, v);\n          break;\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    let line = settings.get('line', 'auto');\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    let position = settings.get('position', 'auto');\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n    cue.position = position;\n  }\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.slice(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n  input = input.slice(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\nclass VTTParser {\n  constructor() {\n    this.state = 'INITIAL';\n    this.buffer = '';\n    this.decoder = new StringDecoder();\n    this.regionList = [];\n    this.cue = null;\n    this.oncue = void 0;\n    this.onparsingerror = void 0;\n    this.onflush = void 0;\n  }\n  parse(data) {\n    const _this = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      _this.buffer += _this.decoder.decode(data, {\n        stream: true\n      });\n    }\n    function collectNextLine() {\n      let buffer = _this.buffer;\n      let pos = 0;\n      buffer = fixLineBreaks(buffer);\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      const line = buffer.slice(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      _this.buffer = buffer.slice(pos);\n      return line;\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {\n        // switch (k) {\n        // case 'region':\n        // 3.3 WebVTT region metadata header syntax\n        // console.log('parse region', v);\n        // parseRegion(v);\n        // break;\n        // }\n      }, /:/);\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      let line = '';\n      if (_this.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        line = collectNextLine();\n        // strip of UTF-8 BOM if any\n        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n        const m = line.match(/^()?WEBVTT([ \\t].*)?$/);\n        if (!(m != null && m[0])) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n        _this.state = 'HEADER';\n      }\n      let alreadyCollectedLine = false;\n      while (_this.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n        switch (_this.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              _this.state = 'ID';\n            }\n            continue;\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              _this.state = 'ID';\n            }\n            continue;\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              _this.state = 'NOTE';\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            _this.cue = new VTTCue(0, 0, '');\n            _this.state = 'CUE';\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf('-->') === -1) {\n              _this.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /* falls through */\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            if (!_this.cue) {\n              _this.state = 'BADCUE';\n              continue;\n            }\n            try {\n              parseCue(line, _this.cue, _this.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              _this.cue = null;\n              _this.state = 'BADCUE';\n              continue;\n            }\n            _this.state = 'CUETEXT';\n            continue;\n          case 'CUETEXT':\n            {\n              const hasSubstring = line.indexOf('-->') !== -1;\n              // 34 - If we have an empty line then report the cue.\n              // 35 - If we have the special substring '-->' then report the cue,\n              // but do not collect the line as we need to process the current\n              // one as a new cue.\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                // We are done parsing self cue.\n                if (_this.oncue && _this.cue) {\n                  _this.oncue(_this.cue);\n                }\n                _this.cue = null;\n                _this.state = 'ID';\n                continue;\n              }\n              if (_this.cue === null) {\n                continue;\n              }\n              if (_this.cue.text) {\n                _this.cue.text += '\\n';\n              }\n              _this.cue.text += line;\n            }\n            continue;\n          case 'BADCUE':\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              _this.state = 'ID';\n            }\n        }\n      }\n    } catch (e) {\n      // If we are currently parsing a cue, report what we have.\n      if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n        _this.oncue(_this.cue);\n      }\n      _this.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n    return this;\n  }\n  flush() {\n    const _this = this;\n    try {\n      // Finish decoding the stream.\n      // _this.buffer += _this.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (_this.cue || _this.state === 'HEADER') {\n        _this.buffer += '\\n\\n';\n        _this.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      if (_this.onparsingerror) {\n        _this.onparsingerror(e);\n      }\n    }\n    if (_this.onflush) {\n      _this.onflush();\n    }\n    return this;\n  }\n}\n\nconst LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n\n// String.prototype.startsWith is not supported in IE11\nconst startsWith = function startsWith(inputString, searchString, position = 0) {\n  return inputString.slice(position, position + searchString.length) === searchString;\n};\nconst cueString2millis = function cueString2millis(timeString) {\n  let ts = parseInt(timeString.slice(-3));\n  const secs = parseInt(timeString.slice(-6, -4));\n  const mins = parseInt(timeString.slice(-9, -7));\n  const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;\n  if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {\n    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);\n  }\n  ts += 1000 * secs;\n  ts += 60 * 1000 * mins;\n  ts += 60 * 60 * 1000 * hours;\n  return ts;\n};\n\n// From https://github.com/darkskyapp/string-hash\nconst hash = function hash(text) {\n  let _hash = 5381;\n  let i = text.length;\n  while (i) {\n    _hash = _hash * 33 ^ text.charCodeAt(--i);\n  }\n  return (_hash >>> 0).toString();\n};\n\n// Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\nfunction generateCueId(startTime, endTime, text) {\n  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\nconst calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n  let currCC = vttCCs[cc];\n  let prevCC = vttCCs[currCC.prevCC];\n\n  // This is the first discontinuity or cues have been processed since the last discontinuity\n  // Offset = current discontinuity time\n  if (!prevCC || !prevCC.new && currCC.new) {\n    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n    currCC.new = false;\n    return;\n  }\n\n  // There have been discontinuities since cues were last parsed.\n  // Offset = time elapsed\n  while ((_prevCC = prevCC) != null && _prevCC.new) {\n    var _prevCC;\n    vttCCs.ccOffset += currCC.start - prevCC.start;\n    currCC.new = false;\n    currCC = prevCC;\n    prevCC = vttCCs[currCC.prevCC];\n  }\n  vttCCs.presentationOffset = presentationTime;\n};\nfunction parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n  const parser = new VTTParser();\n  // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n  // Uint8Array.prototype.reduce is not implemented in IE11\n  const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n  const cues = [];\n  const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;\n  let cueTime = '00:00.000';\n  let timestampMapMPEGTS = 0;\n  let timestampMapLOCAL = 0;\n  let parsingError;\n  let inHeader = true;\n  parser.oncue = function (cue) {\n    // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n    const currCC = vttCCs[cc];\n    let cueOffset = vttCCs.ccOffset;\n\n    // Calculate subtitle PTS offset\n    const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;\n\n    // Update offsets for new discontinuities\n    if (currCC != null && currCC.new) {\n      if (timestampMapLOCAL !== undefined) {\n        // When local time is provided, offset = discontinuity start time - local time\n        cueOffset = vttCCs.ccOffset = currCC.start;\n      } else {\n        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n      }\n    }\n    if (webVttMpegTsMapOffset) {\n      if (!initPTS) {\n        parsingError = new Error('Missing initPTS for VTT MPEGTS');\n        return;\n      }\n      // If we have MPEGTS, offset = presentation time + discontinuity offset\n      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n    }\n    const duration = cue.endTime - cue.startTime;\n    const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n    cue.startTime = Math.max(startTime, 0);\n    cue.endTime = Math.max(startTime + duration, 0);\n\n    //trim trailing webvtt block whitespaces\n    const text = cue.text.trim();\n\n    // Fix encoding of special characters\n    cue.text = decodeURIComponent(encodeURIComponent(text));\n\n    // If the cue was not assigned an id from the VTT file (line above the content), create one.\n    if (!cue.id) {\n      cue.id = generateCueId(cue.startTime, cue.endTime, text);\n    }\n    if (cue.endTime > 0) {\n      cues.push(cue);\n    }\n  };\n  parser.onparsingerror = function (error) {\n    parsingError = error;\n  };\n  parser.onflush = function () {\n    if (parsingError) {\n      errorCallBack(parsingError);\n      return;\n    }\n    callBack(cues);\n  };\n\n  // Go through contents line by line.\n  vttLines.forEach(line => {\n    if (inHeader) {\n      // Look for X-TIMESTAMP-MAP in header.\n      if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n        // Once found, no more are allowed anyway, so stop searching.\n        inHeader = false;\n        // Extract LOCAL and MPEGTS.\n        line.slice(16).split(',').forEach(timestamp => {\n          if (startsWith(timestamp, 'LOCAL:')) {\n            cueTime = timestamp.slice(6);\n          } else if (startsWith(timestamp, 'MPEGTS:')) {\n            timestampMapMPEGTS = parseInt(timestamp.slice(7));\n          }\n        });\n        try {\n          // Convert cue time to seconds\n          timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n        } catch (error) {\n          parsingError = error;\n        }\n        // Return without parsing X-TIMESTAMP-MAP line.\n        return;\n      } else if (line === '') {\n        inHeader = false;\n      }\n    }\n    // Parse line by default.\n    parser.parse(line + '\\n');\n  });\n  parser.flush();\n}\n\nconst IMSC1_CODEC = 'stpp.ttml.im1t';\n\n// Time format: h:m:s:frames(.subframes)\nconst HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n// Time format: hours, minutes, seconds, milliseconds, frames, ticks\nconst TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nconst textAlignToLineAlign = {\n  left: 'start',\n  center: 'center',\n  right: 'end',\n  start: 'start',\n  end: 'end'\n};\nfunction parseIMSC1(payload, initPTS, callBack, errorCallBack) {\n  const results = findBox(new Uint8Array(payload), ['mdat']);\n  if (results.length === 0) {\n    errorCallBack(new Error('Could not parse IMSC1 mdat'));\n    return;\n  }\n  const ttmlList = results.map(mdat => utf8ArrayToStr(mdat));\n  const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);\n  try {\n    ttmlList.forEach(ttml => callBack(parseTTML(ttml, syncTime)));\n  } catch (error) {\n    errorCallBack(error);\n  }\n}\nfunction parseTTML(ttml, syncTime) {\n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(ttml, 'text/xml');\n  const tt = xmlDoc.getElementsByTagName('tt')[0];\n  if (!tt) {\n    throw new Error('Invalid ttml');\n  }\n  const defaultRateInfo = {\n    frameRate: 30,\n    subFrameRate: 1,\n    frameRateMultiplier: 0,\n    tickRate: 0\n  };\n  const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {\n    result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];\n    return result;\n  }, {});\n  const trim = tt.getAttribute('xml:space') !== 'preserve';\n  const styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n  const regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n  const cueElements = getElementCollection(tt, 'body', '[begin]');\n  return [].map.call(cueElements, cueElement => {\n    const cueText = getTextContent(cueElement, trim);\n    if (!cueText || !cueElement.hasAttribute('begin')) {\n      return null;\n    }\n    const startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n    const duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n    let endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n    if (startTime === null) {\n      throw timestampParsingError(cueElement);\n    }\n    if (endTime === null) {\n      if (duration === null) {\n        throw timestampParsingError(cueElement);\n      }\n      endTime = startTime + duration;\n    }\n    const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);\n    cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);\n    const region = regionElements[cueElement.getAttribute('region')];\n    const style = styleElements[cueElement.getAttribute('style')];\n\n    // Apply styles to cue\n    const styles = getTtmlStyles(region, style, styleElements);\n    const {\n      textAlign\n    } = styles;\n    if (textAlign) {\n      // cue.positionAlign not settable in FF~2016\n      const lineAlign = textAlignToLineAlign[textAlign];\n      if (lineAlign) {\n        cue.lineAlign = lineAlign;\n      }\n      cue.align = textAlign;\n    }\n    _extends(cue, styles);\n    return cue;\n  }).filter(cue => cue !== null);\n}\nfunction getElementCollection(fromElement, parentName, childName) {\n  const parent = fromElement.getElementsByTagName(parentName)[0];\n  if (parent) {\n    return [].slice.call(parent.querySelectorAll(childName));\n  }\n  return [];\n}\nfunction collectionToDictionary(elementsWithId) {\n  return elementsWithId.reduce((dict, element) => {\n    const id = element.getAttribute('xml:id');\n    if (id) {\n      dict[id] = element;\n    }\n    return dict;\n  }, {});\n}\nfunction getTextContent(element, trim) {\n  return [].slice.call(element.childNodes).reduce((str, node, i) => {\n    var _node$childNodes;\n    if (node.nodeName === 'br' && i) {\n      return str + '\\n';\n    }\n    if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {\n      return getTextContent(node, trim);\n    } else if (trim) {\n      return str + node.textContent.trim().replace(/\\s+/g, ' ');\n    }\n    return str + node.textContent;\n  }, '');\n}\nfunction getTtmlStyles(region, style, styleElements) {\n  const ttsNs = 'http://www.w3.org/ns/ttml#styling';\n  let regionStyle = null;\n  const styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'\n  // 'fontWeight',\n  // 'lineHeight',\n  // 'wrapOption',\n  // 'fontStyle',\n  // 'direction',\n  // 'writingMode'\n  ];\n\n  const regionStyleName = region != null && region.hasAttribute('style') ? region.getAttribute('style') : null;\n  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n    regionStyle = styleElements[regionStyleName];\n  }\n  return styleAttributes.reduce((styles, name) => {\n    const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n    if (value) {\n      styles[name] = value;\n    }\n    return styles;\n  }, {});\n}\nfunction getAttributeNS(element, ns, name) {\n  if (!element) {\n    return null;\n  }\n  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\nfunction timestampParsingError(node) {\n  return new Error(`Could not parse ttml timestamp ${node}`);\n}\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n  if (!timeAttributeValue) {\n    return null;\n  }\n  let seconds = parseTimeStamp(timeAttributeValue);\n  if (seconds === null) {\n    if (HMSF_REGEX.test(timeAttributeValue)) {\n      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n      seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n    }\n  }\n  return seconds;\n}\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n  const m = HMSF_REGEX.exec(timeAttributeValue);\n  const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n  const m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n  const value = Number(m[1]);\n  const unit = m[2];\n  switch (unit) {\n    case 'h':\n      return value * 3600;\n    case 'm':\n      return value * 60;\n    case 'ms':\n      return value * 1000;\n    case 'f':\n      return value / rateInfo.frameRate;\n    case 't':\n      return value / rateInfo.tickRate;\n  }\n  return value;\n}\n\nclass TimelineController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.media = null;\n    this.config = void 0;\n    this.enabled = true;\n    this.Cues = void 0;\n    this.textTracks = [];\n    this.tracks = [];\n    this.initPTS = [];\n    this.unparsedVttFrags = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.cea608Parser1 = void 0;\n    this.cea608Parser2 = void 0;\n    this.lastSn = -1;\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs();\n    this.captionsProperties = void 0;\n    this.hls = hls;\n    this.config = hls.config;\n    this.Cues = hls.config.cueHandler;\n    this.captionsProperties = {\n      textTrack1: {\n        label: this.config.captionsTextTrack1Label,\n        languageCode: this.config.captionsTextTrack1LanguageCode\n      },\n      textTrack2: {\n        label: this.config.captionsTextTrack2Label,\n        languageCode: this.config.captionsTextTrack2LanguageCode\n      },\n      textTrack3: {\n        label: this.config.captionsTextTrack3Label,\n        languageCode: this.config.captionsTextTrack3LanguageCode\n      },\n      textTrack4: {\n        label: this.config.captionsTextTrack4Label,\n        languageCode: this.config.captionsTextTrack4LanguageCode\n      }\n    };\n    if (this.config.enableCEA708Captions) {\n      const channel1 = new OutputFilter(this, 'textTrack1');\n      const channel2 = new OutputFilter(this, 'textTrack2');\n      const channel3 = new OutputFilter(this, 'textTrack3');\n      const channel4 = new OutputFilter(this, 'textTrack4');\n      this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);\n      this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);\n    }\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  destroy() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    // @ts-ignore\n    this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;\n  }\n  addCues(trackName, startTime, endTime, screen, cueRanges) {\n    // skip cues which overlap more than 50% with previously parsed time ranges\n    let merged = false;\n    for (let i = cueRanges.length; i--;) {\n      const cueRange = cueRanges[i];\n      const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n      if (overlap >= 0) {\n        cueRange[0] = Math.min(cueRange[0], startTime);\n        cueRange[1] = Math.max(cueRange[1], endTime);\n        merged = true;\n        if (overlap / (endTime - startTime) > 0.5) {\n          return;\n        }\n      }\n    }\n    if (!merged) {\n      cueRanges.push([startTime, endTime]);\n    }\n    if (this.config.renderTextTracksNatively) {\n      const track = this.captionsTracks[trackName];\n      this.Cues.newCue(track, startTime, endTime, screen);\n    } else {\n      const cues = this.Cues.newCue(null, startTime, endTime, screen);\n      this.hls.trigger(Events.CUES_PARSED, {\n        type: 'captions',\n        cues,\n        track: trackName\n      });\n    }\n  }\n\n  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    const {\n      unparsedVttFrags\n    } = this;\n    if (id === 'main') {\n      this.initPTS[frag.cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n    }\n\n    // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n    // Parse any unparsed fragments upon receiving the initial PTS.\n    if (unparsedVttFrags.length) {\n      this.unparsedVttFrags = [];\n      unparsedVttFrags.forEach(frag => {\n        this.onFragLoaded(Events.FRAG_LOADED, frag);\n      });\n    }\n  }\n  getExistingTrack(trackName) {\n    const {\n      media\n    } = this;\n    if (media) {\n      for (let i = 0; i < media.textTracks.length; i++) {\n        const textTrack = media.textTracks[i];\n        if (textTrack[trackName]) {\n          return textTrack;\n        }\n      }\n    }\n    return null;\n  }\n  createCaptionsTrack(trackName) {\n    if (this.config.renderTextTracksNatively) {\n      this.createNativeTrack(trackName);\n    } else {\n      this.createNonNativeTrack(trackName);\n    }\n  }\n  createNativeTrack(trackName) {\n    if (this.captionsTracks[trackName]) {\n      return;\n    }\n    const {\n      captionsProperties,\n      captionsTracks,\n      media\n    } = this;\n    const {\n      label,\n      languageCode\n    } = captionsProperties[trackName];\n    // Enable reuse of existing text track.\n    const existingTrack = this.getExistingTrack(trackName);\n    if (!existingTrack) {\n      const textTrack = this.createTextTrack('captions', label, languageCode);\n      if (textTrack) {\n        // Set a special property on the track so we know it's managed by Hls.js\n        textTrack[trackName] = true;\n        captionsTracks[trackName] = textTrack;\n      }\n    } else {\n      captionsTracks[trackName] = existingTrack;\n      clearCurrentCues(captionsTracks[trackName]);\n      sendAddTrackEvent(captionsTracks[trackName], media);\n    }\n  }\n  createNonNativeTrack(trackName) {\n    if (this.nonNativeCaptionsTracks[trackName]) {\n      return;\n    }\n    // Create a list of a single track for the provider to consume\n    const trackProperties = this.captionsProperties[trackName];\n    if (!trackProperties) {\n      return;\n    }\n    const label = trackProperties.label;\n    const track = {\n      _id: trackName,\n      label,\n      kind: 'captions',\n      default: trackProperties.media ? !!trackProperties.media.default : false,\n      closedCaptions: trackProperties.media\n    };\n    this.nonNativeCaptionsTracks[trackName] = track;\n    this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n      tracks: [track]\n    });\n  }\n  createTextTrack(kind, label, lang) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    return media.addTextTrack(kind, label, lang);\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media;\n    this._cleanTracks();\n  }\n  onMediaDetaching() {\n    const {\n      captionsTracks\n    } = this;\n    Object.keys(captionsTracks).forEach(trackName => {\n      clearCurrentCues(captionsTracks[trackName]);\n      delete captionsTracks[trackName];\n    });\n    this.nonNativeCaptionsTracks = {};\n  }\n  onManifestLoading() {\n    this.lastSn = -1; // Detect discontinuity in fragment parsing\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs(); // Detect discontinuity in subtitle manifests\n    this._cleanTracks();\n    this.tracks = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.textTracks = [];\n    this.unparsedVttFrags = [];\n    this.initPTS = [];\n    if (this.cea608Parser1 && this.cea608Parser2) {\n      this.cea608Parser1.reset();\n      this.cea608Parser2.reset();\n    }\n  }\n  _cleanTracks() {\n    // clear outdated subtitles\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = media.textTracks;\n    if (textTracks) {\n      for (let i = 0; i < textTracks.length; i++) {\n        clearCurrentCues(textTracks[i]);\n      }\n    }\n  }\n  onSubtitleTracksUpdated(event, data) {\n    const tracks = data.subtitleTracks || [];\n    const hasIMSC1 = tracks.some(track => track.textCodec === IMSC1_CODEC);\n    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n      const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);\n      if (listIsIdentical) {\n        this.tracks = tracks;\n        return;\n      }\n      this.textTracks = [];\n      this.tracks = tracks;\n      if (this.config.renderTextTracksNatively) {\n        const inUseTracks = this.media ? this.media.textTracks : null;\n        this.tracks.forEach((track, index) => {\n          let textTrack;\n          if (inUseTracks && index < inUseTracks.length) {\n            let inUseTrack = null;\n            for (let i = 0; i < inUseTracks.length; i++) {\n              if (canReuseVttTextTrack(inUseTracks[i], track)) {\n                inUseTrack = inUseTracks[i];\n                break;\n              }\n            }\n\n            // Reuse tracks with the same label, but do not reuse 608/708 tracks\n            if (inUseTrack) {\n              textTrack = inUseTrack;\n            }\n          }\n          if (textTrack) {\n            clearCurrentCues(textTrack);\n          } else {\n            const textTrackKind = this._captionsOrSubtitlesFromCharacteristics(track);\n            textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);\n            if (textTrack) {\n              textTrack.mode = 'disabled';\n            }\n          }\n          if (textTrack) {\n            textTrack.groupId = track.groupId;\n            this.textTracks.push(textTrack);\n          }\n        });\n      } else if (this.tracks.length) {\n        // Create a list of tracks for the provider to consume\n        const tracksList = this.tracks.map(track => {\n          return {\n            label: track.name,\n            kind: track.type.toLowerCase(),\n            default: track.default,\n            subtitleTrack: track\n          };\n        });\n        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n          tracks: tracksList\n        });\n      }\n    }\n  }\n  _captionsOrSubtitlesFromCharacteristics(track) {\n    if (track.attrs.CHARACTERISTICS) {\n      const transcribesSpokenDialog = /transcribes-spoken-dialog/gi.test(track.attrs.CHARACTERISTICS);\n      const describesMusicAndSound = /describes-music-and-sound/gi.test(track.attrs.CHARACTERISTICS);\n      if (transcribesSpokenDialog && describesMusicAndSound) {\n        return 'captions';\n      }\n    }\n    return 'subtitles';\n  }\n  onManifestLoaded(event, data) {\n    if (this.config.enableCEA708Captions && data.captions) {\n      data.captions.forEach(captionsTrack => {\n        const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n        if (!instreamIdMatch) {\n          return;\n        }\n        const trackName = `textTrack${instreamIdMatch[1]}`;\n        const trackProperties = this.captionsProperties[trackName];\n        if (!trackProperties) {\n          return;\n        }\n        trackProperties.label = captionsTrack.name;\n        if (captionsTrack.lang) {\n          // optional attribute\n          trackProperties.languageCode = captionsTrack.lang;\n        }\n        trackProperties.media = captionsTrack;\n      });\n    }\n  }\n  closedCaptionsForLevel(frag) {\n    const level = this.hls.levels[frag.level];\n    return level == null ? void 0 : level.attrs['CLOSED-CAPTIONS'];\n  }\n  onFragLoading(event, data) {\n    const {\n      cea608Parser1,\n      cea608Parser2,\n      lastSn,\n      lastPartIndex\n    } = this;\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    }\n    // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n    if (data.frag.type === PlaylistLevelType.MAIN) {\n      var _data$part$index, _data$part;\n      const sn = data.frag.sn;\n      const partIndex = (_data$part$index = data == null ? void 0 : (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n      if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1)) {\n        cea608Parser1.reset();\n        cea608Parser2.reset();\n      }\n      this.lastSn = sn;\n      this.lastPartIndex = partIndex;\n    }\n  }\n  onFragLoaded(event, data) {\n    const {\n      frag,\n      payload\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      // If fragment is subtitle type, parse as WebVTT.\n      if (payload.byteLength) {\n        const decryptData = frag.decryptdata;\n        // fragment after decryption has a stats object\n        const decrypted = ('stats' in data);\n        // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n        if (decryptData == null || !decryptData.encrypted || decrypted) {\n          const trackPlaylistMedia = this.tracks[frag.level];\n          const vttCCs = this.vttCCs;\n          if (!vttCCs[frag.cc]) {\n            vttCCs[frag.cc] = {\n              start: frag.start,\n              prevCC: this.prevCC,\n              new: true\n            };\n            this.prevCC = frag.cc;\n          }\n          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {\n            this._parseIMSC1(frag, payload);\n          } else {\n            this._parseVTTs(data);\n          }\n        }\n      } else {\n        // In case there is no payload, finish unsuccessfully.\n        this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag,\n          error: new Error('Empty subtitle payload')\n        });\n      }\n    }\n  }\n  _parseIMSC1(frag, payload) {\n    const hls = this.hls;\n    parseIMSC1(payload, this.initPTS[frag.cc], cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      logger.log(`Failed to parse IMSC1: ${error}`);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _parseVTTs(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      payload\n    } = data;\n    // We need an initial synchronisation PTS. Store fragments as long as none has arrived\n    const {\n      initPTS,\n      unparsedVttFrags\n    } = this;\n    const maxAvCC = initPTS.length - 1;\n    if (!initPTS[frag.cc] && maxAvCC === -1) {\n      unparsedVttFrags.push(data);\n      return;\n    }\n    const hls = this.hls;\n    // Parse the WebVTT file contents.\n    const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;\n    parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      const missingInitPTS = error.message === 'Missing initPTS for VTT MPEGTS';\n      if (missingInitPTS) {\n        unparsedVttFrags.push(data);\n      } else {\n        this._fallbackToIMSC1(frag, payload);\n      }\n      // Something went wrong while parsing. Trigger event with success false.\n      logger.log(`Failed to parse VTT cue: ${error}`);\n      if (missingInitPTS && maxAvCC > frag.cc) {\n        return;\n      }\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _fallbackToIMSC1(frag, payload) {\n    // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n    const trackPlaylistMedia = this.tracks[frag.level];\n    if (!trackPlaylistMedia.textCodec) {\n      parseIMSC1(payload, this.initPTS[frag.cc], () => {\n        trackPlaylistMedia.textCodec = IMSC1_CODEC;\n        this._parseIMSC1(frag, payload);\n      }, () => {\n        trackPlaylistMedia.textCodec = 'wvtt';\n      });\n    }\n  }\n  _appendCues(cues, fragLevel) {\n    const hls = this.hls;\n    if (this.config.renderTextTracksNatively) {\n      const textTrack = this.textTracks[fragLevel];\n      // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n      // and trying to access getCueById method of cues will throw an exception\n      // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n      if (!textTrack || textTrack.mode === 'disabled') {\n        return;\n      }\n      cues.forEach(cue => addCueToTrack(textTrack, cue));\n    } else {\n      const currentTrack = this.tracks[fragLevel];\n      if (!currentTrack) {\n        return;\n      }\n      const track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n      hls.trigger(Events.CUES_PARSED, {\n        type: 'subtitles',\n        cues,\n        track\n      });\n    }\n  }\n  onFragDecrypted(event, data) {\n    const {\n      frag\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      this.onFragLoaded(Events.FRAG_LOADED, data);\n    }\n  }\n  onSubtitleTracksCleared() {\n    this.tracks = [];\n    this.captionsTracks = {};\n  }\n  onFragParsingUserdata(event, data) {\n    const {\n      cea608Parser1,\n      cea608Parser2\n    } = this;\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    }\n    const {\n      frag,\n      samples\n    } = data;\n    if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === 'NONE') {\n      return;\n    }\n    // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n    // It will create the proper timestamps based on the PTS value\n    for (let i = 0; i < samples.length; i++) {\n      const ccBytes = samples[i].bytes;\n      if (ccBytes) {\n        const ccdatas = this.extractCea608Data(ccBytes);\n        cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n        cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    endOffsetSubtitles,\n    type\n  }) {\n    const {\n      media\n    } = this;\n    if (!media || media.currentTime < endOffset) {\n      return;\n    }\n    // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n    // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n    if (!type || type === 'video') {\n      const {\n        captionsTracks\n      } = this;\n      Object.keys(captionsTracks).forEach(trackName => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));\n    }\n    if (this.config.renderTextTracksNatively) {\n      // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n      if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n        const {\n          textTracks\n        } = this;\n        Object.keys(textTracks).forEach(trackName => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));\n      }\n    }\n  }\n  extractCea608Data(byteArray) {\n    const actualCCBytes = [[], []];\n    const count = byteArray[0] & 0x1f;\n    let position = 2;\n    for (let j = 0; j < count; j++) {\n      const tmpByte = byteArray[position++];\n      const ccbyte1 = 0x7f & byteArray[position++];\n      const ccbyte2 = 0x7f & byteArray[position++];\n      if (ccbyte1 === 0 && ccbyte2 === 0) {\n        continue;\n      }\n      const ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n      if (ccValid) {\n        const ccType = 0x03 & tmpByte;\n        if (0x00 /* CEA608 field1*/ === ccType || 0x01 /* CEA608 field2*/ === ccType) {\n          // Exclude CEA708 CC data.\n          actualCCBytes[ccType].push(ccbyte1);\n          actualCCBytes[ccType].push(ccbyte2);\n        }\n      }\n    }\n    return actualCCBytes;\n  }\n}\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n  return !!inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);\n}\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\nfunction newVTTCCs() {\n  return {\n    ccOffset: 0,\n    presentationOffset: 0,\n    0: {\n      start: 0,\n      prevCC: -1,\n      new: true\n    }\n  };\n}\n\n/*\n * cap stream level to media size dimension controller\n */\n\nclass CapLevelController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.autoLevelCapping = void 0;\n    this.firstLevel = void 0;\n    this.media = void 0;\n    this.restrictedLevels = void 0;\n    this.timer = void 0;\n    this.clientRect = void 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.firstLevel = -1;\n    this.media = null;\n    this.restrictedLevels = [];\n    this.timer = undefined;\n    this.clientRect = null;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  destroy() {\n    this.unregisterListener();\n    if (this.hls.config.capLevelToPlayerSize) {\n      this.stopCapping();\n    }\n    this.media = null;\n    this.clientRect = null;\n    // @ts-ignore\n    this.hls = this.streamController = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListener() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  onFpsDropLevelCapping(event, data) {\n    // Don't add a restricted level more than once\n    const level = this.hls.levels[data.droppedLevel];\n    if (this.isLevelAllowed(level)) {\n      this.restrictedLevels.push({\n        bitrate: level.bitrate,\n        height: level.height,\n        width: level.width\n      });\n    }\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n    this.clientRect = null;\n  }\n  onManifestParsed(event, data) {\n    const hls = this.hls;\n    this.restrictedLevels = [];\n    this.firstLevel = data.firstLevel;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // Start capping immediately if the manifest has signaled video codecs\n      this.startCapping();\n    }\n  }\n\n  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  onBufferCodecs(event, data) {\n    const hls = this.hls;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n      this.startCapping();\n    }\n  }\n  onMediaDetaching() {\n    this.stopCapping();\n  }\n  detectPlayerSize() {\n    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {\n      const levels = this.hls.levels;\n      if (levels.length) {\n        const hls = this.hls;\n        hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);\n        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n          // usually happen when the user go to the fullscreen mode.\n          this.streamController.nextLevelSwitch();\n        }\n        this.autoLevelCapping = hls.autoLevelCapping;\n      }\n    }\n  }\n\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */\n  getMaxLevel(capLevelIndex) {\n    const levels = this.hls.levels;\n    if (!levels.length) {\n      return -1;\n    }\n    const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);\n    this.clientRect = null;\n    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n  }\n  startCapping() {\n    if (this.timer) {\n      // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n      return;\n    }\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.hls.firstLevel = this.getMaxLevel(this.firstLevel);\n    self.clearInterval(this.timer);\n    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n    this.detectPlayerSize();\n  }\n  stopCapping() {\n    this.restrictedLevels = [];\n    this.firstLevel = -1;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    if (this.timer) {\n      self.clearInterval(this.timer);\n      this.timer = undefined;\n    }\n  }\n  getDimensions() {\n    if (this.clientRect) {\n      return this.clientRect;\n    }\n    const media = this.media;\n    const boundsRect = {\n      width: 0,\n      height: 0\n    };\n    if (media) {\n      const clientRect = media.getBoundingClientRect();\n      boundsRect.width = clientRect.width;\n      boundsRect.height = clientRect.height;\n      if (!boundsRect.width && !boundsRect.height) {\n        // When the media element has no width or height (equivalent to not being in the DOM),\n        // then use its width and height attributes (media.width, media.height)\n        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n      }\n    }\n    this.clientRect = boundsRect;\n    return boundsRect;\n  }\n  get mediaWidth() {\n    return this.getDimensions().width * this.contentScaleFactor;\n  }\n  get mediaHeight() {\n    return this.getDimensions().height * this.contentScaleFactor;\n  }\n  get contentScaleFactor() {\n    let pixelRatio = 1;\n    if (!this.hls.config.ignoreDevicePixelRatio) {\n      try {\n        pixelRatio = self.devicePixelRatio;\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    return pixelRatio;\n  }\n  isLevelAllowed(level) {\n    const restrictedLevels = this.restrictedLevels;\n    return !restrictedLevels.some(restrictedLevel => {\n      return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n    });\n  }\n  static getMaxLevelByMediaSize(levels, width, height) {\n    if (!(levels != null && levels.length)) {\n      return -1;\n    }\n\n    // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n    // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n    const atGreatestBandwidth = (curLevel, nextLevel) => {\n      if (!nextLevel) {\n        return true;\n      }\n      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n    };\n\n    // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n    // the max level\n    let maxLevelIndex = levels.length - 1;\n    for (let i = 0; i < levels.length; i += 1) {\n      const level = levels[i];\n      if ((level.width >= width || level.height >= height) && atGreatestBandwidth(level, levels[i + 1])) {\n        maxLevelIndex = i;\n        break;\n      }\n    }\n    return maxLevelIndex;\n  }\n}\n\nclass FPSController {\n  // stream controller must be provided as a dependency!\n\n  constructor(hls) {\n    this.hls = void 0;\n    this.isVideoPlaybackQualityAvailable = false;\n    this.timer = void 0;\n    this.media = null;\n    this.lastTime = void 0;\n    this.lastDroppedFrames = 0;\n    this.lastDecodedFrames = 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n  }\n  destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n    this.unregisterListeners();\n    this.isVideoPlaybackQualityAvailable = false;\n    this.media = null;\n  }\n  onMediaAttaching(event, data) {\n    const config = this.hls.config;\n    if (config.capLevelOnFPSDrop) {\n      const media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n      this.media = media;\n      if (media && typeof media.getVideoPlaybackQuality === 'function') {\n        this.isVideoPlaybackQualityAvailable = true;\n      }\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n    }\n  }\n  checkFPS(video, decodedFrames, droppedFrames) {\n    const currentTime = performance.now();\n    if (decodedFrames) {\n      if (this.lastTime) {\n        const currentPeriod = currentTime - this.lastTime;\n        const currentDropped = droppedFrames - this.lastDroppedFrames;\n        const currentDecoded = decodedFrames - this.lastDecodedFrames;\n        const droppedFPS = 1000 * currentDropped / currentPeriod;\n        const hls = this.hls;\n        hls.trigger(Events.FPS_DROP, {\n          currentDropped: currentDropped,\n          currentDecoded: currentDecoded,\n          totalDroppedFrames: droppedFrames\n        });\n        if (droppedFPS > 0) {\n          // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n            let currentLevel = hls.currentLevel;\n            logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n              currentLevel = currentLevel - 1;\n              hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                level: currentLevel,\n                droppedLevel: hls.currentLevel\n              });\n              hls.autoLevelCapping = currentLevel;\n              this.streamController.nextLevelSwitch();\n            }\n          }\n        }\n      }\n      this.lastTime = currentTime;\n      this.lastDroppedFrames = droppedFrames;\n      this.lastDecodedFrames = decodedFrames;\n    }\n  }\n  checkFPSInterval() {\n    const video = this.media;\n    if (video) {\n      if (this.isVideoPlaybackQualityAvailable) {\n        const videoPlaybackQuality = video.getVideoPlaybackQuality();\n        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n      } else {\n        // HTMLVideoElement doesn't include the webkit types\n        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n      }\n    }\n  }\n}\n\nconst LOGGER_PREFIX = '[eme]';\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */\nclass EMEController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.keyFormatPromise = null;\n    this.keySystemAccessPromises = {};\n    this._requestLicenseFailureCount = 0;\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];\n    this.onMediaEncrypted = this._onMediaEncrypted.bind(this);\n    this.onWaitingForKey = this._onWaitingForKey.bind(this);\n    this.debug = logger.debug.bind(logger, LOGGER_PREFIX);\n    this.log = logger.log.bind(logger, LOGGER_PREFIX);\n    this.warn = logger.warn.bind(logger, LOGGER_PREFIX);\n    this.error = logger.error.bind(logger, LOGGER_PREFIX);\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetached();\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.requestMediaKeySystemAccessFunc = null;\n    config.licenseXhrSetup = config.licenseResponseCallback = undefined;\n    config.drmSystems = config.drmSystemOptions = {};\n    // @ts-ignore\n    this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;\n    // @ts-ignore\n    this.config = null;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  getLicenseServerUrl(keySystem) {\n    const {\n      drmSystems,\n      widevineLicenseUrl\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.licenseUrl;\n    }\n\n    // For backward compatibility\n    if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {\n      return widevineLicenseUrl;\n    }\n    throw new Error(`no license server URL configured for key-system \"${keySystem}\"`);\n  }\n  getServerCertificateUrl(keySystem) {\n    const {\n      drmSystems\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.serverCertificateUrl;\n    } else {\n      this.log(`No Server Certificate in config.drmSystems[\"${keySystem}\"]`);\n    }\n  }\n  attemptKeySystemAccess(keySystemsToAttempt) {\n    const levels = this.hls.levels;\n    const uniqueCodec = (value, i, a) => !!value && a.indexOf(value) === i;\n    const audioCodecs = levels.map(level => level.audioCodec).filter(uniqueCodec);\n    const videoCodecs = levels.map(level => level.videoCodec).filter(uniqueCodec);\n    if (audioCodecs.length + videoCodecs.length === 0) {\n      videoCodecs.push('avc1.42e01e');\n    }\n    return new Promise((resolve, reject) => {\n      const attempt = keySystems => {\n        const keySystem = keySystems.shift();\n        this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(mediaKeys => resolve({\n          keySystem,\n          mediaKeys\n        })).catch(error => {\n          if (keySystems.length) {\n            attempt(keySystems);\n          } else if (error instanceof EMEKeyError) {\n            reject(error);\n          } else {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n              error,\n              fatal: true\n            }, error.message));\n          }\n        });\n      };\n      attempt(keySystemsToAttempt);\n    });\n  }\n  requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    const {\n      requestMediaKeySystemAccessFunc\n    } = this.config;\n    if (!(typeof requestMediaKeySystemAccessFunc === 'function')) {\n      let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;\n      if (requestMediaKeySystemAccess === null && self.location.protocol === 'http:') {\n        errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;\n      }\n      return Promise.reject(new Error(errMessage));\n    }\n    return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n  }\n  getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n    // This can throw, but is caught in event handler callpath\n    const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);\n    const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n    let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;\n    if (!keySystemAccess) {\n      this.log(`Requesting encrypted media \"${keySystem}\" key-system access with config: ${JSON.stringify(mediaKeySystemConfigs)}`);\n      keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n      const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n        keySystemAccess\n      };\n      keySystemAccess.catch(error => {\n        this.log(`Failed to obtain access to key-system \"${keySystem}\": ${error}`);\n      });\n      return keySystemAccess.then(mediaKeySystemAccess => {\n        this.log(`Access for key-system \"${mediaKeySystemAccess.keySystem}\" obtained`);\n        const certificateRequest = this.fetchServerCertificate(keySystem);\n        this.log(`Create media-keys for \"${keySystem}\"`);\n        _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(mediaKeys => {\n          this.log(`Media-keys created for \"${keySystem}\"`);\n          return certificateRequest.then(certificate => {\n            if (certificate) {\n              return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n            }\n            return mediaKeys;\n          });\n        });\n        _keySystemAccessPromises.mediaKeys.catch(error => {\n          this.error(`Failed to create media-keys for \"${keySystem}\"}: ${error}`);\n        });\n        return _keySystemAccessPromises.mediaKeys;\n      });\n    }\n    return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);\n  }\n  createMediaKeySessionContext({\n    decryptdata,\n    keySystem,\n    mediaKeys\n  }) {\n    this.log(`Creating key-system session \"${keySystem}\" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);\n    const mediaKeysSession = mediaKeys.createSession();\n    const mediaKeySessionContext = {\n      decryptdata,\n      keySystem,\n      mediaKeys,\n      mediaKeysSession,\n      keyStatus: 'status-pending'\n    };\n    this.mediaKeySessions.push(mediaKeySessionContext);\n    return mediaKeySessionContext;\n  }\n  renewKeySession(mediaKeySessionContext) {\n    const decryptdata = mediaKeySessionContext.decryptdata;\n    if (decryptdata.pssh) {\n      const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n      const keyId = this.getKeyIdString(decryptdata);\n      const scheme = 'cenc';\n      this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'expired');\n    } else {\n      this.warn(`Could not renew expired session. Missing pssh initData.`);\n    }\n    this.removeSession(mediaKeySessionContext);\n  }\n  getKeyIdString(decryptdata) {\n    if (!decryptdata) {\n      throw new Error('Could not read keyId of undefined decryptdata');\n    }\n    if (decryptdata.keyId === null) {\n      throw new Error('keyId is null');\n    }\n    return Hex.hexDump(decryptdata.keyId);\n  }\n  updateKeySession(mediaKeySessionContext, data) {\n    var _mediaKeySessionConte;\n    const keySession = mediaKeySessionContext.mediaKeysSession;\n    this.log(`Updating key-session \"${keySession.sessionId}\" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}\n      } (data length: ${data ? data.byteLength : data})`);\n    return keySession.update(data);\n  }\n  selectKeySystemFormat(frag) {\n    const keyFormats = Object.keys(frag.levelkeys || {});\n    if (!this.keyFormatPromise) {\n      this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n    return this.keyFormatPromise;\n  }\n  getKeyFormatPromise(keyFormats) {\n    return new Promise((resolve, reject) => {\n      const keySystemsInConfig = getKeySystemsForConfig(this.config);\n      const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(value => !!value && keySystemsInConfig.indexOf(value) !== -1);\n      return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({\n        keySystem\n      }) => {\n        const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);\n        if (keySystemFormat) {\n          resolve(keySystemFormat);\n        } else {\n          reject(new Error(`Unable to find format for key-system \"${keySystem}\"`));\n        }\n      }).catch(reject);\n    });\n  }\n  loadKey(data) {\n    const decryptdata = data.keyInfo.decryptdata;\n    const keyId = this.getKeyIdString(decryptdata);\n    const keyDetails = `(keyId: ${keyId} format: \"${decryptdata.keyFormat}\" method: ${decryptdata.method} uri: ${decryptdata.uri})`;\n    this.log(`Starting session for key ${keyDetails}`);\n    let keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];\n    if (!keySessionContextPromise) {\n      keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(({\n        keySystem,\n        mediaKeys\n      }) => {\n        this.throwIfDestroyed();\n        this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);\n        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {\n          this.throwIfDestroyed();\n          const keySessionContext = this.createMediaKeySessionContext({\n            keySystem,\n            mediaKeys,\n            decryptdata\n          });\n          const scheme = 'cenc';\n          return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'playlist-key');\n        });\n      });\n      keySessionContextPromise.catch(error => this.handleError(error));\n    }\n    return keySessionContextPromise;\n  }\n  throwIfDestroyed(message = 'Invalid state') {\n    if (!this.hls) {\n      throw new Error('invalid state');\n    }\n  }\n  handleError(error) {\n    if (!this.hls) {\n      return;\n    }\n    this.error(error.message);\n    if (error instanceof EMEKeyError) {\n      this.hls.trigger(Events.ERROR, error.data);\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n        error,\n        fatal: true\n      });\n    }\n  }\n  getKeySystemForKeyPromise(decryptdata) {\n    const keyId = this.getKeyIdString(decryptdata);\n    const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n    if (!mediaKeySessionContext) {\n      const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);\n      const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);\n      return this.attemptKeySystemAccess(keySystemsToAttempt);\n    }\n    return mediaKeySessionContext;\n  }\n  getKeySystemSelectionPromise(keySystemsToAttempt) {\n    if (!keySystemsToAttempt.length) {\n      keySystemsToAttempt = getKeySystemsForConfig(this.config);\n    }\n    if (keySystemsToAttempt.length === 0) {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n        fatal: true\n      }, `Missing key-system license configuration options ${JSON.stringify({\n        drmSystems: this.config.drmSystems\n      })}`);\n    }\n    return this.attemptKeySystemAccess(keySystemsToAttempt);\n  }\n  _onMediaEncrypted(event) {\n    const {\n      initDataType,\n      initData\n    } = event;\n    this.debug(`\"${event.type}\" event: init data type: \"${initDataType}\"`);\n\n    // Ignore event when initData is null\n    if (initData === null) {\n      return;\n    }\n    let keyId;\n    let keySystemDomain;\n    if (initDataType === 'sinf' && this.config.drmSystems[KeySystems.FAIRPLAY]) {\n      // Match sinf keyId to playlist skd://keyId=\n      const json = bin2str(new Uint8Array(initData));\n      try {\n        const sinf = base64Decode(JSON.parse(json).sinf);\n        const tenc = parseSinf(new Uint8Array(sinf));\n        if (!tenc) {\n          return;\n        }\n        keyId = tenc.subarray(8, 24);\n        keySystemDomain = KeySystems.FAIRPLAY;\n      } catch (error) {\n        this.warn('Failed to parse sinf \"encrypted\" event message initData');\n        return;\n      }\n    } else {\n      // Support clear-lead key-session creation (otherwise depend on playlist keys)\n      const psshInfo = parsePssh(initData);\n      if (psshInfo === null) {\n        return;\n      }\n      if (psshInfo.version === 0 && psshInfo.systemId === KeySystemIds.WIDEVINE && psshInfo.data) {\n        keyId = psshInfo.data.subarray(8, 24);\n      }\n      keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);\n    }\n    if (!keySystemDomain || !keyId) {\n      return;\n    }\n    const keyIdHex = Hex.hexDump(keyId);\n    const {\n      keyIdToKeySessionPromise,\n      mediaKeySessions\n    } = this;\n    let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];\n    for (let i = 0; i < mediaKeySessions.length; i++) {\n      // Match playlist key\n      const keyContext = mediaKeySessions[i];\n      const decryptdata = keyContext.decryptdata;\n      if (decryptdata.pssh || !decryptdata.keyId) {\n        continue;\n      }\n      const oldKeyIdHex = Hex.hexDump(decryptdata.keyId);\n      if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, '').indexOf(keyIdHex) !== -1) {\n        keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];\n        delete keyIdToKeySessionPromise[oldKeyIdHex];\n        decryptdata.pssh = new Uint8Array(initData);\n        decryptdata.keyId = keyId;\n        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(() => {\n          return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, 'encrypted-event-key-match');\n        });\n        break;\n      }\n    }\n    if (!keySessionContextPromise) {\n      // Clear-lead key (not encountered in playlist)\n      keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(({\n        keySystem,\n        mediaKeys\n      }) => {\n        var _keySystemToKeySystem;\n        this.throwIfDestroyed();\n        const decryptdata = new LevelKey('ISO-23001-7', keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : '');\n        decryptdata.pssh = new Uint8Array(initData);\n        decryptdata.keyId = keyId;\n        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {\n          this.throwIfDestroyed();\n          const keySessionContext = this.createMediaKeySessionContext({\n            decryptdata,\n            keySystem,\n            mediaKeys\n          });\n          return this.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, 'encrypted-event-no-match');\n        });\n      });\n    }\n    keySessionContextPromise.catch(error => this.handleError(error));\n  }\n  _onWaitingForKey(event) {\n    this.log(`\"${event.type}\" event`);\n  }\n  attemptSetMediaKeys(keySystem, mediaKeys) {\n    const queue = this.setMediaKeysQueue.slice();\n    this.log(`Setting media-keys for \"${keySystem}\"`);\n    // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n    // can be queued for execution for multiple key sessions.\n    const setMediaKeysPromise = Promise.all(queue).then(() => {\n      if (!this.media) {\n        throw new Error('Attempted to set mediaKeys without media element attached');\n      }\n      return this.media.setMediaKeys(mediaKeys);\n    });\n    this.setMediaKeysQueue.push(setMediaKeysPromise);\n    return setMediaKeysPromise.then(() => {\n      this.log(`Media-keys set for \"${keySystem}\"`);\n      queue.push(setMediaKeysPromise);\n      this.setMediaKeysQueue = this.setMediaKeysQueue.filter(p => queue.indexOf(p) === -1);\n    });\n  }\n  generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n    var _this$config$drmSyste, _this$config$drmSyste2;\n    const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;\n    if (generateRequestFilter) {\n      try {\n        const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n        if (!mappedInitData) {\n          throw new Error('Invalid response from configured generateRequest filter');\n        }\n        initDataType = mappedInitData.initDataType;\n        initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;\n      } catch (error) {\n        var _this$hls;\n        this.warn(error.message);\n        if ((_this$hls = this.hls) != null && _this$hls.config.debug) {\n          throw error;\n        }\n      }\n    }\n    if (initData === null) {\n      this.log(`Skipping key-session request for \"${reason}\" (no initData)`);\n      return Promise.resolve(context);\n    }\n    const keyId = this.getKeyIdString(context.decryptdata);\n    this.log(`Generating key-session request for \"${reason}\": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);\n    const licenseStatus = new EventEmitter();\n    context.mediaKeysSession.onmessage = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      const {\n        messageType,\n        message\n      } = event;\n      this.log(`\"${messageType}\" message event for session \"${keySession.sessionId}\" message size: ${message.byteLength}`);\n      if (messageType === 'license-request' || messageType === 'license-renewal') {\n        this.renewLicense(context, message).catch(error => {\n          this.handleError(error);\n          licenseStatus.emit('error', error);\n        });\n      } else if (messageType === 'license-release') {\n        if (context.keySystem === KeySystems.FAIRPLAY) {\n          this.updateKeySession(context, strToUtf8array('acknowledged'));\n          this.removeSession(context);\n        }\n      } else {\n        this.warn(`unhandled media key message type \"${messageType}\"`);\n      }\n    };\n    context.mediaKeysSession.onkeystatuseschange = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      this.onKeyStatusChange(context);\n      const keyStatus = context.keyStatus;\n      licenseStatus.emit('keyStatus', keyStatus);\n      if (keyStatus === 'expired') {\n        this.warn(`${context.keySystem} expired for key ${keyId}`);\n        this.renewKeySession(context);\n      }\n    };\n    const keyUsablePromise = new Promise((resolve, reject) => {\n      licenseStatus.on('error', reject);\n      licenseStatus.on('keyStatus', keyStatus => {\n        if (keyStatus.startsWith('usable')) {\n          resolve();\n        } else if (keyStatus === 'output-restricted') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,\n            fatal: false\n          }, 'HDCP level output restricted'));\n        } else if (keyStatus === 'internal-error') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,\n            fatal: true\n          }, `key status changed to \"${keyStatus}\"`));\n        } else if (keyStatus === 'expired') {\n          reject(new Error('key expired while generating request'));\n        } else {\n          this.warn(`unhandled key status change \"${keyStatus}\"`);\n        }\n      });\n    });\n    return context.mediaKeysSession.generateRequest(initDataType, initData).then(() => {\n      var _context$mediaKeysSes;\n      this.log(`Request generated for key-session \"${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}\" keyId: ${keyId}`);\n    }).catch(error => {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_SESSION,\n        error,\n        fatal: false\n      }, `Error generating key-session request: ${error}`);\n    }).then(() => keyUsablePromise).catch(error => {\n      licenseStatus.removeAllListeners();\n      this.removeSession(context);\n      throw error;\n    }).then(() => {\n      licenseStatus.removeAllListeners();\n      return context;\n    });\n  }\n  onKeyStatusChange(mediaKeySessionContext) {\n    mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status, keyId) => {\n      this.log(`key status change \"${status}\" for keyStatuses keyId: ${Hex.hexDump('buffer' in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);\n      mediaKeySessionContext.keyStatus = status;\n    });\n  }\n  fetchServerCertificate(keySystem) {\n    const config = this.config;\n    const Loader = config.loader;\n    const certLoader = new Loader(config);\n    const url = this.getServerCertificateUrl(keySystem);\n    if (!url) {\n      return Promise.resolve();\n    }\n    this.log(`Fetching serverCertificate for \"${keySystem}\"`);\n    return new Promise((resolve, reject) => {\n      const loaderContext = {\n        responseType: 'arraybuffer',\n        url\n      };\n      const loadPolicy = config.certLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          resolve(response.data);\n        },\n        onError: (response, contex, networkDetails, stats) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response)\n          }, `\"${keySystem}\" certificate request failed (${url}). Status: ${response.code} (${response.text})`));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: {\n              url: loaderContext.url,\n              data: undefined\n            }\n          }, `\"${keySystem}\" certificate request timed out (${url})`));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          reject(new Error('aborted'));\n        }\n      };\n      certLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n    return new Promise((resolve, reject) => {\n      mediaKeys.setServerCertificate(cert).then(success => {\n        this.log(`setServerCertificate ${success ? 'success' : 'not supported by CDM'} (${cert == null ? void 0 : cert.byteLength}) on \"${keySystem}\"`);\n        resolve(mediaKeys);\n      }).catch(error => {\n        reject(new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message));\n      });\n    });\n  }\n  renewLicense(context, keyMessage) {\n    return this.requestLicense(context, new Uint8Array(keyMessage)).then(data => {\n      return this.updateKeySession(context, new Uint8Array(data)).catch(error => {\n        throw new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message);\n      });\n    });\n  }\n  setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n    const licenseXhrSetup = this.config.licenseXhrSetup;\n    if (!licenseXhrSetup) {\n      xhr.open('POST', url, true);\n      return Promise.resolve({\n        xhr,\n        licenseChallenge\n      });\n    }\n    return Promise.resolve().then(() => {\n      if (!keysListItem.decryptdata) {\n        throw new Error('Key removed');\n      }\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).catch(error => {\n      if (!keysListItem.decryptdata) {\n        // Key session removed. Cancel license request.\n        throw error;\n      }\n      // let's try to open before running setup\n      xhr.open('POST', url, true);\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).then(licenseXhrSetupResult => {\n      // if licenseXhrSetup did not yet call open, let's do it now\n      if (!xhr.readyState) {\n        xhr.open('POST', url, true);\n      }\n      const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n      return {\n        xhr,\n        licenseChallenge: finalLicenseChallenge\n      };\n    });\n  }\n  requestLicense(keySessionContext, licenseChallenge) {\n    const keyLoadPolicy = this.config.keyLoadPolicy.default;\n    return new Promise((resolve, reject) => {\n      const url = this.getLicenseServerUrl(keySessionContext.keySystem);\n      this.log(`Sending license request to URL: ${url}`);\n      const xhr = new XMLHttpRequest();\n      xhr.responseType = 'arraybuffer';\n      xhr.onreadystatechange = () => {\n        if (!this.hls || !keySessionContext.mediaKeysSession) {\n          return reject(new Error('invalid state'));\n        }\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            this._requestLicenseFailureCount = 0;\n            let data = xhr.response;\n            this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);\n            const licenseResponseCallback = this.config.licenseResponseCallback;\n            if (licenseResponseCallback) {\n              try {\n                data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);\n              } catch (error) {\n                this.error(error);\n              }\n            }\n            resolve(data);\n          } else {\n            const retryConfig = keyLoadPolicy.errorRetry;\n            const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;\n            this._requestLicenseFailureCount++;\n            if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {\n              reject(new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                fatal: true,\n                networkDetails: xhr,\n                response: {\n                  url,\n                  data: undefined,\n                  code: xhr.status,\n                  text: xhr.statusText\n                }\n              }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));\n            } else {\n              const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;\n              this.warn(`Retrying license request, ${attemptsLeft} attempts left`);\n              this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n            }\n          }\n        }\n      };\n      if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        keySessionContext.licenseXhr.abort();\n      }\n      keySessionContext.licenseXhr = xhr;\n      this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({\n        xhr,\n        licenseChallenge\n      }) => {\n        xhr.send(licenseChallenge);\n      });\n    });\n  }\n  onMediaAttached(event, data) {\n    if (!this.config.emeEnabled) {\n      return;\n    }\n    const media = data.media;\n\n    // keep reference of media\n    this.media = media;\n    media.addEventListener('encrypted', this.onMediaEncrypted);\n    media.addEventListener('waitingforkey', this.onWaitingForKey);\n  }\n  onMediaDetached() {\n    const media = this.media;\n    const mediaKeysList = this.mediaKeySessions;\n    if (media) {\n      media.removeEventListener('encrypted', this.onMediaEncrypted);\n      media.removeEventListener('waitingforkey', this.onWaitingForKey);\n      this.media = null;\n    }\n    this._requestLicenseFailureCount = 0;\n    this.setMediaKeysQueue = [];\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    LevelKey.clearKeyUriToKeyIdMap();\n\n    // Close all sessions and remove media keys from the video element.\n    const keySessionCount = mediaKeysList.length;\n    EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map(mediaKeySessionContext => this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : media.setMediaKeys(null).catch(error => {\n      this.log(`Could not clear media keys: ${error}. media.src: ${media == null ? void 0 : media.src}`);\n    }))).then(() => {\n      if (keySessionCount) {\n        this.log('finished closing key sessions and clearing media keys');\n        mediaKeysList.length = 0;\n      }\n    }).catch(error => {\n      this.log(`Could not close sessions and clear media keys: ${error}. media.src: ${media == null ? void 0 : media.src}`);\n    });\n  }\n  onManifestLoading() {\n    this.keyFormatPromise = null;\n  }\n  onManifestLoaded(event, {\n    sessionKeys\n  }) {\n    if (!sessionKeys || !this.config.emeEnabled) {\n      return;\n    }\n    if (!this.keyFormatPromise) {\n      const keyFormats = sessionKeys.reduce((formats, sessionKey) => {\n        if (formats.indexOf(sessionKey.keyFormat) === -1) {\n          formats.push(sessionKey.keyFormat);\n        }\n        return formats;\n      }, []);\n      this.log(`Selecting key-system from session-keys ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n  }\n  removeSession(mediaKeySessionContext) {\n    const {\n      mediaKeysSession,\n      licenseXhr\n    } = mediaKeySessionContext;\n    if (mediaKeysSession) {\n      this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);\n      mediaKeysSession.onmessage = null;\n      mediaKeysSession.onkeystatuseschange = null;\n      if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        licenseXhr.abort();\n      }\n      mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n      const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n      if (index > -1) {\n        this.mediaKeySessions.splice(index, 1);\n      }\n      return mediaKeysSession.remove().catch(error => {\n        this.log(`Could not remove session: ${error}`);\n      }).then(() => {\n        return mediaKeysSession.close();\n      }).catch(error => {\n        this.log(`Could not close session: ${error}`);\n      });\n    }\n  }\n}\nEMEController.CDMCleanupPromise = void 0;\nclass EMEKeyError extends Error {\n  constructor(data, message) {\n    super(message);\n    this.data = void 0;\n    data.error || (data.error = new Error(message));\n    this.data = data;\n    data.err = data.error;\n  }\n}\n\n/**\n * CMCD spec version\n */\nconst CMCDVersion = 1;\n\n/**\n * CMCD Object Type\n */\nvar CMCDObjectType = {\n  MANIFEST: \"m\",\n  AUDIO: \"a\",\n  VIDEO: \"v\",\n  MUXED: \"av\",\n  INIT: \"i\",\n  CAPTION: \"c\",\n  TIMED_TEXT: \"tt\",\n  KEY: \"k\",\n  OTHER: \"o\"\n};\n\n/**\n * CMCD Streaming Format\n */\nconst CMCDStreamingFormatHLS = 'h';\n\n/**\n * CMCD Streaming Type\n */\n\n/**\n * CMCD Headers\n */\n\n/**\n * CMCD\n */\n\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */\nclass CMCDController {\n  // eslint-disable-line no-restricted-globals\n  // eslint-disable-line no-restricted-globals\n\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = void 0;\n    this.sid = void 0;\n    this.cid = void 0;\n    this.useHeaders = false;\n    this.initialized = false;\n    this.starved = false;\n    this.buffering = true;\n    this.audioBuffer = void 0;\n    this.videoBuffer = void 0;\n    this.onWaiting = () => {\n      if (this.initialized) {\n        this.starved = true;\n      }\n      this.buffering = true;\n    };\n    this.onPlaying = () => {\n      if (!this.initialized) {\n        this.initialized = true;\n      }\n      this.buffering = false;\n    };\n    /**\n     * Apply CMCD data to a manifest request.\n     */\n    this.applyPlaylistData = context => {\n      try {\n        this.apply(context, {\n          ot: CMCDObjectType.MANIFEST,\n          su: !this.initialized\n        });\n      } catch (error) {\n        logger.warn('Could not generate manifest CMCD data.', error);\n      }\n    };\n    /**\n     * Apply CMCD data to a segment request\n     */\n    this.applyFragmentData = context => {\n      try {\n        const fragment = context.frag;\n        const level = this.hls.levels[fragment.level];\n        const ot = this.getObjectType(fragment);\n        const data = {\n          d: fragment.duration * 1000,\n          ot\n        };\n        if (ot === CMCDObjectType.VIDEO || ot === CMCDObjectType.AUDIO || ot == CMCDObjectType.MUXED) {\n          data.br = level.bitrate / 1000;\n          data.tb = this.getTopBandwidth(ot) / 1000;\n          data.bl = this.getBufferLength(ot);\n        }\n        this.apply(context, data);\n      } catch (error) {\n        logger.warn('Could not generate segment CMCD data.', error);\n      }\n    };\n    this.hls = hls;\n    const config = this.config = hls.config;\n    const {\n      cmcd\n    } = config;\n    if (cmcd != null) {\n      config.pLoader = this.createPlaylistLoader();\n      config.fLoader = this.createFragmentLoader();\n      this.sid = cmcd.sessionId || CMCDController.uuid();\n      this.cid = cmcd.contentId;\n      this.useHeaders = cmcd.useHeaders === true;\n      this.registerListeners();\n    }\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetached();\n\n    // @ts-ignore\n    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('waiting', this.onWaiting);\n    this.media.addEventListener('playing', this.onPlaying);\n  }\n  onMediaDetached() {\n    if (!this.media) {\n      return;\n    }\n    this.media.removeEventListener('waiting', this.onWaiting);\n    this.media.removeEventListener('playing', this.onPlaying);\n\n    // @ts-ignore\n    this.media = null;\n  }\n  onBufferCreated(event, data) {\n    var _data$tracks$audio, _data$tracks$video;\n    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;\n    this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;\n  }\n  /**\n   * Create baseline CMCD data\n   */\n  createData() {\n    var _this$media;\n    return {\n      v: CMCDVersion,\n      sf: CMCDStreamingFormatHLS,\n      sid: this.sid,\n      cid: this.cid,\n      pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,\n      mtp: this.hls.bandwidthEstimate / 1000\n    };\n  }\n\n  /**\n   * Apply CMCD data to a request.\n   */\n  apply(context, data = {}) {\n    // apply baseline data\n    _extends(data, this.createData());\n    const isVideo = data.ot === CMCDObjectType.INIT || data.ot === CMCDObjectType.VIDEO || data.ot === CMCDObjectType.MUXED;\n    if (this.starved && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved = false;\n    }\n    if (data.su == null) {\n      data.su = this.buffering;\n    }\n\n    // TODO: Implement rtp, nrr, nor, dl\n\n    if (this.useHeaders) {\n      const headers = CMCDController.toHeaders(data);\n      if (!Object.keys(headers).length) {\n        return;\n      }\n      if (!context.headers) {\n        context.headers = {};\n      }\n      _extends(context.headers, headers);\n    } else {\n      const query = CMCDController.toQuery(data);\n      if (!query) {\n        return;\n      }\n      context.url = CMCDController.appendQueryToUri(context.url, query);\n    }\n  }\n  /**\n   * The CMCD object type.\n   */\n  getObjectType(fragment) {\n    const {\n      type\n    } = fragment;\n    if (type === 'subtitle') {\n      return CMCDObjectType.TIMED_TEXT;\n    }\n    if (fragment.sn === 'initSegment') {\n      return CMCDObjectType.INIT;\n    }\n    if (type === 'audio') {\n      return CMCDObjectType.AUDIO;\n    }\n    if (type === 'main') {\n      if (!this.hls.audioTracks.length) {\n        return CMCDObjectType.MUXED;\n      }\n      return CMCDObjectType.VIDEO;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the highest bitrate.\n   */\n  getTopBandwidth(type) {\n    let bitrate = 0;\n    let levels;\n    const hls = this.hls;\n    if (type === CMCDObjectType.AUDIO) {\n      levels = hls.audioTracks;\n    } else {\n      const max = hls.maxAutoLevel;\n      const len = max > -1 ? max + 1 : hls.levels.length;\n      levels = hls.levels.slice(0, len);\n    }\n    for (const level of levels) {\n      if (level.bitrate > bitrate) {\n        bitrate = level.bitrate;\n      }\n    }\n    return bitrate > 0 ? bitrate : NaN;\n  }\n\n  /**\n   * Get the buffer length for a media type in milliseconds\n   */\n  getBufferLength(type) {\n    const media = this.hls.media;\n    const buffer = type === CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n    if (!buffer || !media) {\n      return NaN;\n    }\n    const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n    return info.len * 1000;\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createPlaylistLoader() {\n    const {\n      pLoader\n    } = this.config;\n    const apply = this.applyPlaylistData;\n    const Ctor = pLoader || this.config.loader;\n    return class CmcdPlaylistLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createFragmentLoader() {\n    const {\n      fLoader\n    } = this.config;\n    const apply = this.applyFragmentData;\n    const Ctor = fLoader || this.config.loader;\n    return class CmcdFragmentLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n\n  /**\n   * Generate a random v4 UUI\n   *\n   * @returns {string}\n   */\n  static uuid() {\n    const url = URL.createObjectURL(new Blob());\n    const uuid = url.toString();\n    URL.revokeObjectURL(url);\n    return uuid.slice(uuid.lastIndexOf('/') + 1);\n  }\n\n  /**\n   * Serialize a CMCD data object according to the rules defined in the\n   * section 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  static serialize(data) {\n    const results = [];\n    const isValid = value => !Number.isNaN(value) && value != null && value !== '' && value !== false;\n    const toRounded = value => Math.round(value);\n    const toHundred = value => toRounded(value / 100) * 100;\n    const toUrlSafe = value => encodeURIComponent(value);\n    const formatters = {\n      br: toRounded,\n      d: toRounded,\n      bl: toHundred,\n      dl: toHundred,\n      mtp: toHundred,\n      nor: toUrlSafe,\n      rtp: toHundred,\n      tb: toRounded\n    };\n    const keys = Object.keys(data || {}).sort();\n    for (const key of keys) {\n      let value = data[key];\n\n      // ignore invalid values\n      if (!isValid(value)) {\n        continue;\n      }\n\n      // Version should only be reported if not equal to 1.\n      if (key === 'v' && value === 1) {\n        continue;\n      }\n\n      // Playback rate should only be sent if not equal to 1.\n      if (key == 'pr' && value === 1) {\n        continue;\n      }\n\n      // Certain values require special formatting\n      const formatter = formatters[key];\n      if (formatter) {\n        value = formatter(value);\n      }\n\n      // Serialize the key/value pair\n      const type = typeof value;\n      let result;\n      if (key === 'ot' || key === 'sf' || key === 'st') {\n        result = `${key}=${value}`;\n      } else if (type === 'boolean') {\n        result = key;\n      } else if (type === 'number') {\n        result = `${key}=${value}`;\n      } else {\n        result = `${key}=${JSON.stringify(value)}`;\n      }\n      results.push(result);\n    }\n    return results.join(',');\n  }\n\n  /**\n   * Convert a CMCD data object to request headers according to the rules\n   * defined in the section 2.1 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  static toHeaders(data) {\n    const keys = Object.keys(data);\n    const headers = {};\n    const headerNames = ['Object', 'Request', 'Session', 'Status'];\n    const headerGroups = [{}, {}, {}, {}];\n    const headerMap = {\n      br: 0,\n      d: 0,\n      ot: 0,\n      tb: 0,\n      bl: 1,\n      dl: 1,\n      mtp: 1,\n      nor: 1,\n      nrr: 1,\n      su: 1,\n      cid: 2,\n      pr: 2,\n      sf: 2,\n      sid: 2,\n      st: 2,\n      v: 2,\n      bs: 3,\n      rtp: 3\n    };\n    for (const key of keys) {\n      // Unmapped fields are mapped to the Request header\n      const index = headerMap[key] != null ? headerMap[key] : 1;\n      headerGroups[index][key] = data[key];\n    }\n    for (let i = 0; i < headerGroups.length; i++) {\n      const value = CMCDController.serialize(headerGroups[i]);\n      if (value) {\n        headers[`CMCD-${headerNames[i]}`] = value;\n      }\n    }\n    return headers;\n  }\n\n  /**\n   * Convert a CMCD data object to query args according to the rules\n   * defined in the section 2.2 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  static toQuery(data) {\n    return `CMCD=${encodeURIComponent(CMCDController.serialize(data))}`;\n  }\n\n  /**\n   * Append query args to a uri.\n   */\n  static appendQueryToUri(uri, query) {\n    if (!query) {\n      return uri;\n    }\n    const separator = uri.includes('?') ? '&' : '?';\n    return `${uri}${separator}${query}`;\n  }\n}\n\nconst PATHWAY_PENALTY_DURATION_MS = 300000;\nclass ContentSteeringController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.log = void 0;\n    this.loader = null;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.pathwayPriority = null;\n    this.timeToLoad = 300;\n    this.reloadTimer = -1;\n    this.updated = 0;\n    this.started = false;\n    this.enabled = true;\n    this.levels = null;\n    this.audioTracks = null;\n    this.subtitleTracks = null;\n    this.penalizedPathways = {};\n    this.hls = hls;\n    this.log = logger.log.bind(logger, `[content-steering]:`);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  startLoad() {\n    this.started = true;\n    self.clearTimeout(this.reloadTimer);\n    if (this.enabled && this.uri) {\n      if (this.updated) {\n        const ttl = Math.max(this.timeToLoad * 1000 - (performance.now() - this.updated), 0);\n        this.scheduleRefresh(this.uri, ttl);\n      } else {\n        this.loadSteeringManifest(this.uri);\n      }\n    }\n  }\n  stopLoad() {\n    this.started = false;\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n    self.clearTimeout(this.reloadTimer);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.stopLoad();\n    // @ts-ignore\n    this.hls = null;\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  removeLevel(levelToRemove) {\n    const levels = this.levels;\n    if (levels) {\n      this.levels = levels.filter(level => level !== levelToRemove);\n    }\n  }\n  onManifestLoading() {\n    this.stopLoad();\n    this.enabled = true;\n    this.timeToLoad = 300;\n    this.updated = 0;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  onManifestLoaded(event, data) {\n    const {\n      contentSteering\n    } = data;\n    if (contentSteering === null) {\n      return;\n    }\n    this.pathwayId = contentSteering.pathwayId;\n    this.uri = contentSteering.uri;\n    if (this.started) {\n      this.startLoad();\n    }\n  }\n  onManifestParsed(event, data) {\n    this.audioTracks = data.audioTracks;\n    this.subtitleTracks = data.subtitleTracks;\n  }\n  onError(event, data) {\n    const {\n      errorAction\n    } = data;\n    if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n      let pathwayPriority = this.pathwayPriority;\n      const pathwayId = this.pathwayId;\n      if (!this.penalizedPathways[pathwayId]) {\n        this.penalizedPathways[pathwayId] = performance.now();\n      }\n      if (!pathwayPriority && this.levels) {\n        // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n        pathwayPriority = this.levels.reduce((pathways, level) => {\n          if (pathways.indexOf(level.pathwayId) === -1) {\n            pathways.push(level.pathwayId);\n          }\n          return pathways;\n        }, []);\n      }\n      if (pathwayPriority && pathwayPriority.length > 1) {\n        this.updatePathwayPriority(pathwayPriority);\n        errorAction.resolved = this.pathwayId !== pathwayId;\n      }\n    }\n  }\n  filterParsedLevels(levels) {\n    // Filter levels to only include those that are in the initial pathway\n    this.levels = levels;\n    let pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n    if (pathwayLevels.length === 0) {\n      const pathwayId = levels[0].pathwayId;\n      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to \"${pathwayId}\"`);\n      pathwayLevels = this.getLevelsForPathway(pathwayId);\n      this.pathwayId = pathwayId;\n    }\n    if (pathwayLevels.length !== levels.length) {\n      this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway \"${this.pathwayId}\"`);\n      return pathwayLevels;\n    }\n    return levels;\n  }\n  getLevelsForPathway(pathwayId) {\n    if (this.levels === null) {\n      return [];\n    }\n    return this.levels.filter(level => pathwayId === level.pathwayId);\n  }\n  updatePathwayPriority(pathwayPriority) {\n    this.pathwayPriority = pathwayPriority;\n    let levels;\n\n    // Evaluate if we should remove the pathway from the penalized list\n    const penalizedPathways = this.penalizedPathways;\n    const now = performance.now();\n    Object.keys(penalizedPathways).forEach(pathwayId => {\n      if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n        delete penalizedPathways[pathwayId];\n      }\n    });\n    for (let i = 0; i < pathwayPriority.length; i++) {\n      const pathwayId = pathwayPriority[i];\n      if (penalizedPathways[pathwayId]) {\n        continue;\n      }\n      if (pathwayId === this.pathwayId) {\n        return;\n      }\n      const selectedIndex = this.hls.nextLoadLevel;\n      const selectedLevel = this.hls.levels[selectedIndex];\n      levels = this.getLevelsForPathway(pathwayId);\n      if (levels.length > 0) {\n        this.log(`Setting Pathway to \"${pathwayId}\"`);\n        this.pathwayId = pathwayId;\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n          levels\n        });\n        // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n        const levelAfterChange = this.hls.levels[selectedIndex];\n        if (selectedLevel && levelAfterChange && this.levels) {\n          if (levelAfterChange.attrs['STABLE-VARIANT-ID'] !== selectedLevel.attrs['STABLE-VARIANT-ID'] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n            this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);\n          }\n          this.hls.nextLoadLevel = selectedIndex;\n        }\n        break;\n      }\n    }\n  }\n  clonePathways(pathwayClones) {\n    const levels = this.levels;\n    if (!levels) {\n      return;\n    }\n    const audioGroupCloneMap = {};\n    const subtitleGroupCloneMap = {};\n    pathwayClones.forEach(pathwayClone => {\n      const {\n        ID: cloneId,\n        'BASE-ID': baseId,\n        'URI-REPLACEMENT': uriReplacement\n      } = pathwayClone;\n      if (levels.some(level => level.pathwayId === cloneId)) {\n        return;\n      }\n      const clonedVariants = this.getLevelsForPathway(baseId).map(baseLevel => {\n        const levelParsed = _extends({}, baseLevel);\n        levelParsed.details = undefined;\n        levelParsed.url = performUriReplacement(baseLevel.uri, baseLevel.attrs['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', uriReplacement);\n        const attributes = new AttrList(baseLevel.attrs);\n        attributes['PATHWAY-ID'] = cloneId;\n        const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;\n        const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;\n        if (clonedAudioGroupId) {\n          audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n          attributes.AUDIO = clonedAudioGroupId;\n        }\n        if (clonedSubtitleGroupId) {\n          subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n          attributes.SUBTITLES = clonedSubtitleGroupId;\n        }\n        levelParsed.attrs = attributes;\n        const clonedLevel = new Level(levelParsed);\n        addGroupId(clonedLevel, 'audio', clonedAudioGroupId);\n        addGroupId(clonedLevel, 'text', clonedSubtitleGroupId);\n        return clonedLevel;\n      });\n      levels.push(...clonedVariants);\n      cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n      cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n    });\n  }\n  loadSteeringManifest(uri) {\n    const config = this.hls.config;\n    const Loader = config.loader;\n    if (this.loader) {\n      this.loader.destroy();\n    }\n    this.loader = new Loader(config);\n    let url;\n    try {\n      url = new self.URL(uri);\n    } catch (error) {\n      this.enabled = false;\n      this.log(`Failed to parse Steering Manifest URI: ${uri}`);\n      return;\n    }\n    if (url.protocol !== 'data:') {\n      const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n      url.searchParams.set('_HLS_pathway', this.pathwayId);\n      url.searchParams.set('_HLS_throughput', '' + throughput);\n    }\n    const context = {\n      responseType: 'json',\n      url: url.href\n    };\n    const loadPolicy = config.steeringManifestLoadPolicy.default;\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const callbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        this.log(`Loaded steering manifest: \"${url}\"`);\n        const steeringData = response.data;\n        if (steeringData.VERSION !== 1) {\n          this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);\n          return;\n        }\n        this.updated = performance.now();\n        this.timeToLoad = steeringData.TTL;\n        const {\n          'RELOAD-URI': reloadUri,\n          'PATHWAY-CLONES': pathwayClones,\n          'PATHWAY-PRIORITY': pathwayPriority\n        } = steeringData;\n        if (reloadUri) {\n          try {\n            this.uri = new self.URL(reloadUri, url).href;\n          } catch (error) {\n            this.enabled = false;\n            this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);\n            return;\n          }\n        }\n        this.scheduleRefresh(this.uri || context.url);\n        if (pathwayClones) {\n          this.clonePathways(pathwayClones);\n        }\n        if (pathwayPriority) {\n          this.updatePathwayPriority(pathwayPriority);\n        }\n      },\n      onError: (error, context, networkDetails, stats) => {\n        this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context.url})`);\n        this.stopLoad();\n        if (error.code === 410) {\n          this.enabled = false;\n          this.log(`Steering manifest ${context.url} no longer available`);\n          return;\n        }\n        let ttl = this.timeToLoad * 1000;\n        if (error.code === 429) {\n          const loader = this.loader;\n          if (typeof (loader == null ? void 0 : loader.getResponseHeader) === 'function') {\n            const retryAfter = loader.getResponseHeader('Retry-After');\n            if (retryAfter) {\n              ttl = parseFloat(retryAfter) * 1000;\n            }\n          }\n          this.log(`Steering manifest ${context.url} rate limited`);\n          return;\n        }\n        this.scheduleRefresh(this.uri || context.url, ttl);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.log(`Timeout loading steering manifest (${context.url})`);\n        this.scheduleRefresh(this.uri || context.url);\n      }\n    };\n    this.log(`Requesting steering manifest: ${url}`);\n    this.loader.load(context, loaderConfig, callbacks);\n  }\n  scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {\n    self.clearTimeout(this.reloadTimer);\n    this.reloadTimer = self.setTimeout(() => {\n      this.loadSteeringManifest(uri);\n    }, ttlMs);\n  }\n}\nfunction cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n  if (!tracks) {\n    return;\n  }\n  Object.keys(groupCloneMap).forEach(audioGroupId => {\n    const clonedTracks = tracks.filter(track => track.groupId === audioGroupId).map(track => {\n      const clonedTrack = _extends({}, track);\n      clonedTrack.details = undefined;\n      clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n      clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', uriReplacement);\n      clonedTrack.groupId = clonedTrack.attrs['GROUP-ID'] = groupCloneMap[audioGroupId];\n      clonedTrack.attrs['PATHWAY-ID'] = cloneId;\n      return clonedTrack;\n    });\n    tracks.push(...clonedTracks);\n  });\n}\nfunction performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n  const {\n    HOST: host,\n    PARAMS: params,\n    [perOptionKey]: perOptionUris\n  } = uriReplacement;\n  let perVariantUri;\n  if (stableId) {\n    perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n    if (perVariantUri) {\n      uri = perVariantUri;\n    }\n  }\n  const url = new self.URL(uri);\n  if (host && !perVariantUri) {\n    url.host = host;\n  }\n  if (params) {\n    Object.keys(params).sort().forEach(key => {\n      if (key) {\n        url.searchParams.set(key, params[key]);\n      }\n    });\n  }\n  return url.href;\n}\n\nconst AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\nclass XhrLoader {\n  constructor(config) {\n    this.xhrSetup = void 0;\n    this.requestTimeout = void 0;\n    this.retryTimeout = void 0;\n    this.retryDelay = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.context = void 0;\n    this.loader = null;\n    this.stats = void 0;\n    this.xhrSetup = config ? config.xhrSetup || null : null;\n    this.stats = new LoadStats();\n    this.retryDelay = 0;\n  }\n  destroy() {\n    this.callbacks = null;\n    this.abortInternal();\n    this.loader = null;\n    this.config = null;\n  }\n  abortInternal() {\n    const loader = this.loader;\n    self.clearTimeout(this.requestTimeout);\n    self.clearTimeout(this.retryTimeout);\n    if (loader) {\n      loader.onreadystatechange = null;\n      loader.onprogress = null;\n      if (loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.loader);\n    }\n  }\n  load(context, config, callbacks) {\n    if (this.stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    this.stats.loading.start = self.performance.now();\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.loadInternal();\n  }\n  loadInternal() {\n    const {\n      config,\n      context\n    } = this;\n    if (!config) {\n      return;\n    }\n    const xhr = this.loader = new self.XMLHttpRequest();\n    const stats = this.stats;\n    stats.loading.first = 0;\n    stats.loaded = 0;\n    stats.aborted = false;\n    const xhrSetup = this.xhrSetup;\n    if (xhrSetup) {\n      Promise.resolve().then(() => {\n        if (this.stats.aborted) return;\n        return xhrSetup(xhr, context.url);\n      }).catch(error => {\n        xhr.open('GET', context.url, true);\n        return xhrSetup(xhr, context.url);\n      }).then(() => {\n        if (this.stats.aborted) return;\n        this.openAndSendXhr(xhr, context, config);\n      }).catch(error => {\n        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n        this.callbacks.onError({\n          code: xhr.status,\n          text: error.message\n        }, context, xhr, stats);\n        return;\n      });\n    } else {\n      this.openAndSendXhr(xhr, context, config);\n    }\n  }\n  openAndSendXhr(xhr, context, config) {\n    if (!xhr.readyState) {\n      xhr.open('GET', context.url, true);\n    }\n    const headers = this.context.headers;\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    if (headers) {\n      for (const header in headers) {\n        xhr.setRequestHeader(header, headers[header]);\n      }\n    }\n    if (context.rangeEnd) {\n      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n    }\n    xhr.onreadystatechange = this.readystatechange.bind(this);\n    xhr.onprogress = this.loadprogress.bind(this);\n    xhr.responseType = context.responseType;\n    // setup timeout before we perform request\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n    xhr.send();\n  }\n  readystatechange() {\n    const {\n      context,\n      loader: xhr,\n      stats\n    } = this;\n    if (!context || !xhr) {\n      return;\n    }\n    const readyState = xhr.readyState;\n    const config = this.config;\n\n    // don't proceed if xhr has been aborted\n    if (stats.aborted) {\n      return;\n    }\n\n    // >= HEADERS_RECEIVED\n    if (readyState >= 2) {\n      if (stats.loading.first === 0) {\n        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n        if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n          self.clearTimeout(this.requestTimeout);\n          config.timeout = config.loadPolicy.maxLoadTimeMs;\n          this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n        }\n      }\n      if (readyState === 4) {\n        self.clearTimeout(this.requestTimeout);\n        xhr.onreadystatechange = null;\n        xhr.onprogress = null;\n        const status = xhr.status;\n        // http status between 200 to 299 are all successful\n        const useResponse = xhr.responseType !== 'text';\n        if (status >= 200 && status < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {\n          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n          const data = useResponse ? xhr.response : xhr.responseText;\n          const len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n          stats.loaded = stats.total = len;\n          stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n          if (!this.callbacks) {\n            return;\n          }\n          const onProgress = this.callbacks.onProgress;\n          if (onProgress) {\n            onProgress(stats, context, data, xhr);\n          }\n          if (!this.callbacks) {\n            return;\n          }\n          const response = {\n            url: xhr.responseURL,\n            data: data,\n            code: status\n          };\n          this.callbacks.onSuccess(response, stats, context, xhr);\n        } else {\n          const retryConfig = config.loadPolicy.errorRetry;\n          const retryCount = stats.retry;\n          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n          if (shouldRetry(retryConfig, retryCount, false, status)) {\n            this.retry(retryConfig);\n          } else {\n            logger.error(`${status} while loading ${context.url}`);\n            this.callbacks.onError({\n              code: status,\n              text: xhr.statusText\n            }, context, xhr, stats);\n          }\n        }\n      }\n    }\n  }\n  loadtimeout() {\n    var _this$config;\n    const retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;\n    const retryCount = this.stats.retry;\n    if (shouldRetry(retryConfig, retryCount, true)) {\n      this.retry(retryConfig);\n    } else {\n      logger.warn(`timeout while loading ${this.context.url}`);\n      const callbacks = this.callbacks;\n      if (callbacks) {\n        this.abortInternal();\n        callbacks.onTimeout(this.stats, this.context, this.loader);\n      }\n    }\n  }\n  retry(retryConfig) {\n    const {\n      context,\n      stats\n    } = this;\n    this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n    stats.retry++;\n    logger.warn(`${status ? 'HTTP Status ' + status : 'Timeout'} while loading ${context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);\n    // abort and reset internal state\n    this.abortInternal();\n    this.loader = null;\n    // schedule retry\n    self.clearTimeout(this.retryTimeout);\n    this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n  }\n  loadprogress(event) {\n    const stats = this.stats;\n    stats.loaded = event.loaded;\n    if (event.lengthComputable) {\n      stats.total = event.total;\n    }\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n      const ageHeader = this.loader.getResponseHeader('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    if (this.loader && new RegExp(`^${name}:\\\\s*[\\\\d.]+\\\\s*$`, 'im').test(this.loader.getAllResponseHeaders())) {\n      return this.loader.getResponseHeader(name);\n    }\n    return null;\n  }\n}\n\nfunction fetchSupported() {\n  if (\n  // @ts-ignore\n  self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n    try {\n      new self.ReadableStream({}); // eslint-disable-line no-new\n      return true;\n    } catch (e) {\n      /* noop */\n    }\n  }\n  return false;\n}\nconst BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\nclass FetchLoader {\n  constructor(config /* HlsConfig */) {\n    this.fetchSetup = void 0;\n    this.requestTimeout = void 0;\n    this.request = void 0;\n    this.response = void 0;\n    this.controller = void 0;\n    this.context = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.stats = void 0;\n    this.loader = null;\n    this.fetchSetup = config.fetchSetup || getRequest;\n    this.controller = new self.AbortController();\n    this.stats = new LoadStats();\n  }\n  destroy() {\n    this.loader = this.callbacks = null;\n    this.abortInternal();\n  }\n  abortInternal() {\n    const response = this.response;\n    if (!(response != null && response.ok)) {\n      this.stats.aborted = true;\n      this.controller.abort();\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.response);\n    }\n  }\n  load(context, config, callbacks) {\n    const stats = this.stats;\n    if (stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    stats.loading.start = self.performance.now();\n    const initParams = getRequestParameters(context, this.controller.signal);\n    const onProgress = callbacks.onProgress;\n    const isArrayBuffer = context.responseType === 'arraybuffer';\n    const LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.request = this.fetchSetup(context, initParams);\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(() => {\n      this.abortInternal();\n      callbacks.onTimeout(stats, context, this.response);\n    }, config.timeout);\n    self.fetch(this.request).then(response => {\n      this.response = this.loader = response;\n      const first = Math.max(self.performance.now(), stats.loading.start);\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(() => {\n        this.abortInternal();\n        callbacks.onTimeout(stats, context, this.response);\n      }, maxLoadTimeMs - (first - stats.loading.start));\n      if (!response.ok) {\n        const {\n          status,\n          statusText\n        } = response;\n        throw new FetchError(statusText || 'fetch, bad network response', status, response);\n      }\n      stats.loading.first = first;\n      stats.total = getContentLength(response.headers) || stats.total;\n      if (onProgress && isFiniteNumber(config.highWaterMark)) {\n        return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n      }\n      if (isArrayBuffer) {\n        return response.arrayBuffer();\n      }\n      if (context.responseType === 'json') {\n        return response.json();\n      }\n      return response.text();\n    }).then(responseData => {\n      const {\n        response\n      } = this;\n      self.clearTimeout(this.requestTimeout);\n      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n      const total = responseData[LENGTH];\n      if (total) {\n        stats.loaded = stats.total = total;\n      }\n      const loaderResponse = {\n        url: response.url,\n        data: responseData,\n        code: response.status\n      };\n      if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n        onProgress(stats, context, responseData, response);\n      }\n      callbacks.onSuccess(loaderResponse, stats, context, response);\n    }).catch(error => {\n      self.clearTimeout(this.requestTimeout);\n      if (stats.aborted) {\n        return;\n      }\n      // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n      // when destroying, 'error' itself can be undefined\n      const code = !error ? 0 : error.code || 0;\n      const text = !error ? null : error.message;\n      callbacks.onError({\n        code,\n        text\n      }, context, error ? error.details : null, stats);\n    });\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.response) {\n      const ageHeader = this.response.headers.get('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    return this.response ? this.response.headers.get(name) : null;\n  }\n  loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {\n    const chunkCache = new ChunkCache();\n    const reader = response.body.getReader();\n    const pump = () => {\n      return reader.read().then(data => {\n        if (data.done) {\n          if (chunkCache.dataLength) {\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n          return Promise.resolve(new ArrayBuffer(0));\n        }\n        const chunk = data.value;\n        const len = chunk.length;\n        stats.loaded += len;\n        if (len < highWaterMark || chunkCache.dataLength) {\n          // The current chunk is too small to to be emitted or the cache already has data\n          // Push it to the cache\n          chunkCache.push(chunk);\n          if (chunkCache.dataLength >= highWaterMark) {\n            // flush in order to join the typed arrays\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n        } else {\n          // If there's nothing cached already, and the chache is large enough\n          // just emit the progress event\n          onProgress(stats, context, chunk, response);\n        }\n        return pump();\n      }).catch(() => {\n        /* aborted */\n        return Promise.reject();\n      });\n    };\n    return pump();\n  }\n}\nfunction getRequestParameters(context, signal) {\n  const initParams = {\n    method: 'GET',\n    mode: 'cors',\n    credentials: 'same-origin',\n    signal,\n    headers: new self.Headers(_extends({}, context.headers))\n  };\n  if (context.rangeEnd) {\n    initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n  }\n  return initParams;\n}\nfunction getByteRangeLength(byteRangeHeader) {\n  const result = BYTERANGE.exec(byteRangeHeader);\n  if (result) {\n    return parseInt(result[2]) - parseInt(result[1]) + 1;\n  }\n}\nfunction getContentLength(headers) {\n  const contentRange = headers.get('Content-Range');\n  if (contentRange) {\n    const byteRangeLength = getByteRangeLength(contentRange);\n    if (isFiniteNumber(byteRangeLength)) {\n      return byteRangeLength;\n    }\n  }\n  const contentLength = headers.get('Content-Length');\n  if (contentLength) {\n    return parseInt(contentLength);\n  }\n}\nfunction getRequest(context, initParams) {\n  return new self.Request(context.url, initParams);\n}\nclass FetchError extends Error {\n  constructor(message, code, details) {\n    super(message);\n    this.code = void 0;\n    this.details = void 0;\n    this.code = code;\n    this.details = details;\n  }\n}\n\nconst WHITESPACE_CHAR = /\\s/;\nconst Cues = {\n  newCue(track, startTime, endTime, captionScreen) {\n    const result = [];\n    let row;\n    // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n    let cue;\n    let indenting;\n    let indent;\n    let text;\n    const Cue = self.VTTCue || self.TextTrackCue;\n    for (let r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n      if (!row.isEmpty()) {\n        var _track$cues;\n        for (let c = 0; c < row.chars.length; c++) {\n          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        }\n        // To be used for cleaning-up orphaned roll-up captions\n        row.cueStartTime = startTime;\n\n        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n        if (startTime === endTime) {\n          endTime += 0.0001;\n        }\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n        const cueText = fixLineBreaks(text.trim());\n        const id = generateCueId(startTime, endTime, cueText);\n\n        // If this cue already exists in the track do not push it\n        if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {\n          cue = new Cue(startTime, endTime, cueText);\n          cue.id = id;\n          cue.line = r + 1;\n          cue.align = 'left';\n          // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n          // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n          // Firefox throws an exception and captions break with out of bounds 0-100 values\n          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n          result.push(cue);\n        }\n      }\n    }\n    if (track && result.length) {\n      // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n      result.sort((cueA, cueB) => {\n        if (cueA.line === 'auto' || cueB.line === 'auto') {\n          return 0;\n        }\n        if (cueA.line > 8 && cueB.line > 8) {\n          return cueB.line - cueA.line;\n        }\n        return cueA.line - cueB.line;\n      });\n      result.forEach(cue => addCueToTrack(track, cue));\n    }\n    return result;\n  }\n};\n\n/**\n * @deprecated use fragLoadPolicy.default\n */\n\n/**\n * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n */\n\nconst defaultLoadPolicy = {\n  maxTimeToFirstByteMs: 8000,\n  maxLoadTimeMs: 20000,\n  timeoutRetry: null,\n  errorRetry: null\n};\n\n/**\n * @ignore\n * If possible, keep hlsDefaultConfig shallow\n * It is cloned whenever a new Hls instance is created, by keeping the config\n * shallow the properties are cloned, and we don't end up manipulating the default\n */\nconst hlsDefaultConfig = _objectSpread2(_objectSpread2({\n  autoStartLoad: true,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: undefined,\n  // used by stream-controller\n  debug: false,\n  // used by logger\n  capLevelOnFPSDrop: false,\n  // used by fps-controller\n  capLevelToPlayerSize: false,\n  // used by cap-level-controller\n  ignoreDevicePixelRatio: false,\n  // used by cap-level-controller\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: Infinity,\n  // used by buffer-controller\n  maxBufferSize: 60 * 1000 * 1000,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller\n  highBufferWatchdogPeriod: 2,\n  // used by stream-controller\n  nudgeOffset: 0.1,\n  // used by stream-controller\n  nudgeMaxRetry: 3,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: Infinity,\n  // used by latency-controller\n  liveSyncDuration: undefined,\n  // used by latency-controller\n  liveMaxLatencyDuration: undefined,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: false,\n  // used by buffer-controller\n  /**\n   * @deprecated use backBufferLength\n   */\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: true,\n  // used by transmuxer\n  workerPath: null,\n  // used by transmuxer\n  enableSoftwareAES: true,\n  // used by decrypter\n  startLevel: undefined,\n  // used by level-controller\n  startFragPrefetch: false,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5000,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  loader: XhrLoader,\n  // loader: FetchLoader,\n  fLoader: undefined,\n  // used by fragment-loader\n  pLoader: undefined,\n  // used by playlist-loader\n  xhrSetup: undefined,\n  // used by xhr-loader\n  licenseXhrSetup: undefined,\n  // used by eme-controller\n  licenseResponseCallback: undefined,\n  // used by eme-controller\n  abrController: AbrController,\n  bufferController: BufferController,\n  capLevelController: CapLevelController,\n  errorController: ErrorController,\n  fpsController: FPSController,\n  stretchShortVideoTrack: false,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: true,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: false,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: false,\n  // used by eme-controller\n  widevineLicenseUrl: undefined,\n  // used by eme-controller\n  drmSystems: {},\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess ,\n  // used by eme-controller\n  testBandwidth: true,\n  progressive: false,\n  lowLatencyMode: true,\n  cmcd: undefined,\n  enableDateRangeMetadataCues: true,\n  enableEmsgMetadataCues: true,\n  enableID3MetadataCues: true,\n  certLoadPolicy: {\n    default: defaultLoadPolicy\n  },\n  keyLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 8000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      },\n      errorRetry: {\n        maxNumRetry: 8,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      }\n    }\n  },\n  manifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: Infinity,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  playlistLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  fragLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 120000,\n      timeoutRetry: {\n        maxNumRetry: 4,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 6,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  steeringManifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    } \n  },\n  // These default settings are deprecated in favor of the above policies\n  // and are maintained for backwards compatibility\n  manifestLoadingTimeOut: 10000,\n  manifestLoadingMaxRetry: 1,\n  manifestLoadingRetryDelay: 1000,\n  manifestLoadingMaxRetryTimeout: 64000,\n  levelLoadingTimeOut: 10000,\n  levelLoadingMaxRetry: 4,\n  levelLoadingRetryDelay: 1000,\n  levelLoadingMaxRetryTimeout: 64000,\n  fragLoadingTimeOut: 20000,\n  fragLoadingMaxRetry: 6,\n  fragLoadingRetryDelay: 1000,\n  fragLoadingMaxRetryTimeout: 64000\n}, timelineConfig()), {}, {\n  subtitleStreamController: SubtitleStreamController ,\n  subtitleTrackController: SubtitleTrackController ,\n  timelineController: TimelineController ,\n  audioStreamController: AudioStreamController ,\n  audioTrackController: AudioTrackController ,\n  emeController: EMEController ,\n  cmcdController: CMCDController ,\n  contentSteeringController: ContentSteeringController \n});\nfunction timelineConfig() {\n  return {\n    cueHandler: Cues,\n    // used by timeline-controller\n    enableWebVTT: true,\n    // used by timeline-controller\n    enableIMSC1: true,\n    // used by timeline-controller\n    enableCEA708Captions: true,\n    // used by timeline-controller\n    captionsTextTrack1Label: 'English',\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: 'en',\n    // used by timeline-controller\n    captionsTextTrack2Label: 'Spanish',\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: 'es',\n    // used by timeline-controller\n    captionsTextTrack3Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: '',\n    // used by timeline-controller\n    captionsTextTrack4Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: '',\n    // used by timeline-controller\n    renderTextTracksNatively: true\n  };\n}\n\n/**\n * @ignore\n */\nfunction mergeConfig(defaultConfig, userConfig) {\n  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  }\n  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  }\n  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  }\n  const defaultsCopy = deepCpy(defaultConfig);\n\n  // Backwards compatibility with deprecated config values\n  const deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n  const deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n  deprecatedSettingTypes.forEach(type => {\n    const policyName = `${type === 'level' ? 'playlist' : type}LoadPolicy`;\n    const policyNotSet = userConfig[policyName] === undefined;\n    const report = [];\n    deprecatedSettings.forEach(setting => {\n      const deprecatedSetting = `${type}Loading${setting}`;\n      const value = userConfig[deprecatedSetting];\n      if (value !== undefined && policyNotSet) {\n        report.push(deprecatedSetting);\n        const settings = defaultsCopy[policyName].default;\n        userConfig[policyName] = {\n          default: settings\n        };\n        switch (setting) {\n          case 'TimeOut':\n            settings.maxLoadTimeMs = value;\n            settings.maxTimeToFirstByteMs = value;\n            break;\n          case 'MaxRetry':\n            settings.errorRetry.maxNumRetry = value;\n            settings.timeoutRetry.maxNumRetry = value;\n            break;\n          case 'RetryDelay':\n            settings.errorRetry.retryDelayMs = value;\n            settings.timeoutRetry.retryDelayMs = value;\n            break;\n          case 'MaxRetryTimeout':\n            settings.errorRetry.maxRetryDelayMs = value;\n            settings.timeoutRetry.maxRetryDelayMs = value;\n            break;\n        }\n      }\n    });\n    if (report.length) {\n      logger.warn(`hls.js config: \"${report.join('\", \"')}\" setting(s) are deprecated, use \"${policyName}\": ${JSON.stringify(userConfig[policyName])}`);\n    }\n  });\n  return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n}\nfunction deepCpy(obj) {\n  if (obj && typeof obj === 'object') {\n    if (Array.isArray(obj)) {\n      return obj.map(deepCpy);\n    }\n    return Object.keys(obj).reduce((result, key) => {\n      result[key] = deepCpy(obj[key]);\n      return result;\n    }, {});\n  }\n  return obj;\n}\n\n/**\n * @ignore\n */\nfunction enableStreamingMode(config) {\n  const currentLoader = config.loader;\n  if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n    // If a developer has configured their own loader, respect that choice\n    logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n    config.progressive = false;\n  } else {\n    const canStreamProgressively = fetchSupported();\n    if (canStreamProgressively) {\n      config.loader = FetchLoader;\n      config.progressive = true;\n      config.enableSoftwareAES = true;\n      logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n    }\n  }\n}\n\n/**\n * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n * @public\n */\nclass Hls {\n  /**\n   * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n   */\n\n  /**\n   * The configuration object provided on player instantiation.\n   */\n\n  /**\n   * Get the video-dev/hls.js package version.\n   */\n  static get version() {\n    return \"1.4.12\";\n  }\n\n  /**\n   * Check if the required MediaSource Extensions are available.\n   */\n  static isSupported() {\n    return isSupported();\n  }\n  static get Events() {\n    return Events;\n  }\n  static get ErrorTypes() {\n    return ErrorTypes;\n  }\n  static get ErrorDetails() {\n    return ErrorDetails;\n  }\n\n  /**\n   * Get the default configuration applied to new instances.\n   */\n  static get DefaultConfig() {\n    if (!Hls.defaultConfig) {\n      return hlsDefaultConfig;\n    }\n    return Hls.defaultConfig;\n  }\n\n  /**\n   * Replace the default configuration applied to new instances.\n   */\n  static set DefaultConfig(defaultConfig) {\n    Hls.defaultConfig = defaultConfig;\n  }\n\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n   */\n  constructor(userConfig = {}) {\n    this.config = void 0;\n    this.userConfig = void 0;\n    this.coreComponents = void 0;\n    this.networkControllers = void 0;\n    this._emitter = new EventEmitter();\n    this._autoLevelCapping = void 0;\n    this._maxHdcpLevel = null;\n    this.abrController = void 0;\n    this.bufferController = void 0;\n    this.capLevelController = void 0;\n    this.latencyController = void 0;\n    this.levelController = void 0;\n    this.streamController = void 0;\n    this.audioTrackController = void 0;\n    this.subtitleTrackController = void 0;\n    this.emeController = void 0;\n    this.cmcdController = void 0;\n    this._media = null;\n    this.url = null;\n    enableLogs(userConfig.debug || false, 'Hls instance');\n    const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);\n    this.userConfig = userConfig;\n    this._autoLevelCapping = -1;\n    if (config.progressive) {\n      enableStreamingMode(config);\n    }\n\n    // core controllers and network loaders\n    const {\n      abrController: ConfigAbrController,\n      bufferController: ConfigBufferController,\n      capLevelController: ConfigCapLevelController,\n      errorController: ConfigErrorController,\n      fpsController: ConfigFpsController\n    } = config;\n    const errorController = new ConfigErrorController(this);\n    const abrController = this.abrController = new ConfigAbrController(this);\n    const bufferController = this.bufferController = new ConfigBufferController(this);\n    const capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n    const fpsController = new ConfigFpsController(this);\n    const playListLoader = new PlaylistLoader(this);\n    const id3TrackController = new ID3TrackController(this);\n    const ConfigContentSteeringController = config.contentSteeringController;\n    // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first\n    const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;\n    const levelController = this.levelController = new LevelController(this, contentSteering);\n    // FragmentTracker must be defined before StreamController because the order of event handling is important\n    const fragmentTracker = new FragmentTracker(this);\n    const keyLoader = new KeyLoader(this.config);\n    const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n\n    // Cap level controller uses streamController to flush the buffer\n    capLevelController.setStreamController(streamController);\n    // fpsController uses streamController to switch when frames are being dropped\n    fpsController.setStreamController(streamController);\n    const networkControllers = [playListLoader, levelController, streamController];\n    if (contentSteering) {\n      networkControllers.splice(1, 0, contentSteering);\n    }\n    this.networkControllers = networkControllers;\n    const coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n    const AudioStreamControllerClass = config.audioStreamController;\n    if (AudioStreamControllerClass) {\n      networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n    const SubtitleStreamControllerClass = config.subtitleStreamController;\n    if (SubtitleStreamControllerClass) {\n      networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    this.createController(config.timelineController, coreComponents);\n    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n    this.cmcdController = this.createController(config.cmcdController, coreComponents);\n    this.latencyController = this.createController(LatencyController, coreComponents);\n    this.coreComponents = coreComponents;\n\n    // Error controller handles errors before and after all other controllers\n    // This listener will be invoked after all other controllers error listeners\n    networkControllers.push(errorController);\n    const onErrorOut = errorController.onErrorOut;\n    if (typeof onErrorOut === 'function') {\n      this.on(Events.ERROR, onErrorOut, errorController);\n    }\n  }\n  createController(ControllerClass, components) {\n    if (ControllerClass) {\n      const controllerInstance = new ControllerClass(this);\n      if (components) {\n        components.push(controllerInstance);\n      }\n      return controllerInstance;\n    }\n    return null;\n  }\n\n  // Delegate the EventEmitter through the public API of Hls.js\n  on(event, listener, context = this) {\n    this._emitter.on(event, listener, context);\n  }\n  once(event, listener, context = this) {\n    this._emitter.once(event, listener, context);\n  }\n  removeAllListeners(event) {\n    this._emitter.removeAllListeners(event);\n  }\n  off(event, listener, context = this, once) {\n    this._emitter.off(event, listener, context, once);\n  }\n  listeners(event) {\n    return this._emitter.listeners(event);\n  }\n  emit(event, name, eventObject) {\n    return this._emitter.emit(event, name, eventObject);\n  }\n  trigger(event, eventObject) {\n    if (this.config.debug) {\n      return this.emit(event, event, eventObject);\n    } else {\n      try {\n        return this.emit(event, event, eventObject);\n      } catch (e) {\n        logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + e.message + '\". Here is a stacktrace:', e);\n        this.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERNAL_EXCEPTION,\n          fatal: false,\n          event: event,\n          error: e\n        });\n      }\n    }\n    return false;\n  }\n  listenerCount(event) {\n    return this._emitter.listenerCount(event);\n  }\n\n  /**\n   * Dispose of the instance\n   */\n  destroy() {\n    logger.log('destroy');\n    this.trigger(Events.DESTROYING, undefined);\n    this.detachMedia();\n    this.removeAllListeners();\n    this._autoLevelCapping = -1;\n    this.url = null;\n    this.networkControllers.forEach(component => component.destroy());\n    this.networkControllers.length = 0;\n    this.coreComponents.forEach(component => component.destroy());\n    this.coreComponents.length = 0;\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.xhrSetup = config.fetchSetup = undefined;\n    // @ts-ignore\n    this.userConfig = null;\n  }\n\n  /**\n   * Attaches Hls.js to a media element\n   */\n  attachMedia(media) {\n    logger.log('attachMedia');\n    this._media = media;\n    this.trigger(Events.MEDIA_ATTACHING, {\n      media: media\n    });\n  }\n\n  /**\n   * Detach Hls.js from the media\n   */\n  detachMedia() {\n    logger.log('detachMedia');\n    this.trigger(Events.MEDIA_DETACHING, undefined);\n    this._media = null;\n  }\n\n  /**\n   * Set the source URL. Can be relative or absolute.\n   */\n  loadSource(url) {\n    this.stopLoad();\n    const media = this.media;\n    const loadedSource = this.url;\n    const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n      alwaysNormalize: true\n    });\n    logger.log(`loadSource:${loadingSource}`);\n    if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n      this.detachMedia();\n      this.attachMedia(media);\n    }\n    // when attaching to a source URL, trigger a playlist load\n    this.trigger(Events.MANIFEST_LOADING, {\n      url: url\n    });\n  }\n\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param startPosition - Set the start position to stream from.\n   * Defaults to -1 (None: starts from earliest point)\n   */\n  startLoad(startPosition = -1) {\n    logger.log(`startLoad(${startPosition})`);\n    this.networkControllers.forEach(controller => {\n      controller.startLoad(startPosition);\n    });\n  }\n\n  /**\n   * Stop loading of any stream data.\n   */\n  stopLoad() {\n    logger.log('stopLoad');\n    this.networkControllers.forEach(controller => {\n      controller.stopLoad();\n    });\n  }\n\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */\n  swapAudioCodec() {\n    logger.log('swapAudioCodec');\n    this.streamController.swapAudioCodec();\n  }\n\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */\n  recoverMediaError() {\n    logger.log('recoverMediaError');\n    const media = this._media;\n    this.detachMedia();\n    if (media) {\n      this.attachMedia(media);\n    }\n  }\n  removeLevel(levelIndex, urlId = 0) {\n    this.levelController.removeLevel(levelIndex, urlId);\n  }\n\n  /**\n   * @returns an array of levels (variants) sorted by HDCP-LEVEL, BANDWIDTH, SCORE, and RESOLUTION (height)\n   */\n  get levels() {\n    const levels = this.levelController.levels;\n    return levels ? levels : [];\n  }\n\n  /**\n   * Index of quality level (variant) currently played\n   */\n  get currentLevel() {\n    return this.streamController.currentLevel;\n  }\n\n  /**\n   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n   */\n  set currentLevel(newLevel) {\n    logger.log(`set currentLevel:${newLevel}`);\n    this.loadLevel = newLevel;\n    this.abrController.clearTimer();\n    this.streamController.immediateLevelSwitch();\n  }\n\n  /**\n   * Index of next quality level loaded as scheduled by stream controller.\n   */\n  get nextLevel() {\n    return this.streamController.nextLevel;\n  }\n\n  /**\n   * Set quality level index for next loaded data.\n   * This will switch the video quality asap, without interrupting playback.\n   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set nextLevel(newLevel) {\n    logger.log(`set nextLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.nextLevelSwitch();\n  }\n\n  /**\n   * Return the quality level of the currently or last (of none is loaded currently) segment\n   */\n  get loadLevel() {\n    return this.levelController.level;\n  }\n\n  /**\n   * Set quality level index for next loaded data in a conservative way.\n   * This will switch the quality without flushing, but interrupt current loading.\n   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set loadLevel(newLevel) {\n    logger.log(`set loadLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n  }\n\n  /**\n   * get next quality level loaded\n   */\n  get nextLoadLevel() {\n    return this.levelController.nextLoadLevel;\n  }\n\n  /**\n   * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n   * Same as `loadLevel` but will wait for next switch (until current loading is done).\n   */\n  set nextLoadLevel(level) {\n    this.levelController.nextLoadLevel = level;\n  }\n\n  /**\n   * Return \"first level\": like a default level, if not set,\n   * falls back to index of first level referenced in manifest\n   */\n  get firstLevel() {\n    return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n  }\n\n  /**\n   * Sets \"first-level\", see getter.\n   */\n  set firstLevel(newLevel) {\n    logger.log(`set firstLevel:${newLevel}`);\n    this.levelController.firstLevel = newLevel;\n  }\n\n  /**\n   * Return start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */\n  get startLevel() {\n    return this.levelController.startLevel;\n  }\n\n  /**\n   * set  start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */\n  set startLevel(newLevel) {\n    logger.log(`set startLevel:${newLevel}`);\n    // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n    if (newLevel !== -1) {\n      newLevel = Math.max(newLevel, this.minAutoLevel);\n    }\n    this.levelController.startLevel = newLevel;\n  }\n\n  /**\n   * Whether level capping is enabled.\n   * Default value is set via `config.capLevelToPlayerSize`.\n   */\n  get capLevelToPlayerSize() {\n    return this.config.capLevelToPlayerSize;\n  }\n\n  /**\n   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n   */\n  set capLevelToPlayerSize(shouldStartCapping) {\n    const newCapLevelToPlayerSize = !!shouldStartCapping;\n    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n      if (newCapLevelToPlayerSize) {\n        this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n      } else {\n        this.capLevelController.stopCapping();\n        this.autoLevelCapping = -1;\n        this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n      }\n\n      this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n    }\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  get autoLevelCapping() {\n    return this._autoLevelCapping;\n  }\n\n  /**\n   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n   */\n  get bandwidthEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimate();\n  }\n\n  /**\n   * get time to first byte estimate\n   * @type {number}\n   */\n  get ttfbEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimateTTFB();\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  set autoLevelCapping(newLevel) {\n    if (this._autoLevelCapping !== newLevel) {\n      logger.log(`set autoLevelCapping:${newLevel}`);\n      this._autoLevelCapping = newLevel;\n    }\n  }\n  get maxHdcpLevel() {\n    return this._maxHdcpLevel;\n  }\n  set maxHdcpLevel(value) {\n    if (HdcpLevels.indexOf(value) > -1) {\n      this._maxHdcpLevel = value;\n    }\n  }\n\n  /**\n   * True when automatic level selection enabled\n   */\n  get autoLevelEnabled() {\n    return this.levelController.manualLevel === -1;\n  }\n\n  /**\n   * Level set manually (if any)\n   */\n  get manualLevel() {\n    return this.levelController.manualLevel;\n  }\n\n  /**\n   * min level selectable in auto mode according to config.minAutoBitrate\n   */\n  get minAutoLevel() {\n    const {\n      levels,\n      config: {\n        minAutoBitrate\n      }\n    } = this;\n    if (!levels) return 0;\n    const len = levels.length;\n    for (let i = 0; i < len; i++) {\n      if (levels[i].maxBitrate >= minAutoBitrate) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * max level selectable in auto mode according to autoLevelCapping\n   */\n  get maxAutoLevel() {\n    const {\n      levels,\n      autoLevelCapping,\n      maxHdcpLevel\n    } = this;\n    let maxAutoLevel;\n    if (autoLevelCapping === -1 && levels && levels.length) {\n      maxAutoLevel = levels.length - 1;\n    } else {\n      maxAutoLevel = autoLevelCapping;\n    }\n    if (maxHdcpLevel) {\n      for (let i = maxAutoLevel; i--;) {\n        const hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n        if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n          return i;\n        }\n      }\n    }\n    return maxAutoLevel;\n  }\n\n  /**\n   * next automatically selected quality level\n   */\n  get nextAutoLevel() {\n    // ensure next auto level is between  min and max auto level\n    return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n  }\n\n  /**\n   * this setter is used to force next auto level.\n   * this is useful to force a switch down in auto mode:\n   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n   * forced value is valid for one fragment. upon successful frag loading at forced level,\n   * this value will be resetted to -1 by ABR controller.\n   */\n  set nextAutoLevel(nextLevel) {\n    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);\n  }\n\n  /**\n   * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n   */\n  get playingDate() {\n    return this.streamController.currentProgramDateTime;\n  }\n  get mainForwardBufferInfo() {\n    return this.streamController.getMainFwdBufferInfo();\n  }\n\n  /**\n   * Get the list of selectable audio tracks\n   */\n  get audioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTracks : [];\n  }\n\n  /**\n   * index of the selected audio track (index in audio track lists)\n   */\n  get audioTrack() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTrack : -1;\n  }\n\n  /**\n   * selects an audio track, based on its index in audio track lists\n   */\n  set audioTrack(audioTrackId) {\n    const audioTrackController = this.audioTrackController;\n    if (audioTrackController) {\n      audioTrackController.audioTrack = audioTrackId;\n    }\n  }\n\n  /**\n   * get alternate subtitle tracks list from playlist\n   */\n  get subtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n  }\n\n  /**\n   * index of the selected subtitle track (index in subtitle track lists)\n   */\n  get subtitleTrack() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n  }\n  get media() {\n    return this._media;\n  }\n\n  /**\n   * select an subtitle track, based on its index in subtitle track lists\n   */\n  set subtitleTrack(subtitleTrackId) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleTrack = subtitleTrackId;\n    }\n  }\n\n  /**\n   * Whether subtitle display is enabled or not\n   */\n  get subtitleDisplay() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n  }\n\n  /**\n   * Enable/disable subtitle display rendering\n   */\n  set subtitleDisplay(value) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleDisplay = value;\n    }\n  }\n\n  /**\n   * get mode for Low-Latency HLS loading\n   */\n  get lowLatencyMode() {\n    return this.config.lowLatencyMode;\n  }\n\n  /**\n   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n   */\n  set lowLatencyMode(mode) {\n    this.config.lowLatencyMode = mode;\n  }\n\n  /**\n   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n   * @returns null prior to loading live Playlist\n   */\n  get liveSyncPosition() {\n    return this.latencyController.liveSyncPosition;\n  }\n\n  /**\n   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n   * @returns 0 before first playlist is loaded\n   */\n  get latency() {\n    return this.latencyController.latency;\n  }\n\n  /**\n   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n   * @returns 0 before first playlist is loaded\n   */\n  get maxLatency() {\n    return this.latencyController.maxLatency;\n  }\n\n  /**\n   * target distance from the edge as calculated by the latency controller\n   */\n  get targetLatency() {\n    return this.latencyController.targetLatency;\n  }\n\n  /**\n   * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n   */\n  get drift() {\n    return this.latencyController.drift;\n  }\n\n  /**\n   * set to true when startLoad is called before MANIFEST_PARSED event\n   */\n  get forceStartLoad() {\n    return this.streamController.forceStartLoad;\n  }\n}\nHls.defaultConfig = void 0;\n\n\n//# sourceMappingURL=hls.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUZBQXVGLGlCQUFpQjtBQUN4RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBLCtEQUErRCw4QkFBOEI7QUFDN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsR0FBRyxzQkFBc0IsU0FBUztBQUN0RixNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSxzQ0FBc0MsaUJBQWlCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxvQ0FBb0M7QUFDdEc7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSxtQ0FBbUM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUUsMkJBQTJCO0FBQ3BHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVUsTUFBTTtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCLFVBQVUsTUFBTTtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEsWUFBWSxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEsWUFBWSxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0JBQW9CLG9CQUFvQix3QkFBd0IsS0FBSyxtQkFBbUI7QUFDaEo7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLCtFQUErRSxXQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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MkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZSxLQUFLOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1FQUFtRSxhQUFhLFdBQVcsY0FBYyxRQUFRLFdBQVc7O0FBRTVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9GQUFvRixZQUFZOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQixxRkFBcUYseUJBQXlCLGFBQWE7QUFDMUo7QUFDQSxzQkFBc0IsZUFBZSxNQUFNLFdBQVc7QUFDdEQsTUFBTTtBQUNOLHlCQUF5QixZQUFZLGFBQWEsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0EsTUFBTTtBQUNOLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdGQUFnRixLQUFLO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0RUFBNEUseUNBQXlDO0FBQ3JIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcscUNBQXFDLEdBQUcsVUFBVTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZLFFBQVEsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWEsR0FBRyxnQkFBZ0IsS0FBSyxvQkFBb0IsVUFBVSxhQUFhO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BELDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkVBQTJFLE1BQU07QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTyxFQUFFLDRIQUE0SDtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw0QkFBNEIsTUFBTSxhQUFhLHFCQUFxQixZQUFZO0FBQzFJO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0Isa0JBQWtCLHdCQUF3QixVQUFVLGFBQWEsVUFBVSxVQUFVLFVBQVUsS0FBSztBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTyxLQUFLLHNDQUFzQztBQUN6RjtBQUNBLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw0QkFBNEIsNEJBQTRCO0FBQ3hEOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWUsR0FBRyx5QkFBeUIsU0FBUyxhQUFhO0FBQ2hIO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxlQUFlLEdBQUcseUJBQXlCLFNBQVMsYUFBYSxPQUFPLE1BQU07QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUNBQXVDLGVBQWU7QUFDdEQsMEJBQTBCLHNCQUFzQixFQUFFLG9CQUFvQixHQUFHLFdBQVcsR0FBRyxVQUFVLEdBQUcsT0FBTztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWMsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLFlBQVk7QUFDN0U7O0FBRUEsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMEJBQTBCO0FBQy9FO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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U0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixZQUFZO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQixjQUFjLG9CQUFvQixFQUFFLGFBQWE7QUFDOUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBFQUEwRSxTQUFTLElBQUksWUFBWTtBQUNuRztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsaUJBQWlCLHNCQUFzQixHQUFHLG9CQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRCw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9FQUFvRSxJQUFJLFdBQVcsV0FBVztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBCQUEwQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFFBQVEsVUFBVSx3QkFBd0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYSw2QkFBNkIsUUFBUTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiw2QkFBNkI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsUUFBUTtBQUMzRjtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3QkFBd0IsNERBQTRELElBQUksMkJBQTJCLDRCQUE0QjtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQ0FBZ0MsWUFBWSxpREFBaUQsSUFBSSxpQkFBaUIsV0FBVyx1Q0FBdUMsYUFBYSxPQUFPO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCLFdBQVcseURBQXlELG9DQUFvQyxjQUFjO0FBQzdLO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsRUFBRSxtQ0FBbUMsV0FBVyxZQUFZO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFVBQVUsSUFBSSxrRkFBa0Y7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsS0FBSyxZQUFZLEVBQUUsWUFBWSxlQUFlLGFBQWEscUJBQXFCLGVBQWUsR0FBRyx5QkFBeUIsS0FBSyxNQUFNO0FBQzNLO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUJBQXVCLGNBQWMsaUNBQWlDLFdBQVc7QUFDakY7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGNBQWM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsY0FBYyxXQUFXLGdCQUFnQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTLEVBQUUsTUFBTSxxQkFBcUIsZUFBZTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxTQUFTLFdBQVcsWUFBWTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVMsWUFBWSxVQUFVO0FBQ3hFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLElBQUksVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSTs7QUFFdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZLGlCQUFpQixtQkFBbUIsS0FBSyxnQkFBZ0IsR0FBRyxpQ0FBaUMsUUFBUTtBQUMvSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVcsY0FBYyxlQUFlLGtCQUFrQixrQkFBa0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVksU0FBUyxrQkFBa0IsYUFBYSxvQkFBb0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG9CQUFvQixHQUFHLFlBQVksR0FBRyxnQkFBZ0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLCtCQUErQixXQUFXLFFBQVEsT0FBTyx1QkFBdUIsWUFBWSxHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixXQUFXLFFBQVE7QUFDMUo7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPLHFCQUFxQixXQUFXLGdDQUFnQyxZQUFZO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNDQUFzQztBQUMvRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsNkRBQTZEO0FBQzdELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLHVCQUF1QjtBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQixTQUFTLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtRUFBbUUsUUFBUTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUNBQXVDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0RBQW9ELGFBQWEsRUFBRSxvREFBb0QsV0FBVyxnQkFBZ0I7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZLFVBQVUsNkJBQTZCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsMkJBQTJCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyxhQUFhLFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZCQUE2QixTQUFTLFdBQVcsWUFBWTtBQUM3RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNDQUFzQztBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBLHNCQUFzQixZQUFZLFVBQVUsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsaUNBQWlDLHNCQUFzQixHQUFHLHlCQUF5QixRQUFRLFFBQVEsbUJBQW1CLElBQUksaUJBQWlCLGFBQWEsU0FBUztBQUN2UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtRkFBbUYsU0FBUyxXQUFXLFlBQVk7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTLFdBQVcsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixTQUFTLE1BQU0saUJBQWlCLEdBQUcsY0FBYyxVQUFVLFdBQVcsT0FBTyxRQUFRO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsRUFBRSxpQ0FBaUMsV0FBVyxZQUFZLDhDQUE4QyxXQUFXO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYyx1QkFBdUIsWUFBWTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZSxvQkFBb0IsWUFBWTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQSxtREFBbUQsd0JBQXdCLFNBQVMsV0FBVztBQUMvRjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLG1DQUFtQyxpQkFBaUIsR0FBRyw4QkFBOEIsR0FBRyxZQUFZO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQiwwQkFBMEIsOEJBQThCLEdBQUcsWUFBWTtBQUN0STtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQiwwQkFBMEIsZ0NBQWdDLEdBQUcsaUJBQWlCO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxxQkFBcUIsU0FBUyxJQUFJLFlBQVk7QUFDOUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLLHlDQUF5QyxNQUFNLHVDQUF1QyxPQUFPO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0VBQStFLFlBQVksSUFBSSxVQUFVO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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eUMsRUFBRSxNQUFNLEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLEdBQUcsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNS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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BELE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCw2Q0FBNkMsTUFBTTtBQUNuRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSSxHQUFHLE1BQU07QUFDakMsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQixJQUFJLEdBQUcsTUFBTTtBQUNqQyxRQUFRO0FBQ1Isb0JBQW9CLElBQUksR0FBRyxzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxJQUFJLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQW1EO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTTtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWUsZ0NBQWdDLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCLEdBQUcsZUFBZSxxQkFBcUIsZUFBZTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUJBQXVCLEtBQUsseUJBQXlCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQixTQUFTLFFBQVE7QUFDNUYsaUVBQWlFLHFCQUFxQixTQUFTLFFBQVE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx5REFBeUQsSUFBSTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxREFBcUQsWUFBWSxFQUFFLFlBQVksR0FBRyxZQUFZO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLFFBQVEsZ0JBQWdCLFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLGlCQUFpQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxtQkFBbUIsOENBQThDLGdCQUFnQixZQUFZLGFBQWEsWUFBWSxHQUFHLHlCQUF5QixLQUFLLGdCQUFnQjtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUc7QUFDbkM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUNBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLLFNBQVMsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUNBQXFDLG9CQUFvQixvQ0FBb0MsV0FBVyxLQUFLLHVDQUF1QztBQUNwSjtBQUNBLEdBQUc7QUFDSCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMubWpzP2MyZjEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHVybFRvb2xraXQgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE4MDhcblxuXHQoZnVuY3Rpb24gKHJvb3QpIHtcblx0ICB2YXIgVVJMX1JFR0VYID1cblx0ICAgIC9eKD89KCg/OlthLXpBLVowLTkrXFwtLl0rOik/KSlcXDEoPz0oKD86XFwvXFwvW15cXC8/I10qKT8pKVxcMig/PSgoPzooPzpbXj8jXFwvXSpcXC8pKlteOz8jXFwvXSopPykpXFwzKCg/OjtbXj8jXSopPykoXFw/W14jXSopPygjW15dKik/JC87XG5cdCAgdmFyIEZJUlNUX1NFR01FTlRfUkVHRVggPSAvXig/PShbXlxcLz8jXSopKVxcMShbXl0qKSQvO1xuXHQgIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuXHQgIHZhciBTTEFTSF9ET1RfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLlxcLlxcLyg/IVxcLlxcLlxcLylbXlxcL10qKD89XFwvKS9nO1xuXG5cdCAgdmFyIFVSTFRvb2xraXQgPSB7XG5cdCAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuXHQgICAgLy8gRS5nXG5cdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuXHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG5cdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gdHJ1ZSAobm90IHNwZWMgY29tcGxpYW50KVxuXHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuXHQgICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24gKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG5cdCAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHQgICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuXHQgICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG5cdCAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuXHQgICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XG5cdCAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuXHQgICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcblx0ICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXG5cdCAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuXHQgICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoXG5cdCAgICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aFxuXHQgICAgICAgICk7XG5cdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYmFzZVBhcnRzRm9yTm9ybWFsaXNlKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuXHQgICAgICBpZiAoIXJlbGF0aXZlUGFydHMpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJlbGF0aXZlUGFydHMuc2NoZW1lKSB7XG5cdCAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcblx0ICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuXHQgICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcblx0ICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCk7XG5cdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGJhc2VQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG5cdCAgICAgIGlmICghYmFzZVBhcnRzKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcblx0ICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2Ncblx0ICAgICAgICAvLyBUaGlzIGNhdXNlcyAnZXhhbXBsZS5jb20vYScgdG8gYmUgaGFuZGxlZCBhcyAnLy9leGFtcGxlLmNvbS9hJyBpbnN0ZWFkIG9mICcvZXhhbXBsZS5jb20vYSdcblx0ICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcblx0ICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuXHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gcGF0aFBhcnRzWzJdO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuXHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gJy8nO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuXHQgICAgICAgIC8vIDJjKSBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIHNjaGVtZSBvZlxuXHQgICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cblx0ICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG5cdCAgICAgICAgbmV0TG9jOiByZWxhdGl2ZVBhcnRzLm5ldExvYyxcblx0ICAgICAgICBwYXRoOiBudWxsLFxuXHQgICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG5cdCAgICAgICAgcXVlcnk6IHJlbGF0aXZlUGFydHMucXVlcnksXG5cdCAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnQsXG5cdCAgICAgIH07XG5cdCAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5uZXRMb2MpIHtcblx0ICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuXHQgICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG5cdCAgICAgICAgLy8gKGlmIGFueSkgb2YgdGhlIGJhc2UgVVJMLlxuXHQgICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcblx0ICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG5cdCAgICAgICAgLy8gcGF0aCBpcyBub3QgcmVsYXRpdmUgYW5kIHdlIHNraXAgdG8gU3RlcCA3LlxuXHQgICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuXHQgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcblx0ICAgICAgICAgICAgLy8gNSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIGVtcHR5IChhbmQgbm90IHByZWNlZGVkIGJ5IGFcblx0ICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcblx0ICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG5cdCAgICAgICAgICAgIC8vIDVhKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHBhcmFtcz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG5cdCAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2Vcblx0ICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuXHQgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuXHQgICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cblx0ICAgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxxdWVyeT4gb2YgdGhlIGJhc2Vcblx0ICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuXHQgICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuXHQgICAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5xdWVyeSA9IGJhc2VQYXJ0cy5xdWVyeTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcblx0ICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuXHQgICAgICAgICAgICAvLyBzbGFzaCBpcyBwcmVzZW50KSBpcyByZW1vdmVkIGFuZCB0aGUgZW1iZWRkZWQgVVJMJ3MgcGF0aCBpc1xuXHQgICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG5cdCAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuXHQgICAgICAgICAgICB2YXIgbmV3UGF0aCA9XG5cdCAgICAgICAgICAgICAgYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArXG5cdCAgICAgICAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuXHQgICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgobmV3UGF0aCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcblx0ICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZVxuXHQgICAgICAgICAgPyBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKVxuXHQgICAgICAgICAgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG5cdCAgICB9LFxuXHQgICAgcGFyc2VVUkw6IGZ1bmN0aW9uICh1cmwpIHtcblx0ICAgICAgdmFyIHBhcnRzID0gVVJMX1JFR0VYLmV4ZWModXJsKTtcblx0ICAgICAgaWYgKCFwYXJ0cykge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcblx0ICAgICAgICBuZXRMb2M6IHBhcnRzWzJdIHx8ICcnLFxuXHQgICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuXHQgICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG5cdCAgICAgICAgcXVlcnk6IHBhcnRzWzVdIHx8ICcnLFxuXHQgICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJyxcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cdCAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHQgICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG5cdCAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcblx0ICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxuXHQgICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cblx0ICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcblx0ICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxuXHQgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG5cdCAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG5cdCAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cblx0ICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcblx0ICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG5cdCAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cblx0ICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuXHQgICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuXHQgICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXG5cdCAgICAgIHdoaWxlIChcblx0ICAgICAgICBwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGhcblx0ICAgICAgKSB7fVxuXHQgICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuXHQgICAgfSxcblx0ICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbiAocGFydHMpIHtcblx0ICAgICAgcmV0dXJuIChcblx0ICAgICAgICBwYXJ0cy5zY2hlbWUgK1xuXHQgICAgICAgIHBhcnRzLm5ldExvYyArXG5cdCAgICAgICAgcGFydHMucGF0aCArXG5cdCAgICAgICAgcGFydHMucGFyYW1zICtcblx0ICAgICAgICBwYXJ0cy5xdWVyeSArXG5cdCAgICAgICAgcGFydHMuZnJhZ21lbnRcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cdCAgfTtcblxuXHQgIG1vZHVsZS5leHBvcnRzID0gVVJMVG9vbGtpdDtcblx0fSkoKTsgXG59ICh1cmxUb29sa2l0KSk7XG5cbnZhciB1cmxUb29sa2l0RXhwb3J0cyA9IHVybFRvb2xraXQuZXhwb3J0cztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuY29uc3QgaXNGaW5pdGVOdW1iZXIgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcbn07XG5cbmxldCBFdmVudHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEV2ZW50cykge1xuICBFdmVudHNbXCJNRURJQV9BVFRBQ0hJTkdcIl0gPSBcImhsc01lZGlhQXR0YWNoaW5nXCI7XG4gIEV2ZW50c1tcIk1FRElBX0FUVEFDSEVEXCJdID0gXCJobHNNZWRpYUF0dGFjaGVkXCI7XG4gIEV2ZW50c1tcIk1FRElBX0RFVEFDSElOR1wiXSA9IFwiaGxzTWVkaWFEZXRhY2hpbmdcIjtcbiAgRXZlbnRzW1wiTUVESUFfREVUQUNIRURcIl0gPSBcImhsc01lZGlhRGV0YWNoZWRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX1JFU0VUXCJdID0gXCJobHNCdWZmZXJSZXNldFwiO1xuICBFdmVudHNbXCJCVUZGRVJfQ09ERUNTXCJdID0gXCJobHNCdWZmZXJDb2RlY3NcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0NSRUFURURcIl0gPSBcImhsc0J1ZmZlckNyZWF0ZWRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0FQUEVORElOR1wiXSA9IFwiaGxzQnVmZmVyQXBwZW5kaW5nXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9BUFBFTkRFRFwiXSA9IFwiaGxzQnVmZmVyQXBwZW5kZWRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0VPU1wiXSA9IFwiaGxzQnVmZmVyRW9zXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9GTFVTSElOR1wiXSA9IFwiaGxzQnVmZmVyRmx1c2hpbmdcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0ZMVVNIRURcIl0gPSBcImhsc0J1ZmZlckZsdXNoZWRcIjtcbiAgRXZlbnRzW1wiTUFOSUZFU1RfTE9BRElOR1wiXSA9IFwiaGxzTWFuaWZlc3RMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX0xPQURFRFwiXSA9IFwiaGxzTWFuaWZlc3RMb2FkZWRcIjtcbiAgRXZlbnRzW1wiTUFOSUZFU1RfUEFSU0VEXCJdID0gXCJobHNNYW5pZmVzdFBhcnNlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9TV0lUQ0hJTkdcIl0gPSBcImhsc0xldmVsU3dpdGNoaW5nXCI7XG4gIEV2ZW50c1tcIkxFVkVMX1NXSVRDSEVEXCJdID0gXCJobHNMZXZlbFN3aXRjaGVkXCI7XG4gIEV2ZW50c1tcIkxFVkVMX0xPQURJTkdcIl0gPSBcImhsc0xldmVsTG9hZGluZ1wiO1xuICBFdmVudHNbXCJMRVZFTF9MT0FERURcIl0gPSBcImhsc0xldmVsTG9hZGVkXCI7XG4gIEV2ZW50c1tcIkxFVkVMX1VQREFURURcIl0gPSBcImhsc0xldmVsVXBkYXRlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9QVFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxQdHNVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkxFVkVMU19VUERBVEVEXCJdID0gXCJobHNMZXZlbHNVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLU19VUERBVEVEXCJdID0gXCJobHNBdWRpb1RyYWNrc1VwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfU1dJVENISU5HXCJdID0gXCJobHNBdWRpb1RyYWNrU3dpdGNoaW5nXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX1NXSVRDSEVEXCJdID0gXCJobHNBdWRpb1RyYWNrU3dpdGNoZWRcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfTE9BRElOR1wiXSA9IFwiaGxzQXVkaW9UcmFja0xvYWRpbmdcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfTE9BREVEXCJdID0gXCJobHNBdWRpb1RyYWNrTG9hZGVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLU19VUERBVEVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tTX0NMRUFSRURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tzQ2xlYXJlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19TV0lUQ0hcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tTd2l0Y2hcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfTE9BRElOR1wiXSA9IFwiaGxzU3VidGl0bGVUcmFja0xvYWRpbmdcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfTE9BREVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrTG9hZGVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEXCJdID0gXCJobHNTdWJ0aXRsZUZyYWdQcm9jZXNzZWRcIjtcbiAgRXZlbnRzW1wiQ1VFU19QQVJTRURcIl0gPSBcImhsc0N1ZXNQYXJzZWRcIjtcbiAgRXZlbnRzW1wiTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORFwiXSA9IFwiaGxzTm9uTmF0aXZlVGV4dFRyYWNrc0ZvdW5kXCI7XG4gIEV2ZW50c1tcIklOSVRfUFRTX0ZPVU5EXCJdID0gXCJobHNJbml0UHRzRm91bmRcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FESU5HXCJdID0gXCJobHNGcmFnTG9hZGluZ1wiO1xuICBFdmVudHNbXCJGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURURcIl0gPSBcImhsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZFwiO1xuICBFdmVudHNbXCJGUkFHX0xPQURFRFwiXSA9IFwiaGxzRnJhZ0xvYWRlZFwiO1xuICBFdmVudHNbXCJGUkFHX0RFQ1JZUFRFRFwiXSA9IFwiaGxzRnJhZ0RlY3J5cHRlZFwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UXCJdID0gXCJobHNGcmFnUGFyc2luZ0luaXRTZWdtZW50XCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0lOR19VU0VSREFUQVwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YVwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfTUVUQURBVEFcIl0gPSBcImhsc0ZyYWdQYXJzaW5nTWV0YWRhdGFcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTRURcIl0gPSBcImhsc0ZyYWdQYXJzZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19CVUZGRVJFRFwiXSA9IFwiaGxzRnJhZ0J1ZmZlcmVkXCI7XG4gIEV2ZW50c1tcIkZSQUdfQ0hBTkdFRFwiXSA9IFwiaGxzRnJhZ0NoYW5nZWRcIjtcbiAgRXZlbnRzW1wiRlBTX0RST1BcIl0gPSBcImhsc0Zwc0Ryb3BcIjtcbiAgRXZlbnRzW1wiRlBTX0RST1BfTEVWRUxfQ0FQUElOR1wiXSA9IFwiaGxzRnBzRHJvcExldmVsQ2FwcGluZ1wiO1xuICBFdmVudHNbXCJFUlJPUlwiXSA9IFwiaGxzRXJyb3JcIjtcbiAgRXZlbnRzW1wiREVTVFJPWUlOR1wiXSA9IFwiaGxzRGVzdHJveWluZ1wiO1xuICBFdmVudHNbXCJLRVlfTE9BRElOR1wiXSA9IFwiaGxzS2V5TG9hZGluZ1wiO1xuICBFdmVudHNbXCJLRVlfTE9BREVEXCJdID0gXCJobHNLZXlMb2FkZWRcIjtcbiAgRXZlbnRzW1wiTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEXCJdID0gXCJobHNMaXZlQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgRXZlbnRzW1wiQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgcmV0dXJuIEV2ZW50cztcbn0oe30pO1xuXG4vKipcbiAqIERlZmluZXMgZWFjaCBFdmVudCB0eXBlIGFuZCBwYXlsb2FkIGJ5IEV2ZW50IG5hbWUuIFVzZWQgaW4ge0BsaW5rIGhscy5qcyNIbHNFdmVudEVtaXR0ZXJ9IHRvIHN0cm9uZ2x5IHR5cGUgdGhlIGV2ZW50IGxpc3RlbmVyIEFQSS5cbiAqL1xuXG5sZXQgRXJyb3JUeXBlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXJyb3JUeXBlcykge1xuICBFcnJvclR5cGVzW1wiTkVUV09SS19FUlJPUlwiXSA9IFwibmV0d29ya0Vycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJNRURJQV9FUlJPUlwiXSA9IFwibWVkaWFFcnJvclwiO1xuICBFcnJvclR5cGVzW1wiS0VZX1NZU1RFTV9FUlJPUlwiXSA9IFwia2V5U3lzdGVtRXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIk1VWF9FUlJPUlwiXSA9IFwibXV4RXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIk9USEVSX0VSUk9SXCJdID0gXCJvdGhlckVycm9yXCI7XG4gIHJldHVybiBFcnJvclR5cGVzO1xufSh7fSk7XG5sZXQgRXJyb3JEZXRhaWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChFcnJvckRldGFpbHMpIHtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19LRVlTXCJdID0gXCJrZXlTeXN0ZW1Ob0tleXNcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19BQ0NFU1NcIl0gPSBcImtleVN5c3RlbU5vQWNjZXNzXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fU0VTU0lPTlwiXSA9IFwia2V5U3lzdGVtTm9TZXNzaW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fQ09ORklHVVJFRF9MSUNFTlNFXCJdID0gXCJrZXlTeXN0ZW1Ob0NvbmZpZ3VyZWRMaWNlbnNlXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRURcIl0gPSBcImtleVN5c3RlbVNlcnZlckNlcnRpZmljYXRlUmVxdWVzdEZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVVwZGF0ZUZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2Vzc2lvblVwZGF0ZUZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRFwiXSA9IFwia2V5U3lzdGVtU3RhdHVzT3V0cHV0UmVzdHJpY3RlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUlwiXSA9IFwia2V5U3lzdGVtU3RhdHVzSW50ZXJuYWxFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX0VSUk9SXCJdID0gXCJtYW5pZmVzdExvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX1RJTUVPVVRcIl0gPSBcIm1hbmlmZXN0TG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfUEFSU0lOR19FUlJPUlwiXSA9IFwibWFuaWZlc3RQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUlwiXSA9IFwibWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9FTVBUWV9FUlJPUlwiXSA9IFwibGV2ZWxFbXB0eUVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfRVJST1JcIl0gPSBcImxldmVsTG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfVElNRU9VVFwiXSA9IFwibGV2ZWxMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9QQVJTSU5HX0VSUk9SXCJdID0gXCJsZXZlbFBhcnNpbmdFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9TV0lUQ0hfRVJST1JcIl0gPSBcImxldmVsU3dpdGNoRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9FUlJPUlwiXSA9IFwiYXVkaW9UcmFja0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcImF1ZGlvVHJhY2tMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9MT0FEX0VSUk9SXCJdID0gXCJzdWJ0aXRsZVRyYWNrTG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVFwiXSA9IFwic3VidGl0bGVUcmFja0xvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfTE9BRF9FUlJPUlwiXSA9IFwiZnJhZ0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfVElNRU9VVFwiXSA9IFwiZnJhZ0xvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfREVDUllQVF9FUlJPUlwiXSA9IFwiZnJhZ0RlY3J5cHRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX1BBUlNJTkdfRVJST1JcIl0gPSBcImZyYWdQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19HQVBcIl0gPSBcImZyYWdHYXBcIjtcbiAgRXJyb3JEZXRhaWxzW1wiUkVNVVhfQUxMT0NfRVJST1JcIl0gPSBcInJlbXV4QWxsb2NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9FUlJPUlwiXSA9IFwia2V5TG9hZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9MT0FEX1RJTUVPVVRcIl0gPSBcImtleUxvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BRERfQ09ERUNfRVJST1JcIl0gPSBcImJ1ZmZlckFkZENvZGVjRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcImJ1ZmZlckluY29tcGF0aWJsZUNvZGVjc0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRJTkdfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9TVEFMTEVEX0VSUk9SXCJdID0gXCJidWZmZXJTdGFsbGVkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0ZVTExfRVJST1JcIl0gPSBcImJ1ZmZlckZ1bGxFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU0VFS19PVkVSX0hPTEVcIl0gPSBcImJ1ZmZlclNlZWtPdmVySG9sZVwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfTlVER0VfT05fU1RBTExcIl0gPSBcImJ1ZmZlck51ZGdlT25TdGFsbFwiO1xuICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9FWENFUFRJT05cIl0gPSBcImludGVybmFsRXhjZXB0aW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIklOVEVSTkFMX0FCT1JURURcIl0gPSBcImFib3J0ZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICByZXR1cm4gRXJyb3JEZXRhaWxzO1xufSh7fSk7XG5cbmNvbnN0IG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5jb25zdCBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG5sZXQgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuXG4vLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuKHR5cGUpIHtcbiAgY29uc3QgZnVuYyA9IHNlbGYuY29uc29sZVt0eXBlXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYy5iaW5kKHNlbGYuY29uc29sZSwgYFske3R5cGV9XSA+YCk7XG4gIH1cbiAgcmV0dXJuIG5vb3A7XG59XG5mdW5jdGlvbiBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsIC4uLmZ1bmN0aW9ucykge1xuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGVuYWJsZUxvZ3MoZGVidWdDb25maWcsIGlkKSB7XG4gIC8vIGNoZWNrIHRoYXQgY29uc29sZSBpcyBhdmFpbGFibGVcbiAgaWYgKHNlbGYuY29uc29sZSAmJiBkZWJ1Z0NvbmZpZyA9PT0gdHJ1ZSB8fCB0eXBlb2YgZGVidWdDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLFxuICAgIC8vIFJlbW92ZSBvdXQgZnJvbSBsaXN0IGhlcmUgdG8gaGFyZC1kaXNhYmxlIGEgbG9nLWxldmVsXG4gICAgLy8gJ3RyYWNlJyxcbiAgICAnZGVidWcnLCAnbG9nJywgJ2luZm8nLCAnd2FybicsICdlcnJvcicpO1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3QgYWxsb3cgdG8gdXNlIGJpbmQgb24gY29uc29sZSBvYmplY3QgYW55d2F5XG4gICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBuZWVkZWRcbiAgICB0cnkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIubG9nKGBEZWJ1ZyBsb2dzIGVuYWJsZWQgZm9yIFwiJHtpZH1cIiBpbiBobHMuanMgdmVyc2lvbiAke1wiMS40LjEyXCJ9YCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gIH1cbn1cbmNvbnN0IGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG5jb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbmNvbnN0IEFUVFJfTElTVF9SRUdFWCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5jbGFzcyBBdHRyTGlzdCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRycykge1xuICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgIGlmIChhdHRyLnN1YnN0cmluZygwLCAyKSA9PT0gJ1gtJykge1xuICAgICAgICAgIHRoaXMuY2xpZW50QXR0cnMgPSB0aGlzLmNsaWVudEF0dHJzIHx8IFtdO1xuICAgICAgICAgIHRoaXMuY2xpZW50QXR0cnMucHVzaChhdHRyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTApO1xuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuICBoZXhhZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICBpZiAodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgIHN0cmluZ1ZhbHVlID0gKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEgPyAnMCcgOiAnJykgKyBzdHJpbmdWYWx1ZTtcbiAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHBhcnNlSW50KHN0cmluZ1ZhbHVlLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cbiAgZGVjaW1hbEZsb2F0aW5nUG9pbnQoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzW2F0dHJOYW1lXSk7XG4gIH1cbiAgb3B0aW9uYWxGbG9hdChhdHRyTmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzW2F0dHJOYW1lXTtcbiAgICByZXR1cm4gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuICBlbnVtZXJhdGVkU3RyaW5nKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICB9XG4gIGJvb2woYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV0gPT09ICdZRVMnO1xuICB9XG4gIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcGFyc2VJbnQocmVzWzFdLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcGFyc2VBdHRyTGlzdChpbnB1dCkge1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBhdHRycyA9IHt9O1xuICAgIGNvbnN0IHF1b3RlID0gJ1wiJztcbiAgICBBVFRSX0xJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG1hdGNoID0gQVRUUl9MSVNUX1JFR0VYLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IHZhbHVlID0gbWF0Y2hbMl07XG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihxdW90ZSkgPT09IDAgJiYgdmFsdWUubGFzdEluZGV4T2YocXVvdGUpID09PSB2YWx1ZS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxufVxuXG4vLyBBdm9pZCBleHBvcnRpbmcgY29uc3QgZW51bSBzbyB0aGF0IHRoZXNlIHZhbHVlcyBjYW4gYmUgaW5saW5lZFxuXG5mdW5jdGlvbiBpc0RhdGVSYW5nZUN1ZUF0dHJpYnV0ZShhdHRyTmFtZSkge1xuICByZXR1cm4gYXR0ck5hbWUgIT09IFwiSURcIiAmJiBhdHRyTmFtZSAhPT0gXCJDTEFTU1wiICYmIGF0dHJOYW1lICE9PSBcIlNUQVJULURBVEVcIiAmJiBhdHRyTmFtZSAhPT0gXCJEVVJBVElPTlwiICYmIGF0dHJOYW1lICE9PSBcIkVORC1EQVRFXCIgJiYgYXR0ck5hbWUgIT09IFwiRU5ELU9OLU5FWFRcIjtcbn1cbmZ1bmN0aW9uIGlzU0NURTM1QXR0cmlidXRlKGF0dHJOYW1lKSB7XG4gIHJldHVybiBhdHRyTmFtZSA9PT0gXCJTQ1RFMzUtT1VUXCIgfHwgYXR0ck5hbWUgPT09IFwiU0NURTM1LUlOXCI7XG59XG5jbGFzcyBEYXRlUmFuZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRlUmFuZ2VBdHRyLCBkYXRlUmFuZ2VXaXRoU2FtZUlkKSB7XG4gICAgdGhpcy5hdHRyID0gdm9pZCAwO1xuICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9lbmREYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkID0gdm9pZCAwO1xuICAgIGlmIChkYXRlUmFuZ2VXaXRoU2FtZUlkKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0F0dHIgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkLmF0dHI7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2aW91c0F0dHIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRlUmFuZ2VBdHRyLCBrZXkpICYmIGRhdGVSYW5nZUF0dHJba2V5XSAhPT0gcHJldmlvdXNBdHRyW2tleV0pIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgREFURVJBTkdFIHRhZyBhdHRyaWJ1dGU6IFwiJHtrZXl9XCIgZG9lcyBub3QgbWF0Y2ggZm9yIHRhZ3Mgd2l0aCBJRDogXCIke2RhdGVSYW5nZUF0dHIuSUR9XCJgKTtcbiAgICAgICAgICB0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCA9IGtleTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTWVyZ2UgRGF0ZVJhbmdlIHRhZ3Mgd2l0aCB0aGUgc2FtZSBJRFxuICAgICAgZGF0ZVJhbmdlQXR0ciA9IF9leHRlbmRzKG5ldyBBdHRyTGlzdCh7fSksIHByZXZpb3VzQXR0ciwgZGF0ZVJhbmdlQXR0cik7XG4gICAgfVxuICAgIHRoaXMuYXR0ciA9IGRhdGVSYW5nZUF0dHI7XG4gICAgdGhpcy5fc3RhcnREYXRlID0gbmV3IERhdGUoZGF0ZVJhbmdlQXR0cltcIlNUQVJULURBVEVcIl0pO1xuICAgIGlmIChcIkVORC1EQVRFXCIgaW4gdGhpcy5hdHRyKSB7XG4gICAgICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUodGhpcy5hdHRyW1wiRU5ELURBVEVcIl0pO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGVuZERhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICB0aGlzLl9lbmREYXRlID0gZW5kRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIuSUQ7XG4gIH1cbiAgZ2V0IGNsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIuQ0xBU1M7XG4gIH1cbiAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnREYXRlO1xuICB9XG4gIGdldCBlbmREYXRlKCkge1xuICAgIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5kRGF0ZTtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGlmIChkdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX3N0YXJ0RGF0ZS5nZXRUaW1lKCkgKyBkdXJhdGlvbiAqIDEwMDApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgaWYgKFwiRFVSQVRJT05cIiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiRFVSQVRJT05cIik7XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZHVyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2VuZERhdGUpIHtcbiAgICAgIHJldHVybiAodGhpcy5fZW5kRGF0ZS5nZXRUaW1lKCkgLSB0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBwbGFubmVkRHVyYXRpb24oKSB7XG4gICAgaWYgKFwiUExBTk5FRC1EVVJBVElPTlwiIGluIHRoaXMuYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcIlBMQU5ORUQtRFVSQVRJT05cIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBlbmRPbk5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5ib29sKFwiRU5ELU9OLU5FWFRcIik7XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5pZCAmJiAhdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgJiYgaXNGaW5pdGVOdW1iZXIodGhpcy5zdGFydERhdGUuZ2V0VGltZSgpKSAmJiAodGhpcy5kdXJhdGlvbiA9PT0gbnVsbCB8fCB0aGlzLmR1cmF0aW9uID49IDApICYmICghdGhpcy5lbmRPbk5leHQgfHwgISF0aGlzLmNsYXNzKTtcbiAgfVxufVxuXG5jbGFzcyBMb2FkU3RhdHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgdGhpcy5yZXRyeSA9IDA7XG4gICAgdGhpcy50b3RhbCA9IDA7XG4gICAgdGhpcy5jaHVua0NvdW50ID0gMDtcbiAgICB0aGlzLmJ3RXN0aW1hdGUgPSAwO1xuICAgIHRoaXMubG9hZGluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICAgIHRoaXMucGFyc2luZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICB9XG59XG5cbnZhciBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgPSB7XG4gIEFVRElPOiBcImF1ZGlvXCIsXG4gIFZJREVPOiBcInZpZGVvXCIsXG4gIEFVRElPVklERU86IFwiYXVkaW92aWRlb1wiXG59O1xuY2xhc3MgQmFzZVNlZ21lbnQge1xuICAvLyBiYXNldXJsIGlzIHRoZSBVUkwgdG8gdGhlIHBsYXlsaXN0XG5cbiAgLy8gcmVsdXJsIGlzIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgdGhhdCBjb21lcyBmcm9tIGluc2lkZSB0aGUgcGxheWxpc3QuXG5cbiAgLy8gSG9sZHMgdGhlIHR5cGVzIG9mIGRhdGEgdGhpcyBmcmFnbWVudCBzdXBwb3J0c1xuXG4gIGNvbnN0cnVjdG9yKGJhc2V1cmwpIHtcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5iYXNldXJsID0gdm9pZCAwO1xuICAgIHRoaXMucmVsdXJsID0gdm9pZCAwO1xuICAgIHRoaXMuZWxlbWVudGFyeVN0cmVhbXMgPSB7XG4gICAgICBbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXTogbnVsbCxcbiAgICAgIFtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dOiBudWxsLFxuICAgICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXTogbnVsbFxuICAgIH07XG4gICAgdGhpcy5iYXNldXJsID0gYmFzZXVybDtcbiAgfVxuXG4gIC8vIHNldEJ5dGVSYW5nZSBjb252ZXJ0cyBhIEVYVC1YLUJZVEVSQU5HRSBhdHRyaWJ1dGUgaW50byBhIHR3byBlbGVtZW50IGFycmF5XG4gIHNldEJ5dGVSYW5nZSh2YWx1ZSwgcHJldmlvdXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB2YWx1ZS5zcGxpdCgnQCcsIDIpO1xuICAgIGNvbnN0IGJ5dGVSYW5nZSA9IFtdO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBieXRlUmFuZ2VbMF0gPSBwcmV2aW91cyA/IHByZXZpb3VzLmJ5dGVSYW5nZUVuZE9mZnNldCA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVSYW5nZVswXSA9IHBhcnNlSW50KHBhcmFtc1sxXSk7XG4gICAgfVxuICAgIGJ5dGVSYW5nZVsxXSA9IHBhcnNlSW50KHBhcmFtc1swXSkgKyBieXRlUmFuZ2VbMF07XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gYnl0ZVJhbmdlO1xuICB9XG4gIGdldCBieXRlUmFuZ2UoKSB7XG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgfVxuICBnZXQgYnl0ZVJhbmdlU3RhcnRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICB9XG4gIGdldCBieXRlUmFuZ2VFbmRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5iYXNldXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VybCB8fCAnJztcbiAgfVxuICBzZXQgdXJsKHZhbHVlKSB7XG4gICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFNlZ21lbnQuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWxEZXRhaWxzLmZyYWdtZW50c30uXG4gKi9cbmNsYXNzIEZyYWdtZW50IGV4dGVuZHMgQmFzZVNlZ21lbnQge1xuICAvLyBFWFRJTkYgaGFzIHRvIGJlIHByZXNlbnQgZm9yIGEgbTN1OCB0byBiZSBjb25zaWRlcmVkIHZhbGlkXG5cbiAgLy8gc24gbm90YXRlcyB0aGUgc2VxdWVuY2UgbnVtYmVyIGZvciBhIHNlZ21lbnQsIGFuZCBpZiBzZXQgdG8gYSBzdHJpbmcgY2FuIGJlICdpbml0U2VnbWVudCdcblxuICAvLyBsZXZlbGtleXMgYXJlIHRoZSBFWFQtWC1LRVkgdGFncyB0aGF0IGFwcGx5IHRvIHRoaXMgc2VnbWVudCBmb3IgZGVjcnlwdGlvblxuICAvLyBjb3JlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJpdmF0ZSBmaWVsZCBfZGVjcnlwdGRhdGEgaXMgdGhlIGxhY2sgb2YgdGhlIGluaXRpYWxpemVkIElWXG4gIC8vIF9kZWNyeXB0ZGF0YSB3aWxsIHNldCB0aGUgSVYgZm9yIHRoaXMgc2VnbWVudCBiYXNlZCBvbiB0aGUgc2VnbWVudCBudW1iZXIgaW4gdGhlIGZyYWdtZW50XG4gIC8vIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZnJhZ21lbnQgdHlwZVxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGZyYWdtZW50IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUga2V5IGxvYWRlci4gU2V0IHdoaWxlIHRoZSBrZXkgaXMgbG9hZGluZywgYW5kIHJlbW92ZWQgYWZ0ZXJ3YXJkcy4gVXNlZCB0byBhYm9ydCBrZXkgbG9hZGluZ1xuICAvLyBUaGUgbGV2ZWwvdHJhY2sgaW5kZXggdG8gd2hpY2ggdGhlIGZyYWdtZW50IGJlbG9uZ3NcbiAgLy8gVGhlIGNvbnRpbnVpdHkgY291bnRlciBvZiB0aGUgZnJhZ21lbnRcbiAgLy8gVGhlIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBUaGUgZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBUaGUgc3RhcnRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIC8vIFRoZSBlbmRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIC8vIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBmcmFnbWVudCwgYXMgbGlzdGVkIGluIHRoZSBtYW5pZmVzdC4gVXBkYXRlZCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gU2V0IGJ5IGB1cGRhdGVGcmFnUFRTRFRTYCBpbiBsZXZlbC1oZWxwZXJcbiAgLy8gVGhlIG1heGltdW0gc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIC8vIFRoZSBtaW5pbXVtIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoYXVkaW8vdmlkZW8gUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gTG9hZC9wYXJzZSB0aW1pbmcgaW5mb3JtYXRpb25cbiAgLy8gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgc2VnbWVudCB3YXMgZG93bmxvYWRlZCBpbiBvcmRlciB0byB0ZXN0IGJpdHJhdGUsIGFuZCB3YXMgbm90IGJ1ZmZlcmVkXG4gIC8vICNFWFRJTkYgIHNlZ21lbnQgdGl0bGVcbiAgLy8gVGhlIE1lZGlhIEluaXRpYWxpemF0aW9uIFNlY3Rpb24gZm9yIHRoaXMgc2VnbWVudFxuICAvLyBGcmFnbWVudCBpcyB0aGUgbGFzdCBmcmFnbWVudCBpbiB0aGUgbWVkaWEgcGxheWxpc3RcbiAgLy8gRnJhZ21lbnQgaXMgbWFya2VkIGJ5IGFuIEVYVC1YLUdBUCB0YWcgaW5kaWNhdGluZyB0aGF0IGl0IGRvZXMgbm90IGNvbnRhaW4gbWVkaWEgZGF0YSBhbmQgc2hvdWxkIG5vdCBiZSBsb2FkZWRcbiAgY29uc3RydWN0b3IodHlwZSwgYmFzZXVybCkge1xuICAgIHN1cGVyKGJhc2V1cmwpO1xuICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gbnVsbDtcbiAgICB0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgdGhpcy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIHRoaXMudGFnTGlzdCA9IFtdO1xuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIHRoaXMuc24gPSAwO1xuICAgIHRoaXMubGV2ZWxrZXlzID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5rZXlMb2FkZXIgPSBudWxsO1xuICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICB0aGlzLmNjID0gMDtcbiAgICB0aGlzLnN0YXJ0UFRTID0gdm9pZCAwO1xuICAgIHRoaXMuZW5kUFRTID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhcnREVFMgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmREVFMgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5kZWx0YVBUUyA9IHZvaWQgMDtcbiAgICB0aGlzLm1heFN0YXJ0UFRTID0gdm9pZCAwO1xuICAgIHRoaXMubWluRW5kUFRTID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgdGhpcy51cmxJZCA9IDA7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB0aGlzLnRpdGxlID0gbnVsbDtcbiAgICB0aGlzLmluaXRTZWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLmVuZExpc3QgPSB2b2lkIDA7XG4gICAgdGhpcy5nYXAgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGVjcnlwdGRhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxrZXlzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbGtleXMgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5cyAmJiAhdGhpcy5sZXZlbGtleXMuTk9ORSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5sZXZlbGtleXMuaWRlbnRpdHk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0ga2V5LmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgICAgaWYgKGtleUZvcm1hdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBlbmRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcih0aGlzLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9ICFpc0Zpbml0ZU51bWJlcih0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIGR1cmF0aW9uICogMTAwMDtcbiAgfVxuICBnZXQgZW5jcnlwdGVkKCkge1xuICAgIHZhciBfdGhpcyRfZGVjcnlwdGRhdGE7XG4gICAgLy8gQXQgdGhlIG0zdTgtcGFyc2VyIGxldmVsIHdlIG5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG1hbmlmZXN0IHNpZ25hbGxlZCBrZXlmb3JtYXRzXG4gICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgLy8gQ3VycmVudGx5LCBrZXlGb3JtYXQgd2lsbCBvbmx5IGJlIHNldCBmb3IgaWRlbnRpdHkga2V5c1xuICAgIGlmICgoX3RoaXMkX2RlY3J5cHRkYXRhID0gdGhpcy5fZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgX3RoaXMkX2RlY3J5cHRkYXRhLmVuY3J5cHRlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgIGNvbnN0IGxlbiA9IGtleUZvcm1hdHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IDEgfHwgbGVuID09PSAxICYmIHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdHNbMF1dLmVuY3J5cHRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNldEtleUZvcm1hdChrZXlGb3JtYXQpIHtcbiAgICBpZiAodGhpcy5sZXZlbGtleXMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdF07XG4gICAgICBpZiAoa2V5ICYmICF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IGtleS5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnRSZXF1ZXN0cygpIHtcbiAgICB2YXIgX3RoaXMkbG9hZGVyLCBfdGhpcyRrZXlMb2FkZXI7XG4gICAgKF90aGlzJGxvYWRlciA9IHRoaXMubG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbG9hZGVyLmFib3J0KCk7XG4gICAgKF90aGlzJGtleUxvYWRlciA9IHRoaXMua2V5TG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMka2V5TG9hZGVyLmFib3J0KCk7XG4gIH1cbiAgc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUywgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBpbmZvID0gZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUUyxcbiAgICAgICAgcGFydGlhbFxuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5mby5zdGFydFBUUyA9IE1hdGgubWluKGluZm8uc3RhcnRQVFMsIHN0YXJ0UFRTKTtcbiAgICBpbmZvLmVuZFBUUyA9IE1hdGgubWF4KGluZm8uZW5kUFRTLCBlbmRQVFMpO1xuICAgIGluZm8uc3RhcnREVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0RFRTLCBzdGFydERUUyk7XG4gICAgaW5mby5lbmREVFMgPSBNYXRoLm1heChpbmZvLmVuZERUUywgZW5kRFRTKTtcbiAgfVxuICBjbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zXG4gICAgfSA9IHRoaXM7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgUGFydGlhbCBTZWdtZW50LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsRGV0YWlscy5wYXJ0TGlzdH0uXG4gKi9cbmNsYXNzIFBhcnQgZXh0ZW5kcyBCYXNlU2VnbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcnRBdHRycywgZnJhZywgYmFzZXVybCwgaW5kZXgsIHByZXZpb3VzKSB7XG4gICAgc3VwZXIoYmFzZXVybCk7XG4gICAgdGhpcy5mcmFnT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmdhcCA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbHVybCA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXggPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgICB0aGlzLmR1cmF0aW9uID0gcGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdEVVJBVElPTicpO1xuICAgIHRoaXMuZ2FwID0gcGFydEF0dHJzLmJvb2woJ0dBUCcpO1xuICAgIHRoaXMuaW5kZXBlbmRlbnQgPSBwYXJ0QXR0cnMuYm9vbCgnSU5ERVBFTkRFTlQnKTtcbiAgICB0aGlzLnJlbHVybCA9IHBhcnRBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdVUkknKTtcbiAgICB0aGlzLmZyYWdtZW50ID0gZnJhZztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgYnl0ZVJhbmdlID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0JZVEVSQU5HRScpO1xuICAgIGlmIChieXRlUmFuZ2UpIHtcbiAgICAgIHRoaXMuc2V0Qnl0ZVJhbmdlKGJ5dGVSYW5nZSwgcHJldmlvdXMpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIHRoaXMuZnJhZ09mZnNldCA9IHByZXZpb3VzLmZyYWdPZmZzZXQgKyBwcmV2aW91cy5kdXJhdGlvbjtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0ICsgdGhpcy5mcmFnT2Zmc2V0O1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBsb2FkZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gISEoZWxlbWVudGFyeVN0cmVhbXMuYXVkaW8gfHwgZWxlbWVudGFyeVN0cmVhbXMudmlkZW8gfHwgZWxlbWVudGFyeVN0cmVhbXMuYXVkaW92aWRlbyk7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9UQVJHRVRfRFVSQVRJT04gPSAxMDtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIE1lZGlhIFBsYXlsaXN0LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsLmRldGFpbHN9LlxuICovXG5jbGFzcyBMZXZlbERldGFpbHMge1xuICAvLyBNYW5pZmVzdCByZWxvYWQgc3luY2hyb25pemF0aW9uXG5cbiAgY29uc3RydWN0b3IoYmFzZVVybCkge1xuICAgIHRoaXMuUFRTS25vd24gPSBmYWxzZTtcbiAgICB0aGlzLmFsaWduZWRTbGlkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5lbmRDQyA9IDA7XG4gICAgdGhpcy5lbmRTTiA9IDA7XG4gICAgdGhpcy5mcmFnbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnbWVudEhpbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0TGlzdCA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMubGl2ZSA9IHRydWU7XG4gICAgdGhpcy5hZ2VIZWFkZXIgPSAwO1xuICAgIHRoaXMuYWR2YW5jZWREYXRlVGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSB2b2lkIDA7XG4gICAgdGhpcy5taXNzZXMgPSAwO1xuICAgIHRoaXMuc3RhcnRDQyA9IDA7XG4gICAgdGhpcy5zdGFydFNOID0gMDtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXRkdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50b3RhbGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIHRoaXMudXJsID0gdm9pZCAwO1xuICAgIHRoaXMubTN1OCA9ICcnO1xuICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgdGhpcy5jYW5CbG9ja1JlbG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuU2tpcFVudGlsID0gMDtcbiAgICB0aGlzLmNhblNraXBEYXRlUmFuZ2VzID0gZmFsc2U7XG4gICAgdGhpcy5za2lwcGVkU2VnbWVudHMgPSAwO1xuICAgIHRoaXMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRIb2xkQmFjayA9IDA7XG4gICAgdGhpcy5ob2xkQmFjayA9IDA7XG4gICAgdGhpcy5wYXJ0VGFyZ2V0ID0gMDtcbiAgICB0aGlzLnByZWxvYWRIaW50ID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGl0aW9uUmVwb3J0cyA9IHZvaWQgMDtcbiAgICB0aGlzLnR1bmVJbkdvYWwgPSAwO1xuICAgIHRoaXMuZGVsdGFVcGRhdGVGYWlsZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5kcmlmdFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kcmlmdEVuZFRpbWUgPSAwO1xuICAgIHRoaXMuZHJpZnRTdGFydCA9IDA7XG4gICAgdGhpcy5kcmlmdEVuZCA9IDA7XG4gICAgdGhpcy5lbmNyeXB0ZWRGcmFnbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG51bGw7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuaGFzVmFyaWFibGVSZWZzID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHt9O1xuICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgfVxuICByZWxvYWRlZChwcmV2aW91cykge1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydFNuRGlmZiA9IHRoaXMubGFzdFBhcnRTbiAtIHByZXZpb3VzLmxhc3RQYXJ0U247XG4gICAgY29uc3QgcGFydEluZGV4RGlmZiA9IHRoaXMubGFzdFBhcnRJbmRleCAtIHByZXZpb3VzLmxhc3RQYXJ0SW5kZXg7XG4gICAgdGhpcy51cGRhdGVkID0gdGhpcy5lbmRTTiAhPT0gcHJldmlvdXMuZW5kU04gfHwgISFwYXJ0SW5kZXhEaWZmIHx8ICEhcGFydFNuRGlmZiB8fCAhdGhpcy5saXZlO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0aGlzLmVuZFNOID4gcHJldmlvdXMuZW5kU04gfHwgcGFydFNuRGlmZiA+IDAgfHwgcGFydFNuRGlmZiA9PT0gMCAmJiBwYXJ0SW5kZXhEaWZmID4gMDtcbiAgICBpZiAodGhpcy51cGRhdGVkIHx8IHRoaXMuYWR2YW5jZWQpIHtcbiAgICAgIHRoaXMubWlzc2VzID0gTWF0aC5mbG9vcihwcmV2aW91cy5taXNzZXMgKiAwLjYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1pc3NlcyA9IHByZXZpb3VzLm1pc3NlcyArIDE7XG4gICAgfVxuICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSBwcmV2aW91cy5hdmFpbGFiaWxpdHlEZWxheTtcbiAgfVxuICBnZXQgaGFzUHJvZ3JhbURhdGVUaW1lKCkge1xuICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpc0Zpbml0ZU51bWJlcih0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5wcm9ncmFtRGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0IGxldmVsVGFyZ2V0RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIHx8IHRoaXMudGFyZ2V0ZHVyYXRpb24gfHwgREVGQVVMVF9UQVJHRVRfRFVSQVRJT047XG4gIH1cbiAgZ2V0IGRyaWZ0KCkge1xuICAgIGNvbnN0IHJ1blRpbWUgPSB0aGlzLmRyaWZ0RW5kVGltZSAtIHRoaXMuZHJpZnRTdGFydFRpbWU7XG4gICAgaWYgKHJ1blRpbWUgPiAwKSB7XG4gICAgICBjb25zdCBydW5EdXJhdGlvbiA9IHRoaXMuZHJpZnRFbmQgLSB0aGlzLmRyaWZ0U3RhcnQ7XG4gICAgICByZXR1cm4gcnVuRHVyYXRpb24gKiAxMDAwIC8gcnVuVGltZTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0IGVkZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydEVuZCB8fCB0aGlzLmZyYWdtZW50RW5kO1xuICB9XG4gIGdldCBwYXJ0RW5kKCkge1xuICAgIHZhciBfdGhpcyRwYXJ0TGlzdDtcbiAgICBpZiAoKF90aGlzJHBhcnRMaXN0ID0gdGhpcy5wYXJ0TGlzdCkgIT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudEVuZDtcbiAgfVxuICBnZXQgZnJhZ21lbnRFbmQoKSB7XG4gICAgdmFyIF90aGlzJGZyYWdtZW50cztcbiAgICBpZiAoKF90aGlzJGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzKSAhPSBudWxsICYmIF90aGlzJGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBhZ2UoKSB7XG4gICAgaWYgKHRoaXMuYWR2YW5jZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KERhdGUubm93KCkgLSB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUsIDApIC8gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IGxhc3RQYXJ0SW5kZXgoKSB7XG4gICAgdmFyIF90aGlzJHBhcnRMaXN0MjtcbiAgICBpZiAoKF90aGlzJHBhcnRMaXN0MiA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGdldCBsYXN0UGFydFNuKCkge1xuICAgIHZhciBfdGhpcyRwYXJ0TGlzdDM7XG4gICAgaWYgKChfdGhpcyRwYXJ0TGlzdDMgPSB0aGlzLnBhcnRMaXN0KSAhPSBudWxsICYmIF90aGlzJHBhcnRMaXN0My5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZnJhZ21lbnQuc247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuZFNOO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERlY29kZShiYXNlNjRlbmNvZGVkU3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjRlbmNvZGVkU3RyKSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlJZEJ5dGVzKHN0cikge1xuICBjb25zdCBrZXlJZGJ5dGVzID0gc3RyVG9VdGY4YXJyYXkoc3RyKS5zdWJhcnJheSgwLCAxNik7XG4gIGNvbnN0IHBhZGRlZGtleUlkYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHBhZGRlZGtleUlkYnl0ZXMuc2V0KGtleUlkYnl0ZXMsIDE2IC0ga2V5SWRieXRlcy5sZW5ndGgpO1xuICByZXR1cm4gcGFkZGVka2V5SWRieXRlcztcbn1cbmZ1bmN0aW9uIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWQpIHtcbiAgY29uc3Qgc3dhcCA9IGZ1bmN0aW9uIHN3YXAoYXJyYXksIGZyb20sIHRvKSB7XG4gICAgY29uc3QgY3VyID0gYXJyYXlbZnJvbV07XG4gICAgYXJyYXlbZnJvbV0gPSBhcnJheVt0b107XG4gICAgYXJyYXlbdG9dID0gY3VyO1xuICB9O1xuICBzd2FwKGtleUlkLCAwLCAzKTtcbiAgc3dhcChrZXlJZCwgMSwgMik7XG4gIHN3YXAoa2V5SWQsIDQsIDUpO1xuICBzd2FwKGtleUlkLCA2LCA3KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHVyaSkge1xuICAvLyBkYXRhOls8bWVkaWEgdHlwZV1bO2F0dHJpYnV0ZT12YWx1ZV1bO2Jhc2U2NF0sPGRhdGE+XG4gIGNvbnN0IGNvbG9uc3BsaXQgPSB1cmkuc3BsaXQoJzonKTtcbiAgbGV0IGtleWRhdGEgPSBudWxsO1xuICBpZiAoY29sb25zcGxpdFswXSA9PT0gJ2RhdGEnICYmIGNvbG9uc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3Qgc2VtaWNvbG9uc3BsaXQgPSBjb2xvbnNwbGl0WzFdLnNwbGl0KCc7Jyk7XG4gICAgY29uc3QgY29tbWFzcGxpdCA9IHNlbWljb2xvbnNwbGl0W3NlbWljb2xvbnNwbGl0Lmxlbmd0aCAtIDFdLnNwbGl0KCcsJyk7XG4gICAgaWYgKGNvbW1hc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBpc2Jhc2U2NCA9IGNvbW1hc3BsaXRbMF0gPT09ICdiYXNlNjQnO1xuICAgICAgY29uc3QgZGF0YSA9IGNvbW1hc3BsaXRbMV07XG4gICAgICBpZiAoaXNiYXNlNjQpIHtcbiAgICAgICAgc2VtaWNvbG9uc3BsaXQuc3BsaWNlKC0xLCAxKTsgLy8gcmVtb3ZlIGZyb20gcHJvY2Vzc2luZ1xuICAgICAgICBrZXlkYXRhID0gYmFzZTY0RGVjb2RlKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ZGF0YSA9IGdldEtleUlkQnl0ZXMoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlkYXRhO1xufVxuZnVuY3Rpb24gc3RyVG9VdGY4YXJyYXkoc3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yL3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICovXG52YXIgS2V5U3lzdGVtcyA9IHtcbiAgQ0xFQVJLRVk6IFwib3JnLnczLmNsZWFya2V5XCIsXG4gIEZBSVJQTEFZOiBcImNvbS5hcHBsZS5mcHNcIixcbiAgUExBWVJFQURZOiBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCIsXG4gIFdJREVWSU5FOiBcImNvbS53aWRldmluZS5hbHBoYVwiXG59O1xuXG4vLyBQbGF5bGlzdCAjRVhULVgtS0VZIEtFWUZPUk1BVCB2YWx1ZXNcbnZhciBLZXlTeXN0ZW1Gb3JtYXRzID0ge1xuICBDTEVBUktFWTogXCJvcmcudzMuY2xlYXJrZXlcIixcbiAgRkFJUlBMQVk6IFwiY29tLmFwcGxlLnN0cmVhbWluZ2tleWRlbGl2ZXJ5XCIsXG4gIFBMQVlSRUFEWTogXCJjb20ubWljcm9zb2Z0LnBsYXlyZWFkeVwiLFxuICBXSURFVklORTogXCJ1cm46dXVpZDplZGVmOGJhOS03OWQ2LTRhY2UtYTNjOC0yN2RjZDUxZDIxZWRcIlxufTtcbmZ1bmN0aW9uIGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKGZvcm1hdCkge1xuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLkZBSVJQTEFZO1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtcy5QTEFZUkVBRFk7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuV0lERVZJTkU7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuQ0xFQVJLRVk7XG4gIH1cbn1cblxuLy8gU3lzdGVtIElEcyBmb3Igd2hpY2ggd2UgY2FuIGV4dHJhY3QgYSBrZXkgSUQgZnJvbSBcImVuY3J5cHRlZFwiIGV2ZW50IFBTU0hcbnZhciBLZXlTeXN0ZW1JZHMgPSB7XG4gIFdJREVWSU5FOiBcImVkZWY4YmE5NzlkNjRhY2VhM2M4MjdkY2Q1MWQyMWVkXCJcbn07XG5mdW5jdGlvbiBrZXlTeXN0ZW1JZFRvS2V5U3lzdGVtRG9tYWluKHN5c3RlbUlkKSB7XG4gIGlmIChzeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLldJREVWSU5FKSB7XG4gICAgcmV0dXJuIEtleVN5c3RlbXMuV0lERVZJTkU7XG4gICAgLy8gfSBlbHNlIGlmIChzeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLlBMQVlSRUFEWSkge1xuICAgIC8vICAgcmV0dXJuIEtleVN5c3RlbXMuUExBWVJFQURZO1xuICAgIC8vIH0gZWxzZSBpZiAoc3lzdGVtSWQgPT09IEtleVN5c3RlbUlkcy5DRU5DIHx8IHN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuQ0xFQVJLRVkpIHtcbiAgICAvLyAgIHJldHVybiBLZXlTeXN0ZW1zLkNMRUFSS0VZO1xuICB9XG59XG5cbmZ1bmN0aW9uIGtleVN5c3RlbURvbWFpblRvS2V5U3lzdGVtRm9ybWF0KGtleVN5c3RlbSkge1xuICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgIGNhc2UgS2V5U3lzdGVtcy5GQUlSUExBWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLkZBSVJQTEFZO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5QTEFZUkVBRFk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLkNMRUFSS0VZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuQ0xFQVJLRVk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEtleVN5c3RlbXNGb3JDb25maWcoY29uZmlnKSB7XG4gIGNvbnN0IHtcbiAgICBkcm1TeXN0ZW1zLFxuICAgIHdpZGV2aW5lTGljZW5zZVVybFxuICB9ID0gY29uZmlnO1xuICBjb25zdCBrZXlTeXN0ZW1zVG9BdHRlbXB0ID0gZHJtU3lzdGVtcyA/IFtLZXlTeXN0ZW1zLkZBSVJQTEFZLCBLZXlTeXN0ZW1zLldJREVWSU5FLCBLZXlTeXN0ZW1zLlBMQVlSRUFEWSwgS2V5U3lzdGVtcy5DTEVBUktFWV0uZmlsdGVyKGtleVN5c3RlbSA9PiAhIWRybVN5c3RlbXNba2V5U3lzdGVtXSkgOiBbXTtcbiAgaWYgKCFrZXlTeXN0ZW1zVG9BdHRlbXB0W0tleVN5c3RlbXMuV0lERVZJTkVdICYmIHdpZGV2aW5lTGljZW5zZVVybCkge1xuICAgIGtleVN5c3RlbXNUb0F0dGVtcHQucHVzaChLZXlTeXN0ZW1zLldJREVWSU5FKTtcbiAgfVxuICByZXR1cm4ga2V5U3lzdGVtc1RvQXR0ZW1wdDtcbn1cbmNvbnN0IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLm5hdmlnYXRvciAmJiBzZWxmLm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICByZXR1cm4gc2VsZi5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzLmJpbmQoc2VsZi5uYXZpZ2F0b3IpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59KCk7XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgbGV0IGluaXREYXRhVHlwZXM7XG4gIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLkZBSVJQTEFZOlxuICAgICAgaW5pdERhdGFUeXBlcyA9IFsnY2VuYycsICdzaW5mJ107XG4gICAgICBicmVhaztcbiAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgY2FzZSBLZXlTeXN0ZW1zLlBMQVlSRUFEWTpcbiAgICAgIGluaXREYXRhVHlwZXMgPSBbJ2NlbmMnXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5DTEVBUktFWTpcbiAgICAgIGluaXREYXRhVHlwZXMgPSBbJ2NlbmMnLCAna2V5aWRzJ107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGtleS1zeXN0ZW06ICR7a2V5U3lzdGVtfWApO1xuICB9XG4gIHJldHVybiBjcmVhdGVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGluaXREYXRhVHlwZXMsIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGluaXREYXRhVHlwZXMsIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucykge1xuICBjb25zdCBiYXNlQ29uZmlnID0ge1xuICAgIGluaXREYXRhVHlwZXM6IGluaXREYXRhVHlwZXMsXG4gICAgcGVyc2lzdGVudFN0YXRlOiBkcm1TeXN0ZW1PcHRpb25zLnBlcnNpc3RlbnRTdGF0ZSB8fCAnbm90LWFsbG93ZWQnLFxuICAgIGRpc3RpbmN0aXZlSWRlbnRpZmllcjogZHJtU3lzdGVtT3B0aW9ucy5kaXN0aW5jdGl2ZUlkZW50aWZpZXIgfHwgJ25vdC1hbGxvd2VkJyxcbiAgICBzZXNzaW9uVHlwZXM6IGRybVN5c3RlbU9wdGlvbnMuc2Vzc2lvblR5cGVzIHx8IFtkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlIHx8ICd0ZW1wb3JhcnknXSxcbiAgICBhdWRpb0NhcGFiaWxpdGllczogYXVkaW9Db2RlY3MubWFwKGNvZGVjID0+ICh7XG4gICAgICBjb250ZW50VHlwZTogYGF1ZGlvL21wNDsgY29kZWNzPVwiJHtjb2RlY31cImAsXG4gICAgICByb2J1c3RuZXNzOiBkcm1TeXN0ZW1PcHRpb25zLmF1ZGlvUm9idXN0bmVzcyB8fCAnJyxcbiAgICAgIGVuY3J5cHRpb25TY2hlbWU6IGRybVN5c3RlbU9wdGlvbnMuYXVkaW9FbmNyeXB0aW9uU2NoZW1lIHx8IG51bGxcbiAgICB9KSksXG4gICAgdmlkZW9DYXBhYmlsaXRpZXM6IHZpZGVvQ29kZWNzLm1hcChjb2RlYyA9PiAoe1xuICAgICAgY29udGVudFR5cGU6IGB2aWRlby9tcDQ7IGNvZGVjcz1cIiR7Y29kZWN9XCJgLFxuICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy52aWRlb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICBlbmNyeXB0aW9uU2NoZW1lOiBkcm1TeXN0ZW1PcHRpb25zLnZpZGVvRW5jcnlwdGlvblNjaGVtZSB8fCBudWxsXG4gICAgfSkpXG4gIH07XG4gIHJldHVybiBbYmFzZUNvbmZpZ107XG59XG5cbmZ1bmN0aW9uIHNsaWNlVWludDgoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIHBvbHlmaWxscyBJRTExIHVzYWdlIG9mIFVpbnQ4QXJyYXkgc2xpY2UuXG4gIC8vIEl0IGFsd2F5cyBleGlzdHMgaW4gdGhlIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBzbyBmYWlscywgYnV0IGl0IGZhaWxzIGF0IHJ1bnRpbWUgb24gSUUxMS5cbiAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlID8gYXJyYXkuc2xpY2Uoc3RhcnQsIGVuZCkgOiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheSwgc3RhcnQsIGVuZCkpO1xufVxuXG4vLyBicmVha2luZyB1cCB0aG9zZSB0d28gdHlwZXMgaW4gb3JkZXIgdG8gY2xhcmlmeSB3aGF0IGlzIGhhcHBlbmluZyBpbiB0aGUgZGVjb2RpbmcgcGF0aC5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGhlYWRlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqL1xuY29uc3QgaXNIZWFkZXIkMiA9IChkYXRhLCBvZmZzZXQpID0+IHtcbiAgLypcbiAgICogaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wXG4gICAqIFswXSAgICAgPSAnSSdcbiAgICogWzFdICAgICA9ICdEJ1xuICAgKiBbMl0gICAgID0gJzMnXG4gICAqIFszLDRdICAgPSB7VmVyc2lvbn1cbiAgICogWzVdICAgICA9IHtGbGFnc31cbiAgICogWzYtOV0gICA9IHtJRDMgU2l6ZX1cbiAgICpcbiAgICogQW4gSUQzdjIgdGFnIGNhbiBiZSBkZXRlY3RlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcbiAgICogICQ0OSA0NCAzMyB5eSB5eSB4eCB6eiB6eiB6eiB6elxuICAgKiBXaGVyZSB5eSBpcyBsZXNzIHRoYW4gJEZGLCB4eCBpcyB0aGUgJ2ZsYWdzJyBieXRlIGFuZCB6eiBpcyBsZXNzIHRoYW4gJDgwXG4gICAqL1xuICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBsb29rIGZvciAnSUQzJyBpZGVudGlmaWVyXG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHg0OSAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4MzMpIHtcbiAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4ZmYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4ZmYpIHtcbiAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGZvb3RlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqL1xuY29uc3QgaXNGb290ZXIgPSAoZGF0YSwgb2Zmc2V0KSA9PiB7XG4gIC8qXG4gICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICovXG4gIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIGxvb2sgZm9yICczREknIGlkZW50aWZpZXJcbiAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDMzICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OSkge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW55IGFkamFjZW50IElEMyB0YWdzIGZvdW5kIGluIGRhdGEgc3RhcnRpbmcgYXQgb2Zmc2V0LCBhcyBvbmUgYmxvY2sgb2YgZGF0YVxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICogQHJldHVybnMgdGhlIGJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBhbnkgSUQzIHRhZ3MgZm91bmRcbiAqIG9yICp1bmRlZmluZWQqIGlmIG5vIGhlYWRlciBpcyBmb3VuZCBhdCB0aGUgc3RhcnRpbmcgb2Zmc2V0XG4gKi9cbmNvbnN0IGdldElEM0RhdGEgPSAoZGF0YSwgb2Zmc2V0KSA9PiB7XG4gIGNvbnN0IGZyb250ID0gb2Zmc2V0O1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgd2hpbGUgKGlzSGVhZGVyJDIoZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIElEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcbiAgICBsZW5ndGggKz0gMTA7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRTaXplKGRhdGEsIG9mZnNldCArIDYpO1xuICAgIGxlbmd0aCArPSBzaXplO1xuICAgIGlmIChpc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcbiAgICAgIC8vIElEMyBmb290ZXIgaXMgMTAgYnl0ZXNcbiAgICAgIGxlbmd0aCArPSAxMDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgfVxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCByZWFkU2l6ZSA9IChkYXRhLCBvZmZzZXQpID0+IHtcbiAgbGV0IHNpemUgPSAwO1xuICBzaXplID0gKGRhdGFbb2Zmc2V0XSAmIDB4N2YpIDw8IDIxO1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDFdICYgMHg3ZikgPDwgMTQ7XG4gIHNpemUgfD0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDdmKSA8PCA3O1xuICBzaXplIHw9IGRhdGFbb2Zmc2V0ICsgM10gJiAweDdmO1xuICByZXR1cm4gc2l6ZTtcbn07XG5jb25zdCBjYW5QYXJzZSQyID0gKGRhdGEsIG9mZnNldCkgPT4ge1xuICByZXR1cm4gaXNIZWFkZXIkMihkYXRhLCBvZmZzZXQpICYmIHJlYWRTaXplKGRhdGEsIG9mZnNldCArIDYpICsgMTAgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG59O1xuXG4vKipcbiAqIFNlYXJjaGVzIGZvciB0aGUgRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZvdW5kIGluIHRoZSBJRDMgZGF0YSBjaHVua1xuICogQHBhcmFtIGRhdGEgLSBCbG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAqL1xuY29uc3QgZ2V0VGltZVN0YW1wID0gZGF0YSA9PiB7XG4gIGNvbnN0IGZyYW1lcyA9IGdldElEM0ZyYW1lcyhkYXRhKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcbiAgICBpZiAoaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgIHJldHVybiByZWFkVGltZVN0YW1wKGZyYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBJRDMgZnJhbWUgaXMgYW4gRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZyYW1lXG4gKi9cbmNvbnN0IGlzVGltZVN0YW1wRnJhbWUgPSBmcmFtZSA9PiB7XG4gIHJldHVybiBmcmFtZSAmJiBmcmFtZS5rZXkgPT09ICdQUklWJyAmJiBmcmFtZS5pbmZvID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnO1xufTtcbmNvbnN0IGdldEZyYW1lRGF0YSA9IGRhdGEgPT4ge1xuICAvKlxuICBGcmFtZSBJRCAgICAgICAkeHggeHggeHggeHggKGZvdXIgY2hhcmFjdGVycylcbiAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XG4gIEZsYWdzICAgICAgICAgICR4eCB4eFxuICAqL1xuICBjb25zdCB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgY29uc3Qgc2l6ZSA9IHJlYWRTaXplKGRhdGEsIDQpO1xuXG4gIC8vIHNraXAgZnJhbWUgaWQsIHNpemUsIGFuZCBmbGFnc1xuICBjb25zdCBvZmZzZXQgPSAxMDtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHNpemUsXG4gICAgZGF0YTogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gKiBAcGFyYW0gaWQzRGF0YSAtIFRoZSBJRDMgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKi9cbmNvbnN0IGdldElEM0ZyYW1lcyA9IGlkM0RhdGEgPT4ge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZnJhbWVzID0gW107XG4gIHdoaWxlIChpc0hlYWRlciQyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICBjb25zdCBzaXplID0gcmVhZFNpemUoaWQzRGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgLy8gc2tpcCBwYXN0IElEMyBoZWFkZXJcbiAgICBvZmZzZXQgKz0gMTA7XG4gICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAvLyBsb29wIHRocm91Z2ggZnJhbWVzIGluIHRoZSBJRDMgdGFnXG4gICAgd2hpbGUgKG9mZnNldCArIDggPCBlbmQpIHtcbiAgICAgIGNvbnN0IGZyYW1lRGF0YSA9IGdldEZyYW1lRGF0YShpZDNEYXRhLnN1YmFycmF5KG9mZnNldCkpO1xuICAgICAgY29uc3QgZnJhbWUgPSBkZWNvZGVGcmFtZShmcmFtZURhdGEpO1xuICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgIGZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2tpcCBmcmFtZSBoZWFkZXIgYW5kIGZyYW1lIGRhdGFcbiAgICAgIG9mZnNldCArPSBmcmFtZURhdGEuc2l6ZSArIDEwO1xuICAgIH1cbiAgICBpZiAoaXNGb290ZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgICAgb2Zmc2V0ICs9IDEwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJhbWVzO1xufTtcbmNvbnN0IGRlY29kZUZyYW1lID0gZnJhbWUgPT4ge1xuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1BSSVYnKSB7XG4gICAgcmV0dXJuIGRlY29kZVByaXZGcmFtZShmcmFtZSk7XG4gIH0gZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1cnKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSTEZyYW1lKGZyYW1lKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlVGV4dEZyYW1lKGZyYW1lKTtcbn07XG5jb25zdCBkZWNvZGVQcml2RnJhbWUgPSBmcmFtZSA9PiB7XG4gIC8qXG4gIEZvcm1hdDogPHRleHQgc3RyaW5nPlxcMDxiaW5hcnkgZGF0YT5cbiAgKi9cbiAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBvd25lciA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICBjb25zdCBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBpbmZvOiBvd25lcixcbiAgICBkYXRhOiBwcml2YXRlRGF0YS5idWZmZXJcbiAgfTtcbn07XG5jb25zdCBkZWNvZGVUZXh0RnJhbWUgPSBmcmFtZSA9PiB7XG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1ZhbHVlfVxuICAgICovXG4gICAgbGV0IGluZGV4ID0gMTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpLCB0cnVlKTtcbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHZhbHVlID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgICBpbmZvOiBkZXNjcmlwdGlvbixcbiAgICAgIGRhdGE6IHZhbHVlXG4gICAgfTtcbiAgfVxuICAvKlxuICBGb3JtYXQ6XG4gIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gIFsxLT9dID0ge1ZhbHVlfVxuICAqL1xuICBjb25zdCB0ZXh0ID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBmcmFtZS50eXBlLFxuICAgIGRhdGE6IHRleHRcbiAgfTtcbn07XG5jb25zdCBkZWNvZGVVUkxGcmFtZSA9IGZyYW1lID0+IHtcbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdXWFhYJykge1xuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1VSTH1cbiAgICAqL1xuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGluZGV4ID0gMTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpLCB0cnVlKTtcbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHZhbHVlID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgICBpbmZvOiBkZXNjcmlwdGlvbixcbiAgICAgIGRhdGE6IHZhbHVlXG4gICAgfTtcbiAgfVxuICAvKlxuICBGb3JtYXQ6XG4gIFswLT9dID0ge1VSTH1cbiAgKi9cbiAgY29uc3QgdXJsID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBmcmFtZS50eXBlLFxuICAgIGRhdGE6IHVybFxuICB9O1xufTtcbmNvbnN0IHJlYWRUaW1lU3RhbXAgPSB0aW1lU3RhbXBGcmFtZSA9PiB7XG4gIGlmICh0aW1lU3RhbXBGcmFtZS5kYXRhLmJ5dGVMZW5ndGggPT09IDgpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGltZVN0YW1wRnJhbWUuZGF0YSk7XG4gICAgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcbiAgICAvLyB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgIGNvbnN0IHB0czMzQml0ID0gZGF0YVszXSAmIDB4MTtcbiAgICBsZXQgdGltZXN0YW1wID0gKGRhdGFbNF0gPDwgMjMpICsgKGRhdGFbNV0gPDwgMTUpICsgKGRhdGFbNl0gPDwgNykgKyBkYXRhWzddO1xuICAgIHRpbWVzdGFtcCAvPSA0NTtcbiAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcbiAgICB9IC8vIDJeMzIgLyA5MFxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQodGltZXN0YW1wKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcbi8vIGh0dHA6Ly93d3cub25pY29zLmNvbS9zdGFmZi9pei9hbXVzZS9qYXZhc2NyaXB0L2V4cGVydC91dGYudHh0XG4vKiB1dGYuanMgLSBVVEYtOCA8PT4gVVRGLTE2IGNvbnZlcnRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDE5OTkgTWFzYW5hbyBJenVtbyA8aXpAb25pY29zLmNvLmpwPlxuICogVmVyc2lvbjogMS4wXG4gKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZS4gIFlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXQuXG4gKi9cbmNvbnN0IHV0ZjhBcnJheVRvU3RyID0gKGFycmF5LCBleGl0T25OdWxsID0gZmFsc2UpID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGdldFRleHREZWNvZGVyKCk7XG4gIGlmIChkZWNvZGVyKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGFycmF5KTtcbiAgICBpZiAoZXhpdE9uTnVsbCkge1xuICAgICAgLy8gZ3JhYiB1cCB0byB0aGUgZmlyc3QgbnVsbFxuICAgICAgY29uc3QgaWR4ID0gZGVjb2RlZC5pbmRleE9mKCdcXDAnKTtcbiAgICAgIHJldHVybiBpZHggIT09IC0xID8gZGVjb2RlZC5zdWJzdHJpbmcoMCwgaWR4KSA6IGRlY29kZWQ7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFueSBudWxsIGNoYXJhY3RlcnNcbiAgICByZXR1cm4gZGVjb2RlZC5yZXBsYWNlKC9cXDAvZywgJycpO1xuICB9XG4gIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgbGV0IGM7XG4gIGxldCBjaGFyMjtcbiAgbGV0IGNoYXIzO1xuICBsZXQgb3V0ID0gJyc7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBjID0gYXJyYXlbaSsrXTtcbiAgICBpZiAoYyA9PT0gMHgwMCAmJiBleGl0T25OdWxsKSB7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gMHgwMCB8fCBjID09PSAweDAzKSB7XG4gICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIDMgKEVORF9PRl9URVhUKSBvciAwIChOVUxMKSB0aGVuIHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxOlxuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSA0OlxuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyAweHh4eHh4eFxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyOlxuICAgICAgY2FzZSAxMzpcbiAgICAgICAgLy8gMTEweCB4eHh4ICAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDFmKSA8PCA2IHwgY2hhcjIgJiAweDNmKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE0OlxuICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDB4MGYpIDw8IDEyIHwgKGNoYXIyICYgMHgzZikgPDwgNiB8IChjaGFyMyAmIDB4M2YpIDw8IDApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5sZXQgZGVjb2RlcjtcbmZ1bmN0aW9uIGdldFRleHREZWNvZGVyKCkge1xuICBpZiAoIWRlY29kZXIgJiYgdHlwZW9mIHNlbGYuVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVjb2RlciA9IG5ldyBzZWxmLlRleHREZWNvZGVyKCd1dGYtOCcpO1xuICB9XG4gIHJldHVybiBkZWNvZGVyO1xufVxuXG4vKipcbiAqICBoZXggZHVtcCBoZWxwZXIgY2xhc3NcbiAqL1xuXG5jb25zdCBIZXggPSB7XG4gIGhleER1bXA6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaCA9IGFycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICB9XG4gICAgICBzdHIgKz0gaDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufTtcblxuY29uc3QgVUlOVDMyX01BWCQxID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbmNvbnN0IHB1c2ggPSBbXS5wdXNoO1xuXG4vLyBXZSBhcmUgdXNpbmcgZml4ZWQgdHJhY2sgSURzIGZvciBkcml2aW5nIHRoZSBNUDQgcmVtdXhlclxuLy8gaW5zdGVhZCBvZiBmb2xsb3dpbmcgdGhlIFRTIFBJRHMuXG4vLyBUaGVyZSBpcyBubyByZWFzb24gbm90IHRvIGRvIHRoaXMgYW5kIHNvbWUgYnJvd3NlcnMvU291cmNlQnVmZmVyLWRlbXV4ZXJzXG4vLyBtYXkgbm90IGxpa2UgaWYgdGhlcmUgYXJlIFRyYWNrSUQgXCJzd2l0Y2hlc1wiXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzEzMzFcbi8vIEhlcmUgd2UgYXJlIG1hcHBpbmcgb3VyIGludGVybmFsIHRyYWNrIHR5cGVzIHRvIGNvbnN0YW50IE1QNCB0cmFjayBJRHNcbi8vIFdpdGggTVNFIGN1cnJlbnRseSBvbmUgY2FuIG9ubHkgaGF2ZSBvbmUgdHJhY2sgb2YgZWFjaCwgYW5kIHdlIGFyZSBtdXhpbmdcbi8vIHdoYXRldmVyIHZpZGVvL2F1ZGlvIHJlbmRpdGlvbiBpbiB0aGVtLlxuY29uc3QgUmVtdXhlclRyYWNrSWRDb25maWcgPSB7XG4gIHZpZGVvOiAxLFxuICBhdWRpbzogMixcbiAgaWQzOiAzLFxuICB0ZXh0OiA0XG59O1xuZnVuY3Rpb24gYmluMnN0cihkYXRhKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGEpO1xufVxuZnVuY3Rpb24gcmVhZFVpbnQxNihidWZmZXIsIG9mZnNldCkge1xuICBjb25zdCB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCA4IHwgYnVmZmVyW29mZnNldCArIDFdO1xuICByZXR1cm4gdmFsIDwgMCA/IDY1NTM2ICsgdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICBjb25zdCB2YWwgPSByZWFkU2ludDMyKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICByZXR1cm4gYnVmZmVyW29mZnNldF0gPDwgMjQgfCBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfCBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAzXTtcbn1cbmZ1bmN0aW9uIHdyaXRlVWludDMyKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlID4+IDI0O1xuICBidWZmZXJbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiAxNiAmIDB4ZmY7XG4gIGJ1ZmZlcltvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDggJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG59XG5cbi8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuZnVuY3Rpb24gZmluZEJveChkYXRhLCBwYXRoKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgaWYgKCFwYXRoLmxlbmd0aCkge1xuICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBjb25zdCBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOykge1xuICAgIGNvbnN0IHNpemUgPSByZWFkVWludDMyKGRhdGEsIGkpO1xuICAgIGNvbnN0IHR5cGUgPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkoaSArIDQsIGkgKyA4KSk7XG4gICAgY29uc3QgZW5kYm94ID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGVuZDtcbiAgICBpZiAodHlwZSA9PT0gcGF0aFswXSkge1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXG4gICAgICAgIC8vIGxvb2tpbmcgZm9yXG4gICAgICAgIHJlc3VsdHMucHVzaChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgdGhlIG5leHQgYm94IGFsb25nIHRoZSBwYXRoXG4gICAgICAgIGNvbnN0IHN1YnJlc3VsdHMgPSBmaW5kQm94KGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZGJveCksIHBhdGguc2xpY2UoMSkpO1xuICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHN1YnJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSBlbmRib3g7XG4gIH1cblxuICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBwYXJzZVNlZ21lbnRJbmRleChzaWR4KSB7XG4gIGNvbnN0IHJlZmVyZW5jZXMgPSBbXTtcbiAgY29uc3QgdmVyc2lvbiA9IHNpZHhbMF07XG5cbiAgLy8gc2V0IGluaXRpYWwgb2Zmc2V0LCB3ZSBza2lwIHRoZSByZWZlcmVuY2UgSUQgKG5vdCBuZWVkZWQpXG4gIGxldCBpbmRleCA9IDg7XG4gIGNvbnN0IHRpbWVzY2FsZSA9IHJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSA0O1xuXG4gIC8vIFRPRE86IHBhcnNlIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSBhbmQgZmlyc3RPZmZzZXRcbiAgLy8gdXN1YWxseSB6ZXJvIGluIG91ciBjYXNlXG4gIGNvbnN0IGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IDA7XG4gIGNvbnN0IGZpcnN0T2Zmc2V0ID0gMDtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICBpbmRleCArPSA4O1xuICB9IGVsc2Uge1xuICAgIGluZGV4ICs9IDE2O1xuICB9XG5cbiAgLy8gc2tpcCByZXNlcnZlZFxuICBpbmRleCArPSAyO1xuICBsZXQgc3RhcnRCeXRlID0gc2lkeC5sZW5ndGggKyBmaXJzdE9mZnNldDtcbiAgY29uc3QgcmVmZXJlbmNlc0NvdW50ID0gcmVhZFVpbnQxNihzaWR4LCBpbmRleCk7XG4gIGluZGV4ICs9IDI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICBsZXQgcmVmZXJlbmNlSW5kZXggPSBpbmRleDtcbiAgICBjb25zdCByZWZlcmVuY2VJbmZvID0gcmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICBjb25zdCByZWZlcmVuY2VTaXplID0gcmVmZXJlbmNlSW5mbyAmIDB4N2ZmZmZmZmY7XG4gICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IChyZWZlcmVuY2VJbmZvICYgMHg4MDAwMDAwMCkgPj4+IDMxO1xuICAgIGlmIChyZWZlcmVuY2VUeXBlID09PSAxKSB7XG4gICAgICBsb2dnZXIud2FybignU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2VnbWVudER1cmF0aW9uID0gcmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgcmVmZXJlbmNlU2l6ZSxcbiAgICAgIHN1YnNlZ21lbnREdXJhdGlvbixcbiAgICAgIC8vIHVuc2NhbGVkXG4gICAgICBpbmZvOiB7XG4gICAgICAgIGR1cmF0aW9uOiBzdWJzZWdtZW50RHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydEJ5dGUsXG4gICAgICAgIGVuZDogc3RhcnRCeXRlICsgcmVmZXJlbmNlU2l6ZSAtIDFcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdGFydEJ5dGUgKz0gcmVmZXJlbmNlU2l6ZTtcblxuICAgIC8vIFNraXBwaW5nIDEgYml0IGZvciB8c3RhcnRzV2l0aFNhcHwsIDMgYml0cyBmb3IgfHNhcFR5cGV8LCBhbmQgMjggYml0c1xuICAgIC8vIGZvciB8c2FwRGVsdGF8LlxuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG5cbiAgICAvLyBza2lwIHRvIG5leHQgcmVmXG4gICAgaW5kZXggPSByZWZlcmVuY2VJbmRleDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSxcbiAgICB0aW1lc2NhbGUsXG4gICAgdmVyc2lvbixcbiAgICByZWZlcmVuY2VzQ291bnQsXG4gICAgcmVmZXJlbmNlc1xuICB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgc3RyZWFtIHR5cGUgYW5kXG4gKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICogbnVtYmVyIG9mIGNsb2NrIHRpY2tzIHBlciBzZWNvbmQgdG8gYXNzdW1lIGZvciB0aW1lLWJhc2VkIHZhbHVlc1xuICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gKlxuICogVG8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lIG9mIGFuIE1QNCwgeW91IG5lZWQgdHdvIHBpZWNlcyBvZlxuICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gKiBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGlzIGFsd2F5cyBleHByZXNzZWQgaW4gdGhlIHRpbWVzY2FsZSBmcm9tXG4gKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICogYGBgXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBtZGhkLnRpbWVzY2FsZVxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gaGRsclxuICogYGBgXG4gKiBAcGFyYW0gaW5pdFNlZ21lbnQgdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcbiAqIEByZXR1cm5zIGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXMgb3IgbnVsbCBpZlxuICogdGhlIGluaXQgc2VnbWVudCBpcyBtYWxmb3JtZWQuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgdHJha3MgPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAndHJhayddKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWsgPSB0cmFrc1tpXTtcbiAgICBjb25zdCB0a2hkID0gZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG4gICAgaWYgKHRraGQpIHtcbiAgICAgIGxldCB2ZXJzaW9uID0gdGtoZFswXTtcbiAgICAgIGxldCBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgY29uc3QgdHJhY2tJZCA9IHJlYWRVaW50MzIodGtoZCwgaW5kZXgpO1xuICAgICAgY29uc3QgbWRoZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XG4gICAgICBpZiAobWRoZCkge1xuICAgICAgICB2ZXJzaW9uID0gbWRoZFswXTtcbiAgICAgICAgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgICAgY29uc3QgdGltZXNjYWxlID0gcmVhZFVpbnQzMihtZGhkLCBpbmRleCk7XG4gICAgICAgIGNvbnN0IGhkbHIgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdoZGxyJ10pWzBdO1xuICAgICAgICBpZiAoaGRscikge1xuICAgICAgICAgIGNvbnN0IGhkbHJUeXBlID0gYmluMnN0cihoZGxyLnN1YmFycmF5KDgsIDEyKSk7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHtcbiAgICAgICAgICAgIHNvdW46IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyxcbiAgICAgICAgICAgIHZpZGU6IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT1xuICAgICAgICAgIH1baGRsclR5cGVdO1xuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBjb2RlYyBkZXRhaWxzXG4gICAgICAgICAgICBjb25zdCBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG4gICAgICAgICAgICBsZXQgY29kZWM7XG4gICAgICAgICAgICBpZiAoc3RzZCkge1xuICAgICAgICAgICAgICBjb2RlYyA9IGJpbjJzdHIoc3RzZC5zdWJhcnJheSgxMiwgMTYpKTtcbiAgICAgICAgICAgICAgLy8gVE9ETzogUGFyc2UgY29kZWMgZGV0YWlscyB0byBiZSBhYmxlIHRvIGJ1aWxkIE1JTUUgdHlwZS5cbiAgICAgICAgICAgICAgLy8gc3RzZC5zdGFydCArPSA4O1xuICAgICAgICAgICAgICAvLyBjb25zdCBjb2RlY0JveCA9IGZpbmRCb3goc3RzZCwgW2NvZGVjXSlbMF07XG4gICAgICAgICAgICAgIC8vIGlmIChjb2RlY0JveCkge1xuICAgICAgICAgICAgICAvLyAgIFRPRE86IENvZGVjIHBhcnNpbmcgc3VwcG9ydCBmb3IgYXZjMSwgbXA0YSwgaGV2YywgYXYwMS4uLlxuICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdFt0cmFja0lkXSA9IHtcbiAgICAgICAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0ge1xuICAgICAgICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgIGlkOiB0cmFja0lkLFxuICAgICAgICAgICAgICBjb2RlY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgdHJleCA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICdtdmV4JywgJ3RyZXgnXSk7XG4gIHRyZXguZm9yRWFjaCh0cmV4ID0+IHtcbiAgICBjb25zdCB0cmFja0lkID0gcmVhZFVpbnQzMih0cmV4LCA0KTtcbiAgICBjb25zdCB0cmFjayA9IHJlc3VsdFt0cmFja0lkXTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLmRlZmF1bHQgPSB7XG4gICAgICAgIGR1cmF0aW9uOiByZWFkVWludDMyKHRyZXgsIDEyKSxcbiAgICAgICAgZmxhZ3M6IHJlYWRVaW50MzIodHJleCwgMjApXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXRjaEVuY3lwdGlvbkRhdGEoaW5pdFNlZ21lbnQsIGRlY3J5cHRkYXRhKSB7XG4gIGlmICghaW5pdFNlZ21lbnQgfHwgIWRlY3J5cHRkYXRhKSB7XG4gICAgcmV0dXJuIGluaXRTZWdtZW50O1xuICB9XG4gIGNvbnN0IGtleUlkID0gZGVjcnlwdGRhdGEua2V5SWQ7XG4gIGlmIChrZXlJZCAmJiBkZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICBjb25zdCB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICAgIHRyYWtzLmZvckVhY2godHJhayA9PiB7XG4gICAgICBjb25zdCBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG5cbiAgICAgIC8vIHNraXAgdGhlIHNhbXBsZSBlbnRyeSBjb3VudFxuICAgICAgY29uc3Qgc2FtcGxlRW50cmllcyA9IHN0c2Quc3ViYXJyYXkoOCk7XG4gICAgICBsZXQgZW5jQm94ZXMgPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFsnZW5jYSddKTtcbiAgICAgIGNvbnN0IGlzQXVkaW8gPSBlbmNCb3hlcy5sZW5ndGggPiAwO1xuICAgICAgaWYgKCFpc0F1ZGlvKSB7XG4gICAgICAgIGVuY0JveGVzID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbJ2VuY3YnXSk7XG4gICAgICB9XG4gICAgICBlbmNCb3hlcy5mb3JFYWNoKGVuYyA9PiB7XG4gICAgICAgIGNvbnN0IGVuY0JveENoaWxkcmVuID0gaXNBdWRpbyA/IGVuYy5zdWJhcnJheSgyOCkgOiBlbmMuc3ViYXJyYXkoNzgpO1xuICAgICAgICBjb25zdCBzaW5mQm94ZXMgPSBmaW5kQm94KGVuY0JveENoaWxkcmVuLCBbJ3NpbmYnXSk7XG4gICAgICAgIHNpbmZCb3hlcy5mb3JFYWNoKHNpbmYgPT4ge1xuICAgICAgICAgIGNvbnN0IHRlbmMgPSBwYXJzZVNpbmYoc2luZik7XG4gICAgICAgICAgaWYgKHRlbmMpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGRlZmF1bHQga2V5IGlkIChrZXlJRCBvZmZzZXQgaXMgYWx3YXlzIDggd2l0aGluIHRoZSB0ZW5jIGJveCk6XG4gICAgICAgICAgICBjb25zdCB0ZW5jS2V5SWQgPSB0ZW5jLnN1YmFycmF5KDgsIDI0KTtcbiAgICAgICAgICAgIGlmICghdGVuY0tleUlkLnNvbWUoYiA9PiBiICE9PSAwKSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBbZW1lXSBQYXRjaGluZyBrZXlJZCBpbiAnZW5jJHtpc0F1ZGlvID8gJ2EnIDogJ3YnfT5zaW5mPj50ZW5jJyBib3g6ICR7SGV4LmhleER1bXAodGVuY0tleUlkKX0gLT4gJHtIZXguaGV4RHVtcChrZXlJZCl9YCk7XG4gICAgICAgICAgICAgIHRlbmMuc2V0KGtleUlkLCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGluaXRTZWdtZW50O1xufVxuZnVuY3Rpb24gcGFyc2VTaW5mKHNpbmYpIHtcbiAgY29uc3Qgc2NobSA9IGZpbmRCb3goc2luZiwgWydzY2htJ10pWzBdO1xuICBpZiAoc2NobSkge1xuICAgIGNvbnN0IHNjaGVtZSA9IGJpbjJzdHIoc2NobS5zdWJhcnJheSg0LCA4KSk7XG4gICAgaWYgKHNjaGVtZSA9PT0gJ2NiY3MnIHx8IHNjaGVtZSA9PT0gJ2NlbmMnKSB7XG4gICAgICByZXR1cm4gZmluZEJveChzaW5mLCBbJ3NjaGknLCAndGVuYyddKVswXTtcbiAgICB9XG4gIH1cbiAgbG9nZ2VyLmVycm9yKGBbZW1lXSBtaXNzaW5nICdzY2htJyBib3hgKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gKiBmcmFnbWVudC4gSWYgbXVsdGlwbGUgZnJhZ21lbnRzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYXJsaWVzdCB0aW1lIGlzXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBUaGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBjYW4gYmUgcGFyc2VkIGZyb20gdHJhY2sgZnJhZ21lbnRcbiAqIG1ldGFkYXRhOlxuICogYGBgXG4gKiBtb29mID4gdHJhZiA+IHRmZHQuYmFzZU1lZGlhRGVjb2RlVGltZVxuICogYGBgXG4gKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICpcbiAqIEBwYXJhbSBpbml0RGF0YSAtIGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXNcbiAqIEBwYXJhbSBmbXA0IC0gdGhlIGJ5dGVzIG9mIHRoZSBtcDQgZnJhZ21lbnRcbiAqIEByZXR1cm5zIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lIGZvciB0aGVcbiAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXJ0RFRTKGluaXREYXRhLCBmbXA0KSB7XG4gIC8vIHdlIG5lZWQgaW5mbyBmcm9tIHR3byBjaGlsZHJlbiBvZiBlYWNoIHRyYWNrIGZyYWdtZW50IGJveFxuICByZXR1cm4gZmluZEJveChmbXA0LCBbJ21vb2YnLCAndHJhZiddKS5yZWR1Y2UoKHJlc3VsdCwgdHJhZikgPT4ge1xuICAgIGNvbnN0IHRmZHQgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKVswXTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICBjb25zdCBzdGFydCA9IGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLnJlZHVjZSgocmVzdWx0LCB0ZmhkKSA9PiB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIGxldCBiYXNlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgLy8gSWYgdmFsdWUgaXMgdG9vIGxhcmdlLCBhc3N1bWUgc2lnbmVkIDY0LWJpdC4gTmVnYXRpdmUgdHJhY2sgZnJhZ21lbnQgZGVjb2RlIHRpbWVzIGFyZSBpbnZhbGlkLCBidXQgdGhleSBleGlzdCBpbiB0aGUgd2lsZC5cbiAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGxhcmdlIHZhbHVlcyBmcm9tIGJlaW5nIHVzZWQgZm9yIGluaXRQVFMsIHdoaWNoIGNhbiBjYXVzZSBwbGF5bGlzdCBzeW5jIGlzc3Vlcy5cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvNTMwM1xuICAgICAgICAgIGlmIChiYXNlVGltZSA9PT0gVUlOVDMyX01BWCQxKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgW21wNC1kZW11eGVyXTogSWdub3JpbmcgYXNzdW1lZCBpbnZhbGlkIHNpZ25lZCA2NC1iaXQgdHJhY2sgZnJhZ21lbnQgZGVjb2RlIHRpbWVgKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJhc2VUaW1lICo9IFVJTlQzMl9NQVgkMSArIDE7XG4gICAgICAgICAgYmFzZVRpbWUgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgICAgICAvLyBjb252ZXJ0IGJhc2UgdGltZSB0byBzZWNvbmRzXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGJhc2VUaW1lIC8gc2NhbGU7XG4gICAgICAgIGlmIChpc0Zpbml0ZShzdGFydFRpbWUpICYmIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnRUaW1lIDwgcmVzdWx0KSkge1xuICAgICAgICAgIHJldHVybiBzdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgbnVsbCk7XG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGlzRmluaXRlKHN0YXJ0KSAmJiAocmVzdWx0ID09PSBudWxsIHx8IHN0YXJ0IDwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBudWxsKTtcbn1cblxuLypcbiAgRm9yIFJlZmVyZW5jZTpcbiAgYWxpZ25lZCg4KSBjbGFzcyBUcmFja0ZyYWdtZW50SGVhZGVyQm94XG4gICAgICAgICAgIGV4dGVuZHMgRnVsbEJveCjigJh0Zmhk4oCZLCAwLCB0Zl9mbGFncyl7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHRyYWNrX0lEO1xuICAgICAvLyBhbGwgdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgIHVuc2lnbmVkIGludCg2NCkgIGJhc2VfZGF0YV9vZmZzZXQ7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb247XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX3NpemU7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gIH1cbiAqL1xuZnVuY3Rpb24gZ2V0RHVyYXRpb24oZGF0YSwgaW5pdERhdGEpIHtcbiAgbGV0IHJhd0R1cmF0aW9uID0gMDtcbiAgbGV0IHZpZGVvRHVyYXRpb24gPSAwO1xuICBsZXQgYXVkaW9EdXJhdGlvbiA9IDA7XG4gIGNvbnN0IHRyYWZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnLCAndHJhZiddKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWYgPSB0cmFmc1tpXTtcbiAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSB0ZmhkICYgdHJ1biBwZXIgdHJhZlxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBmb3IgQ01BRiBzdHlsZSBjb250ZW50LCBhbmQgd2Ugc2hvdWxkIHBlcmhhcHMgY2hlY2sgdGhlIGZ0eXBcbiAgICAvLyBhbmQgb25seSBsb29rIGZvciBhIHNpbmdsZSB0cnVuIHRoZW4sIGJ1dCBmb3IgSVNPQk1GRiB3ZSBzaG91bGQgY2hlY2tcbiAgICAvLyBmb3IgbXVsdGlwbGUgdHJhY2sgcnVucy5cbiAgICBjb25zdCB0ZmhkID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSlbMF07XG4gICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0cmFja0RlZmF1bHQgPSB0cmFjay5kZWZhdWx0O1xuICAgIGNvbnN0IHRmaGRGbGFncyA9IHJlYWRVaW50MzIodGZoZCwgMCkgfCAodHJhY2tEZWZhdWx0ID09IG51bGwgPyB2b2lkIDAgOiB0cmFja0RlZmF1bHQuZmxhZ3MpO1xuICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IHRyYWNrRGVmYXVsdCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tEZWZhdWx0LmR1cmF0aW9uO1xuICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkge1xuICAgICAgLy8gMHgwMDAwMDggaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gZmllbGRcbiAgICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwMikge1xuICAgICAgICAvLyAweDAwMDAwMiBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXggZmllbGQsIHdoaWNoIHByZWNlZGVzIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIC8vIElmIHByZXNlbnQsIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBleGlzdHMgYXQgYnl0ZSBvZmZzZXQgMTJcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDEyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGR1cmF0aW9uIGlzIGF0IGJ5dGUgb2Zmc2V0IDhcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgIGNvbnN0IHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgIGNvbnN0IHRydW5zID0gZmluZEJveCh0cmFmLCBbJ3RydW4nXSk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0cnVucy5sZW5ndGg7IGorKykge1xuICAgICAgcmF3RHVyYXRpb24gPSBjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlcyh0cnVuc1tqXSk7XG4gICAgICBpZiAoIXJhd0R1cmF0aW9uICYmIHNhbXBsZUR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuc1tqXSwgNCk7XG4gICAgICAgIHJhd0R1cmF0aW9uID0gc2FtcGxlRHVyYXRpb24gKiBzYW1wbGVDb3VudDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgdmlkZW9EdXJhdGlvbiArPSByYXdEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sudHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKSB7XG4gICAgICAgIGF1ZGlvRHVyYXRpb24gKz0gcmF3RHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2aWRlb0R1cmF0aW9uID09PSAwICYmIGF1ZGlvRHVyYXRpb24gPT09IDApIHtcbiAgICAvLyBJZiBkdXJhdGlvbiBzYW1wbGVzIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSB0cmFmIHVzZSBzaWR4IHN1YnNlZ21lbnRfZHVyYXRpb25cbiAgICBsZXQgc2lkeER1cmF0aW9uID0gMDtcbiAgICBjb25zdCBzaWR4cyA9IGZpbmRCb3goZGF0YSwgWydzaWR4J10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZHggPSBwYXJzZVNlZ21lbnRJbmRleChzaWR4c1tpXSk7XG4gICAgICBpZiAoc2lkeCAhPSBudWxsICYmIHNpZHgucmVmZXJlbmNlcykge1xuICAgICAgICBzaWR4RHVyYXRpb24gKz0gc2lkeC5yZWZlcmVuY2VzLnJlZHVjZSgoZHVyLCByZWYpID0+IGR1ciArIHJlZi5pbmZvLmR1cmF0aW9uIHx8IDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2lkeER1cmF0aW9uO1xuICB9XG4gIGlmICh2aWRlb0R1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHZpZGVvRHVyYXRpb247XG4gIH1cbiAgcmV0dXJuIGF1ZGlvRHVyYXRpb247XG59XG5cbi8qXG4gIEZvciBSZWZlcmVuY2U6XG4gIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tSdW5Cb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRydW7igJksIHZlcnNpb24sIHRyX2ZsYWdzKSB7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9jb3VudDtcbiAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgIHNpZ25lZCBpbnQoMzIpIGRhdGFfb2Zmc2V0O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBmaXJzdF9zYW1wbGVfZmxhZ3M7XG4gICAgIC8vIGFsbCBmaWVsZHMgaW4gdGhlIGZvbGxvd2luZyBhcnJheSBhcmUgb3B0aW9uYWxcbiAgICAge1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZHVyYXRpb247XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9zaXplO1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZmxhZ3NcbiAgICAgICAgaWYgKHZlcnNpb24gPT0gMClcbiAgICAgICAgICAgeyB1bnNpZ25lZCBpbnQoMzIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgeyBzaWduZWQgaW50KDMyKVxuICAgICB9WyBzYW1wbGVfY291bnQgXVxuICB9XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW4pIHtcbiAgY29uc3QgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApO1xuICAvLyBGbGFncyBhcmUgYXQgb2Zmc2V0IDAsIG5vbi1vcHRpb25hbCBzYW1wbGVfY291bnQgaXMgYXQgb2Zmc2V0IDQuIFRoZXJlZm9yZSB3ZSBzdGFydCA4IGJ5dGVzIGluLlxuICAvLyBFYWNoIGZpZWxkIGlzIGFuIGludDMyLCB3aGljaCBpcyA0IGJ5dGVzXG4gIGxldCBvZmZzZXQgPSA4O1xuICAvLyBkYXRhLW9mZnNldC1wcmVzZW50IGZsYWdcbiAgaWYgKGZsYWdzICYgMHgwMDAwMDEpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuICAvLyBmaXJzdC1zYW1wbGUtZmxhZ3MtcHJlc2VudCBmbGFnXG4gIGlmIChmbGFncyAmIDB4MDAwMDA0KSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgbGV0IGR1cmF0aW9uID0gMDtcbiAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW4sIDQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZUNvdW50OyBpKyspIHtcbiAgICAvLyBzYW1wbGUtZHVyYXRpb24tcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDAxMDApIHtcbiAgICAgIGNvbnN0IHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0cnVuLCBvZmZzZXQpO1xuICAgICAgZHVyYXRpb24gKz0gc2FtcGxlRHVyYXRpb247XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gICAgLy8gc2FtcGxlLXNpemUtcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDAyMDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgICAvLyBzYW1wbGUtZmxhZ3MtcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDA0MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgICAvLyBzYW1wbGUtY29tcG9zaXRpb24tdGltZS1vZmZzZXRzLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwODAwKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR1cmF0aW9uO1xufVxuZnVuY3Rpb24gb2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGZtcDQsIHRpbWVPZmZzZXQpIHtcbiAgZmluZEJveChmbXA0LCBbJ21vb2YnLCAndHJhZiddKS5mb3JFYWNoKHRyYWYgPT4ge1xuICAgIGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLmZvckVhY2godGZoZCA9PiB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkuZm9yRWFjaCh0ZmR0ID0+IHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICAgIGxldCBiYXNlTWVkaWFEZWNvZGVUaW1lID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDQsIGJhc2VNZWRpYURlY29kZVRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgIGNvbnN0IHVwcGVyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVgkMSArIDEpKTtcbiAgICAgICAgICBjb25zdCBsb3dlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYJDEgKyAxKSk7XG4gICAgICAgICAgd3JpdGVVaW50MzIodGZkdCwgNCwgdXBwZXIpO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDgsIGxvd2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBUT0RPOiBDaGVjayBpZiB0aGUgbGFzdCBtb29mK21kYXQgcGFpciBpcyBwYXJ0IG9mIHRoZSB2YWxpZCByYW5nZVxuZnVuY3Rpb24gc2VnbWVudFZhbGlkUmFuZ2UoZGF0YSkge1xuICBjb25zdCBzZWdtZW50ZWRSYW5nZSA9IHtcbiAgICB2YWxpZDogbnVsbCxcbiAgICByZW1haW5kZXI6IG51bGxcbiAgfTtcbiAgY29uc3QgbW9vZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZiddKTtcbiAgaWYgKCFtb29mcykge1xuICAgIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbiAgfSBlbHNlIGlmIChtb29mcy5sZW5ndGggPCAyKSB7XG4gICAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gZGF0YTtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH1cbiAgY29uc3QgbGFzdCA9IG1vb2ZzW21vb2ZzLmxlbmd0aCAtIDFdO1xuICAvLyBPZmZzZXQgYnkgOCBieXRlczsgZmluZEJveCBvZmZzZXRzIHRoZSBzdGFydCBieSBhcyBtdWNoXG4gIHNlZ21lbnRlZFJhbmdlLnZhbGlkID0gc2xpY2VVaW50OChkYXRhLCAwLCBsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gc2xpY2VVaW50OChkYXRhLCBsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xufVxuZnVuY3Rpb24gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpIHtcbiAgY29uc3QgdGVtcCA9IG5ldyBVaW50OEFycmF5KGRhdGExLmxlbmd0aCArIGRhdGEyLmxlbmd0aCk7XG4gIHRlbXAuc2V0KGRhdGExKTtcbiAgdGVtcC5zZXQoZGF0YTIsIGRhdGExLmxlbmd0aCk7XG4gIHJldHVybiB0ZW1wO1xufVxuZnVuY3Rpb24gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHRyYWNrKSB7XG4gIGNvbnN0IHNlaVNhbXBsZXMgPSBbXTtcbiAgY29uc3QgdmlkZW9EYXRhID0gdHJhY2suc2FtcGxlcztcbiAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICBjb25zdCB0cmFja0lkID0gdHJhY2suaWQ7XG4gIGxldCBpc0hFVkNGbGF2b3IgPSBmYWxzZTtcbiAgY29uc3QgbW9vZnMgPSBmaW5kQm94KHZpZGVvRGF0YSwgWydtb29mJ10pO1xuICBtb29mcy5tYXAobW9vZiA9PiB7XG4gICAgY29uc3QgbW9vZk9mZnNldCA9IG1vb2YuYnl0ZU9mZnNldCAtIDg7XG4gICAgY29uc3QgdHJhZnMgPSBmaW5kQm94KG1vb2YsIFsndHJhZiddKTtcbiAgICB0cmFmcy5tYXAodHJhZiA9PiB7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgY29uc3QgYmFzZVRpbWUgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAodGZkdCA9PiB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIHJlc3VsdCArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgLyB0aW1lc2NhbGU7XG4gICAgICB9KVswXTtcbiAgICAgIGlmIChiYXNlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRpbWVPZmZzZXQgPSBiYXNlVGltZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAodGZoZCA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgY29uc3QgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICBjb25zdCBiYXNlRGF0YU9mZnNldFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDEpICE9PSAwO1xuICAgICAgICBjb25zdCBzYW1wbGVEZXNjcmlwdGlvbkluZGV4UHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwMikgIT09IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDgpICE9PSAwO1xuICAgICAgICBsZXQgZGVmYXVsdFNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDEwKSAhPT0gMDtcbiAgICAgICAgbGV0IGRlZmF1bHRTYW1wbGVTaXplID0gMDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNhbXBsZUZsYWdzUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAyMCkgIT09IDA7XG4gICAgICAgIGxldCB0ZmhkT2Zmc2V0ID0gODtcbiAgICAgICAgaWYgKGlkID09PSB0cmFja0lkKSB7XG4gICAgICAgICAgaWYgKGJhc2VEYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTYW1wbGVTaXplID0gcmVhZFVpbnQzMih0ZmhkLCB0ZmhkT2Zmc2V0KTtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIGlzSEVWQ0ZsYXZvciA9IGlzSEVWQyh0cmFjay5jb2RlYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmRCb3godHJhZiwgWyd0cnVuJ10pLm1hcCh0cnVuID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB0cnVuWzBdO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApICYgMHhmZmZmZmY7XG4gICAgICAgICAgICBjb25zdCBkYXRhT2Zmc2V0UHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAwMDQpICE9PSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRHVyYXRpb25QcmVzZW50ID0gKGZsYWdzICYgMHgwMDAxMDApICE9PSAwO1xuICAgICAgICAgICAgbGV0IHNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVNpemVQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAyMDApICE9PSAwO1xuICAgICAgICAgICAgbGV0IHNhbXBsZVNpemUgPSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRmxhZ3NQcmVzZW50ID0gKGZsYWdzICYgMHgwMDA0MDApICE9PSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwODAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBjb21wb3NpdGlvbk9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG4gICAgICAgICAgICBsZXQgdHJ1bk9mZnNldCA9IDg7IC8vIHBhc3QgdmVyc2lvbiwgZmxhZ3MsIGFuZCBzYW1wbGUgY291bnRcblxuICAgICAgICAgICAgaWYgKGRhdGFPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNhbXBsZU9mZnNldCA9IGRhdGFPZmZzZXQgKyBtb29mT2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IHNhbXBsZUNvdW50OyBpeCsrKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gZGVmYXVsdFNhbXBsZVNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFNpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFsdVRvdGFsU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5hbHVUb3RhbFNpemUgPCBzYW1wbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuYWx1U2l6ZSA9IHJlYWRVaW50MzIodmlkZW9EYXRhLCBzYW1wbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgdmlkZW9EYXRhW3NhbXBsZU9mZnNldF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB2aWRlb0RhdGEuc3ViYXJyYXkoc2FtcGxlT2Zmc2V0LCBzYW1wbGVPZmZzZXQgKyBuYWx1U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KGRhdGEsIGlzSEVWQ0ZsYXZvciA/IDIgOiAxLCB0aW1lT2Zmc2V0ICsgY29tcG9zaXRpb25PZmZzZXQgLyB0aW1lc2NhbGUsIHNlaVNhbXBsZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IG5hbHVTaXplO1xuICAgICAgICAgICAgICAgICAgbmFsdVRvdGFsU2l6ZSArPSBuYWx1U2l6ZSArIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRpbWVPZmZzZXQgKz0gc2FtcGxlRHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNlaVNhbXBsZXM7XG59XG5mdW5jdGlvbiBpc0hFVkMoY29kZWMpIHtcbiAgaWYgKCFjb2RlYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBkZWxpbWl0ID0gY29kZWMuaW5kZXhPZignLicpO1xuICBjb25zdCBiYXNlQ29kZWMgPSBkZWxpbWl0IDwgMCA/IGNvZGVjIDogY29kZWMuc3Vic3RyaW5nKDAsIGRlbGltaXQpO1xuICByZXR1cm4gYmFzZUNvZGVjID09PSAnaHZjMScgfHwgYmFzZUNvZGVjID09PSAnaGV2MScgfHxcbiAgLy8gRG9sYnkgVmlzaW9uXG4gIGJhc2VDb2RlYyA9PT0gJ2R2aDEnIHx8IGJhc2VDb2RlYyA9PT0gJ2R2aGUnO1xufVxuZnVuY3Rpb24gaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgbmFsdUhlYWRlcikge1xuICBpZiAoaXNIRVZDRmxhdm9yKSB7XG4gICAgY29uc3QgbmFsdVR5cGUgPSBuYWx1SGVhZGVyID4+IDEgJiAweDNmO1xuICAgIHJldHVybiBuYWx1VHlwZSA9PT0gMzkgfHwgbmFsdVR5cGUgPT09IDQwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5hbHVUeXBlID0gbmFsdUhlYWRlciAmIDB4MWY7XG4gICAgcmV0dXJuIG5hbHVUeXBlID09PSA2O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSh1bmVzY2FwZWREYXRhLCBoZWFkZXJTaXplLCBwdHMsIHNhbXBsZXMpIHtcbiAgY29uc3QgZGF0YSA9IGRpc2NhcmRFUEIodW5lc2NhcGVkRGF0YSk7XG4gIGxldCBzZWlQdHIgPSAwO1xuICAvLyBza2lwIG5hbCBoZWFkZXJcbiAgc2VpUHRyICs9IGhlYWRlclNpemU7XG4gIGxldCBwYXlsb2FkVHlwZSA9IDA7XG4gIGxldCBwYXlsb2FkU2l6ZSA9IDA7XG4gIGxldCBlbmRPZkNhcHRpb25zID0gZmFsc2U7XG4gIGxldCBiID0gMDtcbiAgd2hpbGUgKHNlaVB0ciA8IGRhdGEubGVuZ3RoKSB7XG4gICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpO1xuXG4gICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgIHBheWxvYWRTaXplID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICB9IHdoaWxlIChiID09PSAweGZmKTtcbiAgICBjb25zdCBsZWZ0T3ZlciA9IGRhdGEubGVuZ3RoIC0gc2VpUHRyO1xuICAgIGlmICghZW5kT2ZDYXB0aW9ucyAmJiBwYXlsb2FkVHlwZSA9PT0gNCAmJiBzZWlQdHIgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG4gICAgICBjb25zdCBjb3VudHJ5Q29kZSA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJDb2RlID0gcmVhZFVpbnQxNihkYXRhLCBzZWlQdHIpO1xuICAgICAgICBzZWlQdHIgKz0gMjtcbiAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICBjb25zdCB1c2VyU3RydWN0dXJlID0gcmVhZFVpbnQzMihkYXRhLCBzZWlQdHIpO1xuICAgICAgICAgIHNlaVB0ciArPSA0O1xuICAgICAgICAgIGlmICh1c2VyU3RydWN0dXJlID09PSAweDQ3NDEzOTM0KSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YVR5cGUgPSBkYXRhW3NlaVB0cisrXTtcblxuICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxuICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgICAgICAgICAgY29uc3QgdG90YWxDQ3MgPSAweDFmICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICBjb25zdCBlbmFibGVkID0gMHg0MCAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgY29uc3QgdG90YWxCeXRlcyA9IGVuYWJsZWQgPyAyICsgdG90YWxDQ3MgKiAzIDogMDtcbiAgICAgICAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7XG4gICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5WzBdID0gZmlyc3RCeXRlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWxCeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBieXRlQXJyYXlbaV0gPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB1c2VyRGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgcHRzLFxuICAgICAgICAgICAgICAgIGJ5dGVzOiBieXRlQXJyYXlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkVHlwZSA9PT0gNSAmJiBwYXlsb2FkU2l6ZSA8IGxlZnRPdmVyKSB7XG4gICAgICBlbmRPZkNhcHRpb25zID0gdHJ1ZTtcbiAgICAgIGlmIChwYXlsb2FkU2l6ZSA+IDE2KSB7XG4gICAgICAgIGNvbnN0IHV1aWRTdHJBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBfYiA9IGRhdGFbc2VpUHRyKytdLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaChfYi5sZW5ndGggPT0gMSA/ICcwJyArIF9iIDogX2IpO1xuICAgICAgICAgIGlmIChpID09PSAzIHx8IGkgPT09IDUgfHwgaSA9PT0gNyB8fCBpID09PSA5KSB7XG4gICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXlsb2FkU2l6ZSAtIDE2O1xuICAgICAgICBjb25zdCB1c2VyRGF0YUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHVzZXJEYXRhQnl0ZXNbaV0gPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgICAgfVxuICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgIHB0cyxcbiAgICAgICAgICB1dWlkOiB1dWlkU3RyQXJyYXkuam9pbignJyksXG4gICAgICAgICAgdXNlckRhdGE6IHV0ZjhBcnJheVRvU3RyKHVzZXJEYXRhQnl0ZXMpLFxuICAgICAgICAgIHVzZXJEYXRhQnl0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGxlZnRPdmVyKSB7XG4gICAgICBzZWlQdHIgKz0gcGF5bG9hZFNpemU7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA+IGxlZnRPdmVyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAqL1xuZnVuY3Rpb24gZGlzY2FyZEVQQihkYXRhKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgY29uc3QgRVBCUG9zaXRpb25zID0gW107XG4gIGxldCBpID0gMTtcblxuICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG4gIHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuICAgIGlmIChkYXRhW2ldID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAvLyBhcnJheVxuICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgY29uc3QgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgY29uc3QgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gIGxldCBzb3VyY2VJbmRleCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuZXdMZW5ndGg7IHNvdXJjZUluZGV4KyssIGkrKykge1xuICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgc291cmNlSW5kZXgrKztcbiAgICAgIC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG4gICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICB9XG4gICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICB9XG4gIHJldHVybiBuZXdEYXRhO1xufVxuZnVuY3Rpb24gcGFyc2VFbXNnKGRhdGEpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGRhdGFbMF07XG4gIGxldCBzY2hlbWVJZFVyaSA9ICcnO1xuICBsZXQgdmFsdWUgPSAnJztcbiAgbGV0IHRpbWVTY2FsZSA9IDA7XG4gIGxldCBwcmVzZW50YXRpb25UaW1lRGVsdGEgPSAwO1xuICBsZXQgcHJlc2VudGF0aW9uVGltZSA9IDA7XG4gIGxldCBldmVudER1cmF0aW9uID0gMDtcbiAgbGV0IGlkID0gMDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgdGltZVNjYWxlID0gcmVhZFVpbnQzMihkYXRhLCAxMik7XG4gICAgcHJlc2VudGF0aW9uVGltZURlbHRhID0gcmVhZFVpbnQzMihkYXRhLCAxNik7XG4gICAgZXZlbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoZGF0YSwgMjApO1xuICAgIGlkID0gcmVhZFVpbnQzMihkYXRhLCAyNCk7XG4gICAgb2Zmc2V0ID0gMjg7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgIG9mZnNldCArPSA0O1xuICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBjb25zdCBsZWZ0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBjb25zdCByaWdodFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgcHJlc2VudGF0aW9uVGltZSA9IDIgKiogMzIgKiBsZWZ0UHJlc2VudGF0aW9uVGltZSArIHJpZ2h0UHJlc2VudGF0aW9uVGltZTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHByZXNlbnRhdGlvblRpbWUpKSB7XG4gICAgICBwcmVzZW50YXRpb25UaW1lID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICBsb2dnZXIud2FybignUHJlc2VudGF0aW9uIHRpbWUgZXhjZWVkcyBzYWZlIGludGVnZXIgbGltaXQgYW5kIHdyYXBwZWQgdG8gbWF4IHNhZmUgaW50ZWdlciBpbiBwYXJzaW5nIGVtc2cgYm94Jyk7XG4gICAgfVxuICAgIGV2ZW50RHVyYXRpb24gPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgaWQgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4ge1xuICAgIHNjaGVtZUlkVXJpLFxuICAgIHZhbHVlLFxuICAgIHRpbWVTY2FsZSxcbiAgICBwcmVzZW50YXRpb25UaW1lLFxuICAgIHByZXNlbnRhdGlvblRpbWVEZWx0YSxcbiAgICBldmVudER1cmF0aW9uLFxuICAgIGlkLFxuICAgIHBheWxvYWRcbiAgfTtcbn1cbmZ1bmN0aW9uIG1wNEJveCh0eXBlLCAuLi5wYXlsb2FkKSB7XG4gIGNvbnN0IGxlbiA9IHBheWxvYWQubGVuZ3RoO1xuICBsZXQgc2l6ZSA9IDg7XG4gIGxldCBpID0gbGVuO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIHJlc3VsdFswXSA9IHNpemUgPj4gMjQgJiAweGZmO1xuICByZXN1bHRbMV0gPSBzaXplID4+IDE2ICYgMHhmZjtcbiAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgcmVzdWx0WzNdID0gc2l6ZSAmIDB4ZmY7XG4gIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtcDRwc3NoKHN5c3RlbUlkLCBrZXlpZHMsIGRhdGEpIHtcbiAgaWYgKHN5c3RlbUlkLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3lzdGVtIGlkJyk7XG4gIH1cbiAgbGV0IHZlcnNpb247XG4gIGxldCBraWRzO1xuICBpZiAoa2V5aWRzKSB7XG4gICAgdmVyc2lvbiA9IDE7XG4gICAga2lkcyA9IG5ldyBVaW50OEFycmF5KGtleWlkcy5sZW5ndGggKiAxNik7XG4gICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IGtleWlkcy5sZW5ndGg7IGl4KyspIHtcbiAgICAgIGNvbnN0IGsgPSBrZXlpZHNbaXhdOyAvLyB1aW50OGFycmF5XG4gICAgICBpZiAoay5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgIH1cbiAgICAgIGtpZHMuc2V0KGssIGl4ICogMTYpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ZXJzaW9uID0gMDtcbiAgICBraWRzID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBsZXQga2lkQ291bnQ7XG4gIGlmICh2ZXJzaW9uID4gMCkge1xuICAgIGtpZENvdW50ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgaWYgKGtleWlkcy5sZW5ndGggPiAwKSB7XG4gICAgICBuZXcgRGF0YVZpZXcoa2lkQ291bnQuYnVmZmVyKS5zZXRVaW50MzIoMCwga2V5aWRzLmxlbmd0aCwgZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBraWRDb3VudCA9IG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgY29uc3QgZGF0YVNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgaWYgKGRhdGEgJiYgZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgIG5ldyBEYXRhVmlldyhkYXRhU2l6ZS5idWZmZXIpLnNldFVpbnQzMigwLCBkYXRhLmJ5dGVMZW5ndGgsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gbXA0Qm94KFsxMTIsIDExNSwgMTE1LCAxMDRdLCBuZXcgVWludDhBcnJheShbdmVyc2lvbiwgMHgwMCwgMHgwMCwgMHgwMCAvLyBGbGFnc1xuICBdKSwgc3lzdGVtSWQsXG4gIC8vIDE2IGJ5dGVzXG4gIGtpZENvdW50LCBraWRzLCBkYXRhU2l6ZSwgZGF0YSB8fCBuZXcgVWludDhBcnJheSgpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHNzaChpbml0RGF0YSkge1xuICBpZiAoIShpbml0RGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCBpbml0RGF0YS5ieXRlTGVuZ3RoIDwgMzIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgdmVyc2lvbjogMCxcbiAgICBzeXN0ZW1JZDogJycsXG4gICAga2lkczogbnVsbCxcbiAgICBkYXRhOiBudWxsXG4gIH07XG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5pdERhdGEpO1xuICBjb25zdCBib3hTaXplID0gdmlldy5nZXRVaW50MzIoMCk7XG4gIGlmIChpbml0RGF0YS5ieXRlTGVuZ3RoICE9PSBib3hTaXplICYmIGJveFNpemUgPiA0NCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHR5cGUgPSB2aWV3LmdldFVpbnQzMig0KTtcbiAgaWYgKHR5cGUgIT09IDB4NzA3MzczNjgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN1bHQudmVyc2lvbiA9IHZpZXcuZ2V0VWludDMyKDgpID4+PiAyNDtcbiAgaWYgKHJlc3VsdC52ZXJzaW9uID4gMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc3VsdC5zeXN0ZW1JZCA9IEhleC5oZXhEdW1wKG5ldyBVaW50OEFycmF5KGluaXREYXRhLCAxMiwgMTYpKTtcbiAgY29uc3QgZGF0YVNpemVPcktpZENvdW50ID0gdmlldy5nZXRVaW50MzIoMjgpO1xuICBpZiAocmVzdWx0LnZlcnNpb24gPT09IDApIHtcbiAgICBpZiAoYm94U2l6ZSAtIDMyIDwgZGF0YVNpemVPcktpZENvdW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmRhdGEgPSBuZXcgVWludDhBcnJheShpbml0RGF0YSwgMzIsIGRhdGFTaXplT3JLaWRDb3VudCk7XG4gIH0gZWxzZSBpZiAocmVzdWx0LnZlcnNpb24gPT09IDEpIHtcbiAgICByZXN1bHQua2lkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVNpemVPcktpZENvdW50OyBpKyspIHtcbiAgICAgIHJlc3VsdC5raWRzLnB1c2gobmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEsIDMyICsgaSAqIDE2LCAxNikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5sZXQga2V5VXJpVG9LZXlJZE1hcCA9IHt9O1xuY2xhc3MgTGV2ZWxLZXkge1xuICBzdGF0aWMgY2xlYXJLZXlVcmlUb0tleUlkTWFwKCkge1xuICAgIGtleVVyaVRvS2V5SWRNYXAgPSB7fTtcbiAgfVxuICBjb25zdHJ1Y3RvcihtZXRob2QsIHVyaSwgZm9ybWF0LCBmb3JtYXR2ZXJzaW9ucyA9IFsxXSwgaXYgPSBudWxsKSB7XG4gICAgdGhpcy51cmkgPSB2b2lkIDA7XG4gICAgdGhpcy5tZXRob2QgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlGb3JtYXQgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuY3J5cHRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ29tbW9uRW5jcnlwdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLml2ID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5rZXlJZCA9IG51bGw7XG4gICAgdGhpcy5wc3NoID0gbnVsbDtcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICB0aGlzLmtleUZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLmtleUZvcm1hdFZlcnNpb25zID0gZm9ybWF0dmVyc2lvbnM7XG4gICAgdGhpcy5pdiA9IGl2O1xuICAgIHRoaXMuZW5jcnlwdGVkID0gbWV0aG9kID8gbWV0aG9kICE9PSAnTk9ORScgOiBmYWxzZTtcbiAgICB0aGlzLmlzQ29tbW9uRW5jcnlwdGlvbiA9IHRoaXMuZW5jcnlwdGVkICYmIG1ldGhvZCAhPT0gJ0FFUy0xMjgnO1xuICB9XG4gIGlzU3VwcG9ydGVkKCkge1xuICAgIC8vIElmIGl0J3MgU2VnbWVudCBlbmNyeXB0aW9uIG9yIE5vIGVuY3J5cHRpb24sIGp1c3Qgc2VsZWN0IHRoYXQga2V5IHN5c3RlbVxuICAgIGlmICh0aGlzLm1ldGhvZCkge1xuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgfHwgdGhpcy5tZXRob2QgPT09ICdOT05FJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAvLyBNYWludGFpbiBzdXBwb3J0IGZvciBjbGVhciBTQU1QTEUtQUVTIHdpdGggTVBFRy0zIFRTXG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmtleUZvcm1hdCkge1xuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLlBMQVlSRUFEWTpcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuQ0xFQVJLRVk6XG4gICAgICAgICAgICByZXR1cm4gWydJU08tMjMwMDEtNycsICdTQU1QTEUtQUVTJywgJ1NBTVBMRS1BRVMtQ0VOQycsICdTQU1QTEUtQUVTLUNUUiddLmluZGV4T2YodGhpcy5tZXRob2QpICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0RGVjcnlwdERhdGEoc24pIHtcbiAgICBpZiAoIXRoaXMuZW5jcnlwdGVkIHx8ICF0aGlzLnVyaSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnICYmIHRoaXMudXJpICYmICF0aGlzLml2KSB7XG4gICAgICBpZiAodHlwZW9mIHNuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBXZSBhcmUgZmV0Y2hpbmcgZGVjcnlwdGlvbiBkYXRhIGZvciBhIGluaXRpYWxpemF0aW9uIHNlZ21lbnRcbiAgICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgd2FzIGVuY3J5cHRlZCB3aXRoIEFFUy0xMjhcbiAgICAgICAgLy8gSXQgbXVzdCBoYXZlIGFuIElWIGRlZmluZWQuIFdlIGNhbm5vdCBzdWJzdGl0dXRlIHRoZSBTZWdtZW50IE51bWJlciBpbi5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgJiYgIXRoaXMuaXYpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgbWlzc2luZyBJViBmb3IgaW5pdGlhbGl6YXRpb24gc2VnbWVudCB3aXRoIG1ldGhvZD1cIiR7dGhpcy5tZXRob2R9XCIgLSBjb21wbGlhbmNlIGlzc3VlYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgc24gdG8gcmVzdWx0aW5nIHZhbHVlIGZyb20gaW1wbGljaXQgY29udmVyc2lvbnMgJ2luaXRTZWdtZW50JyB2YWx1ZXMgZm9yIElWIGdlbmVyYXRpb24uXG4gICAgICAgIHNuID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl2ID0gY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc24pO1xuICAgICAgY29uc3QgZGVjcnlwdGRhdGEgPSBuZXcgTGV2ZWxLZXkodGhpcy5tZXRob2QsIHRoaXMudXJpLCAnaWRlbnRpdHknLCB0aGlzLmtleUZvcm1hdFZlcnNpb25zLCBpdik7XG4gICAgICByZXR1cm4gZGVjcnlwdGRhdGE7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBrZXlJZCBpZiBwb3NzaWJsZVxuICAgIGNvbnN0IGtleUJ5dGVzID0gY29udmVydERhdGFVcmlUb0FycmF5Qnl0ZXModGhpcy51cmkpO1xuICAgIGlmIChrZXlCeXRlcykge1xuICAgICAgc3dpdGNoICh0aGlzLmtleUZvcm1hdCkge1xuICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICAgICAgdGhpcy5wc3NoID0ga2V5Qnl0ZXM7XG4gICAgICAgICAgLy8gSW4gY2FzZSBvZiB3aWRldmluZSBrZXlJRCBpcyBlbWJlZGRlZCBpbiBQU1NIIGJveC4gUmVhZCBLZXkgSUQuXG4gICAgICAgICAgaWYgKGtleUJ5dGVzLmxlbmd0aCA+PSAyMikge1xuICAgICAgICAgICAgdGhpcy5rZXlJZCA9IGtleUJ5dGVzLnN1YmFycmF5KGtleUJ5dGVzLmxlbmd0aCAtIDIyLCBrZXlCeXRlcy5sZW5ndGggLSA2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgUGxheVJlYWR5S2V5U3lzdGVtVVVJRCA9IG5ldyBVaW50OEFycmF5KFsweDlhLCAweDA0LCAweGYwLCAweDc5LCAweDk4LCAweDQwLCAweDQyLCAweDg2LCAweGFiLCAweDkyLCAweGU2LCAweDViLCAweGUwLCAweDg4LCAweDVmLCAweDk1XSk7XG4gICAgICAgICAgICB0aGlzLnBzc2ggPSBtcDRwc3NoKFBsYXlSZWFkeUtleVN5c3RlbVVVSUQsIG51bGwsIGtleUJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGtleUJ5dGVzVXRmMTYgPSBuZXcgVWludDE2QXJyYXkoa2V5Qnl0ZXMuYnVmZmVyLCBrZXlCeXRlcy5ieXRlT2Zmc2V0LCBrZXlCeXRlcy5ieXRlTGVuZ3RoIC8gMik7XG4gICAgICAgICAgICBjb25zdCBrZXlCeXRlU3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBBcnJheS5mcm9tKGtleUJ5dGVzVXRmMTYpKTtcblxuICAgICAgICAgICAgLy8gUGFyc2UgUGxheXJlYWR5IFdSTUhlYWRlciBYTUxcbiAgICAgICAgICAgIGNvbnN0IHhtbEtleUJ5dGVzID0ga2V5Qnl0ZVN0ci5zdWJzdHJpbmcoa2V5Qnl0ZVN0ci5pbmRleE9mKCc8JyksIGtleUJ5dGVTdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sS2V5Qnl0ZXMsICd0ZXh0L3htbCcpO1xuICAgICAgICAgICAgY29uc3Qga2V5RGF0YSA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnS0lEJylbMF07XG4gICAgICAgICAgICBpZiAoa2V5RGF0YSkge1xuICAgICAgICAgICAgICBjb25zdCBrZXlJZCA9IGtleURhdGEuY2hpbGROb2Rlc1swXSA/IGtleURhdGEuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgOiBrZXlEYXRhLmdldEF0dHJpYnV0ZSgnVkFMVUUnKTtcbiAgICAgICAgICAgICAgaWYgKGtleUlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SWRBcnJheSA9IGJhc2U2NERlY29kZShrZXlJZCkuc3ViYXJyYXkoMCwgMTYpO1xuICAgICAgICAgICAgICAgIC8vIEtJRCB2YWx1ZSBpbiBQUk8gaXMgYSBiYXNlNjQtZW5jb2RlZCBsaXR0bGUgZW5kaWFuIEdVSUQgaW50ZXJwcmV0YXRpb24gb2YgVVVJRFxuICAgICAgICAgICAgICAgIC8vIEtJRCB2YWx1ZSBpbiDigJh0ZW5j4oCZIGlzIGEgYmlnIGVuZGlhbiBVVUlEIEdVSUQgaW50ZXJwcmV0YXRpb24gb2YgVVVJRFxuICAgICAgICAgICAgICAgIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWRBcnJheSk7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZCA9IGtleUlkQXJyYXk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsZXQga2V5ZGF0YSA9IGtleUJ5dGVzLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgICAgICAgIGlmIChrZXlkYXRhLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICAgICAgICBwYWRkZWQuc2V0KGtleWRhdGEsIDE2IC0ga2V5ZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICBrZXlkYXRhID0gcGFkZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5rZXlJZCA9IGtleWRhdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvcjogYXNzaWduIGEgbmV3IGtleUlkIGZvciBlYWNoIHVyaVxuICAgIGlmICghdGhpcy5rZXlJZCB8fCB0aGlzLmtleUlkLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICBsZXQga2V5SWQgPSBrZXlVcmlUb0tleUlkTWFwW3RoaXMudXJpXTtcbiAgICAgIGlmICgha2V5SWQpIHtcbiAgICAgICAgY29uc3QgdmFsID0gT2JqZWN0LmtleXMoa2V5VXJpVG9LZXlJZE1hcCkubGVuZ3RoICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGtleUlkID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhrZXlJZC5idWZmZXIsIDEyLCA0KTsgLy8gSnVzdCBzZXQgdGhlIGxhc3QgNCBieXRlc1xuICAgICAgICBkdi5zZXRVaW50MzIoMCwgdmFsKTtcbiAgICAgICAga2V5VXJpVG9LZXlJZE1hcFt0aGlzLnVyaV0gPSBrZXlJZDtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5SWQgPSBrZXlJZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpIHtcbiAgY29uc3QgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBmb3IgKGxldCBpID0gMTI7IGkgPCAxNjsgaSsrKSB7XG4gICAgdWludDhWaWV3W2ldID0gc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkgJiAweGZmO1xuICB9XG4gIHJldHVybiB1aW50OFZpZXc7XG59XG5cbmNvbnN0IFZBUklBQkxFX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xce1xcJChbYS16QS1aMC05LV9dKylcXH0vZztcbmZ1bmN0aW9uIGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHIpIHtcbiAgcmV0dXJuIFZBUklBQkxFX1JFUExBQ0VNRU5UX1JFR0VYLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBhdHRyLCBhdHRyaWJ1dGVOYW1lcykge1xuICBpZiAocGFyc2VkLnZhcmlhYmxlTGlzdCAhPT0gbnVsbCB8fCBwYXJzZWQuaGFzVmFyaWFibGVSZWZzKSB7XG4gICAgZm9yIChsZXQgaSA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyW25hbWVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGF0dHJbbmFtZV0gPSBzdWJzdGl0dXRlVmFyaWFibGVzKHBhcnNlZCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHZhbHVlKSB7XG4gIGlmIChwYXJzZWQudmFyaWFibGVMaXN0ICE9PSBudWxsIHx8IHBhcnNlZC5oYXNWYXJpYWJsZVJlZnMpIHtcbiAgICBjb25zdCB2YXJpYWJsZUxpc3QgPSBwYXJzZWQudmFyaWFibGVMaXN0O1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKFZBUklBQkxFX1JFUExBQ0VNRU5UX1JFR0VYLCB2YXJpYWJsZVJlZmVyZW5jZSA9PiB7XG4gICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSB2YXJpYWJsZVJlZmVyZW5jZS5zdWJzdHJpbmcoMiwgdmFyaWFibGVSZWZlcmVuY2UubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCB2YXJpYWJsZVZhbHVlID0gdmFyaWFibGVMaXN0ID09IG51bGwgPyB2b2lkIDAgOiB2YXJpYWJsZUxpc3RbdmFyaWFibGVOYW1lXTtcbiAgICAgIGlmICh2YXJpYWJsZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYE1pc3NpbmcgcHJlY2VkaW5nIEVYVC1YLURFRklORSB0YWcgZm9yIFZhcmlhYmxlIFJlZmVyZW5jZTogXCIke3ZhcmlhYmxlTmFtZX1cImApKTtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlUmVmZXJlbmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhcmlhYmxlVmFsdWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gYWRkVmFyaWFibGVEZWZpbml0aW9uKHBhcnNlZCwgYXR0ciwgcGFyZW50VXJsKSB7XG4gIGxldCB2YXJpYWJsZUxpc3QgPSBwYXJzZWQudmFyaWFibGVMaXN0O1xuICBpZiAoIXZhcmlhYmxlTGlzdCkge1xuICAgIHBhcnNlZC52YXJpYWJsZUxpc3QgPSB2YXJpYWJsZUxpc3QgPSB7fTtcbiAgfVxuICBsZXQgTkFNRTtcbiAgbGV0IFZBTFVFO1xuICBpZiAoJ1FVRVJZUEFSQU0nIGluIGF0dHIpIHtcbiAgICBOQU1FID0gYXR0ci5RVUVSWVBBUkFNO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgc2VsZi5VUkwocGFyZW50VXJsKS5zZWFyY2hQYXJhbXM7XG4gICAgICBpZiAoc2VhcmNoUGFyYW1zLmhhcyhOQU1FKSkge1xuICAgICAgICBWQUxVRSA9IHNlYXJjaFBhcmFtcy5nZXQoTkFNRSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtOQU1FfVwiIGRvZXMgbm90IG1hdGNoIGFueSBxdWVyeSBwYXJhbWV0ZXIgaW4gVVJJOiBcIiR7cGFyZW50VXJsfVwiYCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBFWFQtWC1ERUZJTkUgUVVFUllQQVJBTTogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgTkFNRSA9IGF0dHIuTkFNRTtcbiAgICBWQUxVRSA9IGF0dHIuVkFMVUU7XG4gIH1cbiAgaWYgKE5BTUUgaW4gdmFyaWFibGVMaXN0KSB7XG4gICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYEVYVC1YLURFRklORSBkdXBsaWNhdGUgVmFyaWFibGUgTmFtZSBkZWNsYXJhdGlvbnM6IFwiJHtOQU1FfVwiYCkpO1xuICB9IGVsc2Uge1xuICAgIHZhcmlhYmxlTGlzdFtOQU1FXSA9IFZBTFVFIHx8ICcnO1xuICB9XG59XG5mdW5jdGlvbiBpbXBvcnRWYXJpYWJsZURlZmluaXRpb24ocGFyc2VkLCBhdHRyLCBzb3VyY2VWYXJpYWJsZUxpc3QpIHtcbiAgY29uc3QgSU1QT1JUID0gYXR0ci5JTVBPUlQ7XG4gIGlmIChzb3VyY2VWYXJpYWJsZUxpc3QgJiYgSU1QT1JUIGluIHNvdXJjZVZhcmlhYmxlTGlzdCkge1xuICAgIGxldCB2YXJpYWJsZUxpc3QgPSBwYXJzZWQudmFyaWFibGVMaXN0O1xuICAgIGlmICghdmFyaWFibGVMaXN0KSB7XG4gICAgICBwYXJzZWQudmFyaWFibGVMaXN0ID0gdmFyaWFibGVMaXN0ID0ge307XG4gICAgfVxuICAgIHZhcmlhYmxlTGlzdFtJTVBPUlRdID0gc291cmNlVmFyaWFibGVMaXN0W0lNUE9SVF07XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYEVYVC1YLURFRklORSBJTVBPUlQgYXR0cmlidXRlIG5vdCBmb3VuZCBpbiBNdWx0aXZhcmlhbnQgUGxheWxpc3Q6IFwiJHtJTVBPUlR9XCJgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZWRpYVNvdXJjZSBoZWxwZXJcbiAqL1xuXG5mdW5jdGlvbiBnZXRNZWRpYVNvdXJjZSgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIHNlbGYuTWVkaWFTb3VyY2UgfHwgc2VsZi5XZWJLaXRNZWRpYVNvdXJjZTtcbn1cblxuLy8gZnJvbSBodHRwOi8vbXA0cmEub3JnL2NvZGVjcy5odG1sXG5jb25zdCBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICBhdWRpbzoge1xuICAgIGEzZHM6IHRydWUsXG4gICAgJ2FjLTMnOiB0cnVlLFxuICAgICdhYy00JzogdHJ1ZSxcbiAgICBhbGFjOiB0cnVlLFxuICAgIGFsYXc6IHRydWUsXG4gICAgZHJhMTogdHJ1ZSxcbiAgICAnZHRzKyc6IHRydWUsXG4gICAgJ2R0cy0nOiB0cnVlLFxuICAgIGR0c2M6IHRydWUsXG4gICAgZHRzZTogdHJ1ZSxcbiAgICBkdHNoOiB0cnVlLFxuICAgICdlYy0zJzogdHJ1ZSxcbiAgICBlbmNhOiB0cnVlLFxuICAgIGc3MTk6IHRydWUsXG4gICAgZzcyNjogdHJ1ZSxcbiAgICBtNGFlOiB0cnVlLFxuICAgIG1oYTE6IHRydWUsXG4gICAgbWhhMjogdHJ1ZSxcbiAgICBtaG0xOiB0cnVlLFxuICAgIG1obTI6IHRydWUsXG4gICAgbWxwYTogdHJ1ZSxcbiAgICBtcDRhOiB0cnVlLFxuICAgICdyYXcgJzogdHJ1ZSxcbiAgICBPcHVzOiB0cnVlLFxuICAgIG9wdXM6IHRydWUsXG4gICAgLy8gYnJvd3NlcnMgZXhwZWN0IHRoaXMgdG8gYmUgbG93ZXJjYXNlIGRlc3BpdGUgTVA0UkEgc2F5cyAnT3B1cydcbiAgICBzYW1yOiB0cnVlLFxuICAgIHNhd2I6IHRydWUsXG4gICAgc2F3cDogdHJ1ZSxcbiAgICBzZXZjOiB0cnVlLFxuICAgIHNxY3A6IHRydWUsXG4gICAgc3NtdjogdHJ1ZSxcbiAgICB0d29zOiB0cnVlLFxuICAgIHVsYXc6IHRydWVcbiAgfSxcbiAgdmlkZW86IHtcbiAgICBhdmMxOiB0cnVlLFxuICAgIGF2YzI6IHRydWUsXG4gICAgYXZjMzogdHJ1ZSxcbiAgICBhdmM0OiB0cnVlLFxuICAgIGF2Y3A6IHRydWUsXG4gICAgYXYwMTogdHJ1ZSxcbiAgICBkcmFjOiB0cnVlLFxuICAgIGR2YTE6IHRydWUsXG4gICAgZHZhdjogdHJ1ZSxcbiAgICBkdmgxOiB0cnVlLFxuICAgIGR2aGU6IHRydWUsXG4gICAgZW5jdjogdHJ1ZSxcbiAgICBoZXYxOiB0cnVlLFxuICAgIGh2YzE6IHRydWUsXG4gICAgbWpwMjogdHJ1ZSxcbiAgICBtcDR2OiB0cnVlLFxuICAgIG12YzE6IHRydWUsXG4gICAgbXZjMjogdHJ1ZSxcbiAgICBtdmMzOiB0cnVlLFxuICAgIG12YzQ6IHRydWUsXG4gICAgcmVzdjogdHJ1ZSxcbiAgICBydjYwOiB0cnVlLFxuICAgIHMyNjM6IHRydWUsXG4gICAgc3ZjMTogdHJ1ZSxcbiAgICBzdmMyOiB0cnVlLFxuICAgICd2Yy0xJzogdHJ1ZSxcbiAgICB2cDA4OiB0cnVlLFxuICAgIHZwMDk6IHRydWVcbiAgfSxcbiAgdGV4dDoge1xuICAgIHN0cHA6IHRydWUsXG4gICAgd3Z0dDogdHJ1ZVxuICB9XG59O1xuY29uc3QgTWVkaWFTb3VyY2UkMiA9IGdldE1lZGlhU291cmNlKCk7XG5mdW5jdGlvbiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkge1xuICBjb25zdCB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICByZXR1cm4gISF0eXBlQ29kZXMgJiYgdHlwZUNvZGVzW2NvZGVjLnNsaWNlKDAsIDQpXSA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNChjb2RlYywgdHlwZSkge1xuICB2YXIgX01lZGlhU291cmNlJGlzVHlwZVN1O1xuICByZXR1cm4gKF9NZWRpYVNvdXJjZSRpc1R5cGVTdSA9IE1lZGlhU291cmNlJDIgPT0gbnVsbCA/IHZvaWQgMCA6IE1lZGlhU291cmNlJDIuaXNUeXBlU3VwcG9ydGVkKGAke3R5cGUgfHwgJ3ZpZGVvJ30vbXA0O2NvZGVjcz1cIiR7Y29kZWN9XCJgKSkgIT0gbnVsbCA/IF9NZWRpYVNvdXJjZSRpc1R5cGVTdSA6IGZhbHNlO1xufVxuXG5jb25zdCBNQVNURVJfUExBWUxJU1RfUkVHRVggPSAvI0VYVC1YLVNUUkVBTS1JTkY6KFteXFxyXFxuXSopKD86W1xcclxcbl0oPzojW15cXHJcXG5dKik/KSooW15cXHJcXG5dKyl8I0VYVC1YLShTRVNTSU9OLURBVEF8U0VTU0lPTi1LRVl8REVGSU5FfENPTlRFTlQtU1RFRVJJTkd8U1RBUlQpOihbXlxcclxcbl0qKVtcXHJcXG5dKy9nO1xuY29uc3QgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG5jb25zdCBJU19NRURJQV9QTEFZTElTVCA9IC9eI0VYVCg/OklORnwtWC1UQVJHRVREVVJBVElPTik6L207IC8vIEhhbmRsZSBlbXB0eSBNZWRpYSBQbGF5bGlzdCAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG5cbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFsvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSxcbi8vIGR1cmF0aW9uICgjRVhUSU5GOjxkdXJhdGlvbj4sPHRpdGxlPiksIGdyb3VwIDEgPT4gZHVyYXRpb24sIGdyb3VwIDIgPT4gdGl0bGVcbi8oPyEjKSAqKFxcU1tcXFMgXSopLy5zb3VyY2UsXG4vLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuLyNFWFQtWC1CWVRFUkFOR0U6KiguKykvLnNvdXJjZSxcbi8vIG5leHQgc2VnbWVudCdzIGJ5dGVyYW5nZSwgZ3JvdXAgNCA9PiByYW5nZSBzcGVjICh4QHkpXG4vI0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSxcbi8vIG5leHQgc2VnbWVudCdzIHByb2dyYW0gZGF0ZS90aW1lIGdyb3VwIDUgPT4gdGhlIGRhdGV0aW1lIHNwZWNcbi8jLiovLnNvdXJjZSAvLyBBbGwgb3RoZXIgbm9uLXNlZ21lbnQgb3JpZW50ZWQgdGFncyB3aWxsIG1hdGNoIHdpdGggYWxsIGdyb3VwcyBlbXB0eVxuXS5qb2luKCd8JyksICdnJyk7XG5jb25zdCBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gbmV3IFJlZ0V4cChbLyMoRVhUTTNVKS8uc291cmNlLCAvI0VYVC1YLShEQVRFUkFOR0V8REVGSU5FfEtFWXxNQVB8UEFSVHxQQVJULUlORnxQTEFZTElTVC1UWVBFfFBSRUxPQUQtSElOVHxSRU5ESVRJT04tUkVQT1JUfFNFUlZFUi1DT05UUk9MfFNLSVB8U1RBUlQpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oQklUUkFURXxESVNDT05USU5VSVRZLVNFUVVFTkNFfE1FRElBLVNFUVVFTkNFfFRBUkdFVERVUkFUSU9OfFZFUlNJT04pOiAqKFxcZCspLy5zb3VyY2UsIC8jRVhULVgtKERJU0NPTlRJTlVJVFl8RU5ETElTVHxHQVApLy5zb3VyY2UsIC8oIykoW146XSopOiguKikvLnNvdXJjZSwgLygjKSguKikoPzouKilcXHI/XFxuPy8uc291cmNlXS5qb2luKCd8JykpO1xuY2xhc3MgTTNVOFBhcnNlciB7XG4gIHN0YXRpYyBmaW5kR3JvdXAoZ3JvdXBzLCBtZWRpYUdyb3VwSWQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICBpZiAoZ3JvdXAuaWQgPT09IG1lZGlhR3JvdXBJZCkge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjb252ZXJ0QVZDMVRvQVZDT1RJKGNvZGVjKSB7XG4gICAgLy8gQ29udmVydCBhdmMxIGNvZGVjIHN0cmluZyBmcm9tIFJGQy00MjgxIHRvIFJGQy02MzgxIGZvciBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWRcbiAgICBjb25zdCBhdmNkYXRhID0gY29kZWMuc3BsaXQoJy4nKTtcbiAgICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gYXZjZGF0YS5zaGlmdCgpICsgJy4nO1xuICAgICAgcmVzdWx0ICs9IHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpO1xuICAgICAgcmVzdWx0ICs9ICgnMDAwJyArIHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gY29kZWM7XG4gIH1cbiAgc3RhdGljIHJlc29sdmUodXJsLCBiYXNlVXJsKSB7XG4gICAgcmV0dXJuIHVybFRvb2xraXRFeHBvcnRzLmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsLCB7XG4gICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgaXNNZWRpYVBsYXlsaXN0KHN0cikge1xuICAgIHJldHVybiBJU19NRURJQV9QTEFZTElTVC50ZXN0KHN0cik7XG4gIH1cbiAgc3RhdGljIHBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsKSB7XG4gICAgY29uc3QgaGFzVmFyaWFibGVSZWZzID0gaGFzVmFyaWFibGVSZWZlcmVuY2VzKHN0cmluZykgO1xuICAgIGNvbnN0IHBhcnNlZCA9IHtcbiAgICAgIGNvbnRlbnRTdGVlcmluZzogbnVsbCxcbiAgICAgIGxldmVsczogW10sXG4gICAgICBwbGF5bGlzdFBhcnNpbmdFcnJvcjogbnVsbCxcbiAgICAgIHNlc3Npb25EYXRhOiBudWxsLFxuICAgICAgc2Vzc2lvbktleXM6IG51bGwsXG4gICAgICBzdGFydFRpbWVPZmZzZXQ6IG51bGwsXG4gICAgICB2YXJpYWJsZUxpc3Q6IG51bGwsXG4gICAgICBoYXNWYXJpYWJsZVJlZnNcbiAgICB9O1xuICAgIGNvbnN0IGxldmVsc1dpdGhLbm93bkNvZGVjcyA9IFtdO1xuICAgIE1BU1RFUl9QTEFZTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIGxldCByZXN1bHQ7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgIHZhciBfbGV2ZWwkdW5rbm93bkNvZGVjcztcbiAgICAgICAgLy8gJyNFWFQtWC1TVFJFQU0tSU5GJyBpcyBmb3VuZCwgcGFyc2UgbGV2ZWwgdGFnICBpbiBncm91cCAxXG4gICAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XG4gICAgICAgIHtcbiAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgYXR0cnMsIFsnQ09ERUNTJywgJ1NVUFBMRU1FTlRBTC1DT0RFQ1MnLCAnQUxMT1dFRC1DUEMnLCAnUEFUSFdBWS1JRCcsICdTVEFCTEUtVkFSSUFOVC1JRCcsICdBVURJTycsICdWSURFTycsICdTVUJUSVRMRVMnLCAnQ0xPU0VELUNBUFRJT05TJywgJ05BTUUnXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHJlc3VsdFsyXSkgO1xuICAgICAgICBjb25zdCBsZXZlbCA9IHtcbiAgICAgICAgICBhdHRycyxcbiAgICAgICAgICBiaXRyYXRlOiBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyksXG4gICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSxcbiAgICAgICAgICB1cmw6IE0zVThQYXJzZXIucmVzb2x2ZSh1cmksIGJhc2V1cmwpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgIGxldmVsLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb2RlY3MoKGF0dHJzLkNPREVDUyB8fCAnJykuc3BsaXQoL1sgLF0rLykuZmlsdGVyKGMgPT4gYyksIGxldmVsKTtcbiAgICAgICAgaWYgKGxldmVsLnZpZGVvQ29kZWMgJiYgbGV2ZWwudmlkZW9Db2RlYy5pbmRleE9mKCdhdmMxJykgIT09IC0xKSB7XG4gICAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IE0zVThQYXJzZXIuY29udmVydEFWQzFUb0FWQ09USShsZXZlbC52aWRlb0NvZGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoX2xldmVsJHVua25vd25Db2RlY3MgPSBsZXZlbC51bmtub3duQ29kZWNzKSAhPSBudWxsICYmIF9sZXZlbCR1bmtub3duQ29kZWNzLmxlbmd0aCkpIHtcbiAgICAgICAgICBsZXZlbHNXaXRoS25vd25Db2RlY3MucHVzaChsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLmxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHJlc3VsdFszXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHJlc3VsdFs0XTtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICBjYXNlICdTRVNTSU9OLURBVEEnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtU0VTU0lPTi1EQVRBXG4gICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25BdHRycyA9IG5ldyBBdHRyTGlzdChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBzZXNzaW9uQXR0cnMsIFsnREFUQS1JRCcsICdMQU5HVUFHRScsICdWQUxVRScsICdVUkknXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGF0YUlkID0gc2Vzc2lvbkF0dHJzWydEQVRBLUlEJ107XG4gICAgICAgICAgICAgIGlmIChkYXRhSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnNlc3Npb25EYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbkRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25EYXRhW2RhdGFJZF0gPSBzZXNzaW9uQXR0cnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU0VTU0lPTi1LRVknOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtU0VTU0lPTi1LRVlcbiAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IHBhcnNlS2V5KGF0dHJpYnV0ZXMsIGJhc2V1cmwsIHBhcnNlZCk7XG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uS2V5LmVuY3J5cHRlZCAmJiBzZXNzaW9uS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnNlc3Npb25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbktleXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25LZXlzLnB1c2goc2Vzc2lvbktleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFtLZXlzXSBJZ25vcmluZyBpbnZhbGlkIEVYVC1YLVNFU1NJT04tS0VZIHRhZzogXCIke2F0dHJpYnV0ZXN9XCJgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdERUZJTkUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtREVGSU5FXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZUF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIHZhcmlhYmxlQXR0cmlidXRlcywgWydOQU1FJywgJ1ZBTFVFJywgJ1FVRVJZUEFSQU0nXSk7XG4gICAgICAgICAgICAgICAgYWRkVmFyaWFibGVEZWZpbml0aW9uKHBhcnNlZCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBiYXNldXJsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdDT05URU5ULVNURUVSSU5HJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gI0VYVC1YLUNPTlRFTlQtU1RFRVJJTkdcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudFN0ZWVyaW5nQXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzLCBbJ1NFUlZFUi1VUkknLCAnUEFUSFdBWS1JRCddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJzZWQuY29udGVudFN0ZWVyaW5nID0ge1xuICAgICAgICAgICAgICAgIHVyaTogTTNVOFBhcnNlci5yZXNvbHZlKGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXNbJ1NFUlZFUi1VUkknXSwgYmFzZXVybCksXG4gICAgICAgICAgICAgICAgcGF0aHdheUlkOiBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzWydQQVRIV0FZLUlEJ10gfHwgJy4nXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gI0VYVC1YLVNUQVJUXG4gICAgICAgICAgICAgIHBhcnNlZC5zdGFydFRpbWVPZmZzZXQgPSBwYXJzZVN0YXJ0VGltZU9mZnNldChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRmlsdGVyIG91dCBsZXZlbHMgd2l0aCB1bmtub3duIGNvZGVjcyBpZiBpdCBkb2VzIG5vdCByZW1vdmUgYWxsIGxldmVsc1xuICAgIGNvbnN0IHN0cmlwVW5rbm93bkNvZGVjTGV2ZWxzID0gbGV2ZWxzV2l0aEtub3duQ29kZWNzLmxlbmd0aCA+IDAgJiYgbGV2ZWxzV2l0aEtub3duQ29kZWNzLmxlbmd0aCA8IHBhcnNlZC5sZXZlbHMubGVuZ3RoO1xuICAgIHBhcnNlZC5sZXZlbHMgPSBzdHJpcFVua25vd25Db2RlY0xldmVscyA/IGxldmVsc1dpdGhLbm93bkNvZGVjcyA6IHBhcnNlZC5sZXZlbHM7XG4gICAgaWYgKHBhcnNlZC5sZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ25vIGxldmVscyBmb3VuZCBpbiBtYW5pZmVzdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCBiYXNldXJsLCBwYXJzZWQpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICBjb25zdCBsZXZlbHMgPSBwYXJzZWQubGV2ZWxzO1xuICAgIGNvbnN0IGdyb3Vwc0J5VHlwZSA9IHtcbiAgICAgIEFVRElPOiBsZXZlbHMubWFwKGxldmVsID0+ICh7XG4gICAgICAgIGlkOiBsZXZlbC5hdHRycy5BVURJTyxcbiAgICAgICAgYXVkaW9Db2RlYzogbGV2ZWwuYXVkaW9Db2RlY1xuICAgICAgfSkpLFxuICAgICAgU1VCVElUTEVTOiBsZXZlbHMubWFwKGxldmVsID0+ICh7XG4gICAgICAgIGlkOiBsZXZlbC5hdHRycy5TVUJUSVRMRVMsXG4gICAgICAgIHRleHRDb2RlYzogbGV2ZWwudGV4dENvZGVjXG4gICAgICB9KSksXG4gICAgICAnQ0xPU0VELUNBUFRJT05TJzogW11cbiAgICB9O1xuICAgIGxldCBpZCA9IDA7XG4gICAgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBhdHRycy5UWVBFO1xuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gZ3JvdXBzQnlUeXBlW3R5cGVdO1xuICAgICAgICBjb25zdCBtZWRpYXMgPSByZXN1bHRzW3R5cGVdIHx8IFtdO1xuICAgICAgICByZXN1bHRzW3R5cGVdID0gbWVkaWFzO1xuICAgICAgICB7XG4gICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGF0dHJzLCBbJ1VSSScsICdHUk9VUC1JRCcsICdMQU5HVUFHRScsICdBU1NPQy1MQU5HVUFHRScsICdTVEFCTEUtUkVORElUSU9OLUlEJywgJ05BTUUnLCAnSU5TVFJFQU0tSUQnLCAnQ0hBUkFDVEVSSVNUSUNTJywgJ0NIQU5ORUxTJ10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lZGlhID0ge1xuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgICAgaWQ6IGlkKyssXG4gICAgICAgICAgZ3JvdXBJZDogYXR0cnNbJ0dST1VQLUlEJ10gfHwgJycsXG4gICAgICAgICAgaW5zdHJlYW1JZDogYXR0cnNbJ0lOU1RSRUFNLUlEJ10sXG4gICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSB8fCBhdHRycy5MQU5HVUFHRSB8fCAnJyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGRlZmF1bHQ6IGF0dHJzLmJvb2woJ0RFRkFVTFQnKSxcbiAgICAgICAgICBhdXRvc2VsZWN0OiBhdHRycy5ib29sKCdBVVRPU0VMRUNUJyksXG4gICAgICAgICAgZm9yY2VkOiBhdHRycy5ib29sKCdGT1JDRUQnKSxcbiAgICAgICAgICBsYW5nOiBhdHRycy5MQU5HVUFHRSxcbiAgICAgICAgICB1cmw6IGF0dHJzLlVSSSA/IE0zVThQYXJzZXIucmVzb2x2ZShhdHRycy5VUkksIGJhc2V1cmwpIDogJydcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGdyb3VwcyAhPSBudWxsICYmIGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYXVkaW8gb3IgdGV4dCBncm91cHMgc2lnbmFsbGVkIGluIHRoZSBtYW5pZmVzdCwgbGV0J3MgbG9vayBmb3IgYSBtYXRjaGluZyBjb2RlYyBzdHJpbmcgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIHRoZSB0cmFjayBzaWduYWxsZWQsIGxldHMgdXNlIHRoZSBmaXJzdCBhdWRpbyBncm91cHMgY29kZWMgd2UgaGF2ZVxuICAgICAgICAgIC8vIEFjdGluZyBhcyBhIGJlc3QgZ3Vlc3NcbiAgICAgICAgICBjb25zdCBncm91cENvZGVjID0gTTNVOFBhcnNlci5maW5kR3JvdXAoZ3JvdXBzLCBtZWRpYS5ncm91cElkKSB8fCBncm91cHNbMF07XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICdhdWRpb0NvZGVjJyk7XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICd0ZXh0Q29kZWMnKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIHN0YXRpYyBwYXJzZUxldmVsUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsLCBpZCwgdHlwZSwgbGV2ZWxVcmxJZCwgbXVsdGl2YXJpYW50VmFyaWFibGVMaXN0KSB7XG4gICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWxEZXRhaWxzKGJhc2V1cmwpO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsLmZyYWdtZW50cztcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgaW5pdCBzZWdtZW50IHNlZW4gKGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgc2VnbWVudHMpXG4gICAgbGV0IGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRTTiA9IDA7XG4gICAgbGV0IGN1cnJlbnRQYXJ0ID0gMDtcbiAgICBsZXQgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgbGV0IGRpc2NvbnRpbnVpdHlDb3VudGVyID0gMDtcbiAgICBsZXQgcHJldkZyYWcgPSBudWxsO1xuICAgIGxldCBmcmFnID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGk7XG4gICAgbGV0IGxldmVsa2V5cztcbiAgICBsZXQgZmlyc3RQZHRJbmRleCA9IC0xO1xuICAgIGxldCBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcbiAgICBsZXZlbC5tM3U4ID0gc3RyaW5nO1xuICAgIGxldmVsLmhhc1ZhcmlhYmxlUmVmcyA9IGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHJpbmcpIDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNyZWF0ZU5leHRGcmFnKSB7XG4gICAgICAgIGNyZWF0ZU5leHRGcmFnID0gZmFsc2U7XG4gICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgICAgIC8vIHNldHVwIHRoZSBuZXh0IGZyYWdtZW50IGZvciBwYXJ0IGxvYWRpbmdcbiAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcmVzdWx0WzFdO1xuICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgIC8vIElORlxuICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7XG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgY29uc3QgdGl0bGUgPSAoJyAnICsgcmVzdWx0WzJdKS5zbGljZSgxKTtcbiAgICAgICAgZnJhZy50aXRsZSA9IHRpdGxlIHx8IG51bGw7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHRpdGxlID8gWydJTkYnLCBkdXJhdGlvbiwgdGl0bGVdIDogWydJTkYnLCBkdXJhdGlvbl0pO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHtcbiAgICAgICAgLy8gdXJsXG4gICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICAgIGlmIChsZXZlbGtleXMpIHtcbiAgICAgICAgICAgIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgICBmcmFnLnVybElkID0gbGV2ZWxVcmxJZDtcbiAgICAgICAgICBmcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgY29uc3QgdXJpID0gKCcgJyArIHJlc3VsdFszXSkuc2xpY2UoMSk7XG4gICAgICAgICAgZnJhZy5yZWx1cmwgPSBzdWJzdGl0dXRlVmFyaWFibGVzKGxldmVsLCB1cmkpIDtcbiAgICAgICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgICAgIHByZXZGcmFnID0gZnJhZztcbiAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgY3VycmVudFNOKys7XG4gICAgICAgICAgY3VycmVudFBhcnQgPSAwO1xuICAgICAgICAgIGNyZWF0ZU5leHRGcmFnID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNF0pIHtcbiAgICAgICAgLy8gWC1CWVRFUkFOR0VcbiAgICAgICAgY29uc3QgZGF0YSA9ICgnICcgKyByZXN1bHRbNF0pLnNsaWNlKDEpO1xuICAgICAgICBpZiAocHJldkZyYWcpIHtcbiAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShkYXRhLCBwcmV2RnJhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzVdKSB7XG4gICAgICAgIC8vIFBST0dSQU0tREFURS1USU1FXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSAoJyAnICsgcmVzdWx0WzVdKS5zbGljZSgxKTtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydQUk9HUkFNLURBVEUtVElNRScsIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lXSk7XG4gICAgICAgIGlmIChmaXJzdFBkdEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIGZpcnN0UGR0SW5kZXggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ05vIG1hdGNoZXMgb24gc2xvdyByZWdleCBtYXRjaCBmb3IgbGV2ZWwgcGxheWxpc3QhJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBjb25zdCB0YWcgPSAoJyAnICsgcmVzdWx0W2ldKS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpICsgMV0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSByZXN1bHRbaSArIDJdID8gKCcgJyArIHJlc3VsdFtpICsgMl0pLnNsaWNlKDEpIDogJyc7XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgICBsZXZlbC50eXBlID0gdmFsdWUxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgICBjdXJyZW50U04gPSBsZXZlbC5zdGFydFNOID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1NLSVAnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBza2lwQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHNraXBBdHRycywgWydSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc2tpcHBlZFNlZ21lbnRzID0gc2tpcEF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdTS0lQUEVELVNFR01FTlRTJyk7XG4gICAgICAgICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihza2lwcGVkU2VnbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuc2tpcHBlZFNlZ21lbnRzID0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCByZXN1bHQgaW4gZnJhZ21lbnRzW10gY29udGFpbmluZyB1bmRlZmluZWQgdmFsdWVzLCB3aGljaCB3ZSB3aWxsIGZpbGwgaW4gd2l0aCBgbWVyZ2VEZXRhaWxzYFxuICAgICAgICAgICAgICAgIGZvciAobGV0IF9pID0gc2tpcHBlZFNlZ21lbnRzOyBfaS0tOykge1xuICAgICAgICAgICAgICAgICAgZnJhZ21lbnRzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTTiArPSBza2lwcGVkU2VnbWVudHM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHNraXBBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcy5zcGxpdCgnXFx0Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBNYXRoLm1heChwYXJzZUludCh2YWx1ZTEpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFWFRNM1UnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZTEgfHwgdmFsdWUyKSB7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyKys7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0dBUCc6XG4gICAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbdGFnXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdCSVRSQVRFJzpcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWcsIHZhbHVlMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnREFURVJBTkdFJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlQXR0ciA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgZGF0ZVJhbmdlQXR0ciwgWydJRCcsICdDTEFTUycsICdTVEFSVC1EQVRFJywgJ0VORC1EQVRFJywgJ1NDVEUzNS1DTUQnLCAnU0NURTM1LU9VVCcsICdTQ1RFMzUtSU4nXSk7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgZGF0ZVJhbmdlQXR0ciwgZGF0ZVJhbmdlQXR0ci5jbGllbnRBdHRycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlID0gbmV3IERhdGVSYW5nZShkYXRlUmFuZ2VBdHRyLCBsZXZlbC5kYXRlUmFuZ2VzW2RhdGVSYW5nZUF0dHIuSURdKTtcbiAgICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5pc1ZhbGlkIHx8IGxldmVsLnNraXBwZWRTZWdtZW50cykge1xuICAgICAgICAgICAgICAgIGxldmVsLmRhdGVSYW5nZXNbZGF0ZVJhbmdlLmlkXSA9IGRhdGVSYW5nZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgSWdub3JpbmcgaW52YWxpZCBEQVRFUkFOR0UgdGFnOiBcIiR7dmFsdWUxfVwiYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQWRkIHRvIGZyYWdtZW50IHRhZyBsaXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoPCB2MS4yLjApXG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnRVhULVgtREFURVJBTkdFJywgdmFsdWUxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0RFRklORSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZUF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIFsnTkFNRScsICdWQUxVRScsICdJTVBPUlQnLCAnUVVFUllQQVJBTSddKTtcbiAgICAgICAgICAgICAgICBpZiAoJ0lNUE9SVCcgaW4gdmFyaWFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICBpbXBvcnRWYXJpYWJsZURlZmluaXRpb24obGV2ZWwsIHZhcmlhYmxlQXR0cmlidXRlcywgbXVsdGl2YXJpYW50VmFyaWFibGVMaXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYWRkVmFyaWFibGVEZWZpbml0aW9uKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0tFWSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGxldmVsS2V5ID0gcGFyc2VLZXkodmFsdWUxLCBiYXNldXJsLCBsZXZlbCk7XG4gICAgICAgICAgICAgIGlmIChsZXZlbEtleS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsS2V5Lm1ldGhvZCA9PT0gJ05PTkUnKSB7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFsZXZlbGtleXMpIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5cyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxrZXlzW2xldmVsS2V5LmtleUZvcm1hdF0pIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5cyA9IF9leHRlbmRzKHt9LCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXZlbGtleXNbbGV2ZWxLZXkua2V5Rm9ybWF0XSA9IGxldmVsS2V5O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbS2V5c10gSWdub3JpbmcgaW52YWxpZCBFWFQtWC1LRVkgdGFnOiBcIiR7dmFsdWUxfVwiYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01BUCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBtYXBBdHRycywgWydCWVRFUkFOR0UnLCAnVVJJJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmcmFnLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBhZnRlciBzZWdtZW50IGR1cmF0aW9uIHRhZy5cbiAgICAgICAgICAgICAgICAvLyAgICNFWFRJTkY6IDYuMFxuICAgICAgICAgICAgICAgIC8vICAgI0VYVC1YLU1BUDpVUkk9XCJpbml0Lm1wNFxuICAgICAgICAgICAgICAgIGNvbnN0IGluaXQgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoaW5pdCwgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSAmJiAhZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBiZWZvcmUgc2VnbWVudCBkdXJhdGlvbiB0YWdcbiAgICAgICAgICAgICAgICBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU0VSVkVSLUNPTlRST0wnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJDb250cm9sQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuQmxvY2tSZWxvYWQgPSBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLUJMT0NLLVJFTE9BRCcpO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5Ta2lwVW50aWwgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnQ0FOLVNLSVAtVU5USUwnLCAwKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcERhdGVSYW5nZXMgPSBsZXZlbC5jYW5Ta2lwVW50aWwgPiAwICYmIHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tU0tJUC1EQVRFUkFOR0VTJyk7XG4gICAgICAgICAgICAgIGxldmVsLnBhcnRIb2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdQQVJULUhPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgICBsZXZlbC5ob2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdIT0xELUJBQ0snLCAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUEFSVC1JTkYnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0SW5mQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwucGFydFRhcmdldCA9IHBhcnRJbmZBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnUEFSVC1UQVJHRVQnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUEFSVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0O1xuICAgICAgICAgICAgICBpZiAoIXBhcnRMaXN0KSB7XG4gICAgICAgICAgICAgICAgcGFydExpc3QgPSBsZXZlbC5wYXJ0TGlzdCA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRnJhZ21lbnRQYXJ0ID0gY3VycmVudFBhcnQgPiAwID8gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudFBhcnQrKztcbiAgICAgICAgICAgICAgY29uc3QgcGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBwYXJ0QXR0cnMsIFsnQllURVJBTkdFJywgJ1VSSSddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gbmV3IFBhcnQocGFydEF0dHJzLCBmcmFnLCBiYXNldXJsLCBpbmRleCwgcHJldmlvdXNGcmFnbWVudFBhcnQpO1xuICAgICAgICAgICAgICBwYXJ0TGlzdC5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICBmcmFnLmR1cmF0aW9uICs9IHBhcnQuZHVyYXRpb247XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BSRUxPQUQtSElOVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZWxvYWRIaW50QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHByZWxvYWRIaW50QXR0cnMsIFsnVVJJJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldmVsLnByZWxvYWRIaW50ID0gcHJlbG9hZEhpbnRBdHRycztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUkVORElUSU9OLVJFUE9SVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbmRpdGlvblJlcG9ydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCByZW5kaXRpb25SZXBvcnRBdHRycywgWydVUkknXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyA9IGxldmVsLnJlbmRpdGlvblJlcG9ydHMgfHwgW107XG4gICAgICAgICAgICAgIGxldmVsLnJlbmRpdGlvblJlcG9ydHMucHVzaChyZW5kaXRpb25SZXBvcnRBdHRycyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2dnZXIud2FybihgbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2RnJhZyAmJiAhcHJldkZyYWcucmVsdXJsKSB7XG4gICAgICBmcmFnbWVudHMucG9wKCk7XG4gICAgICB0b3RhbGR1cmF0aW9uIC09IHByZXZGcmFnLmR1cmF0aW9uO1xuICAgICAgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50SGludCA9IHByZXZGcmFnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV2ZWwucGFydExpc3QpIHtcbiAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBmcmFnO1xuICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudExlbmd0aCA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgZmlyc3RGcmFnbWVudCA9IGZyYWdtZW50c1swXTtcbiAgICBjb25zdCBsYXN0RnJhZ21lbnQgPSBmcmFnbWVudHNbZnJhZ21lbnRMZW5ndGggLSAxXTtcbiAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLnNraXBwZWRTZWdtZW50cyAqIGxldmVsLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmICh0b3RhbGR1cmF0aW9uID4gMCAmJiBmcmFnbWVudExlbmd0aCAmJiBsYXN0RnJhZ21lbnQpIHtcbiAgICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBmcmFnbWVudExlbmd0aDtcbiAgICAgIGNvbnN0IGxhc3RTbiA9IGxhc3RGcmFnbWVudC5zbjtcbiAgICAgIGxldmVsLmVuZFNOID0gbGFzdFNuICE9PSAnaW5pdFNlZ21lbnQnID8gbGFzdFNuIDogMDtcbiAgICAgIGlmICghbGV2ZWwubGl2ZSkge1xuICAgICAgICBsYXN0RnJhZ21lbnQuZW5kTGlzdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RGcmFnbWVudCkge1xuICAgICAgICBsZXZlbC5zdGFydENDID0gZmlyc3RGcmFnbWVudC5jYztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV2ZWwuZW5kU04gPSAwO1xuICAgICAgbGV2ZWwuc3RhcnRDQyA9IDA7XG4gICAgfVxuICAgIGlmIChsZXZlbC5mcmFnbWVudEhpbnQpIHtcbiAgICAgIHRvdGFsZHVyYXRpb24gKz0gbGV2ZWwuZnJhZ21lbnRIaW50LmR1cmF0aW9uO1xuICAgIH1cbiAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICBsZXZlbC5lbmRDQyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuXG4gICAgLyoqXG4gICAgICogQmFja2ZpbGwgYW55IG1pc3NpbmcgUERUIHZhbHVlc1xuICAgICAqIFwiSWYgdGhlIGZpcnN0IEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZyBpbiBhIFBsYXlsaXN0IGFwcGVhcnMgYWZ0ZXJcbiAgICAgKiBvbmUgb3IgbW9yZSBNZWRpYSBTZWdtZW50IFVSSXMsIHRoZSBjbGllbnQgU0hPVUxEIGV4dHJhcG9sYXRlXG4gICAgICogYmFja3dhcmQgZnJvbSB0aGF0IHRhZyAodXNpbmcgRVhUSU5GIGR1cmF0aW9ucyBhbmQvb3IgbWVkaWFcbiAgICAgKiB0aW1lc3RhbXBzKSB0byBhc3NvY2lhdGUgZGF0ZXMgd2l0aCB0aG9zZSBzZWdtZW50cy5cIlxuICAgICAqIFdlIGhhdmUgYWxyZWFkeSBleHRyYXBvbGF0ZWQgZm9yd2FyZCwgYnV0IGFsbCBmcmFnbWVudHMgdXAgdG8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIFBEVCBkbyBub3QgaGF2ZSB0aGVpciBQRFRzXG4gICAgICogY29tcHV0ZWQuXG4gICAgICovXG4gICAgaWYgKGZpcnN0UGR0SW5kZXggPiAwKSB7XG4gICAgICBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUtleShrZXlUYWdBdHRyaWJ1dGVzLCBiYXNldXJsLCBwYXJzZWQpIHtcbiAgdmFyIF9rZXlBdHRycyRNRVRIT0QsIF9rZXlBdHRycyRLRVlGT1JNQVQ7XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MjE2I3NlY3Rpb24tNC4zLjIuNFxuICBjb25zdCBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChrZXlUYWdBdHRyaWJ1dGVzKTtcbiAge1xuICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBrZXlBdHRycywgWydLRVlGT1JNQVQnLCAnS0VZRk9STUFUVkVSU0lPTlMnLCAnVVJJJywgJ0lWJywgJ1VSSSddKTtcbiAgfVxuICBjb25zdCBkZWNyeXB0bWV0aG9kID0gKF9rZXlBdHRycyRNRVRIT0QgPSBrZXlBdHRycy5NRVRIT0QpICE9IG51bGwgPyBfa2V5QXR0cnMkTUVUSE9EIDogJyc7XG4gIGNvbnN0IGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkk7XG4gIGNvbnN0IGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgY29uc3QgZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID0ga2V5QXR0cnMuS0VZRk9STUFUVkVSU0lPTlM7XG4gIC8vIEZyb20gUkZDOiBUaGlzIGF0dHJpYnV0ZSBpcyBPUFRJT05BTDsgaXRzIGFic2VuY2UgaW5kaWNhdGVzIGFuIGltcGxpY2l0IHZhbHVlIG9mIFwiaWRlbnRpdHlcIi5cbiAgY29uc3QgZGVjcnlwdGtleWZvcm1hdCA9IChfa2V5QXR0cnMkS0VZRk9STUFUID0ga2V5QXR0cnMuS0VZRk9STUFUKSAhPSBudWxsID8gX2tleUF0dHJzJEtFWUZPUk1BVCA6ICdpZGVudGl0eSc7XG4gIGlmIChkZWNyeXB0dXJpICYmIGtleUF0dHJzLklWICYmICFkZWNyeXB0aXYpIHtcbiAgICBsb2dnZXIuZXJyb3IoYEludmFsaWQgSVY6ICR7a2V5QXR0cnMuSVZ9YCk7XG4gIH1cbiAgLy8gSWYgZGVjcnlwdHVyaSBpcyBhIFVSSSB3aXRoIGEgc2NoZW1lLCB0aGVuIGJhc2V1cmwgd2lsbCBiZSBpZ25vcmVkXG4gIC8vIE5vIHVyaSBpcyBhbGxvd2VkIHdoZW4gTUVUSE9EIGlzIE5PTkVcbiAgY29uc3QgcmVzb2x2ZWRVcmkgPSBkZWNyeXB0dXJpID8gTTNVOFBhcnNlci5yZXNvbHZlKGRlY3J5cHR1cmksIGJhc2V1cmwpIDogJyc7XG4gIGNvbnN0IGtleUZvcm1hdFZlcnNpb25zID0gKGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA/IGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA6ICcxJykuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKS5maWx0ZXIoTnVtYmVyLmlzRmluaXRlKTtcbiAgcmV0dXJuIG5ldyBMZXZlbEtleShkZWNyeXB0bWV0aG9kLCByZXNvbHZlZFVyaSwgZGVjcnlwdGtleWZvcm1hdCwga2V5Rm9ybWF0VmVyc2lvbnMsIGRlY3J5cHRpdik7XG59XG5mdW5jdGlvbiBwYXJzZVN0YXJ0VGltZU9mZnNldChzdGFydEF0dHJpYnV0ZXMpIHtcbiAgY29uc3Qgc3RhcnRBdHRycyA9IG5ldyBBdHRyTGlzdChzdGFydEF0dHJpYnV0ZXMpO1xuICBjb25zdCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICBpZiAoaXNGaW5pdGVOdW1iZXIoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgIHJldHVybiBzdGFydFRpbWVPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZXRDb2RlY3MoY29kZWNzLCBsZXZlbCkge1xuICBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3RleHQnXS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcihjb2RlYyA9PiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkpO1xuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHByZWZlcnJlZCA9IGZpbHRlcmVkLmZpbHRlcihjb2RlYyA9PiB7XG4gICAgICAgIHJldHVybiBjb2RlYy5sYXN0SW5kZXhPZignYXZjMScsIDApID09PSAwIHx8IGNvZGVjLmxhc3RJbmRleE9mKCdtcDRhJywgMCkgPT09IDA7XG4gICAgICB9KTtcbiAgICAgIGxldmVsW2Ake3R5cGV9Q29kZWNgXSA9IHByZWZlcnJlZC5sZW5ndGggPiAwID8gcHJlZmVycmVkWzBdIDogZmlsdGVyZWRbMF07XG5cbiAgICAgIC8vIHJlbW92ZSBmcm9tIGxpc3RcbiAgICAgIGNvZGVjcyA9IGNvZGVjcy5maWx0ZXIoY29kZWMgPT4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xKTtcbiAgICB9XG4gIH0pO1xuICBsZXZlbC51bmtub3duQ29kZWNzID0gY29kZWNzO1xufVxuZnVuY3Rpb24gYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwSXRlbSwgY29kZWNQcm9wZXJ0eSkge1xuICBjb25zdCBjb2RlY1ZhbHVlID0gZ3JvdXBJdGVtW2NvZGVjUHJvcGVydHldO1xuICBpZiAoY29kZWNWYWx1ZSkge1xuICAgIG1lZGlhW2NvZGVjUHJvcGVydHldID0gY29kZWNWYWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCkge1xuICBsZXQgZnJhZ1ByZXYgPSBmcmFnbWVudHNbZmlyc3RQZHRJbmRleF07XG4gIGZvciAobGV0IGkgPSBmaXJzdFBkdEluZGV4OyBpLS07KSB7XG4gICAgY29uc3QgZnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICAvLyBFeGl0IG9uIGRlbHRhLXBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBmcmFnUHJldi5wcm9ncmFtRGF0ZVRpbWUgLSBmcmFnLmR1cmF0aW9uICogMTAwMDtcbiAgICBmcmFnUHJldiA9IGZyYWc7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZykge1xuICBpZiAoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IERhdGUucGFyc2UoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICB9IGVsc2UgaWYgKHByZXZGcmFnICE9IG51bGwgJiYgcHJldkZyYWcucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cbiAgaWYgKCFpc0Zpbml0ZU51bWJlcihmcmFnLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5cykge1xuICBmcmFnLnJlbHVybCA9IG1hcEF0dHJzLlVSSTtcbiAgaWYgKG1hcEF0dHJzLkJZVEVSQU5HRSkge1xuICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKG1hcEF0dHJzLkJZVEVSQU5HRSk7XG4gIH1cbiAgZnJhZy5sZXZlbCA9IGlkO1xuICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgaWYgKGxldmVsa2V5cykge1xuICAgIGZyYWcubGV2ZWxrZXlzID0gbGV2ZWxrZXlzO1xuICB9XG4gIGZyYWcuaW5pdFNlZ21lbnQgPSBudWxsO1xufVxuZnVuY3Rpb24gc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKSB7XG4gIGZyYWcubGV2ZWxrZXlzID0gbGV2ZWxrZXlzO1xuICBjb25zdCB7XG4gICAgZW5jcnlwdGVkRnJhZ21lbnRzXG4gIH0gPSBsZXZlbDtcbiAgaWYgKCghZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCB8fCBlbmNyeXB0ZWRGcmFnbWVudHNbZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCAtIDFdLmxldmVsa2V5cyAhPT0gbGV2ZWxrZXlzKSAmJiBPYmplY3Qua2V5cyhsZXZlbGtleXMpLnNvbWUoZm9ybWF0ID0+IGxldmVsa2V5c1tmb3JtYXRdLmlzQ29tbW9uRW5jcnlwdGlvbikpIHtcbiAgICBlbmNyeXB0ZWRGcmFnbWVudHMucHVzaChmcmFnKTtcbiAgfVxufVxuXG52YXIgUGxheWxpc3RDb250ZXh0VHlwZSA9IHtcbiAgTUFOSUZFU1Q6IFwibWFuaWZlc3RcIixcbiAgTEVWRUw6IFwibGV2ZWxcIixcbiAgQVVESU9fVFJBQ0s6IFwiYXVkaW9UcmFja1wiLFxuICBTVUJUSVRMRV9UUkFDSzogXCJzdWJ0aXRsZVRyYWNrXCJcbn07XG52YXIgUGxheWxpc3RMZXZlbFR5cGUgPSB7XG4gIE1BSU46IFwibWFpblwiLFxuICBBVURJTzogXCJhdWRpb1wiLFxuICBTVUJUSVRMRTogXCJzdWJ0aXRsZVwiXG59O1xuXG5mdW5jdGlvbiBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCkge1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gY29udGV4dDtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPO1xuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU47XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gIGxldCB1cmwgPSByZXNwb25zZS51cmw7XG4gIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxuICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgIHVybCA9IGNvbnRleHQudXJsO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5jbGFzcyBQbGF5bGlzdExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge31cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0cyBvciBjb25maWd1cmVkIGxvYWRlci10eXBlIG92ZXJsb2FkcyAocExvYWRlciBhbmQgbG9hZGVyIGNvbmZpZyBwYXJhbXMpXG4gICAqL1xuICBjcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IFBMb2FkZXIgPSBjb25maWcucExvYWRlcjtcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IEludGVybmFsTG9hZGVyID0gUExvYWRlciB8fCBMb2FkZXI7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEludGVybmFsTG9hZGVyKGNvbmZpZyk7XG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBsb2FkZXI7XG4gICAgcmV0dXJuIGxvYWRlcjtcbiAgfVxuICBnZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICB9XG4gIHJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpIHtcbiAgICBpZiAodGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYGRlc3Ryb3lgIG9uIGFsbCBpbnRlcm5hbCBsb2FkZXIgaW5zdGFuY2VzIG1hcHBlZCAob25lIHBlciBjb250ZXh0IHR5cGUpXG4gICAqL1xuICBkZXN0cm95SW50ZXJuYWxMb2FkZXJzKCkge1xuICAgIGZvciAoY29uc3QgY29udGV4dFR5cGUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICB1cmxcbiAgICB9ID0gZGF0YTtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkOiBudWxsLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IG51bGxcbiAgICB9KTtcbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgbGV2ZWwsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9ID0gZGF0YTtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQsXG4gICAgICBsZXZlbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0pO1xuICB9XG4gIG9uQXVkaW9UcmFja0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9ID0gZGF0YTtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgbGV2ZWw6IG51bGwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0ssXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9KTtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSk7XG4gIH1cbiAgbG9hZChjb250ZXh0KSB7XG4gICAgdmFyIF9jb250ZXh0JGRlbGl2ZXJ5RGlyZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBMb2FkaW5nIHBsYXlsaXN0IG9mIHR5cGUgJHtjb250ZXh0LnR5cGV9LCBsZXZlbDogJHtjb250ZXh0LmxldmVsfSwgaWQ6ICR7Y29udGV4dC5pZH1gKTtcblxuICAgIC8vIENoZWNrIGlmIGEgbG9hZGVyIGZvciB0aGlzIGNvbnRleHQgYWxyZWFkeSBleGlzdHNcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XG4gICAgICBpZiAobG9hZGVyQ29udGV4dCAmJiBsb2FkZXJDb250ZXh0LnVybCA9PT0gY29udGV4dC51cmwpIHtcbiAgICAgICAgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcFxuICAgICAgICBsb2dnZXIudHJhY2UoJ1twbGF5bGlzdC1sb2FkZXJdOiBwbGF5bGlzdCByZXF1ZXN0IG9uZ29pbmcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZyhgW3BsYXlsaXN0LWxvYWRlcl06IGFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogJHtjb250ZXh0LnR5cGV9YCk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBkaWZmZXJlbnQgY29uZmlncyBmb3IgcmV0cmllcyBkZXBlbmRpbmcgb25cbiAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXG4gICAgbGV0IGxvYWRQb2xpY3k7XG4gICAgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCkge1xuICAgICAgbG9hZFBvbGljeSA9IGNvbmZpZy5tYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZFBvbGljeSA9IF9leHRlbmRzKHt9LCBjb25maWcucGxheWxpc3RMb2FkUG9saWN5LmRlZmF1bHQsIHtcbiAgICAgICAgdGltZW91dFJldHJ5OiBudWxsLFxuICAgICAgICBlcnJvclJldHJ5OiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgbG9hZGVyID0gdGhpcy5jcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcblxuICAgIC8vIE92ZXJyaWRlIGxldmVsL3RyYWNrIHRpbWVvdXQgZm9yIExMLUhMUyByZXF1ZXN0c1xuICAgIC8vICh0aGUgZGVmYXVsdCBvZiAxMDAwMG1zIGlzIGNvdW50ZXIgcHJvZHVjdGl2ZSB0byBibG9ja2luZyBwbGF5bGlzdCByZWxvYWQgcmVxdWVzdHMpXG4gICAgaWYgKChfY29udGV4dCRkZWxpdmVyeURpcmUgPSBjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT0gbnVsbCAmJiBfY29udGV4dCRkZWxpdmVyeURpcmUucGFydCkge1xuICAgICAgbGV0IGxldmVsRGV0YWlscztcbiAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgY29udGV4dC5sZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5sZXZlbHNbY29udGV4dC5sZXZlbF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGNvbnRleHQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuYXVkaW9UcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGNvbnRleHQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuc3VidGl0bGVUcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgICAgY29uc3QgcGFydFRhcmdldCA9IGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREdXJhdGlvbiA9IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgICAgaWYgKHBhcnRUYXJnZXQgJiYgdGFyZ2V0RHVyYXRpb24pIHtcbiAgICAgICAgICBjb25zdCBtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoID0gTWF0aC5tYXgocGFydFRhcmdldCAqIDMsIHRhcmdldER1cmF0aW9uICogMC44KSAqIDEwMDA7XG4gICAgICAgICAgbG9hZFBvbGljeSA9IF9leHRlbmRzKHt9LCBsb2FkUG9saWN5LCB7XG4gICAgICAgICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogTWF0aC5taW4obWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCwgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNcyksXG4gICAgICAgICAgICBtYXhMb2FkVGltZU1zOiBNYXRoLm1pbihtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoLCBsb2FkUG9saWN5Lm1heFRpbWVUb0ZpcnN0Qnl0ZU1zKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eSA9IGxvYWRQb2xpY3kuZXJyb3JSZXRyeSB8fCBsb2FkUG9saWN5LnRpbWVvdXRSZXRyeSB8fCB7fTtcbiAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICBsb2FkUG9saWN5LFxuICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhOdW1SZXRyeSB8fCAwLFxuICAgICAgcmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5LnJldHJ5RGVsYXlNcyB8fCAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgfTtcbiAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgICAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGlmIGl0IGlzIGFuIE0zVTggYXQgYWxsXG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV3IEVycm9yKCdubyBFWFRNM1UgZGVsaW1pdGVyJyksIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsIHN0YXRzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoTTNVOFBhcnNlci5pc01lZGlhUGxheWxpc3Qoc3RyaW5nKSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyB8fCBudWxsLCBsb2FkZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgZmFsc2UsIHJlc3BvbnNlLCBzdGF0cyk7XG4gICAgICB9LFxuICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0cnVlLCB1bmRlZmluZWQsIHN0YXRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbG9nZ2VyLmRlYnVnKGBbcGxheWxpc3QtbG9hZGVyXTogQ2FsbGluZyBpbnRlcm5hbCBsb2FkZXIgZGVsZWdhdGUgZm9yIFVSTDogJHtjb250ZXh0LnVybH1gKTtcblxuICAgIGxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgfVxuICBoYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3Qgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcbiAgICBjb25zdCB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgY29uc3QgcGFyc2VkUmVzdWx0ID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgdXJsKTtcbiAgICBpZiAocGFyc2VkUmVzdWx0LnBsYXlsaXN0UGFyc2luZ0Vycm9yKSB7XG4gICAgICB0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBwYXJzZWRSZXN1bHQucGxheWxpc3RQYXJzaW5nRXJyb3IsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRlbnRTdGVlcmluZyxcbiAgICAgIGxldmVscyxcbiAgICAgIHNlc3Npb25EYXRhLFxuICAgICAgc2Vzc2lvbktleXMsXG4gICAgICBzdGFydFRpbWVPZmZzZXQsXG4gICAgICB2YXJpYWJsZUxpc3RcbiAgICB9ID0gcGFyc2VkUmVzdWx0O1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gdmFyaWFibGVMaXN0O1xuICAgIGNvbnN0IHtcbiAgICAgIEFVRElPOiBhdWRpb1RyYWNrcyA9IFtdLFxuICAgICAgU1VCVElUTEVTOiBzdWJ0aXRsZXMsXG4gICAgICAnQ0xPU0VELUNBUFRJT05TJzogY2FwdGlvbnNcbiAgICB9ID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsIHBhcnNlZFJlc3VsdCk7XG4gICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBmb3VuZCBhbiBhdWRpbyB0cmFjayBlbWJlZGRlZCBpbiBtYWluIHBsYXlsaXN0IChhdWRpbyB0cmFjayB3aXRob3V0IFVSSSBhdHRyaWJ1dGUpXG4gICAgICBjb25zdCBlbWJlZGRlZEF1ZGlvRm91bmQgPSBhdWRpb1RyYWNrcy5zb21lKGF1ZGlvVHJhY2sgPT4gIWF1ZGlvVHJhY2sudXJsKTtcblxuICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNpZ25hbCB0aGlzIG1haW4gYXVkaW8gdHJhY2sgdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aFxuICAgICAgLy8gYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbilcbiAgICAgIC8vIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxuICAgICAgaWYgKCFlbWJlZGRlZEF1ZGlvRm91bmQgJiYgbGV2ZWxzWzBdLmF1ZGlvQ29kZWMgJiYgIWxldmVsc1swXS5hdHRycy5BVURJTykge1xuICAgICAgICBsb2dnZXIubG9nKCdbcGxheWxpc3QtbG9hZGVyXTogYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6ICdtYWluJyxcbiAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgZ3JvdXBJZDogJ21haW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlZDogZmFsc2UsXG4gICAgICAgICAgaWQ6IC0xLFxuICAgICAgICAgIGF0dHJzOiBuZXcgQXR0ckxpc3Qoe30pLFxuICAgICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgICAgdXJsOiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3MsXG4gICAgICBzdWJ0aXRsZXMsXG4gICAgICBjYXB0aW9ucyxcbiAgICAgIGNvbnRlbnRTdGVlcmluZyxcbiAgICAgIHVybCxcbiAgICAgIHN0YXRzLFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0LFxuICAgICAgdmFyaWFibGVMaXN0XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgbG9hZGVyKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBsZXZlbCxcbiAgICAgIHR5cGVcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgY29uc3QgbGV2ZWxVcmxJZCA9IGlzRmluaXRlTnVtYmVyKGlkKSA/IGlkIDogMDtcbiAgICBjb25zdCBsZXZlbElkID0gaXNGaW5pdGVOdW1iZXIobGV2ZWwpID8gbGV2ZWwgOiBsZXZlbFVybElkO1xuICAgIGNvbnN0IGxldmVsVHlwZSA9IG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdChyZXNwb25zZS5kYXRhLCB1cmwsIGxldmVsSWQsIGxldmVsVHlwZSwgbGV2ZWxVcmxJZCwgdGhpcy52YXJpYWJsZUxpc3QpO1xuXG4gICAgLy8gV2UgaGF2ZSBkb25lIG91ciBmaXJzdCByZXF1ZXN0IChNYW5pZmVzdC10eXBlKSBhbmQgcmVjZWl2ZVxuICAgIC8vIG5vdCBhIG1hc3RlciBwbGF5bGlzdCBidXQgYSBjaHVuay1saXN0ICh0cmFjay9sZXZlbClcbiAgICAvLyBXZSBmaXJlIHRoZSBtYW5pZmVzdC1sb2FkZWQgZXZlbnQgYW55d2F5IHdpdGggdGhlIHBhcnNlZCBsZXZlbC1kZXRhaWxzXG4gICAgLy8gYnkgY3JlYXRpbmcgYSBzaW5nbGUtbGV2ZWwgc3RydWN0dXJlIGZvciBpdC5cbiAgICBpZiAodHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCkge1xuICAgICAgY29uc3Qgc2luZ2xlTGV2ZWwgPSB7XG4gICAgICAgIGF0dHJzOiBuZXcgQXR0ckxpc3Qoe30pLFxuICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICB1cmxcbiAgICAgIH07XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcbiAgICAgICAgYXVkaW9UcmFja3M6IFtdLFxuICAgICAgICB1cmwsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICAgIHNlc3Npb25LZXlzOiBudWxsLFxuICAgICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgICAgdmFyaWFibGVMaXN0OiBudWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzYXZlIHBhcnNpbmcgdGltZVxuICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuICAgIGNvbnRleHQubGV2ZWxEZXRhaWxzID0gbGV2ZWxEZXRhaWxzO1xuICAgIHRoaXMuaGFuZGxlUGxheWxpc3RMb2FkZWQobGV2ZWxEZXRhaWxzLCByZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBsb2FkZXIpO1xuICB9XG4gIGhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBlcnJvciwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSB7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCxcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgZXJyOiBlcnJvcixcbiAgICAgIGVycm9yLFxuICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzdGF0c1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdGltZW91dCA9IGZhbHNlLCByZXNwb25zZSwgc3RhdHMpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBBIG5ldHdvcmsgJHt0aW1lb3V0ID8gJ3RpbWVvdXQnIDogJ2Vycm9yJyArIChyZXNwb25zZSA/ICcgKHN0YXR1cyAnICsgcmVzcG9uc2UuY29kZSArICcpJyA6ICcnKX0gb2NjdXJyZWQgd2hpbGUgbG9hZGluZyAke2NvbnRleHQudHlwZX1gO1xuICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYDogJHtjb250ZXh0LmxldmVsfSBpZDogJHtjb250ZXh0LmlkfWA7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgfHwgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLKSB7XG4gICAgICBtZXNzYWdlICs9IGAgaWQ6ICR7Y29udGV4dC5pZH0gZ3JvdXAtaWQ6IFwiJHtjb250ZXh0Lmdyb3VwSWR9XCJgO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBsb2dnZXIud2FybihgW3BsYXlsaXN0LWxvYWRlcl06ICR7bWVzc2FnZX1gKTtcbiAgICBsZXQgZGV0YWlscyA9IEVycm9yRGV0YWlscy5VTktOT1dOO1xuICAgIGxldCBmYXRhbCA9IGZhbHNlO1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWwsXG4gICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgbG9hZGVyLFxuICAgICAgY29udGV4dCxcbiAgICAgIGVycm9yLFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzdGF0c1xuICAgIH07XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBjb25zdCB1cmwgPSAobmV0d29ya0RldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IG5ldHdvcmtEZXRhaWxzLnVybCkgfHwgY29udGV4dC51cmw7XG4gICAgICBlcnJvckRhdGEucmVzcG9uc2UgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgIHVybCxcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICB9LCByZXNwb25zZSk7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICB9XG4gIGhhbmRsZVBsYXlsaXN0TG9hZGVkKGxldmVsRGV0YWlscywgcmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgbG9hZGVyKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGxldmVsLFxuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcmVudCA9IG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcbiAgICBjb25zdCBsZXZlbEluZGV4ID0gdHlwZW9mIGNvbnRleHQubGV2ZWwgPT09ICdudW1iZXInICYmIHBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGxldmVsIDogdW5kZWZpbmVkO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IF9lcnJvciA9IG5ldyBFcnJvcignTm8gU2VnbWVudHMgZm91bmQgaW4gUGxheWxpc3QnKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIGVycm9yOiBfZXJyb3IsXG4gICAgICAgIHJlYXNvbjogX2Vycm9yLm1lc3NhZ2UsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc3RhdHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgbGV2ZWxEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIFRhcmdldCBEdXJhdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IGxldmVsRGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvcjtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0c1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSAmJiBsb2FkZXIpIHtcbiAgICAgIGlmIChsb2FkZXIuZ2V0Q2FjaGVBZ2UpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IGxvYWRlci5nZXRDYWNoZUFnZSgpIHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoIWxvYWRlci5nZXRDYWNoZUFnZSB8fCBpc05hTihsZXZlbERldGFpbHMuYWdlSGVhZGVyKSkge1xuICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXggfHwgMCxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQgfHwgJycsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50KHRyYWNrLCB2aWRlb0VsKSB7XG4gIGxldCBldmVudDtcbiAgdHJ5IHtcbiAgICBldmVudCA9IG5ldyBFdmVudCgnYWRkdHJhY2snKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZm9yIElFMTFcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICB9XG4gIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5mdW5jdGlvbiBhZGRDdWVUb1RyYWNrKHRyYWNrLCBjdWUpIHtcbiAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgLy8gY3VlIGNhbiBhcHBlYXIgbW9yZSB0aGFuIG9uY2UgaW4gZGlmZmVyZW50IHZ0dCBmaWxlcy5cbiAgLy8gVGhpcyBhdm9pZCBzaG93aW5nIGR1cGxpY2F0ZWQgY3VlcyB3aXRoIHNhbWUgdGltZWNvZGUgYW5kIHRleHQuXG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3VlcyAmJiAhdHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICB0cnkge1xuICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICBpZiAoIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWRkQ3VlIGlzIGZhaWxlZCBmb3I6ICR7Y3VlfWApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBbdGV4dHRyYWNrLXV0aWxzXTogJHtlcnJ9YCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0ZXh0VHJhY2tDdWUgPSBuZXcgc2VsZi5UZXh0VHJhY2tDdWUoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIGN1ZS50ZXh0KTtcbiAgICAgICAgdGV4dFRyYWNrQ3VlLmlkID0gY3VlLmlkO1xuICAgICAgICB0cmFjay5hZGRDdWUodGV4dFRyYWNrQ3VlKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBbdGV4dHRyYWNrLXV0aWxzXTogTGVnYWN5IFRleHRUcmFja0N1ZSBmYWxsYmFjayBmYWlsZWQ6ICR7ZXJyMn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaykge1xuICAvLyBXaGVuIHRyYWNrLm1vZGUgaXMgZGlzYWJsZWQsIHRyYWNrLmN1ZXMgd2lsbCBiZSBudWxsLlxuICAvLyBUbyBndWFyYW50ZWUgdGhlIHJlbW92YWwgb2YgY3Vlcywgd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAvLyBjaGFuZ2UgdGhlIG1vZGUgdG8gaGlkZGVuXG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3Vlcykge1xuICAgIGZvciAobGV0IGkgPSB0cmFjay5jdWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbaV0pO1xuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVDdWVzSW5SYW5nZSh0cmFjaywgc3RhcnQsIGVuZCwgcHJlZGljYXRlKSB7XG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3VlcyAmJiB0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjdWVzID0gZ2V0Q3Vlc0luUmFuZ2UodHJhY2suY3Vlcywgc3RhcnQsIGVuZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoY3Vlc1tpXSkpIHtcbiAgICAgICAgdHJhY2sucmVtb3ZlQ3VlKGN1ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5cbi8vIEZpbmQgZmlyc3QgY3VlIHN0YXJ0aW5nIGFmdGVyIGdpdmVuIHRpbWUuXG4vLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGJpbmFyeSBzZWFyY2ggTyhsb2cobikpLlxuZnVuY3Rpb24gZ2V0Rmlyc3RDdWVJbmRleEFmdGVyVGltZShjdWVzLCB0aW1lKSB7XG4gIC8vIElmIGZpcnN0IGN1ZSBzdGFydHMgYWZ0ZXIgdGltZSwgc3RhcnQgdGhlcmVcbiAgaWYgKHRpbWUgPCBjdWVzWzBdLnN0YXJ0VGltZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIElmIHRoZSBsYXN0IGN1ZSBlbmRzIGJlZm9yZSB0aW1lIHRoZXJlIGlzIG5vIG92ZXJsYXBcbiAgY29uc3QgbGVuID0gY3Vlcy5sZW5ndGggLSAxO1xuICBpZiAodGltZSA+IGN1ZXNbbGVuXS5lbmRUaW1lKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gbGVuO1xuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHJpZ2h0ICsgbGVmdCkgLyAyKTtcbiAgICBpZiAodGltZSA8IGN1ZXNbbWlkXS5zdGFydFRpbWUpIHtcbiAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpbWUgPiBjdWVzW21pZF0uc3RhcnRUaW1lICYmIGxlZnQgPCBsZW4pIHtcbiAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIG5vdCBsb3dlciBvciBoaWdoZXIsIGl0IG11c3QgYmUgZXF1YWwuXG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50LCBsZWZ0IGFuZCByaWdodCBoYXZlIHN3YXBwZWQuXG4gIC8vIE5vIGRpcmVjdCBtYXRjaCB3YXMgZm91bmQsIGxlZnQgb3IgcmlnaHQgZWxlbWVudCBtdXN0IGJlIHRoZSBjbG9zZXN0LiBDaGVjayB3aGljaCBvbmUgaGFzIHRoZSBzbWFsbGVzdCBkaWZmLlxuICByZXR1cm4gY3Vlc1tsZWZ0XS5zdGFydFRpbWUgLSB0aW1lIDwgdGltZSAtIGN1ZXNbcmlnaHRdLnN0YXJ0VGltZSA/IGxlZnQgOiByaWdodDtcbn1cbmZ1bmN0aW9uIGdldEN1ZXNJblJhbmdlKGN1ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgY3Vlc0ZvdW5kID0gW107XG4gIGNvbnN0IGZpcnN0Q3VlSW5SYW5nZSA9IGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3Vlcywgc3RhcnQpO1xuICBpZiAoZmlyc3RDdWVJblJhbmdlID4gLTEpIHtcbiAgICBmb3IgKGxldCBpID0gZmlyc3RDdWVJblJhbmdlLCBsZW4gPSBjdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjdWUgPSBjdWVzW2ldO1xuICAgICAgaWYgKGN1ZS5zdGFydFRpbWUgPj0gc3RhcnQgJiYgY3VlLmVuZFRpbWUgPD0gZW5kKSB7XG4gICAgICAgIGN1ZXNGb3VuZC5wdXNoKGN1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGN1ZXNGb3VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1ZXNGb3VuZDtcbn1cblxudmFyIE1ldGFkYXRhU2NoZW1hID0ge1xuICBhdWRpb0lkMzogXCJvcmcuaWQzXCIsXG4gIGRhdGVSYW5nZTogXCJjb20uYXBwbGUucXVpY2t0aW1lLkhMU1wiLFxuICBlbXNnOiBcImh0dHBzOi8vYW9tZWRpYS5vcmcvZW1zZy9JRDNcIlxufTtcblxuY29uc3QgTUlOX0NVRV9EVVJBVElPTiA9IDAuMjU7XG5mdW5jdGlvbiBnZXRDdWVDbGFzcygpIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAvLyBBdHRlbXB0IHRvIHJlY3JlYXRlIFNhZmFyaSBmdW5jdGlvbmFsaXR5IGJ5IGNyZWF0aW5nXG4gIC8vIFdlYktpdERhdGFDdWUgb2JqZWN0cyB3aGVuIGF2YWlsYWJsZSBhbmQgc3RvcmUgdGhlIGRlY29kZWRcbiAgLy8gSUQzIGRhdGEgaW4gdGhlIHZhbHVlIHByb3BlcnR5IG9mIHRoZSBjdWVcbiAgcmV0dXJuIHNlbGYuV2ViS2l0RGF0YUN1ZSB8fCBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcbn1cblxuLy8gVlRUQ3VlIGxhdGVzdCBkcmFmdCBhbGxvd3MgYW4gaW5maW5pdGUgZHVyYXRpb24sIGZhbGxiYWNrXG4vLyB0byBNQVhfVkFMVUUgaWYgbmVjZXNzYXJ5XG5jb25zdCBNQVhfQ1VFX0VORFRJTUUgPSAoKCkgPT4ge1xuICBjb25zdCBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICB0cnkge1xuICAgIG5ldyBDdWUoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgfVxuICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xufSkoKTtcbmZ1bmN0aW9uIGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhkYXRlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMCAtIG9mZnNldDtcbn1cbmZ1bmN0aW9uIGhleFRvQXJyYXlCdWZmZXIoc3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oc3RyLnJlcGxhY2UoL14weC8sICcnKS5yZXBsYWNlKC8oW1xcZGEtZkEtRl17Mn0pID8vZywgJzB4JDEgJykucmVwbGFjZSgvICskLywgJycpLnNwbGl0KCcgJykpLmJ1ZmZlcjtcbn1cbmNsYXNzIElEM1RyYWNrQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gIH1cbiAgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cblxuICAvLyBBZGQgSUQzIG1ldGF0YWRhdGEgdGV4dCB0cmFjay5cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLmlkM1RyYWNrKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gIH1cbiAgY3JlYXRlVHJhY2sobWVkaWEpIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIHJldHVybiB0cmFjaztcbiAgfVxuICBnZXRJRDNUcmFjayh0ZXh0VHJhY2tzKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dFRyYWNrID0gdGV4dFRyYWNrc1tpXTtcbiAgICAgIGlmICh0ZXh0VHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJyAmJiB0ZXh0VHJhY2subGFiZWwgPT09ICdpZDMnKSB7XG4gICAgICAgIC8vIHNlbmQgJ2FkZHRyYWNrJyB3aGVuIHJldXNpbmcgdGhlIHRleHRUcmFjayBmb3IgbWV0YWRhdGEsXG4gICAgICAgIC8vIHNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgY2FwdGlvbnNcbiAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQodGV4dFRyYWNrLCB0aGlzLm1lZGlhKTtcbiAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKCdtZXRhZGF0YScsICdpZDMnKTtcbiAgfVxuICBvbkZyYWdQYXJzaW5nTWV0YWRhdGEoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiB7XG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMsXG4gICAgICAgICAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgJiYgIWVuYWJsZUlEM01ldGFkYXRhQ3Vlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzYW1wbGVzXG4gICAgfSA9IGRhdGE7XG5cbiAgICAvLyBjcmVhdGUgdHJhY2sgZHluYW1pY2FsbHlcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgIH1cbiAgICBjb25zdCBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdHlwZSA9IHNhbXBsZXNbaV0udHlwZTtcbiAgICAgIGlmICh0eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmICFlbmFibGVFbXNnTWV0YWRhdGFDdWVzIHx8ICFlbmFibGVJRDNNZXRhZGF0YUN1ZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmcmFtZXMgPSBnZXRJRDNGcmFtZXMoc2FtcGxlc1tpXS5kYXRhKTtcbiAgICAgIGlmIChmcmFtZXMpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2FtcGxlc1tpXS5wdHM7XG4gICAgICAgIGxldCBlbmRUaW1lID0gc3RhcnRUaW1lICsgc2FtcGxlc1tpXS5kdXJhdGlvbjtcbiAgICAgICAgaWYgKGVuZFRpbWUgPiBNQVhfQ1VFX0VORFRJTUUpIHtcbiAgICAgICAgICBlbmRUaW1lID0gTUFYX0NVRV9FTkRUSU1FO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVEaWZmID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgaWYgKHRpbWVEaWZmIDw9IDApIHtcbiAgICAgICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgTUlOX0NVRV9EVVJBVElPTjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZyYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2pdO1xuICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHB1dCB0aGUgdGltZXN0YW1wIGZyYW1lIGluIHRoZSBUZXh0VHJhY2tcbiAgICAgICAgICBpZiAoIWlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICAgICAgICAvLyBhZGQgYSBib3VuZHMgdG8gYW55IHVuYm91bmRlZCBjdWVzXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlkM0N1ZUVuZHMoc3RhcnRUaW1lLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gICAgICAgICAgICBjdWUudmFsdWUgPSBmcmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgIGN1ZS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWQzVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZUlkM0N1ZUVuZHMoc3RhcnRUaW1lLCB0eXBlKSB7XG4gICAgdmFyIF90aGlzJGlkM1RyYWNrO1xuICAgIGNvbnN0IGN1ZXMgPSAoX3RoaXMkaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaWQzVHJhY2suY3VlcztcbiAgICBpZiAoY3Vlcykge1xuICAgICAgZm9yIChsZXQgaSA9IGN1ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNbaV07XG4gICAgICAgIGlmIChjdWUudHlwZSA9PT0gdHlwZSAmJiBjdWUuc3RhcnRUaW1lIDwgc3RhcnRUaW1lICYmIGN1ZS5lbmRUaW1lID09PSBNQVhfQ1VFX0VORFRJTUUpIHtcbiAgICAgICAgICBjdWUuZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCB7XG4gICAgc3RhcnRPZmZzZXQsXG4gICAgZW5kT2Zmc2V0LFxuICAgIHR5cGVcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMsXG4gICAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3Vlc1xuICAgICAgfVxuICAgIH0gPSBobHM7XG4gICAgaWYgKGlkM1RyYWNrICYmIChlbmFibGVFbXNnTWV0YWRhdGFDdWVzIHx8IGVuYWJsZUlEM01ldGFkYXRhQ3VlcykpIHtcbiAgICAgIGxldCBwcmVkaWNhdGU7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBwcmVkaWNhdGUgPSBjdWUgPT4gY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzICYmIGVuYWJsZUlEM01ldGFkYXRhQ3VlcztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICBwcmVkaWNhdGUgPSBjdWUgPT4gY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGN1ZSA9PiBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMgJiYgZW5hYmxlSUQzTWV0YWRhdGFDdWVzIHx8IGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM7XG4gICAgICB9XG4gICAgICByZW1vdmVDdWVzSW5SYW5nZShpZDNUcmFjaywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgcHJlZGljYXRlKTtcbiAgICB9XG4gIH1cbiAgb25MZXZlbFVwZGF0ZWQoZXZlbnQsIHtcbiAgICBkZXRhaWxzXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMubWVkaWEgfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICF0aGlzLmhscy5jb25maWcuZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCxcbiAgICAgIGlkM1RyYWNrXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZGF0ZVJhbmdlc1xuICAgIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZXMpO1xuICAgIC8vIFJlbW92ZSBjdWVzIGZyb20gdHJhY2sgbm90IGZvdW5kIGluIGRldGFpbHMuZGF0ZVJhbmdlc1xuICAgIGlmIChpZDNUcmFjaykge1xuICAgICAgY29uc3QgaWRzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWQpLmZpbHRlcihpZCA9PiAhaWRzLmluY2x1ZGVzKGlkKSk7XG4gICAgICBmb3IgKGxldCBpID0gaWRzVG9SZW1vdmUubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvbnN0IGlkID0gaWRzVG9SZW1vdmVbaV07XG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0uY3VlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIGlkM1RyYWNrLnJlbW92ZUN1ZShkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdLmN1ZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXhpdCBpZiB0aGUgcGxheWxpc3QgZG9lcyBub3QgaGF2ZSBEYXRlIFJhbmdlcyBvciBkb2VzIG5vdCBoYXZlIFByb2dyYW0gRGF0ZSBUaW1lXG4gICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZGV0YWlscy5mcmFnbWVudHNbZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlkcy5sZW5ndGggPT09IDAgfHwgIWlzRmluaXRlTnVtYmVyKGxhc3RGcmFnbWVudCA9PSBudWxsID8gdm9pZCAwIDogbGFzdEZyYWdtZW50LnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICB9XG4gICAgY29uc3QgZGF0ZVRpbWVPZmZzZXQgPSBsYXN0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lIC8gMTAwMCAtIGxhc3RGcmFnbWVudC5zdGFydDtcbiAgICBjb25zdCBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpZCA9IGlkc1tpXTtcbiAgICAgIGNvbnN0IGRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgY29uc3QgYXBwZW5kZWREYXRlUmFuZ2VDdWVzID0gZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgIGNvbnN0IGN1ZXMgPSAoYXBwZW5kZWREYXRlUmFuZ2VDdWVzID09IG51bGwgPyB2b2lkIDAgOiBhcHBlbmRlZERhdGVSYW5nZUN1ZXMuY3VlcykgfHwge307XG4gICAgICBsZXQgZHVyYXRpb25Lbm93biA9IChhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5kdXJhdGlvbktub3duKSB8fCBmYWxzZTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhkYXRlUmFuZ2Uuc3RhcnREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICBsZXQgZW5kVGltZSA9IE1BWF9DVUVfRU5EVElNRTtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSBkYXRlUmFuZ2UuZW5kRGF0ZTtcbiAgICAgIGlmIChlbmREYXRlKSB7XG4gICAgICAgIGVuZFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoZW5kRGF0ZSwgZGF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0ZVJhbmdlLmVuZE9uTmV4dCAmJiAhZHVyYXRpb25Lbm93bikge1xuICAgICAgICBjb25zdCBuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcyA9IGlkcy5yZWR1Y2UoKGZpbHRlck1hcEFycmF5LCBpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUuY2xhc3MgPT09IGRhdGVSYW5nZS5jbGFzcyAmJiBjYW5kaWRhdGUuaWQgIT09IGlkICYmIGNhbmRpZGF0ZS5zdGFydERhdGUgPiBkYXRlUmFuZ2Uuc3RhcnREYXRlKSB7XG4gICAgICAgICAgICBmaWx0ZXJNYXBBcnJheS5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaWx0ZXJNYXBBcnJheTtcbiAgICAgICAgfSwgW10pLnNvcnQoKGEsIGIpID0+IGEuc3RhcnREYXRlLmdldFRpbWUoKSAtIGIuc3RhcnREYXRlLmdldFRpbWUoKSlbMF07XG4gICAgICAgIGlmIChuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcykge1xuICAgICAgICAgIGVuZFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3Muc3RhcnREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgZHVyYXRpb25Lbm93biA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2UuYXR0cik7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXR0cmlidXRlc1tqXTtcbiAgICAgICAgaWYgKCFpc0RhdGVSYW5nZUN1ZUF0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1ZSA9IGN1ZXNba2V5XTtcbiAgICAgICAgaWYgKGN1ZSkge1xuICAgICAgICAgIGlmIChkdXJhdGlvbktub3duICYmICFhcHBlbmRlZERhdGVSYW5nZUN1ZXMuZHVyYXRpb25Lbm93bikge1xuICAgICAgICAgICAgY3VlLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZGF0YSA9IGRhdGVSYW5nZS5hdHRyW2tleV07XG4gICAgICAgICAgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsICcnKTtcbiAgICAgICAgICBpZiAoaXNTQ1RFMzVBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgICAgZGF0YSA9IGhleFRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ZS52YWx1ZSA9IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIGN1ZS50eXBlID0gTWV0YWRhdGFTY2hlbWEuZGF0ZVJhbmdlO1xuICAgICAgICAgIGN1ZS5pZCA9IGlkO1xuICAgICAgICAgIHRoaXMuaWQzVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgY3Vlc1trZXldID0gY3VlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdID0ge1xuICAgICAgICBjdWVzLFxuICAgICAgICBkYXRlUmFuZ2UsXG4gICAgICAgIGR1cmF0aW9uS25vd25cbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIExhdGVuY3lDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuc3RhbGxDb3VudCA9IDA7XG4gICAgdGhpcy5fbGF0ZW5jeSA9IG51bGw7XG4gICAgdGhpcy50aW1ldXBkYXRlSGFuZGxlciA9ICgpID0+IHRoaXMudGltZXVwZGF0ZSgpO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZ2V0IGxhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhdGVuY3kgfHwgMDtcbiAgfVxuICBnZXQgbWF4TGF0ZW5jeSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBsZXZlbERldGFpbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbiA6IDA7XG4gIH1cbiAgZ2V0IHRhcmdldExhdGVuY3koKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGhvbGRCYWNrLFxuICAgICAgcGFydEhvbGRCYWNrLFxuICAgICAgdGFyZ2V0ZHVyYXRpb25cbiAgICB9ID0gbGV2ZWxEZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxpdmVTeW5jRHVyYXRpb24sXG4gICAgICBsaXZlU3luY0R1cmF0aW9uQ291bnQsXG4gICAgICBsb3dMYXRlbmN5TW9kZVxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCB1c2VyQ29uZmlnID0gdGhpcy5obHMudXNlckNvbmZpZztcbiAgICBsZXQgdGFyZ2V0TGF0ZW5jeSA9IGxvd0xhdGVuY3lNb2RlID8gcGFydEhvbGRCYWNrIHx8IGhvbGRCYWNrIDogaG9sZEJhY2s7XG4gICAgaWYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB0YXJnZXRMYXRlbmN5ID09PSAwKSB7XG4gICAgICB0YXJnZXRMYXRlbmN5ID0gbGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gbGl2ZVN5bmNEdXJhdGlvbiA6IGxpdmVTeW5jRHVyYXRpb25Db3VudCAqIHRhcmdldGR1cmF0aW9uO1xuICAgIH1cbiAgICBjb25zdCBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSA9IHRhcmdldGR1cmF0aW9uO1xuICAgIGNvbnN0IGxpdmVTeW5jT25TdGFsbEluY3JlYXNlID0gMS4wO1xuICAgIHJldHVybiB0YXJnZXRMYXRlbmN5ICsgTWF0aC5taW4odGhpcy5zdGFsbENvdW50ICogbGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UsIG1heExpdmVTeW5jT25TdGFsbEluY3JlYXNlKTtcbiAgfVxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICBjb25zdCBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgIGNvbnN0IHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgaWYgKGxpdmVFZGdlID09PSBudWxsIHx8IHRhcmdldExhdGVuY3kgPT09IG51bGwgfHwgbGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWRnZSA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGNvbnN0IHN5bmNQb3NpdGlvbiA9IGxpdmVFZGdlIC0gdGFyZ2V0TGF0ZW5jeSAtIHRoaXMuZWRnZVN0YWxsZWQ7XG4gICAgY29uc3QgbWluID0gZWRnZSAtIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGNvbnN0IG1heCA9IGVkZ2UgLSAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgfHwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBzeW5jUG9zaXRpb24pLCBtYXgpO1xuICB9XG4gIGdldCBkcmlmdCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbERldGFpbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsRGV0YWlscy5kcmlmdDtcbiAgfVxuICBnZXQgZWRnZVN0YWxsZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IG1heExldmVsVXBkYXRlQWdlID0gKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0IHx8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikgKiAzO1xuICAgIHJldHVybiBNYXRoLm1heChsZXZlbERldGFpbHMuYWdlIC0gbWF4TGV2ZWxVcGRhdGVBZ2UsIDApO1xuICB9XG4gIGdldCBmb3J3YXJkQnVmZmVyTGVuZ3RoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCAhbGV2ZWxEZXRhaWxzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyZWRSYW5nZXMgPSBtZWRpYS5idWZmZXJlZC5sZW5ndGg7XG4gICAgcmV0dXJuIChidWZmZXJlZFJhbmdlcyA/IG1lZGlhLmJ1ZmZlcmVkLmVuZChidWZmZXJlZFJhbmdlcyAtIDEpIDogbGV2ZWxEZXRhaWxzLmVkZ2UpIC0gdGhpcy5jdXJyZW50VGltZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGluZygpO1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCB7XG4gICAgZGV0YWlsc1xuICB9KSB7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBkZXRhaWxzO1xuICAgIGlmIChkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICB0aGlzLnRpbWV1cGRhdGUoKTtcbiAgICB9XG4gICAgaWYgKCFkZXRhaWxzLmxpdmUgJiYgdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMkbGV2ZWxEZXRhaWxzO1xuICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YWxsQ291bnQrKztcbiAgICBpZiAoKF90aGlzJGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzKSAhPSBudWxsICYmIF90aGlzJGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBsb2dnZXIud2FybignW3BsYXliYWNrLXJhdGUtY29udHJvbGxlcl06IFN0YWxsIGRldGVjdGVkLCBhZGp1c3RpbmcgdGFyZ2V0IGxhdGVuY3knKTtcbiAgICB9XG4gIH1cbiAgdGltZXVwZGF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIGxldmVsRGV0YWlsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgbGF0ZW5jeSA9IHRoaXMuY29tcHV0ZUxhdGVuY3koKTtcbiAgICBpZiAobGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sYXRlbmN5ID0gbGF0ZW5jeTtcblxuICAgIC8vIEFkYXB0IHBsYXliYWNrUmF0ZSB0byBtZWV0IHRhcmdldCBsYXRlbmN5IGluIGxvdy1sYXRlbmN5IG1vZGVcbiAgICBjb25zdCB7XG4gICAgICBsb3dMYXRlbmN5TW9kZSxcbiAgICAgIG1heExpdmVTeW5jUGxheWJhY2tSYXRlXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghbG93TGF0ZW5jeU1vZGUgfHwgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMudGFyZ2V0TGF0ZW5jeTtcbiAgICBpZiAodGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXN0YW5jZUZyb21UYXJnZXQgPSBsYXRlbmN5IC0gdGFyZ2V0TGF0ZW5jeTtcbiAgICAvLyBPbmx5IGFkanVzdCBwbGF5YmFja1JhdGUgd2hlbiB3aXRoaW4gb25lIHRhcmdldCBkdXJhdGlvbiBvZiB0YXJnZXRMYXRlbmN5XG4gICAgLy8gYW5kIG1vcmUgdGhhbiBvbmUgc2Vjb25kIGZyb20gdW5kZXItYnVmZmVyaW5nLlxuICAgIC8vIFBsYXliYWNrIGZ1cnRoZXIgdGhhbiBvbmUgdGFyZ2V0IGR1cmF0aW9uIGZyb20gdGFyZ2V0IGNhbiBiZSBjb25zaWRlcmVkIERWUiBwbGF5YmFjay5cbiAgICBjb25zdCBsaXZlTWluTGF0ZW5jeUR1cmF0aW9uID0gTWF0aC5taW4odGhpcy5tYXhMYXRlbmN5LCB0YXJnZXRMYXRlbmN5ICsgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICBjb25zdCBpbkxpdmVSYW5nZSA9IGRpc3RhbmNlRnJvbVRhcmdldCA8IGxpdmVNaW5MYXRlbmN5RHVyYXRpb247XG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlICYmIGluTGl2ZVJhbmdlICYmIGRpc3RhbmNlRnJvbVRhcmdldCA+IDAuMDUgJiYgdGhpcy5mb3J3YXJkQnVmZmVyTGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4oMiwgTWF0aC5tYXgoMS4wLCBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSkpO1xuICAgICAgY29uc3QgcmF0ZSA9IE1hdGgucm91bmQoMiAvICgxICsgTWF0aC5leHAoLTAuNzUgKiBkaXN0YW5jZUZyb21UYXJnZXQgLSB0aGlzLmVkZ2VTdGFsbGVkKSkgKiAyMCkgLyAyMDtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMSwgcmF0ZSkpO1xuICAgIH0gZWxzZSBpZiAobWVkaWEucGxheWJhY2tSYXRlICE9PSAxICYmIG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMCkge1xuICAgICAgbWVkaWEucGxheWJhY2tSYXRlID0gMTtcbiAgICB9XG4gIH1cbiAgZXN0aW1hdGVMaXZlRWRnZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbERldGFpbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsRGV0YWlscy5lZGdlICsgbGV2ZWxEZXRhaWxzLmFnZTtcbiAgfVxuICBjb21wdXRlTGF0ZW5jeSgpIHtcbiAgICBjb25zdCBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgIGlmIChsaXZlRWRnZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsaXZlRWRnZSAtIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cbn1cblxuY29uc3QgSGRjcExldmVscyA9IFsnTk9ORScsICdUWVBFLTAnLCAnVFlQRS0xJywgbnVsbF07XG52YXIgSGxzU2tpcCA9IHtcbiAgTm86IFwiXCIsXG4gIFllczogXCJZRVNcIixcbiAgdjI6IFwidjJcIlxufTtcbmZ1bmN0aW9uIGdldFNraXBWYWx1ZShkZXRhaWxzLCBtc24pIHtcbiAgY29uc3Qge1xuICAgIGNhblNraXBVbnRpbCxcbiAgICBjYW5Ta2lwRGF0ZVJhbmdlcyxcbiAgICBlbmRTTlxuICB9ID0gZGV0YWlscztcbiAgY29uc3Qgc25DaGFuZ2VHb2FsID0gbXNuICE9PSB1bmRlZmluZWQgPyBtc24gLSBlbmRTTiA6IDA7XG4gIGlmIChjYW5Ta2lwVW50aWwgJiYgc25DaGFuZ2VHb2FsIDwgY2FuU2tpcFVudGlsKSB7XG4gICAgaWYgKGNhblNraXBEYXRlUmFuZ2VzKSB7XG4gICAgICByZXR1cm4gSGxzU2tpcC52MjtcbiAgICB9XG4gICAgcmV0dXJuIEhsc1NraXAuWWVzO1xuICB9XG4gIHJldHVybiBIbHNTa2lwLk5vO1xufVxuY2xhc3MgSGxzVXJsUGFyYW1ldGVycyB7XG4gIGNvbnN0cnVjdG9yKG1zbiwgcGFydCwgc2tpcCkge1xuICAgIHRoaXMubXNuID0gdm9pZCAwO1xuICAgIHRoaXMucGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLnNraXAgPSB2b2lkIDA7XG4gICAgdGhpcy5tc24gPSBtc247XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnNraXAgPSBza2lwO1xuICB9XG4gIGFkZERpcmVjdGl2ZXModXJpKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gICAgaWYgKHRoaXMubXNuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX21zbicsIHRoaXMubXNuLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3BhcnQnLCB0aGlzLnBhcnQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3NraXAnLCB0aGlzLnNraXApO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH1cbn1cbmNsYXNzIExldmVsIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuX2F0dHJzID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmJpdHJhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2RlY1NldCA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLnVua25vd25Db2RlY3MgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb0dyb3VwSWRzID0gdm9pZCAwO1xuICAgIHRoaXMuZGV0YWlscyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgIHRoaXMubG9hZEVycm9yID0gMDtcbiAgICB0aGlzLmxvYWRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlYWxCaXRyYXRlID0gMDtcbiAgICB0aGlzLnRleHRHcm91cElkcyA9IHZvaWQgMDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLl91cmxJZCA9IDA7XG4gICAgdGhpcy51cmwgPSBbZGF0YS51cmxdO1xuICAgIHRoaXMuX2F0dHJzID0gW2RhdGEuYXR0cnNdO1xuICAgIHRoaXMuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZTtcbiAgICBpZiAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICB0aGlzLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgfVxuICAgIHRoaXMuaWQgPSBkYXRhLmlkIHx8IDA7XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoIHx8IDA7XG4gICAgdGhpcy5oZWlnaHQgPSBkYXRhLmhlaWdodCB8fCAwO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGRhdGEuYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSBkYXRhLnZpZGVvQ29kZWM7XG4gICAgdGhpcy51bmtub3duQ29kZWNzID0gZGF0YS51bmtub3duQ29kZWNzO1xuICAgIHRoaXMuY29kZWNTZXQgPSBbZGF0YS52aWRlb0NvZGVjLCBkYXRhLmF1ZGlvQ29kZWNdLmZpbHRlcihjID0+IGMpLmpvaW4oJywnKS5yZXBsYWNlKC9cXC5bXi4sXSsvZywgJycpO1xuICB9XG4gIGdldCBtYXhCaXRyYXRlKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnJlYWxCaXRyYXRlLCB0aGlzLmJpdHJhdGUpO1xuICB9XG4gIGdldCBhdHRycygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cnNbdGhpcy5fdXJsSWRdO1xuICB9XG4gIGdldCBwYXRod2F5SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cnNbJ1BBVEhXQVktSUQnXSB8fCAnLic7XG4gIH1cbiAgZ2V0IHVyaSgpIHtcbiAgICByZXR1cm4gdGhpcy51cmxbdGhpcy5fdXJsSWRdIHx8ICcnO1xuICB9XG4gIGdldCB1cmxJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsSWQ7XG4gIH1cbiAgc2V0IHVybElkKHZhbHVlKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSAlIHRoaXMudXJsLmxlbmd0aDtcbiAgICBpZiAodGhpcy5fdXJsSWQgIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgICAgdGhpcy5sb2FkRXJyb3IgPSAwO1xuICAgICAgdGhpcy5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fdXJsSWQgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGF1ZGlvR3JvdXBJZCgpIHtcbiAgICB2YXIgX3RoaXMkYXVkaW9Hcm91cElkcztcbiAgICByZXR1cm4gKF90aGlzJGF1ZGlvR3JvdXBJZHMgPSB0aGlzLmF1ZGlvR3JvdXBJZHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhdWRpb0dyb3VwSWRzW3RoaXMudXJsSWRdO1xuICB9XG4gIGdldCB0ZXh0R3JvdXBJZCgpIHtcbiAgICB2YXIgX3RoaXMkdGV4dEdyb3VwSWRzO1xuICAgIHJldHVybiAoX3RoaXMkdGV4dEdyb3VwSWRzID0gdGhpcy50ZXh0R3JvdXBJZHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0ZXh0R3JvdXBJZHNbdGhpcy51cmxJZF07XG4gIH1cbiAgYWRkRmFsbGJhY2soZGF0YSkge1xuICAgIHRoaXMudXJsLnB1c2goZGF0YS51cmwpO1xuICAgIHRoaXMuX2F0dHJzLnB1c2goZGF0YS5hdHRycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnJvbVRvUFRTKGZyYWdGcm9tLCBmcmFnVG8pIHtcbiAgY29uc3QgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTO1xuICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZ1RvUFRTKSkge1xuICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICBsZXQgZHVyYXRpb24gPSAwO1xuICAgIGxldCBmcmFnO1xuICAgIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgICAgZHVyYXRpb24gPSBmcmFnVG9QVFMgLSBmcmFnRnJvbS5zdGFydDtcbiAgICAgIGZyYWcgPSBmcmFnRnJvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgIGZyYWcgPSBmcmFnVG87XG4gICAgfVxuICAgIGlmIChmcmFnLmR1cmF0aW9uICE9PSBkdXJhdGlvbikge1xuICAgICAgZnJhZy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIH1cbiAgICAvLyB3ZSBkb250IGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gIH0gZWxzZSBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICBjb25zdCBjb250aWd1b3VzID0gZnJhZ0Zyb20uY2MgPT09IGZyYWdUby5jYztcbiAgICAvLyBUT0RPOiBXaXRoIHBhcnQtbG9hZGluZyBlbmQvZHVyYXRpb25zIHdlIG5lZWQgdG8gY29uZmlybSB0aGUgd2hvbGUgZnJhZ21lbnQgaXMgbG9hZGVkIGJlZm9yZSB1c2luZyAob3Igc2V0dGluZykgbWluRW5kUFRTXG4gICAgaWYgKGNvbnRpZ3VvdXMgJiYgZnJhZ0Zyb20ubWluRW5kUFRTKSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIChmcmFnRnJvbS5taW5FbmRQVFMgLSBmcmFnRnJvbS5zdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZyYWdUby5zdGFydCA9IE1hdGgubWF4KGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uLCAwKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRnJhZ1BUU0RUUyhkZXRhaWxzLCBmcmFnLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKSB7XG4gIGNvbnN0IHBhcnNlZE1lZGlhRHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgaWYgKHBhcnNlZE1lZGlhRHVyYXRpb24gPD0gMCkge1xuICAgIGxvZ2dlci53YXJuKCdGcmFnbWVudCBzaG91bGQgaGF2ZSBhIHBvc2l0aXZlIGR1cmF0aW9uJywgZnJhZyk7XG4gICAgZW5kUFRTID0gc3RhcnRQVFMgKyBmcmFnLmR1cmF0aW9uO1xuICAgIGVuZERUUyA9IHN0YXJ0RFRTICsgZnJhZy5kdXJhdGlvbjtcbiAgfVxuICBsZXQgbWF4U3RhcnRQVFMgPSBzdGFydFBUUztcbiAgbGV0IG1pbkVuZFBUUyA9IGVuZFBUUztcbiAgY29uc3QgZnJhZ1N0YXJ0UHRzID0gZnJhZy5zdGFydFBUUztcbiAgY29uc3QgZnJhZ0VuZFB0cyA9IGZyYWcuZW5kUFRTO1xuICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZ1N0YXJ0UHRzKSkge1xuICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgIGNvbnN0IGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZ1N0YXJ0UHRzIC0gc3RhcnRQVFMpO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIoZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBkZWx0YVBUUztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IE1hdGgubWF4KGRlbHRhUFRTLCBmcmFnLmRlbHRhUFRTKTtcbiAgICB9XG4gICAgbWF4U3RhcnRQVFMgPSBNYXRoLm1heChzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLCBmcmFnU3RhcnRQdHMpO1xuICAgIHN0YXJ0RFRTID0gTWF0aC5taW4oc3RhcnREVFMsIGZyYWcuc3RhcnREVFMpO1xuICAgIG1pbkVuZFBUUyA9IE1hdGgubWluKGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICBlbmREVFMgPSBNYXRoLm1heChlbmREVFMsIGZyYWcuZW5kRFRTKTtcbiAgfVxuICBjb25zdCBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcbiAgaWYgKGZyYWcuc3RhcnQgIT09IDApIHtcbiAgICBmcmFnLnN0YXJ0ID0gc3RhcnRQVFM7XG4gIH1cbiAgZnJhZy5kdXJhdGlvbiA9IGVuZFBUUyAtIGZyYWcuc3RhcnQ7XG4gIGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgZnJhZy5tYXhTdGFydFBUUyA9IG1heFN0YXJ0UFRTO1xuICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gIGZyYWcuZW5kUFRTID0gZW5kUFRTO1xuICBmcmFnLm1pbkVuZFBUUyA9IG1pbkVuZFBUUztcbiAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gIGNvbnN0IHNuID0gZnJhZy5zbjsgLy8gJ2luaXRTZWdtZW50J1xuICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxuICBpZiAoIWRldGFpbHMgfHwgc24gPCBkZXRhaWxzLnN0YXJ0U04gfHwgc24gPiBkZXRhaWxzLmVuZFNOKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IGk7XG4gIGNvbnN0IGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIC8vIHVwZGF0ZSBmcmFnIHJlZmVyZW5jZSBpbiBmcmFnbWVudHMgYXJyYXlcbiAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgZnJhZ21lbnRzIGFycmF5IG1pZ2h0IG5vdCBjb250YWluIHRoaXMgZnJhZyBvYmplY3QuXG4gIC8vIHRoaXMgd2lsbCBoYXBwZW4gaWYgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIGJldHdlZW4gZnJhZyBsb2FkaW5nIGFuZCBjYWxsIHRvIHVwZGF0ZUZyYWdQVFNEVFMoKVxuICAvLyBpZiB3ZSBkb24ndCB1cGRhdGUgZnJhZywgd2Ugd29uJ3QgYmUgYWJsZSB0byBwcm9wYWdhdGUgUFRTIGluZm8gb24gdGhlIHBsYXlsaXN0XG4gIC8vIHJlc3VsdGluZyBpbiBpbnZhbGlkIHNsaWRpbmcgY29tcHV0YXRpb25cbiAgZnJhZ21lbnRzW2ZyYWdJZHhdID0gZnJhZztcbiAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bS0xIHRvIGZyYWcgMFxuICBmb3IgKGkgPSBmcmFnSWR4OyBpID4gMDsgaS0tKSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgLSAxXSk7XG4gIH1cblxuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtIHRvIGxhc3QgZnJhZ1xuICBmb3IgKGkgPSBmcmFnSWR4OyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbaV0sIGZyYWdtZW50c1tpICsgMV0pO1xuICB9XG4gIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLCBkZXRhaWxzLmZyYWdtZW50SGludCk7XG4gIH1cbiAgZGV0YWlscy5QVFNLbm93biA9IGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICByZXR1cm4gZHJpZnQ7XG59XG5mdW5jdGlvbiBtZXJnZURldGFpbHMob2xkRGV0YWlscywgbmV3RGV0YWlscykge1xuICAvLyBUcmFjayB0aGUgbGFzdCBpbml0U2VnbWVudCBwcm9jZXNzZWQuIEluaXRpYWxpemUgaXQgdG8gdGhlIGxhc3Qgb25lIG9uIHRoZSB0aW1lbGluZS5cbiAgbGV0IGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gIGNvbnN0IG9sZEZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuICBmb3IgKGxldCBpID0gb2xkRnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgb2xkSW5pdCA9IG9sZEZyYWdtZW50c1tpXS5pbml0U2VnbWVudDtcbiAgICBpZiAob2xkSW5pdCkge1xuICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gb2xkSW5pdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAob2xkRGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAvLyBwcmV2ZW50IFBUUyBhbmQgZHVyYXRpb24gZnJvbSBiZWluZyBhZGp1c3RlZCBvbiB0aGUgbmV4dCBoaW50XG4gICAgZGVsZXRlIG9sZERldGFpbHMuZnJhZ21lbnRIaW50LmVuZFBUUztcbiAgfVxuICAvLyBjaGVjayBpZiBvbGQvbmV3IHBsYXlsaXN0cyBoYXZlIGZyYWdtZW50cyBpbiBjb21tb25cbiAgLy8gbG9vcCB0aHJvdWdoIG92ZXJsYXBwaW5nIFNOIGFuZCB1cGRhdGUgc3RhcnRQVFMgLCBjYywgYW5kIGR1cmF0aW9uIGlmIGFueSBmb3VuZFxuICBsZXQgY2NPZmZzZXQgPSAwO1xuICBsZXQgUFRTRnJhZztcbiAgbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscywgbmV3RGV0YWlscywgKG9sZEZyYWcsIG5ld0ZyYWcpID0+IHtcbiAgICBpZiAob2xkRnJhZy5yZWx1cmwpIHtcbiAgICAgIC8vIERvIG5vdCBjb21wYXJlIENDIGlmIHRoZSBvbGQgZnJhZ21lbnQgaGFzIG5vIHVybC4gVGhpcyBpcyBhIGxldmVsLmZyYWdtZW50SGludCB1c2VkIGJ5IExMLUhMUyBwYXJ0cy5cbiAgICAgIC8vIEl0IG1heWJlIGJlIG9mZiBieSAxIGlmIGl0IHdhcyBjcmVhdGVkIGJlZm9yZSBhbnkgcGFydHMgb3IgZGlzY29udGludWl0eSB0YWdzIHdlcmUgYXBwZW5kZWQgdG8gdGhlIGVuZFxuICAgICAgLy8gb2YgdGhlIHBsYXlsaXN0LlxuICAgICAgY2NPZmZzZXQgPSBvbGRGcmFnLmNjIC0gbmV3RnJhZy5jYztcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKG9sZEZyYWcuc3RhcnRQVFMpICYmIGlzRmluaXRlTnVtYmVyKG9sZEZyYWcuZW5kUFRTKSkge1xuICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgbmV3RnJhZy5zdGFydERUUyA9IG9sZEZyYWcuc3RhcnREVFM7XG4gICAgICBuZXdGcmFnLm1heFN0YXJ0UFRTID0gb2xkRnJhZy5tYXhTdGFydFBUUztcbiAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICBuZXdGcmFnLmVuZERUUyA9IG9sZEZyYWcuZW5kRFRTO1xuICAgICAgbmV3RnJhZy5taW5FbmRQVFMgPSBvbGRGcmFnLm1pbkVuZFBUUztcbiAgICAgIG5ld0ZyYWcuZHVyYXRpb24gPSBvbGRGcmFnLmVuZFBUUyAtIG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICBpZiAobmV3RnJhZy5kdXJhdGlvbikge1xuICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgIH1cblxuICAgICAgLy8gUFRTIGlzIGtub3duIHdoZW4gYW55IHNlZ21lbnQgaGFzIHN0YXJ0UFRTIGFuZCBlbmRQVFNcbiAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBuZXdEZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgbmV3RnJhZy5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZEZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgbmV3RnJhZy5sb2FkZXIgPSBvbGRGcmFnLmxvYWRlcjtcbiAgICBuZXdGcmFnLnN0YXRzID0gb2xkRnJhZy5zdGF0cztcbiAgICBuZXdGcmFnLnVybElkID0gb2xkRnJhZy51cmxJZDtcbiAgICBpZiAob2xkRnJhZy5pbml0U2VnbWVudCkge1xuICAgICAgbmV3RnJhZy5pbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRGcmFnLmluaXRTZWdtZW50O1xuICAgIH1cbiAgfSk7XG4gIGlmIChjdXJyZW50SW5pdFNlZ21lbnQpIHtcbiAgICBjb25zdCBmcmFnbWVudHNUb0NoZWNrID0gbmV3RGV0YWlscy5mcmFnbWVudEhpbnQgPyBuZXdEZXRhaWxzLmZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpIDogbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgZnJhZ21lbnRzVG9DaGVjay5mb3JFYWNoKGZyYWcgPT4ge1xuICAgICAgdmFyIF9jdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICBpZiAoIWZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZy5pbml0U2VnbWVudC5yZWx1cmwgPT09ICgoX2N1cnJlbnRJbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jdXJyZW50SW5pdFNlZ21lbnQucmVsdXJsKSkge1xuICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSBuZXdEZXRhaWxzLmZyYWdtZW50cy5zb21lKGZyYWcgPT4gIWZyYWcpO1xuICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBsb2dnZXIud2FybignW2xldmVsLWhlbHBlcl0gUHJldmlvdXMgcGxheWxpc3QgbWlzc2luZyBzZWdtZW50cyBza2lwcGVkIGluIGRlbHRhIHBsYXlsaXN0Jyk7XG4gICAgICBmb3IgKGxldCBpID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7IGktLTspIHtcbiAgICAgICAgbmV3RGV0YWlscy5mcmFnbWVudHMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIG5ld0RldGFpbHMuc3RhcnRTTiA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnNuO1xuICAgICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gICAgfSBlbHNlIGlmIChuZXdEZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzKSB7XG4gICAgICBuZXdEZXRhaWxzLmRhdGVSYW5nZXMgPSBtZXJnZURhdGVSYW5nZXMob2xkRGV0YWlscy5kYXRlUmFuZ2VzLCBuZXdEZXRhaWxzLmRhdGVSYW5nZXMsIG5ld0RldGFpbHMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld0ZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoY2NPZmZzZXQpIHtcbiAgICBsb2dnZXIud2FybignZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50Jyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcbiAgICB9XG4gIH1cbiAgaWYgKG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gIH1cblxuICAvLyBNZXJnZSBwYXJ0c1xuICBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZERldGFpbHMucGFydExpc3QsIG5ld0RldGFpbHMucGFydExpc3QsIChvbGRQYXJ0LCBuZXdQYXJ0KSA9PiB7XG4gICAgbmV3UGFydC5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZFBhcnQuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgbmV3UGFydC5zdGF0cyA9IG9sZFBhcnQuc3RhdHM7XG4gIH0pO1xuXG4gIC8vIGlmIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBjb250YWlucyBQVFMgaW5mbywgcmVjb21wdXRlIFBUUyBpbmZvcm1hdGlvbiBmb3IgYWxsIGZyYWdtZW50c1xuICBpZiAoUFRTRnJhZykge1xuICAgIHVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscywgUFRTRnJhZywgUFRTRnJhZy5zdGFydFBUUywgUFRTRnJhZy5lbmRQVFMsIFBUU0ZyYWcuc3RhcnREVFMsIFBUU0ZyYWcuZW5kRFRTKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkRnJhZ21lbnRzIHJhbmdlXG4gICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgYWxzbyBuZWVkIHRvIGFkanVzdCBzdGFydCBvZmZzZXQgb2YgYWxsIGZyYWdtZW50c1xuICAgIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscyk7XG4gIH1cbiAgaWYgKG5ld0ZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24gPSBuZXdEZXRhaWxzLmVkZ2UgLSBuZXdGcmFnbWVudHNbMF0uc3RhcnQ7XG4gIH1cbiAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0VGltZSA9IG9sZERldGFpbHMuZHJpZnRTdGFydFRpbWU7XG4gIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IG9sZERldGFpbHMuZHJpZnRTdGFydDtcbiAgY29uc3QgYWR2YW5jZWREYXRlVGltZSA9IG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgaWYgKG5ld0RldGFpbHMuYWR2YW5jZWQgJiYgYWR2YW5jZWREYXRlVGltZSkge1xuICAgIGNvbnN0IGVkZ2UgPSBuZXdEZXRhaWxzLmVkZ2U7XG4gICAgaWYgKCFuZXdEZXRhaWxzLmRyaWZ0U3RhcnQpIHtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0ID0gZWRnZTtcbiAgICB9XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBlZGdlO1xuICB9IGVsc2Uge1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gb2xkRGV0YWlscy5kcmlmdEVuZFRpbWU7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IG9sZERldGFpbHMuZHJpZnRFbmQ7XG4gICAgbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gb2xkRGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZURhdGVSYW5nZXMob2xkRGF0ZVJhbmdlcywgZGVsdGFEYXRlUmFuZ2VzLCByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gIGNvbnN0IGRhdGVSYW5nZXMgPSBfZXh0ZW5kcyh7fSwgb2xkRGF0ZVJhbmdlcyk7XG4gIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VzW2lkXTtcbiAgICB9KTtcbiAgfVxuICBPYmplY3Qua2V5cyhkZWx0YURhdGVSYW5nZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IGRhdGVSYW5nZSA9IG5ldyBEYXRlUmFuZ2UoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyLCBkYXRlUmFuZ2VzW2lkXSk7XG4gICAgaWYgKGRhdGVSYW5nZS5pc1ZhbGlkKSB7XG4gICAgICBkYXRlUmFuZ2VzW2lkXSA9IGRhdGVSYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oYElnbm9yaW5nIGludmFsaWQgUGxheWxpc3QgRGVsdGEgVXBkYXRlIERBVEVSQU5HRSB0YWc6IFwiJHtKU09OLnN0cmluZ2lmeShkZWx0YURhdGVSYW5nZXNbaWRdLmF0dHIpfVwiYCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGVSYW5nZXM7XG59XG5mdW5jdGlvbiBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZFBhcnRzLCBuZXdQYXJ0cywgaW50ZXJzZWN0aW9uRm4pIHtcbiAgaWYgKG9sZFBhcnRzICYmIG5ld1BhcnRzKSB7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb2xkUGFydHMubGVuZ3RoOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBvbGRQYXJ0ID0gb2xkUGFydHNbaV07XG4gICAgICBjb25zdCBuZXdQYXJ0ID0gbmV3UGFydHNbaSArIGRlbHRhXTtcbiAgICAgIGlmIChvbGRQYXJ0ICYmIG5ld1BhcnQgJiYgb2xkUGFydC5pbmRleCA9PT0gbmV3UGFydC5pbmRleCAmJiBvbGRQYXJ0LmZyYWdtZW50LnNuID09PSBuZXdQYXJ0LmZyYWdtZW50LnNuKSB7XG4gICAgICAgIGludGVyc2VjdGlvbkZuKG9sZFBhcnQsIG5ld1BhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGEtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIGludGVyc2VjdGlvbkZuKSB7XG4gIGNvbnN0IHNraXBwZWRTZWdtZW50cyA9IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzO1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KG9sZERldGFpbHMuc3RhcnRTTiwgbmV3RGV0YWlscy5zdGFydFNOKSAtIG5ld0RldGFpbHMuc3RhcnRTTjtcbiAgY29uc3QgZW5kID0gKG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gMSA6IDApICsgKHNraXBwZWRTZWdtZW50cyA/IG5ld0RldGFpbHMuZW5kU04gOiBNYXRoLm1pbihvbGREZXRhaWxzLmVuZFNOLCBuZXdEZXRhaWxzLmVuZFNOKSkgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGRlbHRhID0gbmV3RGV0YWlscy5zdGFydFNOIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBuZXdGcmFncyA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50ID8gbmV3RGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG5ld0RldGFpbHMuZnJhZ21lbnRIaW50KSA6IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCBvbGRGcmFncyA9IG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gb2xkRGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSA6IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBjb25zdCBvbGRGcmFnID0gb2xkRnJhZ3NbZGVsdGEgKyBpXTtcbiAgICBsZXQgbmV3RnJhZyA9IG5ld0ZyYWdzW2ldO1xuICAgIGlmIChza2lwcGVkU2VnbWVudHMgJiYgIW5ld0ZyYWcgJiYgaSA8IHNraXBwZWRTZWdtZW50cykge1xuICAgICAgLy8gRmlsbCBpbiBza2lwcGVkIHNlZ21lbnRzIGluIGRlbHRhIHBsYXlsaXN0XG4gICAgICBuZXdGcmFnID0gbmV3RGV0YWlscy5mcmFnbWVudHNbaV0gPSBvbGRGcmFnO1xuICAgIH1cbiAgICBpZiAob2xkRnJhZyAmJiBuZXdGcmFnKSB7XG4gICAgICBpbnRlcnNlY3Rpb25GbihvbGRGcmFnLCBuZXdGcmFnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscykge1xuICBjb25zdCBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiArIG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKGRlbHRhIDwgMCB8fCBkZWx0YSA+PSBvbGRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkZFNsaWRpbmcobmV3RGV0YWlscywgb2xkRnJhZ21lbnRzW2RlbHRhXS5zdGFydCk7XG59XG5mdW5jdGlvbiBhZGRTbGlkaW5nKGRldGFpbHMsIHN0YXJ0KSB7XG4gIGlmIChzdGFydCkge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZvciAobGV0IGkgPSBkZXRhaWxzLnNraXBwZWRTZWdtZW50czsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhZ21lbnRzW2ldLnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRIaW50LnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsKG5ld0RldGFpbHMsIGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gSW5maW5pdHkpIHtcbiAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCAqIG5ld0RldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gIGlmIChuZXdEZXRhaWxzLnVwZGF0ZWQpIHtcbiAgICAvLyBVc2UgbGFzdCBzZWdtZW50IGR1cmF0aW9uIHdoZW4gc2hvcnRlciB0aGFuIHRhcmdldCBkdXJhdGlvbiBhbmQgbmVhciBsaXZlIGVkZ2VcbiAgICBjb25zdCBmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyA9IDQ7XG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggJiYgcmVsb2FkSW50ZXJ2YWwgKiBsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyA+IGRpc3RhbmNlVG9MaXZlRWRnZU1zKSB7XG4gICAgICBjb25zdCBsYXN0U2VnbWVudER1cmF0aW9uID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5kdXJhdGlvbiAqIDEwMDA7XG4gICAgICBpZiAobGFzdFNlZ21lbnREdXJhdGlvbiA8IHJlbG9hZEludGVydmFsKSB7XG4gICAgICAgIHJlbG9hZEludGVydmFsID0gbGFzdFNlZ21lbnREdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZXN0aW1hdGUgPSAnbWlzcyBoYWxmIGF2ZXJhZ2UnO1xuICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgLy8gY2hhbmdlZCB0aGVuIGl0IE1VU1Qgd2FpdCBmb3IgYSBwZXJpb2Qgb2Ygb25lLWhhbGYgdGhlIHRhcmdldFxuICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICByZWxvYWRJbnRlcnZhbCAvPSAyO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKTtcbn1cbmZ1bmN0aW9uIGdldEZyYWdtZW50V2l0aFNOKGxldmVsLCBzbiwgZnJhZ0N1cnJlbnQpIHtcbiAgaWYgKCEobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5kZXRhaWxzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gIGxldCBmcmFnbWVudCA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gIGlmIChmcmFnbWVudCkge1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBmcmFnbWVudCA9IGxldmVsRGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgaWYgKHNuIDwgbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQuc24gPT09IHNuKSB7XG4gICAgcmV0dXJuIGZyYWdDdXJyZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UGFydFdpdGgobGV2ZWwsIHNuLCBwYXJ0SW5kZXgpIHtcbiAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICBpZiAoIShsZXZlbCAhPSBudWxsICYmIGxldmVsLmRldGFpbHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGZpbmRQYXJ0KChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5wYXJ0TGlzdCwgc24sIHBhcnRJbmRleCk7XG59XG5mdW5jdGlvbiBmaW5kUGFydChwYXJ0TGlzdCwgc24sIHBhcnRJbmRleCkge1xuICBpZiAocGFydExpc3QpIHtcbiAgICBmb3IgKGxldCBpID0gcGFydExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpZiAocGFydC5pbmRleCA9PT0gcGFydEluZGV4ICYmIHBhcnQuZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNUaW1lb3V0RXJyb3IoZXJyb3IpIHtcbiAgc3dpdGNoIChlcnJvci5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UmV0cnlDb25maWcobG9hZFBvbGljeSwgZXJyb3IpIHtcbiAgY29uc3QgaXNUaW1lb3V0ID0gaXNUaW1lb3V0RXJyb3IoZXJyb3IpO1xuICByZXR1cm4gbG9hZFBvbGljeS5kZWZhdWx0W2Ake2lzVGltZW91dCA/ICd0aW1lb3V0JyA6ICdlcnJvcid9UmV0cnlgXTtcbn1cbmZ1bmN0aW9uIGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHJldHJ5Q291bnQpIHtcbiAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IGRlbGF5XG4gIGNvbnN0IGJhY2tvZmZGYWN0b3IgPSByZXRyeUNvbmZpZy5iYWNrb2ZmID09PSAnbGluZWFyJyA/IDEgOiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAgcmV0dXJuIE1hdGgubWluKGJhY2tvZmZGYWN0b3IgKiByZXRyeUNvbmZpZy5yZXRyeURlbGF5TXMsIHJldHJ5Q29uZmlnLm1heFJldHJ5RGVsYXlNcyk7XG59XG5mdW5jdGlvbiBnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzKGxvZGVyQ29uZmlnKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbG9kZXJDb25maWcpLCB7XG4gICAgZXJyb3JSZXRyeTogbnVsbCxcbiAgICB0aW1lb3V0UmV0cnk6IG51bGxcbiAgfSk7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgaXNUaW1lb3V0LCBodHRwU3RhdHVzKSB7XG4gIHJldHVybiAhIXJldHJ5Q29uZmlnICYmIHJldHJ5Q291bnQgPCByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSAmJiAocmV0cnlGb3JIdHRwU3RhdHVzKGh0dHBTdGF0dXMpIHx8ICEhaXNUaW1lb3V0KTtcbn1cbmZ1bmN0aW9uIHJldHJ5Rm9ySHR0cFN0YXR1cyhodHRwU3RhdHVzKSB7XG4gIC8vIERvIG5vdCByZXRyeSBvbiBzdGF0dXMgNHh4LCBzdGF0dXMgMCAoQ09SUyBlcnJvciksIG9yIHVuZGVmaW5lZCAoZGVjcnlwdC9nYXAvcGFyc2UgZXJyb3IpXG4gIHJldHVybiBodHRwU3RhdHVzID09PSAwICYmIG5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlIHx8ICEhaHR0cFN0YXR1cyAmJiAoaHR0cFN0YXR1cyA8IDQwMCB8fCBodHRwU3RhdHVzID4gNDk5KTtcbn1cblxuY29uc3QgQmluYXJ5U2VhcmNoID0ge1xuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSBjb21wYXJpc29uRm5cbiAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAqICAgICAgICAgID4gLTEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBsb3dlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIG9iamVjdCBpZiBmb3VuZCwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxuICAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbiAobGlzdCwgY29tcGFyaXNvbkZuKSB7XG4gICAgbGV0IG1pbkluZGV4ID0gMDtcbiAgICBsZXQgbWF4SW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG4gICAgICBjb25zdCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyaXNvbkZuKGN1cnJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBmaXJzdCBmcmFnbWVudCB3aG9zZSBlbmRQZHQgdmFsdWUgZXhjZWVkcyB0aGUgZ2l2ZW4gUERULCBvciBudWxsLlxuICogQHBhcmFtIGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0gUERUVmFsdWUgLSBUaGUgUERUIHZhbHVlIHdoaWNoIG11c3QgYmUgZXhjZWVkZWRcbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICovXG5mdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gIGlmIChQRFRWYWx1ZSA9PT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShmcmFnbWVudHMpIHx8ICFmcmFnbWVudHMubGVuZ3RoIHx8ICFpc0Zpbml0ZU51bWJlcihQRFRWYWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICBjb25zdCBzdGFydFBEVCA9IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA8IChzdGFydFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVuZFBEVCA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoUERUVmFsdWUgPj0gKGVuZFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHx8IDA7XG4gIGZvciAobGV0IHNlZyA9IDA7IHNlZyA8IGZyYWdtZW50cy5sZW5ndGg7ICsrc2VnKSB7XG4gICAgY29uc3QgZnJhZyA9IGZyYWdtZW50c1tzZWddO1xuICAgIGlmIChwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKSkge1xuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSBmcmFnUHJldmlvdXMgLSBUaGUgbGFzdCBmcmFnIHN1Y2Nlc3NmdWxseSBhcHBlbmRlZFxuICogQHBhcmFtIGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0gYnVmZmVyRW5kIC0gVGhlIGVuZCBvZiB0aGUgY29udGlndW91cyBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyBhIG1hdGNoaW5nIGZyYWdtZW50IG9yIG51bGxcbiAqL1xuZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwKSB7XG4gIGxldCBmcmFnTmV4dCA9IG51bGw7XG4gIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1tmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc24gKyAxXSB8fCBudWxsO1xuICB9IGVsc2UgaWYgKGJ1ZmZlckVuZCA9PT0gMCAmJiBmcmFnbWVudHNbMF0uc3RhcnQgPT09IDApIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1swXTtcbiAgfVxuICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gIGlmIChmcmFnTmV4dCAmJiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnTmV4dCkgPT09IDApIHtcbiAgICByZXR1cm4gZnJhZ05leHQ7XG4gIH1cbiAgLy8gV2UgbWlnaHQgYmUgc2Vla2luZyBwYXN0IHRoZSB0b2xlcmFuY2Ugc28gZmluZCB0aGUgYmVzdCBtYXRjaFxuICBjb25zdCBmb3VuZEZyYWdtZW50ID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdC5iaW5kKG51bGwsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpO1xuICBpZiAoZm91bmRGcmFnbWVudCAmJiAoZm91bmRGcmFnbWVudCAhPT0gZnJhZ1ByZXZpb3VzIHx8ICFmcmFnTmV4dCkpIHtcbiAgICByZXR1cm4gZm91bmRGcmFnbWVudDtcbiAgfVxuICAvLyBJZiBubyBtYXRjaCB3YXMgZm91bmQgcmV0dXJuIHRoZSBuZXh0IGZyYWdtZW50IGFmdGVyIGZyYWdQcmV2aW91cywgb3IgbnVsbFxuICByZXR1cm4gZnJhZ05leHQ7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlTbidzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIEBwYXJhbSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIGJ1ZmZlckVuZCAtIFRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyAwIGlmIGl0IG1hdGNoZXMsIDEgaWYgdG9vIGxvdywgLTEgaWYgdG9vIGhpZ2hcbiAqL1xuZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwLCBjYW5kaWRhdGUpIHtcbiAgLy8gZWFnZXJseSBhY2NlcHQgYW4gYWNjdXJhdGUgbWF0Y2ggKG5vIHRvbGVyYW5jZSlcbiAgaWYgKGNhbmRpZGF0ZS5zdGFydCA8PSBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uID4gYnVmZmVyRW5kKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICBjb25zdCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpO1xuICBpZiAoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9IGJ1ZmZlckVuZCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVBkdCdzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXG4gKiBAcGFyYW0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSBwZHRCdWZmZXJFbmQgLSBUaGUgVW5peCB0aW1lIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgdHJ1ZSBpZiBjb250aWd1b3VzLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdChwZHRCdWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICBjb25zdCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpICogMTAwMDtcblxuICAvLyBlbmRQcm9ncmFtRGF0ZVRpbWUgY2FuIGJlIG51bGwsIGRlZmF1bHQgdG8gemVyb1xuICBjb25zdCBlbmRQcm9ncmFtRGF0ZVRpbWUgPSBjYW5kaWRhdGUuZW5kUHJvZ3JhbURhdGVUaW1lIHx8IDA7XG4gIHJldHVybiBlbmRQcm9ncmFtRGF0ZVRpbWUgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBwZHRCdWZmZXJFbmQ7XG59XG5mdW5jdGlvbiBmaW5kRnJhZ1dpdGhDQyhmcmFnbWVudHMsIGNjKSB7XG4gIHJldHVybiBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgY2FuZGlkYXRlID0+IHtcbiAgICBpZiAoY2FuZGlkYXRlLmNjIDwgY2MpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLmNjID4gY2MpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgUkVORElUSU9OX1BFTkFMVFlfRFVSQVRJT05fTVMgPSAzMDAwMDA7XG52YXIgTmV0d29ya0Vycm9yQWN0aW9uID0ge1xuICBEb05vdGhpbmc6IDAsXG4gIFNlbmRFbmRDYWxsYmFjazogMSxcbiAgU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDogMixcbiAgUmVtb3ZlQWx0ZXJuYXRlUGVybWFuZW50bHk6IDMsXG4gIEluc2VydERpc2NvbnRpbnVpdHk6IDQsXG4gIFJldHJ5UmVxdWVzdDogNVxufTtcbnZhciBFcnJvckFjdGlvbkZsYWdzID0ge1xuICBOb25lOiAwLFxuICBNb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDogMSxcbiAgTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1A6IDIsXG4gIFN3aXRjaFRvU0RSOiA0XG59OyAvLyBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZVxuY2xhc3MgRXJyb3JDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICB0aGlzLnBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGBbaW5mb106YCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGBbd2FybmluZ106YCk7XG4gICAgdGhpcy5lcnJvciA9IGxvZ2dlci5lcnJvci5iaW5kKGxvZ2dlciwgYFtlcnJvcl06YCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvck91dCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICB9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgfVxuICBzdG9wTG9hZCgpIHt9XG4gIGdldFZhcmlhbnRMZXZlbEluZGV4KGZyYWcpIHtcbiAgICByZXR1cm4gKGZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWcudHlwZSkgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyBmcmFnLmxldmVsIDogdGhpcy5obHMubG9hZExldmVsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgdGhpcy5wZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gIH1cbiAgb25MZXZlbFVwZGF0ZWQoKSB7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGZyYWcsIF9kYXRhJGxldmVsO1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBkYXRhLmNvbnRleHQ7XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc2VnbWVudCBlcnJvcnMgbWFya2VkIGFzIGdhcFxuICAgICAgICBpZiAoKF9kYXRhJGZyYWcgPSBkYXRhLmZyYWcpICE9IG51bGwgJiYgX2RhdGEkZnJhZy5nYXApIHtcbiAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uRG9Ob3RoaW5nLFxuICAgICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFN3aXRjaCBsZXZlbCBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGFsbG93IHJldHJ5IGNvdW50IHRvIHJlYWNoIG1heCBlcnJvciByZXRyaWVzXG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSk7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5hY3Rpb24gPSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZGF0YSRjb250ZXh0LCBfZGF0YSRjb250ZXh0JGxldmVsRGU7XG4gICAgICAgICAgLy8gT25seSByZXRyeSB3aGVuIGVtcHR5IGFuZCBsaXZlXG4gICAgICAgICAgY29uc3QgbGV2ZWxJbmRleCA9IGRhdGEucGFyZW50ID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gZGF0YS5sZXZlbCA6IGhscy5sb2FkTGV2ZWw7XG4gICAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SICYmICEhKChfZGF0YSRjb250ZXh0ID0gZGF0YS5jb250ZXh0KSAhPSBudWxsICYmIChfZGF0YSRjb250ZXh0JGxldmVsRGUgPSBfZGF0YSRjb250ZXh0LmxldmVsRGV0YWlscykgIT0gbnVsbCAmJiBfZGF0YSRjb250ZXh0JGxldmVsRGUubGl2ZSkpIHtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRXNjYWxhdGUgdG8gZmF0YWwgaWYgbm90IHJldHJ5aW5nIG9yIHN3aXRjaGluZ1xuICAgICAgICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKHR5cGVvZiAoY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5sZXZlbCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEsIGNvbnRleHQubGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5TVUJUSVRMRV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gaGxzLmxldmVsc1tobHMubG9hZExldmVsXTtcbiAgICAgICAgICBpZiAobGV2ZWwgJiYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBjb250ZXh0Lmdyb3VwSWQgPT09IGxldmVsLmF1ZGlvR3JvdXBJZCB8fCBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgY29udGV4dC5ncm91cElkID09PSBsZXZlbC50ZXh0R3JvdXBJZCkpIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gUGF0aHdheSBzd2l0Y2ggb3IgUmVkdW5kYW50IGZhaWxvdmVyIGlmIHBvc3NpYmxlIGZvciBmYXN0ZXN0IHJlY292ZXJ5XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYWxsb3cgcGxheWxpc3QgcmV0cnkgY291bnQgdG8gcmVhY2ggbWF4IGVycm9yIHJldHJpZXNcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBobHMubG9hZExldmVsKTtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uYWN0aW9uID0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmZsYWdzID0gRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbaGxzLmxvYWRMZXZlbF07XG4gICAgICAgICAgY29uc3QgcmVzdHJpY3RlZEhkY3BMZXZlbCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICAgIGlmIChyZXN0cmljdGVkSGRjcExldmVsKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUCxcbiAgICAgICAgICAgICAgaGRjcExldmVsOiByZXN0cmljdGVkSGRjcExldmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1I6XG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIChfZGF0YSRsZXZlbCA9IGRhdGEubGV2ZWwpICE9IG51bGwgPyBfZGF0YSRsZXZlbCA6IGhscy5sb2FkTGV2ZWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT046XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEU6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEw6XG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uRG9Ob3RoaW5nLFxuICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS50eXBlID09PSBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IpIHtcbiAgICAgIGNvbnN0IGxldmVsSW5kZXggPSB0aGlzLmdldFZhcmlhbnRMZXZlbEluZGV4KGRhdGEuZnJhZyk7XG4gICAgICAvLyBEbyBub3QgcmV0cnkgbGV2ZWwuIEVzY2FsYXRlIHRvIGZhdGFsIGlmIHN3aXRjaGluZyBsZXZlbHMgZmFpbHMuXG4gICAgICBkYXRhLmxldmVsUmV0cnkgPSBmYWxzZTtcbiAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBnZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCkge1xuICAgIHZhciBfZGF0YSRyZXNwb25zZTtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKGhscy5jb25maWcucGxheWxpc3RMb2FkUG9saWN5LCBkYXRhKTtcbiAgICBjb25zdCByZXRyeUNvdW50ID0gdGhpcy5wbGF5bGlzdEVycm9yKys7XG4gICAgY29uc3QgaHR0cFN0YXR1cyA9IChfZGF0YSRyZXNwb25zZSA9IGRhdGEucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRyZXNwb25zZS5jb2RlO1xuICAgIGNvbnN0IHJldHJ5ID0gc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGlzVGltZW91dEVycm9yKGRhdGEpLCBodHRwU3RhdHVzKTtcbiAgICBpZiAocmV0cnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCxcbiAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgcmV0cnlDb25maWcsXG4gICAgICAgIHJldHJ5Q291bnRcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICBpZiAocmV0cnlDb25maWcpIHtcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q29uZmlnID0gcmV0cnlDb25maWc7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvdW50ID0gcmV0cnlDb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yQWN0aW9uO1xuICB9XG4gIGdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAvLyBTaGFyZSBmcmFnbWVudCBlcnJvciBjb3VudCBhY2Nyb3NzIG1lZGlhIG9wdGlvbnMgKG1haW4sIGF1ZGlvLCBzdWJzKVxuICAgIC8vIFRoaXMgYWxsb3dzIGZvciBsZXZlbCBiYXNlZCByZW5kaXRpb24gc3dpdGNoaW5nIHdoZW4gbWVkaWEgb3B0aW9uIGFzc2V0cyBmYWlsXG4gICAgY29uc3QgdmFyaWFudExldmVsSW5kZXggPSB0aGlzLmdldFZhcmlhbnRMZXZlbEluZGV4KGRhdGEuZnJhZyk7XG4gICAgY29uc3QgbGV2ZWwgPSBobHMubGV2ZWxzW3ZhcmlhbnRMZXZlbEluZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnTG9hZFBvbGljeSxcbiAgICAgIGtleUxvYWRQb2xpY3lcbiAgICB9ID0gaGxzLmNvbmZpZztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKGRhdGEuZGV0YWlscy5zdGFydHNXaXRoKCdrZXknKSA/IGtleUxvYWRQb2xpY3kgOiBmcmFnTG9hZFBvbGljeSwgZGF0YSk7XG4gICAgY29uc3QgZnJhZ21lbnRFcnJvcnMgPSBobHMubGV2ZWxzLnJlZHVjZSgoYWNjLCBsZXZlbCkgPT4gYWNjICsgbGV2ZWwuZnJhZ21lbnRFcnJvciwgMCk7XG4gICAgLy8gU3dpdGNoIGxldmVscyB3aGVuIG91dCBvZiByZXRyaWVkIG9yIGxldmVsIGluZGV4IG91dCBvZiBib3VuZHNcbiAgICBpZiAobGV2ZWwpIHtcbiAgICAgIHZhciBfZGF0YSRyZXNwb25zZTI7XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuRlJBR19HQVApIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvcisrO1xuICAgICAgfVxuICAgICAgY29uc3QgaHR0cFN0YXR1cyA9IChfZGF0YSRyZXNwb25zZTIgPSBkYXRhLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkcmVzcG9uc2UyLmNvZGU7XG4gICAgICBjb25zdCByZXRyeSA9IHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCBmcmFnbWVudEVycm9ycywgaXNUaW1lb3V0RXJyb3IoZGF0YSksIGh0dHBTdGF0dXMpO1xuICAgICAgaWYgKHJldHJ5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0LFxuICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgICAgcmV0cnlDb25maWcsXG4gICAgICAgICAgcmV0cnlDb3VudDogZnJhZ21lbnRFcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVhY2ggbWF4IHJldHJ5IGNvdW50LCBvciBNaXNzaW5nIGxldmVsIHJlZmVyZW5jZVxuICAgIC8vIFN3aXRjaCB0byB2YWxpZCBpbmRleFxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCB2YXJpYW50TGV2ZWxJbmRleCk7XG4gICAgLy8gQWRkIHJldHJ5IGRldGFpbHMgdG8gYWxsb3cgc2tpcHBpbmcgb2YgRlJBR19QQVJTSU5HX0VSUk9SXG4gICAgaWYgKHJldHJ5Q29uZmlnKSB7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvbmZpZyA9IHJldHJ5Q29uZmlnO1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb3VudCA9IGZyYWdtZW50RXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JBY3Rpb247XG4gIH1cbiAgZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmIChsZXZlbEluZGV4ID09PSBudWxsIHx8IGxldmVsSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV2ZWxJbmRleCA9IGhscy5sb2FkTGV2ZWw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGlmIChsZXZlbCkge1xuICAgICAgbGV2ZWwubG9hZEVycm9yKys7XG4gICAgICBpZiAoaGxzLmF1dG9MZXZlbEVuYWJsZWQpIHtcbiAgICAgICAgdmFyIF9kYXRhJGZyYWcyLCBfZGF0YSRjb250ZXh0MjtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBuZXh0IGxldmVsIHRvIHJldHJ5XG4gICAgICAgIGxldCBuZXh0TGV2ZWwgPSAtMTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICBsb2FkTGV2ZWwsXG4gICAgICAgICAgbWluQXV0b0xldmVsLFxuICAgICAgICAgIG1heEF1dG9MZXZlbFxuICAgICAgICB9ID0gaGxzO1xuICAgICAgICBjb25zdCBmcmFnRXJyb3JUeXBlID0gKF9kYXRhJGZyYWcyID0gZGF0YS5mcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZnJhZzIudHlwZTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGU6IHBsYXlsaXN0RXJyb3JUeXBlLFxuICAgICAgICAgIGdyb3VwSWQ6IHBsYXlsaXN0RXJyb3JHcm91cElkXG4gICAgICAgIH0gPSAoX2RhdGEkY29udGV4dDIgPSBkYXRhLmNvbnRleHQpICE9IG51bGwgPyBfZGF0YSRjb250ZXh0MiA6IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IChpICsgbG9hZExldmVsKSAlIGxldmVscy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSAhPT0gbG9hZExldmVsICYmIGNhbmRpZGF0ZSA+PSBtaW5BdXRvTGV2ZWwgJiYgY2FuZGlkYXRlIDw9IG1heEF1dG9MZXZlbCAmJiBsZXZlbHNbY2FuZGlkYXRlXS5sb2FkRXJyb3IgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsQ2FuZGlkYXRlID0gbGV2ZWxzW2NhbmRpZGF0ZV07XG4gICAgICAgICAgICAvLyBTa2lwIGxldmVsIHN3aXRjaCBpZiBHQVAgdGFnIGlzIGZvdW5kIGluIG5leHQgbGV2ZWwgYXQgc2FtZSBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQICYmIGRhdGEuZnJhZykge1xuICAgICAgICAgICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbHNbY2FuZGlkYXRlXS5kZXRhaWxzO1xuICAgICAgICAgICAgICBpZiAobGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhZ0NhbmRpZGF0ZSA9IGZpbmRGcmFnbWVudEJ5UFRTKGRhdGEuZnJhZywgbGV2ZWxEZXRhaWxzLmZyYWdtZW50cywgZGF0YS5mcmFnLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ0NhbmRpZGF0ZSAhPSBudWxsICYmIGZyYWdDYW5kaWRhdGUuZ2FwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGxheWxpc3RFcnJvclR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgcGxheWxpc3RFcnJvckdyb3VwSWQgPT09IGxldmVsQ2FuZGlkYXRlLmF1ZGlvR3JvdXBJZCB8fCBwbGF5bGlzdEVycm9yVHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBwbGF5bGlzdEVycm9yR3JvdXBJZCA9PT0gbGV2ZWxDYW5kaWRhdGUudGV4dEdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgLy8gRm9yIGF1ZGlvL3N1YnMgcGxheWxpc3QgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFnRXJyb3JUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTyAmJiBsZXZlbC5hdWRpb0dyb3VwSWQgPT09IGxldmVsQ2FuZGlkYXRlLmF1ZGlvR3JvdXBJZCB8fCBmcmFnRXJyb3JUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSAmJiBsZXZlbC50ZXh0R3JvdXBJZCA9PT0gbGV2ZWxDYW5kaWRhdGUudGV4dEdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgLy8gRm9yIGF1ZGlvL3N1YnMgZnJhZyBlcnJvcnMgZmluZCBhbm90aGVyIGdyb3VwIElEIG9yIGZhbGx0aHJvdWdoIHRvIHJlZHVuZGFudCBmYWlsLW92ZXJcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0TGV2ZWwgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRMZXZlbCA+IC0xICYmIGhscy5sb2FkTGV2ZWwgIT09IG5leHRMZXZlbCkge1xuICAgICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgICAgICBuZXh0QXV0b0xldmVsOiBuZXh0TGV2ZWxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vIGxldmVscyB0byBzd2l0Y2ggLyBNYW51YWwgbGV2ZWwgc2VsZWN0aW9uIC8gTGV2ZWwgbm90IGZvdW5kXG4gICAgLy8gUmVzb2x2ZSB3aXRoIFBhdGh3YXkgc3dpdGNoLCBSZWR1bmRhbnQgZmFpbC1vdmVyLCBvciBzdGF5IG9uIGxvd2VzdCBMZXZlbFxuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3RcbiAgICB9O1xuICB9XG4gIG9uRXJyb3JPdXQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkZXJyb3JBY3Rpb247XG4gICAgc3dpdGNoICgoX2RhdGEkZXJyb3JBY3Rpb24gPSBkYXRhLmVycm9yQWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZXJyb3JBY3Rpb24uYWN0aW9uKSB7XG4gICAgICBjYXNlIE5ldHdvcmtFcnJvckFjdGlvbi5Eb05vdGhpbmc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDpcbiAgICAgICAgdGhpcy5zZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94KGRhdGEpO1xuICAgICAgICBpZiAoIWRhdGEuZXJyb3JBY3Rpb24ucmVzb2x2ZWQgJiYgZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuRlJBR19HQVApIHtcbiAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHRoaXMuaGxzLnN0b3BMb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICBpZiAoIWVycm9yQWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZsYWdzLFxuICAgICAgaGRjcExldmVsLFxuICAgICAgbmV4dEF1dG9MZXZlbFxuICAgIH0gPSBlcnJvckFjdGlvbjtcbiAgICBzd2l0Y2ggKGZsYWdzKSB7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTm9uZTpcbiAgICAgICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLCBuZXh0QXV0b0xldmVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBIYW5kbGUgUmVkdW5kYW50IExldmVscyBoZXJlLiBQYXRod2F5IHN3aXRjaGluZyBpcyBoYW5kbGVkIGJ5IGNvbnRlbnQtc3RlZXJpbmctY29udHJvbGxlclxuICAgICAgICAgIGlmICghZXJyb3JBY3Rpb24ucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdGhpcy5yZWR1bmRhbnRGYWlsb3ZlcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1A6XG4gICAgICAgIGlmIChoZGNwTGV2ZWwpIHtcbiAgICAgICAgICBobHMubWF4SGRjcExldmVsID0gSGRjcExldmVsc1tIZGNwTGV2ZWxzLmluZGV4T2YoaGRjcExldmVsKSAtIDFdO1xuICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhcm4oYFJlc3RyaWN0aW5nIHBsYXliYWNrIHRvIEhEQ1AtTEVWRUwgb2YgXCIke2hscy5tYXhIZGNwTGV2ZWx9XCIgb3IgbG93ZXJgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIElmIG5vdCByZXNvbHZlZCBieSBwcmV2aW91cyBhY3Rpb25zIHRyeSB0byBzd2l0Y2ggdG8gbmV4dCBsZXZlbFxuICAgIGlmICghZXJyb3JBY3Rpb24ucmVzb2x2ZWQpIHtcbiAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YSwgbmV4dEF1dG9MZXZlbCk7XG4gICAgfVxuICB9XG4gIHN3aXRjaExldmVsKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICBpZiAobGV2ZWxJbmRleCAhPT0gdW5kZWZpbmVkICYmIGRhdGEuZXJyb3JBY3Rpb24pIHtcbiAgICAgIHRoaXMud2Fybihgc3dpdGNoaW5nIHRvIGxldmVsICR7bGV2ZWxJbmRleH0gYWZ0ZXIgJHtkYXRhLmRldGFpbHN9YCk7XG4gICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbGV2ZWxJbmRleDtcbiAgICAgIGRhdGEuZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgLy8gU3RyZWFtIGNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoaXMgYnV0IHdvbid0IHN3aXRjaCBvbiBmYWxzZSBzdGFydFxuICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG4gIHJlZHVuZGFudEZhaWxvdmVyKGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBwZW5hbGl6ZWRSZW5kaXRpb25zXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbGV2ZWxJbmRleCA9IGRhdGEucGFyZW50ID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gZGF0YS5sZXZlbCA6IGhscy5sb2FkTGV2ZWw7XG4gICAgY29uc3QgbGV2ZWwgPSBobHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGNvbnN0IHJlZHVuZGFudExldmVscyA9IGxldmVsLnVybC5sZW5ndGg7XG4gICAgY29uc3QgZXJyb3JVcmxJZCA9IGRhdGEuZnJhZyA/IGRhdGEuZnJhZy51cmxJZCA6IGxldmVsLnVybElkO1xuICAgIGlmIChsZXZlbC51cmxJZCA9PT0gZXJyb3JVcmxJZCAmJiAoIWRhdGEuZnJhZyB8fCBsZXZlbC5kZXRhaWxzKSkge1xuICAgICAgdGhpcy5wZW5hbGl6ZVJlbmRpdGlvbihsZXZlbCwgZGF0YSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmVkdW5kYW50TGV2ZWxzOyBpKyspIHtcbiAgICAgIGNvbnN0IG5ld1VybElkID0gKGVycm9yVXJsSWQgKyBpKSAlIHJlZHVuZGFudExldmVscztcbiAgICAgIGNvbnN0IHBlbmFsaXplZFJlbmRpdGlvbiA9IHBlbmFsaXplZFJlbmRpdGlvbnNbbmV3VXJsSWRdO1xuICAgICAgLy8gQ2hlY2sgaWYgcmVuZGl0aW9uIGlzIHBlbmFsaXplZCBhbmQgc2tpcCBpZiBpdCBpcyBhIGJhZCBmaXQgZm9yIGZhaWxvdmVyXG4gICAgICBpZiAoIXBlbmFsaXplZFJlbmRpdGlvbiB8fCBjaGVja0V4cGlyZWQocGVuYWxpemVkUmVuZGl0aW9uLCBkYXRhLCBwZW5hbGl6ZWRSZW5kaXRpb25zW2Vycm9yVXJsSWRdKSkge1xuICAgICAgICAvLyBkZWxldGUgcGVuYWxpemVkUmVuZGl0aW9uc1tuZXdVcmxJZF07XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdXJsIGlkIG9mIGFsbCBsZXZlbHMgc28gdGhhdCB3ZSBzdGF5IG9uIHRoZSBzYW1lIHNldCBvZiB2YXJpYW50cyB3aGVuIGxldmVsIHN3aXRjaGluZ1xuICAgICAgICB0aGlzLndhcm4oYFN3aXRjaGluZyB0byBSZWR1bmRhbnQgU3RyZWFtICR7bmV3VXJsSWQgKyAxfS8ke3JlZHVuZGFudExldmVsc306IFwiJHtsZXZlbC51cmxbbmV3VXJsSWRdfVwiIGFmdGVyICR7ZGF0YS5kZXRhaWxzfWApO1xuICAgICAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgICAgICBobHMubGV2ZWxzLmZvckVhY2gobHYgPT4ge1xuICAgICAgICAgIGx2LnVybElkID0gbmV3VXJsSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsSW5kZXg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcGVuYWxpemVSZW5kaXRpb24obGV2ZWwsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBwZW5hbGl6ZWRSZW5kaXRpb25zXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcGVuYWxpemVkUmVuZGl0aW9uID0gcGVuYWxpemVkUmVuZGl0aW9uc1tsZXZlbC51cmxJZF0gfHwge1xuICAgICAgbGFzdEVycm9yUGVyZk1zOiAwLFxuICAgICAgZXJyb3JzOiBbXSxcbiAgICAgIGRldGFpbHM6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcGVuYWxpemVkUmVuZGl0aW9uLmxhc3RFcnJvclBlcmZNcyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHBlbmFsaXplZFJlbmRpdGlvbi5lcnJvcnMucHVzaChkYXRhKTtcbiAgICBwZW5hbGl6ZWRSZW5kaXRpb24uZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgcGVuYWxpemVkUmVuZGl0aW9uc1tsZXZlbC51cmxJZF0gPSBwZW5hbGl6ZWRSZW5kaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRXhwaXJlZChwZW5hbGl6ZWRSZW5kaXRpb24sIGRhdGEsIGN1cnJlbnRQZW5hbHR5U3RhdGUpIHtcbiAgLy8gRXhwaXJlIHBlbmFsdHkgZm9yIHN3aXRjaGluZyBiYWNrIHRvIHJlbmRpdGlvbiBhZnRlciBSRU5ESVRJT05fUEVOQUxUWV9EVVJBVElPTl9NU1xuICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBwZW5hbGl6ZWRSZW5kaXRpb24ubGFzdEVycm9yUGVyZk1zID4gUkVORElUSU9OX1BFTkFMVFlfRFVSQVRJT05fTVMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBFeHBpcmUgcGVuYWx0eSBvbiBHQVAgdGFnIGVycm9yIGlmIHJlbmRpdGlvbiBoYXMgbm8gR0FQIGF0IHBvc2l0aW9uIChkb2VzIG5vdCBjb3ZlciBtZWRpYSB0cmFja3MpXG4gIGNvbnN0IGxhc3RFcnJvckRldGFpbHMgPSBwZW5hbGl6ZWRSZW5kaXRpb24uZGV0YWlscztcbiAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQICYmIGxhc3RFcnJvckRldGFpbHMgJiYgZGF0YS5mcmFnKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBkYXRhLmZyYWcuc3RhcnQ7XG4gICAgY29uc3QgY2FuZGlkYXRlRnJhZyA9IGZpbmRGcmFnbWVudEJ5UFRTKG51bGwsIGxhc3RFcnJvckRldGFpbHMuZnJhZ21lbnRzLCBwb3NpdGlvbik7XG4gICAgaWYgKGNhbmRpZGF0ZUZyYWcgJiYgIWNhbmRpZGF0ZUZyYWcuZ2FwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gRXhwaXJlIHBlbmFsdHkgaWYgdGhlcmUgYXJlIG1vcmUgZXJyb3JzIGluIGN1cnJlbnRMZXZlbCB0aGFuIGluIHBlbmFsaXplZFJlbmRpdGlvblxuICBpZiAoY3VycmVudFBlbmFsdHlTdGF0ZSAmJiBwZW5hbGl6ZWRSZW5kaXRpb24uZXJyb3JzLmxlbmd0aCA8IGN1cnJlbnRQZW5hbHR5U3RhdGUuZXJyb3JzLmxlbmd0aCkge1xuICAgIGNvbnN0IGxhc3RDYW5kaWRhdGVFcnJvciA9IHBlbmFsaXplZFJlbmRpdGlvbi5lcnJvcnNbcGVuYWxpemVkUmVuZGl0aW9uLmVycm9ycy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdEVycm9yRGV0YWlscyAmJiBsYXN0Q2FuZGlkYXRlRXJyb3IuZnJhZyAmJiBkYXRhLmZyYWcgJiYgTWF0aC5hYnMobGFzdENhbmRpZGF0ZUVycm9yLmZyYWcuc3RhcnQgLSBkYXRhLmZyYWcuc3RhcnQpID4gbGFzdEVycm9yRGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGxvZ1ByZWZpeCkge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSBudWxsO1xuICB9XG4gIGNsZWFyVGltZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgfVxuICBzdGFydExvYWQoKSB7XG4gICAgdGhpcy5jYW5Mb2FkID0gdHJ1ZTtcbiAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIHN3aXRjaFBhcmFtcyhwbGF5bGlzdFVyaSwgcHJldmlvdXMpIHtcbiAgICBjb25zdCByZW5kaXRpb25SZXBvcnRzID0gcHJldmlvdXMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzLnJlbmRpdGlvblJlcG9ydHM7XG4gICAgaWYgKHJlbmRpdGlvblJlcG9ydHMpIHtcbiAgICAgIGxldCBmb3VuZEluZGV4ID0gLTE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRpdGlvblJlcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IHJlbmRpdGlvblJlcG9ydHNbaV07XG4gICAgICAgIGxldCB1cmk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJpID0gbmV3IHNlbGYuVVJMKGF0dHIuVVJJLCBwcmV2aW91cy51cmwpLmhyZWY7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCBmb3IgUmVuZGl0aW9uIFJlcG9ydDogJHtlcnJvcn1gKTtcbiAgICAgICAgICB1cmkgPSBhdHRyLlVSSSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgZXhhY3QgbWF0Y2guIE90aGVyd2lzZSwgdGhlIGxhc3QgcGFydGlhbCBtYXRjaCwgaWYgYW55LCB3aWxsIGJlIHVzZWRcbiAgICAgICAgLy8gKFBsYXlsaXN0IFVSSSBpbmNsdWRlcyBhIHF1ZXJ5IHN0cmluZyB0aGF0IHRoZSBSZW5kaXRpb24gUmVwb3J0IGRvZXMgbm90KVxuICAgICAgICBpZiAodXJpID09PSBwbGF5bGlzdFVyaSkge1xuICAgICAgICAgIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHVyaSA9PT0gcGxheWxpc3RVcmkuc3Vic3RyaW5nKDAsIHVyaS5sZW5ndGgpKSB7XG4gICAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBjb25zdCBhdHRyID0gcmVuZGl0aW9uUmVwb3J0c1tmb3VuZEluZGV4XTtcbiAgICAgICAgY29uc3QgbXNuID0gcGFyc2VJbnQoYXR0clsnTEFTVC1NU04nXSkgfHwgKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5sYXN0UGFydFNuKTtcbiAgICAgICAgbGV0IHBhcnQgPSBwYXJzZUludChhdHRyWydMQVNULVBBUlQnXSkgfHwgKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5sYXN0UGFydEluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRHb2FsID0gTWF0aC5taW4ocHJldmlvdXMuYWdlIC0gcHJldmlvdXMucGFydFRhcmdldCwgcHJldmlvdXMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgIGlmIChwYXJ0ID49IDAgJiYgY3VycmVudEdvYWwgPiBwcmV2aW91cy5wYXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICBwYXJ0ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGxzVXJsUGFyYW1ldGVycyhtc24sIHBhcnQgPj0gMCA/IHBhcnQgOiB1bmRlZmluZWQsIEhsc1NraXAuTm8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIGlmICh0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xKSB7XG4gICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbiAgICAvLyBMb2FkaW5nIGlzIGhhbmRsZWQgYnkgdGhlIHN1YmNsYXNzZXNcbiAgfVxuXG4gIHNob3VsZExvYWRQbGF5bGlzdChwbGF5bGlzdCkge1xuICAgIHJldHVybiB0aGlzLmNhbkxvYWQgJiYgISFwbGF5bGlzdCAmJiAhIXBsYXlsaXN0LnVybCAmJiAoIXBsYXlsaXN0LmRldGFpbHMgfHwgcGxheWxpc3QuZGV0YWlscy5saXZlKTtcbiAgfVxuICBzaG91bGRSZWxvYWRQbGF5bGlzdChwbGF5bGlzdCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVyID09PSAtMSAmJiB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xICYmIHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KHBsYXlsaXN0KTtcbiAgfVxuICBwbGF5bGlzdExvYWRlZChpbmRleCwgZGF0YSwgcHJldmlvdXNEZXRhaWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGV0YWlscyxcbiAgICAgIHN0YXRzXG4gICAgfSA9IGRhdGE7XG5cbiAgICAvLyBTZXQgbGFzdCB1cGRhdGVkIGRhdGUtdGltZVxuICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZCA9IHN0YXRzLmxvYWRpbmcuZmlyc3QgPyBNYXRoLm1heCgwLCBub3cgLSBzdGF0cy5sb2FkaW5nLmZpcnN0KSA6IDA7XG4gICAgZGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gRGF0ZS5ub3coKSAtIGVsYXBzZWQ7XG5cbiAgICAvLyBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdCwgYXJtIGEgdGltZXIgdG8gcmVsb2FkIGl0XG4gICAgaWYgKGRldGFpbHMubGl2ZSB8fCBwcmV2aW91c0RldGFpbHMgIT0gbnVsbCAmJiBwcmV2aW91c0RldGFpbHMubGl2ZSkge1xuICAgICAgZGV0YWlscy5yZWxvYWRlZChwcmV2aW91c0RldGFpbHMpO1xuICAgICAgaWYgKHByZXZpb3VzRGV0YWlscykge1xuICAgICAgICB0aGlzLmxvZyhgbGl2ZSBwbGF5bGlzdCAke2luZGV4fSAke2RldGFpbHMuYWR2YW5jZWQgPyAnUkVGUkVTSEVEICcgKyBkZXRhaWxzLmxhc3RQYXJ0U24gKyAnLScgKyBkZXRhaWxzLmxhc3RQYXJ0SW5kZXggOiBkZXRhaWxzLnVwZGF0ZWQgPyAnVVBEQVRFRCcgOiAnTUlTU0VEJ31gKTtcbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIGxpdmUgcGxheWxpc3RzIHRvIGFkanVzdCBmcmFnbWVudCBzdGFydHMgYW5kIGZpbGwgaW4gZGVsdGEgcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyAmJiBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1lcmdlRGV0YWlscyhwcmV2aW91c0RldGFpbHMsIGRldGFpbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNhbkxvYWQgfHwgIWRldGFpbHMubGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgICAgbGV0IG1zbiA9IHVuZGVmaW5lZDtcbiAgICAgIGxldCBwYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgJiYgZGV0YWlscy5lbmRTTiAmJiBkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICAgIC8vIExvYWQgbGV2ZWwgd2l0aCBMTC1ITFMgZGVsaXZlcnkgZGlyZWN0aXZlc1xuICAgICAgICBjb25zdCBsb3dMYXRlbmN5TW9kZSA9IHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgICAgICAgY29uc3QgbGFzdFBhcnRTbiA9IGRldGFpbHMubGFzdFBhcnRTbjtcbiAgICAgICAgY29uc3QgZW5kU24gPSBkZXRhaWxzLmVuZFNOO1xuICAgICAgICBjb25zdCBsYXN0UGFydEluZGV4ID0gZGV0YWlscy5sYXN0UGFydEluZGV4O1xuICAgICAgICBjb25zdCBoYXNQYXJ0cyA9IGxhc3RQYXJ0SW5kZXggIT09IC0xO1xuICAgICAgICBjb25zdCBsYXN0UGFydCA9IGxhc3RQYXJ0U24gPT09IGVuZFNuO1xuICAgICAgICAvLyBXaGVuIGxvdyBsYXRlbmN5IG1vZGUgaXMgZGlzYWJsZWQsIHdlJ2xsIHNraXAgcGFydCByZXF1ZXN0cyBvbmNlIHRoZSBsYXN0IHBhcnQgaW5kZXggaXMgZm91bmRcbiAgICAgICAgY29uc3QgbmV4dFNuU3RhcnRJbmRleCA9IGxvd0xhdGVuY3lNb2RlID8gMCA6IGxhc3RQYXJ0SW5kZXg7XG4gICAgICAgIGlmIChoYXNQYXJ0cykge1xuICAgICAgICAgIG1zbiA9IGxhc3RQYXJ0ID8gZW5kU24gKyAxIDogbGFzdFBhcnRTbjtcbiAgICAgICAgICBwYXJ0ID0gbGFzdFBhcnQgPyBuZXh0U25TdGFydEluZGV4IDogbGFzdFBhcnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXNuID0gZW5kU24gKyAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvdy1MYXRlbmN5IENETiBUdW5lLWluOiBcImFnZVwiIGhlYWRlciBhbmQgdGltZSBzaW5jZSBsb2FkIGluZGljYXRlcyB3ZSdyZSBiZWhpbmQgYnkgbW9yZSB0aGFuIG9uZSBwYXJ0XG4gICAgICAgIC8vIFVwZGF0ZSBkaXJlY3RpdmVzIHRvIG9idGFpbiB0aGUgUGxheWxpc3QgdGhhdCBoYXMgdGhlIGVzdGltYXRlZCBhZGRpdGlvbmFsIGR1cmF0aW9uIG9mIG1lZGlhXG4gICAgICAgIGNvbnN0IGxhc3RBZHZhbmNlZCA9IGRldGFpbHMuYWdlO1xuICAgICAgICBjb25zdCBjZG5BZ2UgPSBsYXN0QWR2YW5jZWQgKyBkZXRhaWxzLmFnZUhlYWRlcjtcbiAgICAgICAgbGV0IGN1cnJlbnRHb2FsID0gTWF0aC5taW4oY2RuQWdlIC0gZGV0YWlscy5wYXJ0VGFyZ2V0LCBkZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMS41KTtcbiAgICAgICAgaWYgKGN1cnJlbnRHb2FsID4gMCkge1xuICAgICAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgY3VycmVudEdvYWwgPiBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXR0ZW1wdGVkIHRvIGdldCB0aGUgbmV4dCBvciBsYXRlc3QgcGxheWxpc3QgdXBkYXRlLCBidXQgY3VycmVudEdvYWwgaW5jcmVhc2VkLFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBlaXRoZXIgY2FuJ3QgY2F0Y2h1cCwgb3IgdGhlIFwiYWdlXCIgaGVhZGVyIGNhbm5vdCBiZSB0cnVzdGVkLlxuICAgICAgICAgICAgdGhpcy53YXJuKGBDRE4gVHVuZS1pbiBnb2FsIGluY3JlYXNlZCBmcm9tOiAke3ByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsfSB0bzogJHtjdXJyZW50R29hbH0gd2l0aCBwbGF5bGlzdCBhZ2U6ICR7ZGV0YWlscy5hZ2V9YCk7XG4gICAgICAgICAgICBjdXJyZW50R29hbCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gTWF0aC5mbG9vcihjdXJyZW50R29hbCAvIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgICAgbXNuICs9IHNlZ21lbnRzO1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IE1hdGgucm91bmQoY3VycmVudEdvYWwgJSBkZXRhaWxzLnRhcmdldGR1cmF0aW9uIC8gZGV0YWlscy5wYXJ0VGFyZ2V0KTtcbiAgICAgICAgICAgICAgcGFydCArPSBwYXJ0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nKGBDRE4gVHVuZS1pbiBhZ2U6ICR7ZGV0YWlscy5hZ2VIZWFkZXJ9cyBsYXN0IGFkdmFuY2VkICR7bGFzdEFkdmFuY2VkLnRvRml4ZWQoMil9cyBnb2FsOiAke2N1cnJlbnRHb2FsfSBza2lwIHNuICR7c2VnbWVudHN9IHRvIHBhcnQgJHtwYXJ0fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXRhaWxzLnR1bmVJbkdvYWwgPSBjdXJyZW50R29hbDtcbiAgICAgICAgfVxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KTtcbiAgICAgICAgaWYgKGxvd0xhdGVuY3lNb2RlIHx8ICFsYXN0UGFydCkge1xuICAgICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGRlbGl2ZXJ5RGlyZWN0aXZlcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgfHwgZGV0YWlscy5jYW5Ta2lwVW50aWwpIHtcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gdGhpcy5nZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCk7XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5obHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgLSBidWZmZXJJbmZvLmxlbiA6IDA7XG4gICAgICBjb25zdCBkaXN0YW5jZVRvTGl2ZUVkZ2VNcyA9IChkZXRhaWxzLmVkZ2UgLSBwb3NpdGlvbikgKiAxMDAwO1xuICAgICAgY29uc3QgcmVsb2FkSW50ZXJ2YWwgPSBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoZGV0YWlscywgZGlzdGFuY2VUb0xpdmVFZGdlTXMpO1xuICAgICAgaWYgKGRldGFpbHMudXBkYXRlZCAmJiBub3cgPiB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgKyByZWxvYWRJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKG1zbiAhPT0gdW5kZWZpbmVkICYmIGRldGFpbHMuY2FuQmxvY2tSZWxvYWQpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5maXJzdCArIHJlbG9hZEludGVydmFsIC0gKGRldGFpbHMucGFydFRhcmdldCAqIDEwMDAgfHwgMTAwMCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9PT0gLTEgfHwgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICsgcmVsb2FkSW50ZXJ2YWwgPCBub3cpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gbm93O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlcXVlc3RTY2hlZHVsZWQgLSBub3cgPD0gMCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgKz0gcmVsb2FkSW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICBsZXQgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gdGhpcy5yZXF1ZXN0U2NoZWR1bGVkIC0gbm93O1xuICAgICAgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gTWF0aC5tYXgoMCwgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKTtcbiAgICAgIHRoaXMubG9nKGByZWxvYWQgbGl2ZSBwbGF5bGlzdCAke2luZGV4fSBpbiAke01hdGgucm91bmQoZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKX0gbXNgKTtcbiAgICAgIC8vIHRoaXMubG9nKFxuICAgICAgLy8gICBgbGl2ZSByZWxvYWQgJHtkZXRhaWxzLnVwZGF0ZWQgPyAnUkVGUkVTSEVEJyA6ICdNSVNTRUQnfVxuICAgICAgLy8gcmVsb2FkIGluICR7ZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlIC8gMTAwMH1cbiAgICAgIC8vIHJvdW5kIHRyaXAgJHsoc3RhdHMubG9hZGluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSAvIDEwMDB9XG4gICAgICAvLyBkaWZmICR7XG4gICAgICAvLyAgIChyZWxvYWRJbnRlcnZhbCAtXG4gICAgICAvLyAgICAgKGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSArXG4gICAgICAvLyAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCAtXG4gICAgICAvLyAgICAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0KSkgL1xuICAgICAgLy8gICAxMDAwXG4gICAgICAvLyB9XG4gICAgICAvLyByZWxvYWQgaW50ZXJ2YWwgJHtyZWxvYWRJbnRlcnZhbCAvIDEwMDB9XG4gICAgICAvLyB0YXJnZXQgZHVyYXRpb24gJHtkZXRhaWxzLnRhcmdldGR1cmF0aW9ufVxuICAgICAgLy8gZGlzdGFuY2UgdG8gZWRnZSAke2Rpc3RhbmNlVG9MaXZlRWRnZU1zIC8gMTAwMH1gXG4gICAgICAvLyApO1xuXG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHRoaXMubG9hZFBsYXlsaXN0KGRlbGl2ZXJ5RGlyZWN0aXZlcyksIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH1cbiAgfVxuICBnZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCkge1xuICAgIGxldCBza2lwID0gZ2V0U2tpcFZhbHVlKGRldGFpbHMsIG1zbik7XG4gICAgaWYgKHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzICE9IG51bGwgJiYgcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMuc2tpcCAmJiBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBtc24gPSBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcy5tc247XG4gICAgICBwYXJ0ID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMucGFydDtcbiAgICAgIHNraXAgPSBIbHNTa2lwLk5vO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhsc1VybFBhcmFtZXRlcnMobXNuLCBwYXJ0LCBza2lwKTtcbiAgfVxuICBjaGVja1JldHJ5KGVycm9yRXZlbnQpIHtcbiAgICBjb25zdCBlcnJvckRldGFpbHMgPSBlcnJvckV2ZW50LmRldGFpbHM7XG4gICAgY29uc3QgaXNUaW1lb3V0ID0gaXNUaW1lb3V0RXJyb3IoZXJyb3JFdmVudCk7XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSBlcnJvckV2ZW50LmVycm9yQWN0aW9uO1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGlvbixcbiAgICAgIHJldHJ5Q291bnQgPSAwLFxuICAgICAgcmV0cnlDb25maWdcbiAgICB9ID0gZXJyb3JBY3Rpb24gfHwge307XG4gICAgY29uc3QgcmV0cnkgPSAhIWVycm9yQWN0aW9uICYmICEhcmV0cnlDb25maWcgJiYgKGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCB8fCAhZXJyb3JBY3Rpb24ucmVzb2x2ZWQgJiYgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCk7XG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICB2YXIgX2Vycm9yRXZlbnQkY29udGV4dDtcbiAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IC0xO1xuICAgICAgaWYgKHJldHJ5Q291bnQgPj0gcmV0cnlDb25maWcubWF4TnVtUmV0cnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGltZW91dCAmJiAoX2Vycm9yRXZlbnQkY29udGV4dCA9IGVycm9yRXZlbnQuY29udGV4dCkgIT0gbnVsbCAmJiBfZXJyb3JFdmVudCRjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykge1xuICAgICAgICAvLyBUaGUgTEwtSExTIHJlcXVlc3QgYWxyZWFkeSB0aW1lZCBvdXQgc28gcmV0cnkgaW1tZWRpYXRlbHlcbiAgICAgICAgdGhpcy53YXJuKGBSZXRyeWluZyBwbGF5bGlzdCBsb2FkaW5nICR7cmV0cnlDb3VudCArIDF9LyR7cmV0cnlDb25maWcubWF4TnVtUmV0cnl9IGFmdGVyIFwiJHtlcnJvckRldGFpbHN9XCIgd2l0aG91dCBkZWxpdmVyeS1kaXJlY3RpdmVzYCk7XG4gICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHJldHJ5Q291bnQpO1xuICAgICAgICAvLyBTY2hlZHVsZSBsZXZlbC90cmFjayByZWxvYWRcbiAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB0aGlzLmxvYWRQbGF5bGlzdCgpLCBkZWxheSk7XG4gICAgICAgIHRoaXMud2FybihgUmV0cnlpbmcgcGxheWxpc3QgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBhZnRlciBcIiR7ZXJyb3JEZXRhaWxzfVwiIGluICR7ZGVsYXl9bXNgKTtcbiAgICAgIH1cbiAgICAgIC8vIGBsZXZlbFJldHJ5ID0gdHJ1ZWAgdXNlZCB0byBpbmZvcm0gb3RoZXIgY29udHJvbGxlcnMgdGhhdCBhIHJldHJ5IGlzIGhhcHBlbmluZ1xuICAgICAgZXJyb3JFdmVudC5sZXZlbFJldHJ5ID0gdHJ1ZTtcbiAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHJ5O1xuICB9XG59XG5cbmxldCBjaHJvbWVPckZpcmVmb3g7XG5jbGFzcyBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzLCBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyKSB7XG4gICAgc3VwZXIoaGxzLCAnW2xldmVsLWNvbnRyb2xsZXJdJyk7XG4gICAgdGhpcy5fbGV2ZWxzID0gW107XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLnN0ZWVyaW5nID0gdm9pZCAwO1xuICAgIHRoaXMub25QYXJzZWRDb21wbGV0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0ZWVyaW5nID0gY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zdGVlcmluZyA9IG51bGw7XG4gICAgdGhpcy5yZXNldExldmVscygpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBzdGFydExvYWQoKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuXG4gICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgfSk7XG4gICAgc3VwZXIuc3RhcnRMb2FkKCk7XG4gIH1cbiAgcmVzZXRMZXZlbHMoKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgIHRoaXMuX2xldmVscyA9IFtdO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5yZXNldExldmVscygpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBsZXZlbHMgPSBbXTtcbiAgICBjb25zdCBsZXZlbFNldCA9IHt9O1xuICAgIGxldCBsZXZlbEZyb21TZXQ7XG5cbiAgICAvLyByZWdyb3VwIHJlZHVuZGFudCBsZXZlbHMgdG9nZXRoZXJcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsUGFyc2VkID0+IHtcbiAgICAgIHZhciBfbGV2ZWxQYXJzZWQkYXVkaW9Db2Q7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbGV2ZWxQYXJzZWQuYXR0cnM7XG5cbiAgICAgIC8vIGVyYXNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQuXG4gICAgICAvLyBkZW11eGVyIHdpbGwgYXV0b2RldGVjdCBjb2RlYyBhbmQgZmFsbGJhY2sgdG8gbXBlZy9hdWRpb1xuICAgICAgaWYgKCgoX2xldmVsUGFyc2VkJGF1ZGlvQ29kID0gbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbFBhcnNlZCRhdWRpb0NvZC5pbmRleE9mKCdtcDRhLjQwLjM0JykpICE9PSAtMSkge1xuICAgICAgICBjaHJvbWVPckZpcmVmb3ggfHwgKGNocm9tZU9yRmlyZWZveCA9IC9jaHJvbWV8ZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xuICAgICAgICBpZiAoY2hyb21lT3JGaXJlZm94KSB7XG4gICAgICAgICAgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBBVURJTyxcbiAgICAgICAgQ09ERUNTLFxuICAgICAgICAnRlJBTUUtUkFURSc6IEZSQU1FUkFURSxcbiAgICAgICAgJ1BBVEhXQVktSUQnOiBQQVRIV0FZLFxuICAgICAgICBSRVNPTFVUSU9OLFxuICAgICAgICBTVUJUSVRMRVNcbiAgICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgICAgY29uc3QgY29udGVudFN0ZWVyaW5nUHJlZml4ID0gYCR7UEFUSFdBWSB8fCAnLid9LWAgO1xuICAgICAgY29uc3QgbGV2ZWxLZXkgPSBgJHtjb250ZW50U3RlZXJpbmdQcmVmaXh9JHtsZXZlbFBhcnNlZC5iaXRyYXRlfS0ke1JFU09MVVRJT059LSR7RlJBTUVSQVRFfS0ke0NPREVDU31gO1xuICAgICAgbGV2ZWxGcm9tU2V0ID0gbGV2ZWxTZXRbbGV2ZWxLZXldO1xuICAgICAgaWYgKCFsZXZlbEZyb21TZXQpIHtcbiAgICAgICAgbGV2ZWxGcm9tU2V0ID0gbmV3IExldmVsKGxldmVsUGFyc2VkKTtcbiAgICAgICAgbGV2ZWxTZXRbbGV2ZWxLZXldID0gbGV2ZWxGcm9tU2V0O1xuICAgICAgICBsZXZlbHMucHVzaChsZXZlbEZyb21TZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxGcm9tU2V0LmFkZEZhbGxiYWNrKGxldmVsUGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIGFkZEdyb3VwSWQobGV2ZWxGcm9tU2V0LCAnYXVkaW8nLCBBVURJTyk7XG4gICAgICBhZGRHcm91cElkKGxldmVsRnJvbVNldCwgJ3RleHQnLCBTVUJUSVRMRVMpO1xuICAgIH0pO1xuICAgIHRoaXMuZmlsdGVyQW5kU29ydE1lZGlhT3B0aW9ucyhsZXZlbHMsIGRhdGEpO1xuICB9XG4gIGZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnModW5maWx0ZXJlZExldmVscywgZGF0YSkge1xuICAgIGxldCBhdWRpb1RyYWNrcyA9IFtdO1xuICAgIGxldCBzdWJ0aXRsZVRyYWNrcyA9IFtdO1xuICAgIGxldCByZXNvbHV0aW9uRm91bmQgPSBmYWxzZTtcbiAgICBsZXQgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2U7XG4gICAgbGV0IGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlO1xuXG4gICAgLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcbiAgICBsZXQgbGV2ZWxzID0gdW5maWx0ZXJlZExldmVscy5maWx0ZXIoKHtcbiAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB1bmtub3duQ29kZWNzXG4gICAgfSkgPT4ge1xuICAgICAgcmVzb2x1dGlvbkZvdW5kIHx8IChyZXNvbHV0aW9uRm91bmQgPSAhISh3aWR0aCAmJiBoZWlnaHQpKTtcbiAgICAgIHZpZGVvQ29kZWNGb3VuZCB8fCAodmlkZW9Db2RlY0ZvdW5kID0gISF2aWRlb0NvZGVjKTtcbiAgICAgIGF1ZGlvQ29kZWNGb3VuZCB8fCAoYXVkaW9Db2RlY0ZvdW5kID0gISFhdWRpb0NvZGVjKTtcbiAgICAgIHJldHVybiAhKHVua25vd25Db2RlY3MgIT0gbnVsbCAmJiB1bmtub3duQ29kZWNzLmxlbmd0aCkgJiYgKCFhdWRpb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNChhdWRpb0NvZGVjLCAnYXVkaW8nKSkgJiYgKCF2aWRlb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh2aWRlb0NvZGVjLCAndmlkZW8nKSk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYXVkaW8tb25seSBsZXZlbCBpZiB3ZSBhbHNvIGhhdmUgbGV2ZWxzIHdpdGggdmlkZW8gY29kZWNzIG9yIFJFU09MVVRJT04gc2lnbmFsbGVkXG4gICAgaWYgKChyZXNvbHV0aW9uRm91bmQgfHwgdmlkZW9Db2RlY0ZvdW5kKSAmJiBhdWRpb0NvZGVjRm91bmQpIHtcbiAgICAgIGxldmVscyA9IGxldmVscy5maWx0ZXIoKHtcbiAgICAgICAgdmlkZW9Db2RlYyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSkgPT4gISF2aWRlb0NvZGVjIHx8ICEhKHdpZHRoICYmIGhlaWdodCkpO1xuICAgIH1cbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRGlzcGF0Y2ggZXJyb3IgYWZ0ZXIgTUFOSUZFU1RfTE9BREVEIGlzIGRvbmUgcHJvcGFnYXRpbmdcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5obHMpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignbm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdCcpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIHVybDogZGF0YS51cmwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuYXVkaW9UcmFja3MpIHtcbiAgICAgIGF1ZGlvVHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcy5maWx0ZXIodHJhY2sgPT4gIXRyYWNrLmF1ZGlvQ29kZWMgfHwgaXNDb2RlY1N1cHBvcnRlZEluTXA0KHRyYWNrLmF1ZGlvQ29kZWMsICdhdWRpbycpKTtcbiAgICAgIC8vIEFzc2lnbiBpZHMgYWZ0ZXIgZmlsdGVyaW5nIGFzIGFycmF5IGluZGljZXMgYnkgZ3JvdXAtaWRcbiAgICAgIGFzc2lnblRyYWNrSWRzQnlHcm91cChhdWRpb1RyYWNrcyk7XG4gICAgfVxuICAgIGlmIChkYXRhLnN1YnRpdGxlcykge1xuICAgICAgc3VidGl0bGVUcmFja3MgPSBkYXRhLnN1YnRpdGxlcztcbiAgICAgIGFzc2lnblRyYWNrSWRzQnlHcm91cChzdWJ0aXRsZVRyYWNrcyk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgY29uc3QgdW5zb3J0ZWRMZXZlbHMgPSBsZXZlbHMuc2xpY2UoMCk7XG4gICAgLy8gc29ydCBsZXZlbHMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdFxuICAgIGxldmVscy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5hdHRyc1snSERDUC1MRVZFTCddICE9PSBiLmF0dHJzWydIRENQLUxFVkVMJ10pIHtcbiAgICAgICAgcmV0dXJuIChhLmF0dHJzWydIRENQLUxFVkVMJ10gfHwgJycpID4gKGIuYXR0cnNbJ0hEQ1AtTEVWRUwnXSB8fCAnJykgPyAxIDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoYS5iaXRyYXRlICE9PSBiLmJpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuYml0cmF0ZSAtIGIuYml0cmF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhLmF0dHJzWydGUkFNRS1SQVRFJ10gIT09IGIuYXR0cnNbJ0ZSQU1FLVJBVEUnXSkge1xuICAgICAgICByZXR1cm4gYS5hdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnRlJBTUUtUkFURScpIC0gYi5hdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnRlJBTUUtUkFURScpO1xuICAgICAgfVxuICAgICAgaWYgKGEuYXR0cnMuU0NPUkUgIT09IGIuYXR0cnMuU0NPUkUpIHtcbiAgICAgICAgcmV0dXJuIGEuYXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1NDT1JFJykgLSBiLmF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdTQ09SRScpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc29sdXRpb25Gb3VuZCAmJiBhLmhlaWdodCAhPT0gYi5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGEuaGVpZ2h0IC0gYi5oZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICBsZXQgZmlyc3RMZXZlbEluUGxheWxpc3QgPSB1bnNvcnRlZExldmVsc1swXTtcbiAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgbGV2ZWxzID0gdGhpcy5zdGVlcmluZy5maWx0ZXJQYXJzZWRMZXZlbHMobGV2ZWxzKTtcbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoICE9PSB1bnNvcnRlZExldmVscy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnNvcnRlZExldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh1bnNvcnRlZExldmVsc1tpXS5wYXRod2F5SWQgPT09IGxldmVsc1swXS5wYXRod2F5SWQpIHtcbiAgICAgICAgICAgIGZpcnN0TGV2ZWxJblBsYXlsaXN0ID0gdW5zb3J0ZWRMZXZlbHNbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuXG4gICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbHNbaV0gPT09IGZpcnN0TGV2ZWxJblBsYXlsaXN0KSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICB0aGlzLmxvZyhgbWFuaWZlc3QgbG9hZGVkLCAke2xldmVscy5sZW5ndGh9IGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiAke2ZpcnN0TGV2ZWxJblBsYXlsaXN0LmJpdHJhdGV9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEF1ZGlvIGlzIG9ubHkgYWx0ZXJuYXRlIGlmIG1hbmlmZXN0IGluY2x1ZGUgYSBVUkkgYWxvbmcgd2l0aCB0aGUgYXVkaW8gZ3JvdXAgdGFnLFxuICAgIC8vIGFuZCB0aGlzIGlzIG5vdCBhbiBhdWRpby1vbmx5IHN0cmVhbSB3aGVyZSBsZXZlbHMgY29udGFpbiBhdWRpby1vbmx5XG4gICAgY29uc3QgYXVkaW9Pbmx5ID0gYXVkaW9Db2RlY0ZvdW5kICYmICF2aWRlb0NvZGVjRm91bmQ7XG4gICAgY29uc3QgZWRhdGEgPSB7XG4gICAgICBsZXZlbHMsXG4gICAgICBhdWRpb1RyYWNrcyxcbiAgICAgIHN1YnRpdGxlVHJhY2tzLFxuICAgICAgc2Vzc2lvbkRhdGE6IGRhdGEuc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5czogZGF0YS5zZXNzaW9uS2V5cyxcbiAgICAgIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsXG4gICAgICBzdGF0czogZGF0YS5zdGF0cyxcbiAgICAgIGF1ZGlvOiBhdWRpb0NvZGVjRm91bmQsXG4gICAgICB2aWRlbzogdmlkZW9Db2RlY0ZvdW5kLFxuICAgICAgYWx0QXVkaW86ICFhdWRpb09ubHkgJiYgYXVkaW9UcmFja3Muc29tZSh0ID0+ICEhdC51cmwpXG4gICAgfTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIGVkYXRhKTtcblxuICAgIC8vIEluaXRpYXRlIGxvYWRpbmcgYWZ0ZXIgYWxsIGNvbnRyb2xsZXJzIGhhdmUgcmVjZWl2ZWQgTUFOSUZFU1RfUEFSU0VEXG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hdXRvU3RhcnRMb2FkIHx8IHRoaXMuaGxzLmZvcmNlU3RhcnRMb2FkKSB7XG4gICAgICB0aGlzLmhscy5zdGFydExvYWQodGhpcy5obHMuY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuICBnZXQgbGV2ZWxzKCkge1xuICAgIGlmICh0aGlzLl9sZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xldmVscztcbiAgfVxuICBnZXQgbGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gIH1cbiAgc2V0IGxldmVsKG5ld0xldmVsKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuICAgIGlmIChsZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdMZXZlbCA8IDAgfHwgbmV3TGV2ZWwgPj0gbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgLy8gaW52YWxpZCBsZXZlbCBpZCBnaXZlbiwgdHJpZ2dlciBlcnJvclxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ2ludmFsaWQgbGV2ZWwgaWR4Jyk7XG4gICAgICBjb25zdCBmYXRhbCA9IG5ld0xldmVsIDwgMDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1IsXG4gICAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgICAgZmF0YWwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5ld0xldmVsID0gTWF0aC5taW4obmV3TGV2ZWwsIGxldmVscy5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgIGNvbnN0IGxhc3RMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgIGNvbnN0IGxhc3RQYXRod2F5SWQgPSBsYXN0TGV2ZWwgPyBsYXN0TGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF07XG4gICAgY29uc3QgcGF0aHdheUlkID0gbGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXTtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICBpZiAobGFzdExldmVsSW5kZXggPT09IG5ld0xldmVsICYmIGxldmVsLmRldGFpbHMgJiYgbGFzdExldmVsICYmIGxhc3RQYXRod2F5SWQgPT09IHBhdGh3YXlJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgU3dpdGNoaW5nIHRvIGxldmVsICR7bmV3TGV2ZWx9JHtwYXRod2F5SWQgPyAnIHdpdGggUGF0aHdheSAnICsgcGF0aHdheUlkIDogJyd9IGZyb20gbGV2ZWwgJHtsYXN0TGV2ZWxJbmRleH0ke2xhc3RQYXRod2F5SWQgPyAnIHdpdGggUGF0aHdheSAnICsgbGFzdFBhdGh3YXlJZCA6ICcnfWApO1xuICAgIGNvbnN0IGxldmVsU3dpdGNoaW5nRGF0YSA9IF9leHRlbmRzKHt9LCBsZXZlbCwge1xuICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgbWF4Qml0cmF0ZTogbGV2ZWwubWF4Qml0cmF0ZSxcbiAgICAgIGF0dHJzOiBsZXZlbC5hdHRycyxcbiAgICAgIHVyaTogbGV2ZWwudXJpLFxuICAgICAgdXJsSWQ6IGxldmVsLnVybElkXG4gICAgfSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGRlbGV0ZSBsZXZlbFN3aXRjaGluZ0RhdGEuX2F0dHJzO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBkZWxldGUgbGV2ZWxTd2l0Y2hpbmdEYXRhLl91cmxJZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIGxldmVsU3dpdGNoaW5nRGF0YSk7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgY29uc3QgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKGxldmVsLnVyaSwgbGFzdExldmVsID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TGV2ZWwuZGV0YWlscyk7XG4gICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gIH1cbiAgc2V0IG1hbnVhbExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9XG4gIGdldCBmaXJzdExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICB9XG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIC8vIGhscy5zdGFydExldmVsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjb25maWcuc3RhcnRMZXZlbFxuICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgdmFsdWVzIGFyZSBkZWZpbmVkLCBmYWxsYmFjayBvbiB0aGlzLl9maXJzdExldmVsIChmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiB2YXJpYW50IG1hbmlmZXN0KVxuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1N0YXJ0TGV2ZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XG4gICAgfVxuICB9XG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCAmJiBkYXRhLmNvbnRleHQubGV2ZWwgPT09IHRoaXMubGV2ZWwpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICB9XG4gIH1cblxuICAvLyByZXNldCBlcnJvcnMgb24gdGhlIHN1Y2Nlc3NmdWwgbG9hZCBvZiBhIGZyYWdtZW50XG4gIG9uRnJhZ0xvYWRlZChldmVudCwge1xuICAgIGZyYWdcbiAgfSkge1xuICAgIGlmIChmcmFnICE9PSB1bmRlZmluZWQgJiYgZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMjtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbCxcbiAgICAgIGRldGFpbHNcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBjdXJMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG4gICAgaWYgKCFjdXJMZXZlbCkge1xuICAgICAgdmFyIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTtcbiAgICAgIHRoaXMud2FybihgSW52YWxpZCBsZXZlbCBpbmRleCAke2xldmVsfWApO1xuICAgICAgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT0gbnVsbCAmJiBfZGF0YSRkZWxpdmVyeURpcmVjdGkuc2tpcCkge1xuICAgICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsXG4gICAgaWYgKGxldmVsID09PSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4KSB7XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICAgIGlmIChjdXJMZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGxldmVsLCBkYXRhLCBjdXJMZXZlbC5kZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkyID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMpICE9IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMi5za2lwKSB7XG4gICAgICAvLyByZWNlaXZlZCBhIGRlbHRhIHBsYXlsaXN0IHVwZGF0ZSB0aGF0IGNhbm5vdCBiZSBtZXJnZWRcbiAgICAgIGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgIGlmICghY3VycmVudExldmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvR3JvdXBJZCA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2RhdGEuaWRdLmdyb3VwSWQ7XG4gICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzICYmIGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWQgIT09IGF1ZGlvR3JvdXBJZCkge1xuICAgICAgbGV0IHVybElkID0gLTE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkc1tpXSA9PT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgdXJsSWQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXJsSWQgIT09IC0xICYmIHVybElkICE9PSBjdXJyZW50TGV2ZWwudXJsSWQpIHtcbiAgICAgICAgY3VycmVudExldmVsLnVybElkID0gdXJsSWQ7XG4gICAgICAgIGlmICh0aGlzLmNhbkxvYWQpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCk7XG4gICAgY29uc3QgY3VycmVudExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgIGlmIChjdXJyZW50TGV2ZWwgJiYgdGhpcy5zaG91bGRMb2FkUGxheWxpc3QoY3VycmVudExldmVsKSkge1xuICAgICAgY29uc3QgaWQgPSBjdXJyZW50TGV2ZWwudXJsSWQ7XG4gICAgICBsZXQgdXJsID0gY3VycmVudExldmVsLnVyaTtcbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGF0aHdheUlkID0gY3VycmVudExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgICB0aGlzLmxvZyhgTG9hZGluZyBsZXZlbCBpbmRleCAke2N1cnJlbnRMZXZlbEluZGV4fSR7KGhsc1VybFBhcmFtZXRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhsc1VybFBhcmFtZXRlcnMubXNuKSAhPT0gdW5kZWZpbmVkID8gJyBhdCBzbiAnICsgaGxzVXJsUGFyYW1ldGVycy5tc24gKyAnIHBhcnQgJyArIGhsc1VybFBhcmFtZXRlcnMucGFydCA6ICcnfSB3aXRoJHtwYXRod2F5SWQgPyAnIFBhdGh3YXkgJyArIHBhdGh3YXlJZCA6ICcnfSBVUkkgJHtpZCArIDF9LyR7Y3VycmVudExldmVsLnVybC5sZW5ndGh9ICR7dXJsfWApO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdOZXcgdmlkZW8gcXVhbGl0eSBsZXZlbCBhdWRpbyBncm91cCBpZDonLCBsZXZlbE9iamVjdC5hdHRycy5BVURJTywgbGV2ZWwpO1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbEluZGV4LFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG4gIHNldCBuZXh0TG9hZExldmVsKG5leHRMZXZlbCkge1xuICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxldmVsKGxldmVsSW5kZXgsIHVybElkKSB7XG4gICAgY29uc3QgZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCA9ICh1cmwsIGlkKSA9PiBpZCAhPT0gdXJsSWQ7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggIT09IGxldmVsSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwudXJsLmxlbmd0aCA+IDEgJiYgdXJsSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbC51cmwgPSBsZXZlbC51cmwuZmlsdGVyKGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXgpO1xuICAgICAgICBpZiAobGV2ZWwuYXVkaW9Hcm91cElkcykge1xuICAgICAgICAgIGxldmVsLmF1ZGlvR3JvdXBJZHMgPSBsZXZlbC5hdWRpb0dyb3VwSWRzLmZpbHRlcihmaWx0ZXJMZXZlbEFuZEdyb3VwQnlJZEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwudGV4dEdyb3VwSWRzKSB7XG4gICAgICAgICAgbGV2ZWwudGV4dEdyb3VwSWRzID0gbGV2ZWwudGV4dEdyb3VwSWRzLmZpbHRlcihmaWx0ZXJMZXZlbEFuZEdyb3VwQnlJZEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgICAgdGhpcy5zdGVlcmluZy5yZW1vdmVMZXZlbChsZXZlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxTX1VQREFURUQsIHtcbiAgICAgIGxldmVsc1xuICAgIH0pO1xuICB9XG4gIG9uTGV2ZWxzVXBkYXRlZChldmVudCwge1xuICAgIGxldmVsc1xuICB9KSB7XG4gICAgbGV2ZWxzLmZvckVhY2goKGxldmVsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkZXRhaWxzXG4gICAgICB9ID0gbGV2ZWw7XG4gICAgICBpZiAoZGV0YWlscyAhPSBudWxsICYmIGRldGFpbHMuZnJhZ21lbnRzKSB7XG4gICAgICAgIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgICAgIGZyYWdtZW50LmxldmVsID0gaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgfVxufVxuZnVuY3Rpb24gYWRkR3JvdXBJZChsZXZlbCwgdHlwZSwgaWQpIHtcbiAgaWYgKCFpZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgIGlmICghbGV2ZWwuYXVkaW9Hcm91cElkcykge1xuICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcyA9IFtdO1xuICAgIH1cbiAgICBsZXZlbC5hdWRpb0dyb3VwSWRzW2xldmVsLnVybC5sZW5ndGggLSAxXSA9IGlkO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGlmICghbGV2ZWwudGV4dEdyb3VwSWRzKSB7XG4gICAgICBsZXZlbC50ZXh0R3JvdXBJZHMgPSBbXTtcbiAgICB9XG4gICAgbGV2ZWwudGV4dEdyb3VwSWRzW2xldmVsLnVybC5sZW5ndGggLSAxXSA9IGlkO1xuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25UcmFja0lkc0J5R3JvdXAodHJhY2tzKSB7XG4gIGNvbnN0IGdyb3VwcyA9IHt9O1xuICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgY29uc3QgZ3JvdXBJZCA9IHRyYWNrLmdyb3VwSWQgfHwgJyc7XG4gICAgdHJhY2suaWQgPSBncm91cHNbZ3JvdXBJZF0gPSBncm91cHNbZ3JvdXBJZF0gfHwgMDtcbiAgICBncm91cHNbZ3JvdXBJZF0rKztcbiAgfSk7XG59XG5cbnZhciBGcmFnbWVudFN0YXRlID0ge1xuICBOT1RfTE9BREVEOiBcIk5PVF9MT0FERURcIixcbiAgQVBQRU5ESU5HOiBcIkFQUEVORElOR1wiLFxuICBQQVJUSUFMOiBcIlBBUlRJQUxcIixcbiAgT0s6IFwiT0tcIlxufTtcbmNsYXNzIEZyYWdtZW50VHJhY2tlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc0dhcHMgPSBmYWxzZTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5mcmFnbWVudHMgPVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IHRoaXMudGltZVJhbmdlcyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgb3IgUGFydCB3aXRoIGFuIGFwcGVuZGVkIHJhbmdlIHRoYXQgbWF0Y2hlcyB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZVxuICAgKiBPdGhlcndpc2UsIHJldHVybiBudWxsXG4gICAqL1xuICBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVQYXJ0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY29uc3QgYWN0aXZlUGFydCA9IGFjdGl2ZVBhcnRzW2ldO1xuICAgICAgICBpZiAoIWFjdGl2ZVBhcnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRlZFBUUyA9IGFjdGl2ZVBhcnQuZW5kO1xuICAgICAgICBpZiAoYWN0aXZlUGFydC5zdGFydCA8PSBwb3NpdGlvbiAmJiBhcHBlbmRlZFBUUyAhPT0gbnVsbCAmJiBwb3NpdGlvbiA8PSBhcHBlbmRlZFBUUykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVQYXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBidWZmZXJlZCBGcmFnbWVudCB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIEEgYnVmZmVyZWQgRnJhZ21lbnQgaXMgb25lIHdob3NlIGxvYWRpbmcsIHBhcnNpbmcgYW5kIGFwcGVuZGluZyBpcyBkb25lIChjb21wbGV0ZWQgb3IgXCJwYXJ0aWFsXCIgbWVhbmluZyBhYm9ydGVkKS5cbiAgICogSWYgbm90IGZvdW5kIGFueSBGcmFnbWVudCwgcmV0dXJuIG51bGxcbiAgICovXG4gIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cyk7XG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXlzW2ldXTtcbiAgICAgIGlmICgoZnJhZ21lbnRFbnRpdHkgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSkgPT09IGxldmVsVHlwZSAmJiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgaWYgKGZyYWcuc3RhcnQgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZnJhZy5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsIGZyYWdtZW50cyBlZmZlY3RlZCBieSBjb2RlZCBmcmFtZSBldmljdGlvbiB3aWxsIGJlIHJlbW92ZWRcbiAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXG4gICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgKi9cbiAgZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UsIHBsYXlsaXN0VHlwZSwgYXBwZW5kZWRQYXJ0KSB7XG4gICAgaWYgKHRoaXMudGltZVJhbmdlcykge1xuICAgICAgdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dID0gdGltZVJhbmdlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbnkgZmxhZ2dlZCBmcmFnbWVudHMgaGF2ZSBiZWVuIHVubG9hZGVkXG4gICAgLy8gZXhjbHVkaW5nIGFueXRoaW5nIG5ld2VyIHRoYW4gYXBwZW5kZWRQYXJ0U25cbiAgICBjb25zdCBhcHBlbmRlZFBhcnRTbiA9IChhcHBlbmRlZFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVuZGVkUGFydC5mcmFnbWVudC5zbikgfHwgLTE7XG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGFwcGVuZGVkUGFydFNuID49IGZyYWdtZW50RW50aXR5LmJvZHkuc24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiAhZnJhZ21lbnRFbnRpdHkubG9hZGVkKSB7XG4gICAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUgPT09IHBsYXlsaXN0VHlwZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICBpZiAoIWVzRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlc0RhdGEudGltZS5zb21lKHRpbWUgPT4ge1xuICAgICAgICBjb25zdCBpc05vdEJ1ZmZlcmVkID0gIXRoaXMuaXNUaW1lQnVmZmVyZWQodGltZS5zdGFydFBUUywgdGltZS5lbmRQVFMsIHRpbWVSYW5nZSk7XG4gICAgICAgIGlmIChpc05vdEJ1ZmZlcmVkKSB7XG4gICAgICAgICAgLy8gVW5yZWdpc3RlciBwYXJ0aWFsIGZyYWdtZW50IGFzIGl0IG5lZWRzIHRvIGxvYWQgYWdhaW4gdG8gYmUgcmV1c2VkXG4gICAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOb3RCdWZmZXJlZDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZnJhZ21lbnQgcGFzc2VkIGluIGlzIGxvYWRlZCBpbiB0aGUgYnVmZmVyIHByb3Blcmx5XG4gICAqIFBhcnRpYWxseSBsb2FkZWQgZnJhZ21lbnRzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICovXG4gIGRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSkge1xuICAgIGNvbnN0IHRpbWVSYW5nZXMgPSB0aGlzLnRpbWVSYW5nZXM7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIXRpbWVSYW5nZXMgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoIWZyYWdtZW50RW50aXR5IHx8IGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkICYmIGZyYWcuZ2FwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzRnJhZ0hpbnQgPSAhZnJhZy5yZWx1cmw7XG4gICAgT2JqZWN0LmtleXModGltZVJhbmdlcykuZm9yRWFjaChlbGVtZW50YXJ5U3RyZWFtID0+IHtcbiAgICAgIGNvbnN0IHN0cmVhbUluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgaWYgKCFzdHJlYW1JbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICBjb25zdCBwYXJ0aWFsID0gaXNGcmFnSGludCB8fCBzdHJlYW1JbmZvLnBhcnRpYWwgPT09IHRydWU7XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXSA9IHRoaXMuZ2V0QnVmZmVyZWRUaW1lcyhmcmFnLCBwYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpO1xuICAgIH0pO1xuICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgaWYgKE9iamVjdC5rZXlzKGZyYWdtZW50RW50aXR5LnJhbmdlKS5sZW5ndGgpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGVuZExpc3QgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZExpc3QgPSBmcmFnLmVuZExpc3QgfHwgZnJhZ21lbnRFbnRpdHkuYm9keS5lbmRMaXN0O1xuICAgICAgaWYgKGVuZExpc3QpIHtcbiAgICAgICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50RW50aXR5LmJvZHkudHlwZV0gPSBmcmFnbWVudEVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICAvLyBSZW1vdmUgb2xkZXIgZnJhZ21lbnQgcGFydHMgZnJvbSBsb29rdXAgYWZ0ZXIgZnJhZyBpcyB0cmFja2VkIGFzIGJ1ZmZlcmVkXG4gICAgICAgIHRoaXMucmVtb3ZlUGFydHMoZnJhZy5zbiAtIDEsIGZyYWcudHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBmcmFnbWVudCBpZiBub3RoaW5nIHdhcyBhcHBlbmRlZFxuICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlUGFydHMoc25Ub0tlZXAsIGxldmVsVHlwZSkge1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV0gPSBhY3RpdmVQYXJ0cy5maWx0ZXIocGFydCA9PiBwYXJ0LmZyYWdtZW50LnNuID49IHNuVG9LZWVwKTtcbiAgfVxuICBmcmFnQnVmZmVyZWQoZnJhZywgZm9yY2UpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgbGV0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSAmJiBmb3JjZSkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSA9IHtcbiAgICAgICAgYm9keTogZnJhZyxcbiAgICAgICAgYXBwZW5kZWRQVFM6IG51bGwsXG4gICAgICAgIGxvYWRlZDogbnVsbCxcbiAgICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgfTtcbiAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICB0aGlzLmhhc0dhcHMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGdldEJ1ZmZlcmVkVGltZXMoZnJhZ21lbnQsIHBhcnQsIHBhcnRpYWwsIHRpbWVSYW5nZSkge1xuICAgIGNvbnN0IGJ1ZmZlcmVkID0ge1xuICAgICAgdGltZTogW10sXG4gICAgICBwYXJ0aWFsXG4gICAgfTtcbiAgICBjb25zdCBzdGFydFBUUyA9IGZyYWdtZW50LnN0YXJ0O1xuICAgIGNvbnN0IGVuZFBUUyA9IGZyYWdtZW50LmVuZDtcbiAgICBjb25zdCBtaW5FbmRQVFMgPSBmcmFnbWVudC5taW5FbmRQVFMgfHwgZW5kUFRTO1xuICAgIGNvbnN0IG1heFN0YXJ0UFRTID0gZnJhZ21lbnQubWF4U3RhcnRQVFMgfHwgc3RhcnRQVFM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKG1heFN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBtaW5FbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICAvLyBGcmFnbWVudCBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gYnVmZmVyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyIHRpbWVSYW5nZSB0aW1lcyBzaW5jZSBpdCdzIGNvbXBsZXRlbHkgcGxheWFibGVcbiAgICAgICAgYnVmZmVyZWQudGltZS5wdXNoKHtcbiAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRQVFMgPCBlbmRUaW1lICYmIGVuZFBUUyA+IHN0YXJ0VGltZSkge1xuICAgICAgICBidWZmZXJlZC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoIGJ1ZmZlclxuICAgICAgICAvLyBHZXQgcGxheWFibGUgc2VjdGlvbnMgb2YgdGhlIGZyYWdtZW50XG4gICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvciBhIGNlcnRhaW4gdGltZVxuICAgKi9cbiAgZ2V0UGFydGlhbEZyYWdtZW50KHRpbWUpIHtcbiAgICBsZXQgYmVzdEZyYWdtZW50ID0gbnVsbDtcbiAgICBsZXQgdGltZVBhZGRpbmc7XG4gICAgbGV0IHN0YXJ0VGltZTtcbiAgICBsZXQgZW5kVGltZTtcbiAgICBsZXQgYmVzdE92ZXJsYXAgPSAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1ZmZlclBhZGRpbmcsXG4gICAgICBmcmFnbWVudHNcbiAgICB9ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhmcmFnbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuc3RhcnQgLSBidWZmZXJQYWRkaW5nO1xuICAgICAgICBlbmRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5lbmQgKyBidWZmZXJQYWRkaW5nO1xuICAgICAgICBpZiAodGltZSA+PSBzdGFydFRpbWUgJiYgdGltZSA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBmcmFnbWVudCB0aGF0IGhhcyB0aGUgbW9zdCBwYWRkaW5nIGZyb20gc3RhcnQgYW5kIGVuZCB0aW1lXG4gICAgICAgICAgdGltZVBhZGRpbmcgPSBNYXRoLm1pbih0aW1lIC0gc3RhcnRUaW1lLCBlbmRUaW1lIC0gdGltZSk7XG4gICAgICAgICAgaWYgKGJlc3RPdmVybGFwIDw9IHRpbWVQYWRkaW5nKSB7XG4gICAgICAgICAgICBiZXN0RnJhZ21lbnQgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICAgICAgYmVzdE92ZXJsYXAgPSB0aW1lUGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYmVzdEZyYWdtZW50O1xuICB9XG4gIGlzRW5kTGlzdEFwcGVuZGVkKHR5cGUpIHtcbiAgICBjb25zdCBsYXN0RnJhZ21lbnRFbnRpdHkgPSB0aGlzLmVuZExpc3RGcmFnbWVudHNbdHlwZV07XG4gICAgcmV0dXJuIGxhc3RGcmFnbWVudEVudGl0eSAhPT0gdW5kZWZpbmVkICYmIChsYXN0RnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgfHwgaXNQYXJ0aWFsKGxhc3RGcmFnbWVudEVudGl0eSkpO1xuICB9XG4gIGdldFN0YXRlKGZyYWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkc7XG4gICAgICB9IGVsc2UgaWYgKGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuUEFSVElBTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLk9LO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEO1xuICB9XG4gIGlzVGltZUJ1ZmZlcmVkKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xuICAgIGxldCBzdGFydFRpbWU7XG4gICAgbGV0IGVuZFRpbWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBvbkZyYWdMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0gPSBkYXRhO1xuICAgIC8vIGRvbid0IHRyYWNrIGluaXRzZWdtZW50IChmb3Igd2hpY2ggc24gaXMgbm90IGEgbnVtYmVyKVxuICAgIC8vIGRvbid0IHRyYWNrIGZyYWdzIHVzZWQgZm9yIGJpdHJhdGVUZXN0LCB0aGV5J3JlIGlycmVsZXZhbnQuXG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgfHwgZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZyYWdtZW50IGVudGl0eSBgbG9hZGVkYCBGcmFnTG9hZGVkRGF0YSBpcyBudWxsIHdoZW4gbG9hZGluZyBwYXJ0c1xuICAgIGNvbnN0IGxvYWRlZCA9IHBhcnQgPyBudWxsIDogZGF0YTtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gPSB7XG4gICAgICBib2R5OiBmcmFnLFxuICAgICAgYXBwZW5kZWRQVFM6IG51bGwsXG4gICAgICBsb2FkZWQsXG4gICAgICBidWZmZXJlZDogZmFsc2UsXG4gICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gIH1cbiAgb25CdWZmZXJBcHBlbmRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgdGltZVJhbmdlc1xuICAgIH0gPSBkYXRhO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGZyYWcudHlwZTtcbiAgICBpZiAocGFydCkge1xuICAgICAgbGV0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbcGxheWxpc3RUeXBlXTtcbiAgICAgIGlmICghYWN0aXZlUGFydHMpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbcGxheWxpc3RUeXBlXSA9IGFjdGl2ZVBhcnRzID0gW107XG4gICAgICB9XG4gICAgICBhY3RpdmVQYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICAvLyBTdG9yZSB0aGUgbGF0ZXN0IHRpbWVSYW5nZXMgbG9hZGVkIGluIHRoZSBidWZmZXJcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSB0aW1lUmFuZ2VzO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goZWxlbWVudGFyeVN0cmVhbSA9PiB7XG4gICAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgdGhpcy5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSwgcGxheWxpc3RUeXBlLCBwYXJ0KTtcbiAgICB9KTtcbiAgfVxuICBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhkYXRhKTtcbiAgfVxuICBoYXNGcmFnbWVudChmcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgcmV0dXJuICEhdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gIH1cbiAgaGFzUGFydHModHlwZSkge1xuICAgIHZhciBfdGhpcyRhY3RpdmVQYXJ0TGlzdHM7XG4gICAgcmV0dXJuICEhKChfdGhpcyRhY3RpdmVQYXJ0TGlzdHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1t0eXBlXSkgIT0gbnVsbCAmJiBfdGhpcyRhY3RpdmVQYXJ0TGlzdHMubGVuZ3RoKTtcbiAgfVxuICByZW1vdmVGcmFnbWVudHNJblJhbmdlKHN0YXJ0LCBlbmQsIHBsYXlsaXN0VHlwZSwgd2l0aEdhcE9ubHksIHVuYnVmZmVyZWRPbmx5KSB7XG4gICAgaWYgKHdpdGhHYXBPbmx5ICYmICF0aGlzLmhhc0dhcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhZyA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICBpZiAoZnJhZy50eXBlICE9PSBwbGF5bGlzdFR5cGUgfHwgd2l0aEdhcE9ubHkgJiYgIWZyYWcuZ2FwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLnN0YXJ0IDwgZW5kICYmIGZyYWcuZW5kID4gc3RhcnQgJiYgKGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkIHx8IHVuYnVmZmVyZWRPbmx5KSkge1xuICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlbW92ZUZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBmcmFnbWVudC5zdGF0cy5sb2FkZWQgPSAwO1xuICAgIGZyYWdtZW50LmNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8oKTtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2ZyYWdtZW50LnR5cGVdO1xuICAgIGlmIChhY3RpdmVQYXJ0cykge1xuICAgICAgY29uc3Qgc25Ub1JlbW92ZSA9IGZyYWdtZW50LnNuO1xuICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZnJhZ21lbnQudHlwZV0gPSBhY3RpdmVQYXJ0cy5maWx0ZXIocGFydCA9PiBwYXJ0LmZyYWdtZW50LnNuICE9PSBzblRvUmVtb3ZlKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmIChmcmFnbWVudC5lbmRMaXN0KSB7XG4gICAgICBkZWxldGUgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50LnR5cGVdO1xuICAgIH1cbiAgfVxuICByZW1vdmVBbGxGcmFnbWVudHMoKSB7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuaGFzR2FwcyA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpIHtcbiAgdmFyIF9mcmFnbWVudEVudGl0eSRyYW5nZSwgX2ZyYWdtZW50RW50aXR5JHJhbmdlMiwgX2ZyYWdtZW50RW50aXR5JHJhbmdlMztcbiAgcmV0dXJuIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkICYmIChmcmFnbWVudEVudGl0eS5ib2R5LmdhcCB8fCAoKF9mcmFnbWVudEVudGl0eSRyYW5nZSA9IGZyYWdtZW50RW50aXR5LnJhbmdlLnZpZGVvKSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWdtZW50RW50aXR5JHJhbmdlLnBhcnRpYWwpIHx8ICgoX2ZyYWdtZW50RW50aXR5JHJhbmdlMiA9IGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvKSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWdtZW50RW50aXR5JHJhbmdlMi5wYXJ0aWFsKSB8fCAoKF9mcmFnbWVudEVudGl0eSRyYW5nZTMgPSBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpb3ZpZGVvKSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWdtZW50RW50aXR5JHJhbmdlMy5wYXJ0aWFsKSk7XG59XG5mdW5jdGlvbiBnZXRGcmFnbWVudEtleShmcmFnbWVudCkge1xuICByZXR1cm4gYCR7ZnJhZ21lbnQudHlwZX1fJHtmcmFnbWVudC5sZXZlbH1fJHtmcmFnbWVudC51cmxJZH1fJHtmcmFnbWVudC5zbn1gO1xufVxuXG5jb25zdCBNSU5fQ0hVTktfU0laRSA9IE1hdGgucG93KDIsIDE3KTsgLy8gMTI4a2JcblxuY2xhc3MgRnJhZ21lbnRMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5wYXJ0TG9hZFRpbWVvdXQgPSAtMTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBhYm9ydCgpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIC8vIEFib3J0IHRoZSBsb2FkZXIgZm9yIGN1cnJlbnQgZnJhZ21lbnQuIE9ubHkgb25lIG1heSBsb2FkIGF0IGFueSBnaXZlbiB0aW1lXG4gICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgfVxuICBsb2FkKGZyYWcsIG9uUHJvZ3Jlc3MpIHtcbiAgICBjb25zdCB1cmwgPSBmcmFnLnVybDtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgRnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBhICR7dXJsID8gJ3BhcnQgbGlzdCcgOiAndXJsJ31gKSxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIGNvbnN0IERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICBpZiAoZnJhZy50YWdMaXN0LnNvbWUodGFncyA9PiB0YWdzWzBdID09PSAnR0FQJykpIHtcbiAgICAgICAgICByZWplY3QoY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGVtcG9yYXJ5IHRyZWF0bWVudCBhcyBHQVAgdGFnXG4gICAgICAgICAgZnJhZy5nYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXIgPSBmcmFnLmxvYWRlciA9IEZyYWdtZW50SUxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZyk7XG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCk7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDAsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgPyBJbmZpbml0eSA6IE1JTl9DSFVOS19TSVpFXG4gICAgICB9O1xuICAgICAgLy8gQXNzaWduIGZyYWcgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuICAgICAgZnJhZy5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIGxldCBwYXlsb2FkID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICBpZiAoY29udGV4dC5yZXNldElWICYmIGZyYWcuZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgICAgIGZyYWcuZGVjcnlwdGRhdGEuaXYgPSBuZXcgVWludDhBcnJheShwYXlsb2FkLnNsaWNlKDAsIDE2KSk7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5zbGljZSgxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICByZXNwb25zZTogX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgSFRUUCBFcnJvciAke3Jlc3BvbnNlLmNvZGV9ICR7cmVzcG9uc2UudGV4dH1gKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignQWJvcnRlZCcpLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBUaW1lb3V0IGFmdGVyICR7bG9hZGVyQ29uZmlnLnRpbWVvdXR9bXNgKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IChzdGF0cywgY29udGV4dCwgZGF0YSwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGxvYWRQYXJ0KGZyYWcsIHBhcnQsIG9uUHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmFib3J0KCk7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXI7XG4gICAgY29uc3QgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcuZ2FwIHx8IHBhcnQuZ2FwKSB7XG4gICAgICAgIHJlamVjdChjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZywgcGFydCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlciA9IGZyYWcubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnLCBwYXJ0KTtcbiAgICAgIC8vIFNob3VsZCB3ZSBkZWZpbmUgYW5vdGhlciBsb2FkIHBvbGljeSBmb3IgcGFydHM/XG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCk7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDAsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IE1JTl9DSFVOS19TSVpFXG4gICAgICB9O1xuICAgICAgLy8gQXNzaWduIHBhcnQgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuICAgICAgcGFydC5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KTtcbiAgICAgICAgICBjb25zdCBwYXJ0TG9hZGVkRGF0YSA9IHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBvblByb2dyZXNzKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICByZXNvbHZlKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LCByZXNwb25zZSksXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gJHtyZXNwb25zZS50ZXh0fWApLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIGZyYWcuc3RhdHMuYWJvcnRlZCA9IHBhcnQuc3RhdHMuYWJvcnRlZDtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0Fib3J0ZWQnKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYFRpbWVvdXQgYWZ0ZXIgJHtsb2FkZXJDb25maWcudGltZW91dH1tc2ApLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KSB7XG4gICAgY29uc3QgZnJhZ1N0YXRzID0gZnJhZy5zdGF0cztcbiAgICBjb25zdCBwYXJ0U3RhdHMgPSBwYXJ0LnN0YXRzO1xuICAgIGNvbnN0IHBhcnRUb3RhbCA9IHBhcnRTdGF0cy50b3RhbDtcbiAgICBmcmFnU3RhdHMubG9hZGVkICs9IHBhcnRTdGF0cy5sb2FkZWQ7XG4gICAgaWYgKHBhcnRUb3RhbCkge1xuICAgICAgY29uc3QgZXN0VG90YWxQYXJ0cyA9IE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAvIHBhcnQuZHVyYXRpb24pO1xuICAgICAgY29uc3QgZXN0TG9hZGVkUGFydHMgPSBNYXRoLm1pbihNYXRoLnJvdW5kKGZyYWdTdGF0cy5sb2FkZWQgLyBwYXJ0VG90YWwpLCBlc3RUb3RhbFBhcnRzKTtcbiAgICAgIGNvbnN0IGVzdFJlbWFpbmluZ1BhcnRzID0gZXN0VG90YWxQYXJ0cyAtIGVzdExvYWRlZFBhcnRzO1xuICAgICAgY29uc3QgZXN0UmVtYWluaW5nQnl0ZXMgPSBlc3RSZW1haW5pbmdQYXJ0cyAqIE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIGVzdExvYWRlZFBhcnRzKTtcbiAgICAgIGZyYWdTdGF0cy50b3RhbCA9IGZyYWdTdGF0cy5sb2FkZWQgKyBlc3RSZW1haW5pbmdCeXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1N0YXRzLnRvdGFsID0gTWF0aC5tYXgoZnJhZ1N0YXRzLmxvYWRlZCwgZnJhZ1N0YXRzLnRvdGFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJhZ0xvYWRpbmcgPSBmcmFnU3RhdHMubG9hZGluZztcbiAgICBjb25zdCBwYXJ0TG9hZGluZyA9IHBhcnRTdGF0cy5sb2FkaW5nO1xuICAgIGlmIChmcmFnTG9hZGluZy5zdGFydCkge1xuICAgICAgLy8gYWRkIHRvIGZyYWdtZW50IGxvYWRlciBsYXRlbmN5XG4gICAgICBmcmFnTG9hZGluZy5maXJzdCArPSBwYXJ0TG9hZGluZy5maXJzdCAtIHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnTG9hZGluZy5zdGFydCA9IHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgPSBwYXJ0TG9hZGluZy5maXJzdDtcbiAgICB9XG4gICAgZnJhZ0xvYWRpbmcuZW5kID0gcGFydExvYWRpbmcuZW5kO1xuICB9XG4gIHJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcikge1xuICAgIGZyYWcubG9hZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5sb2FkZXIgPT09IGxvYWRlcikge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5wYXJ0TG9hZFRpbWVvdXQpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgICBsb2FkZXIuZGVzdHJveSgpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQgPSBudWxsKSB7XG4gIGNvbnN0IHNlZ21lbnQgPSBwYXJ0IHx8IGZyYWc7XG4gIGNvbnN0IGxvYWRlckNvbnRleHQgPSB7XG4gICAgZnJhZyxcbiAgICBwYXJ0LFxuICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICB1cmw6IHNlZ21lbnQudXJsLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgcmFuZ2VFbmQ6IDBcbiAgfTtcbiAgY29uc3Qgc3RhcnQgPSBzZWdtZW50LmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICBjb25zdCBlbmQgPSBzZWdtZW50LmJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0KSAmJiBpc0Zpbml0ZU51bWJlcihlbmQpKSB7XG4gICAgdmFyIF9mcmFnJGRlY3J5cHRkYXRhO1xuICAgIGxldCBieXRlUmFuZ2VTdGFydCA9IHN0YXJ0O1xuICAgIGxldCBieXRlUmFuZ2VFbmQgPSBlbmQ7XG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgJiYgKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRkZWNyeXB0ZGF0YS5tZXRob2QpID09PSAnQUVTLTEyOCcpIHtcbiAgICAgIC8vIE1BUCBzZWdtZW50IGVuY3J5cHRlZCB3aXRoIG1ldGhvZCAnQUVTLTEyOCcsIHdoZW4gc2VydmVkIHdpdGggSFRUUCBSYW5nZSxcbiAgICAgIC8vIGhhcyB0aGUgdW5lbmNyeXB0ZWQgc2l6ZSBzcGVjaWZpZWQgaW4gdGhlIHJhbmdlLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWhscy1yZmM4MjE2YmlzLTA4I3NlY3Rpb24tNi4zLjZcbiAgICAgIGNvbnN0IGZyYWdtZW50TGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICBpZiAoZnJhZ21lbnRMZW4gJSAxNikge1xuICAgICAgICBieXRlUmFuZ2VFbmQgPSBlbmQgKyAoMTYgLSBmcmFnbWVudExlbiAlIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gMCkge1xuICAgICAgICBsb2FkZXJDb250ZXh0LnJlc2V0SVYgPSB0cnVlO1xuICAgICAgICBieXRlUmFuZ2VTdGFydCA9IHN0YXJ0IC0gMTY7XG4gICAgICB9XG4gICAgfVxuICAgIGxvYWRlckNvbnRleHQucmFuZ2VTdGFydCA9IGJ5dGVSYW5nZVN0YXJ0O1xuICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBieXRlUmFuZ2VFbmQ7XG4gIH1cbiAgcmV0dXJuIGxvYWRlckNvbnRleHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZywgcGFydCkge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgR0FQICR7ZnJhZy5nYXAgPyAndGFnJyA6ICdhdHRyaWJ1dGUnfSBmb3VuZGApO1xuICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19HQVAsXG4gICAgZmF0YWw6IGZhbHNlLFxuICAgIGZyYWcsXG4gICAgZXJyb3IsXG4gICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgfTtcbiAgaWYgKHBhcnQpIHtcbiAgICBlcnJvckRhdGEucGFydCA9IHBhcnQ7XG4gIH1cbiAgKHBhcnQgPyBwYXJ0IDogZnJhZykuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gIHJldHVybiBuZXcgTG9hZEVycm9yKGVycm9yRGF0YSk7XG59XG5jbGFzcyBMb2FkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcihkYXRhLmVycm9yLm1lc3NhZ2UpO1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59XG5cbmNsYXNzIEtleUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMua2V5VXJpVG9LZXlJbmZvID0ge307XG4gICAgdGhpcy5lbWVDb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBhYm9ydCh0eXBlKSB7XG4gICAgZm9yIChjb25zdCB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0ubG9hZGVyO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBpZiAodHlwZSAmJiB0eXBlICE9PSBsb2FkZXIuY29udGV4dC5mcmFnLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRldGFjaCgpIHtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3Qga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgICAvLyBSZW1vdmUgY2FjaGVkIEVNRSBrZXlzIG9uIGRldGFjaFxuICAgICAgaWYgKGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dCB8fCBrZXlJbmZvLmRlY3J5cHRkYXRhLmlzQ29tbW9uRW5jcnlwdGlvbikge1xuICAgICAgICBkZWxldGUgdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdXJpIGluIHRoaXMua2V5VXJpVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5rZXlVcmlUb0tleUluZm8gPSB7fTtcbiAgfVxuICBjcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgZGV0YWlscyA9IEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZXJyb3IsIG5ldHdvcmtEZXRhaWxzLCByZXNwb25zZSkge1xuICAgIHJldHVybiBuZXcgTG9hZEVycm9yKHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHMsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBmcmFnLFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBlcnJvcixcbiAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgfSk7XG4gIH1cbiAgbG9hZENsZWFyKGxvYWRpbmdGcmFnLCBlbmNyeXB0ZWRGcmFnbWVudHMpIHtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIC8vIGFjY2VzcyBrZXktc3lzdGVtIHdpdGggbmVhcmVzdCBrZXkgb24gc3RhcnQgKGxvYWlkbmcgZnJhZyBpcyB1bmVuY3J5cHRlZClcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc24sXG4gICAgICAgIGNjXG4gICAgICB9ID0gbG9hZGluZ0ZyYWc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmcmFnID0gZW5jcnlwdGVkRnJhZ21lbnRzW2ldO1xuICAgICAgICBpZiAoY2MgPD0gZnJhZy5jYyAmJiAoc24gPT09ICdpbml0U2VnbWVudCcgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBzbiA8IGZyYWcuc24pKSB7XG4gICAgICAgICAgdGhpcy5lbWVDb250cm9sbGVyLnNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKS50aGVuKGtleVN5c3RlbUZvcm1hdCA9PiB7XG4gICAgICAgICAgICBmcmFnLnNldEtleUZvcm1hdChrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWQoZnJhZykge1xuICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSAmJiBmcmFnLmVuY3J5cHRlZCAmJiB0aGlzLmVtZUNvbnRyb2xsZXIpIHtcbiAgICAgIC8vIE11bHRpcGxlIGtleXMsIGJ1dCBub25lIHNlbGVjdGVkLCByZXNvbHZlIGluIGVtZS1jb250cm9sbGVyXG4gICAgICByZXR1cm4gdGhpcy5lbWVDb250cm9sbGVyLnNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKS50aGVuKGtleVN5c3RlbUZvcm1hdCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRJbnRlcm5hbChmcmFnLCBrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWRJbnRlcm5hbChmcmFnKTtcbiAgfVxuICBsb2FkSW50ZXJuYWwoZnJhZywga2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgdmFyIF9rZXlJbmZvLCBfa2V5SW5mbzI7XG4gICAgaWYgKGtleVN5c3RlbUZvcm1hdCkge1xuICAgICAgZnJhZy5zZXRLZXlGb3JtYXQoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGlmICghZGVjcnlwdGRhdGEpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGtleVN5c3RlbUZvcm1hdCA/IGBFeHBlY3RlZCBmcmFnLmRlY3J5cHRkYXRhIHRvIGJlIGRlZmluZWQgYWZ0ZXIgc2V0dGluZyBmb3JtYXQgJHtrZXlTeXN0ZW1Gb3JtYXR9YCA6ICdNaXNzaW5nIGRlY3J5cHRpb24gZGF0YSBvbiBmcmFnbWVudCBpbiBvbktleUxvYWRpbmcnKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGVycm9yKSk7XG4gICAgfVxuICAgIGNvbnN0IHVyaSA9IGRlY3J5cHRkYXRhLnVyaTtcbiAgICBpZiAoIXVyaSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBJbnZhbGlkIGtleSBVUkk6IFwiJHt1cml9XCJgKSkpO1xuICAgIH1cbiAgICBsZXQga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgaWYgKChfa2V5SW5mbyA9IGtleUluZm8pICE9IG51bGwgJiYgX2tleUluZm8uZGVjcnlwdGRhdGEua2V5KSB7XG4gICAgICBkZWNyeXB0ZGF0YS5rZXkgPSBrZXlJbmZvLmRlY3J5cHRkYXRhLmtleTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBmcmFnLFxuICAgICAgICBrZXlJbmZvXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGtleSBsb2FkIHByb21pc2UgYXMgbG9uZyBhcyBpdCBkb2VzIG5vdCBoYXZlIGEgbWVkaWFrZXkgc2Vzc2lvbiB3aXRoIGFuIHVudXNhYmxlIGtleSBzdGF0dXNcbiAgICBpZiAoKF9rZXlJbmZvMiA9IGtleUluZm8pICE9IG51bGwgJiYgX2tleUluZm8yLmtleUxvYWRQcm9taXNlKSB7XG4gICAgICB2YXIgX2tleUluZm8kbWVkaWFLZXlTZXNzO1xuICAgICAgc3dpdGNoICgoX2tleUluZm8kbWVkaWFLZXlTZXNzID0ga2V5SW5mby5tZWRpYUtleVNlc3Npb25Db250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2tleUluZm8kbWVkaWFLZXlTZXNzLmtleVN0YXR1cykge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnc3RhdHVzLXBlbmRpbmcnOlxuICAgICAgICBjYXNlICd1c2FibGUnOlxuICAgICAgICBjYXNlICd1c2FibGUtaW4tZnV0dXJlJzpcbiAgICAgICAgICByZXR1cm4ga2V5SW5mby5rZXlMb2FkUHJvbWlzZS50aGVuKGtleUxvYWRlZERhdGEgPT4ge1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjb3JyZWN0IGZyYWdtZW50IHdpdGggdXBkYXRlZCBkZWNyeXB0ZGF0YSBrZXkgYW5kIGxvYWRlZCBrZXlJbmZvXG4gICAgICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSBrZXlMb2FkZWREYXRhLmtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAga2V5SW5mb1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBrZXkgc2Vzc2lvbiBhbmQgc3RhdHVzIGFuZCBpdCBpcyBub3QgcGVuZGluZyBvciB1c2FibGUsIGNvbnRpbnVlXG4gICAgICAvLyBUaGlzIHdpbGwgZ28gYmFjayB0byB0aGUgZW1lLWNvbnRyb2xsZXIgZm9yIGV4cGlyZWQga2V5cyB0byBnZXQgYSBuZXcga2V5TG9hZFByb21pc2VcbiAgICB9XG5cbiAgICAvLyBMb2FkIHRoZSBrZXkgb3IgcmV0dXJuIHRoZSBsb2FkaW5nIHByb21pc2VcbiAgICBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXSA9IHtcbiAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAga2V5TG9hZFByb21pc2U6IG51bGwsXG4gICAgICBsb2FkZXI6IG51bGwsXG4gICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0OiBudWxsXG4gICAgfTtcbiAgICBzd2l0Y2ggKGRlY3J5cHRkYXRhLm1ldGhvZCkge1xuICAgICAgY2FzZSAnSVNPLTIzMDAxLTcnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUyc6XG4gICAgICBjYXNlICdTQU1QTEUtQUVTLUNFTkMnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUy1DVFInOlxuICAgICAgICBpZiAoZGVjcnlwdGRhdGEua2V5Rm9ybWF0ID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgLy8gbG9hZEtleUhUVFAgaGFuZGxlcyBodHRwKHMpIGFuZCBkYXRhIFVSTHNcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5RU1FKGtleUluZm8sIGZyYWcpO1xuICAgICAgY2FzZSAnQUVTLTEyOCc6XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBLZXkgc3VwcGxpZWQgd2l0aCB1bnN1cHBvcnRlZCBNRVRIT0Q6IFwiJHtkZWNyeXB0ZGF0YS5tZXRob2R9XCJgKSkpO1xuICAgIH1cbiAgfVxuICBsb2FkS2V5RU1FKGtleUluZm8sIGZyYWcpIHtcbiAgICBjb25zdCBrZXlMb2FkZWREYXRhID0ge1xuICAgICAgZnJhZyxcbiAgICAgIGtleUluZm9cbiAgICB9O1xuICAgIGlmICh0aGlzLmVtZUNvbnRyb2xsZXIgJiYgdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5lbWVDb250cm9sbGVyLmxvYWRLZXkoa2V5TG9hZGVkRGF0YSk7XG4gICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiAoa2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS50aGVuKGtleVNlc3Npb25Db250ZXh0ID0+IHtcbiAgICAgICAgICBrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSBrZXlTZXNzaW9uQ29udGV4dDtcbiAgICAgICAgICByZXR1cm4ga2V5TG9hZGVkRGF0YTtcbiAgICAgICAgfSkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAvLyBSZW1vdmUgcHJvbWlzZSBmb3IgbGljZW5zZSByZW5ld2FsIG9yIHJldHJ5XG4gICAgICAgICAga2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleUxvYWRlZERhdGEpO1xuICB9XG4gIGxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICBmcmFnLmtleUxvYWRlciA9IGtleUluZm8ubG9hZGVyID0ga2V5TG9hZGVyO1xuICAgIHJldHVybiBrZXlJbmZvLmtleUxvYWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IHtcbiAgICAgICAga2V5SW5mbyxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICB1cmw6IGtleUluZm8uZGVjcnlwdGRhdGEudXJpXG4gICAgICB9O1xuXG4gICAgICAvLyBtYXhSZXRyeSBpcyAwIHNvIHRoYXQgaW5zdGVhZCBvZiByZXRyeWluZyB0aGUgc2FtZSBrZXkgb24gdGhlIHNhbWUgdmFyaWFudCBtdWx0aXBsZSB0aW1lcyxcbiAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLmtleUxvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBrZXlJbmZvLFxuICAgICAgICAgICAgdXJsOiB1cmlcbiAgICAgICAgICB9ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEgfHwga2V5SW5mbyAhPT0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcignYWZ0ZXIga2V5IGxvYWQsIGRlY3J5cHRkYXRhIHVuc2V0IG9yIGNoYW5nZWQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5SW5mby5kZWNyeXB0ZGF0YS5rZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuXG4gICAgICAgICAgLy8gZGV0YWNoIGZyYWdtZW50IGtleSBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgICAgICAgZnJhZy5rZXlMb2FkZXIgPSBudWxsO1xuICAgICAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBrZXlJbmZvXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICByZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSBsb2FkaW5nIGtleSAke3Jlc3BvbnNlLnRleHR9YCksIG5ldHdvcmtEZXRhaWxzLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICB1cmw6IGxvYWRlckNvbnRleHQudXJsLFxuICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgfSwgcmVzcG9uc2UpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VULCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIHRpbWVkIG91dCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICByZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsIG5ldyBFcnJvcigna2V5IGxvYWRpbmcgYWJvcnRlZCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAga2V5TG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH0pO1xuICB9XG4gIHJlc2V0TG9hZGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAga2V5SW5mbyxcbiAgICAgIHVybDogdXJpXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgbG9hZGVyID0ga2V5SW5mby5sb2FkZXI7XG4gICAgaWYgKGZyYWcua2V5TG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKiBTdWItY2xhc3Mgc3BlY2lhbGl6YXRpb24gb2YgRXZlbnRIYW5kbGVyIGJhc2UgY2xhc3MuXG4gKlxuICogVGFza0xvb3AgYWxsb3dzIHRvIHNjaGVkdWxlIGEgdGFzayBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKG9wdGlvbm5hbHkgcmVwZWF0ZWRseSkgb24gdGhlIG1haW4gbG9vcCxcbiAqIHNjaGVkdWxlZCBhc3luY2hyb25lb3VzbHksIGF2b2lkaW5nIHJlY3Vyc2l2ZSBjYWxscyBpbiB0aGUgc2FtZSB0aWNrLlxuICpcbiAqIFRoZSB0YXNrIGl0c2VsZiBpcyBpbXBsZW1lbnRlZCBpbiBgZG9UaWNrYC4gSXQgY2FuIGJlIHJlcXVlc3RlZCBhbmQgY2FsbGVkIGZvciBzaW5nbGUgZXhlY3V0aW9uXG4gKiB1c2luZyB0aGUgYHRpY2tgIG1ldGhvZC5cbiAqXG4gKiBJdCB3aWxsIGJlIGFzc3VyZWQgdGhhdCB0aGUgdGFzayBleGVjdXRpb24gbWV0aG9kIChgdGlja2ApIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgbWFpbiBsb29wIFwidGlja1wiLFxuICogbm8gbWF0dGVyIGhvdyBvZnRlbiBpdCBnZXRzIHJlcXVlc3RlZCBmb3IgZXhlY3V0aW9uLiBFeGVjdXRpb24gaW4gZnVydGhlciB0aWNrcyB3aWxsIGJlIHNjaGVkdWxlZCBhY2NvcmRpbmdseS5cbiAqXG4gKiBJZiBmdXJ0aGVyIGV4ZWN1dGlvbiByZXF1ZXN0cyBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgb24gdGhlIG5leHQgdGljaywgaXQgY2FuIGJlIGNoZWNrZWQgd2l0aCBgaGFzTmV4dFRpY2tgLFxuICogYW5kIGNhbmNlbGxlZCB3aXRoIGBjbGVhck5leHRUaWNrYC5cbiAqXG4gKiBUaGUgdGFzayBjYW4gYmUgc2NoZWR1bGVkIGFzIGFuIGludGVydmFsIHJlcGVhdGVkbHkgd2l0aCBhIHBlcmlvZCBhcyBwYXJhbWV0ZXIgKHNlZSBgc2V0SW50ZXJ2YWxgLCBgY2xlYXJJbnRlcnZhbGApLlxuICpcbiAqIFN1Yi1jbGFzc2VzIG5lZWQgdG8gaW1wbGVtZW50IHRoZSBgZG9UaWNrYCBtZXRob2Qgd2hpY2ggd2lsbCBlZmZlY3RpdmVseSBoYXZlIHRoZSB0YXNrIGV4ZWN1dGlvbiByb3V0aW5lLlxuICpcbiAqIEZ1cnRoZXIgZXhwbGFuYXRpb25zOlxuICpcbiAqIFRoZSBiYXNlY2xhc3MgaGFzIGEgYHRpY2tgIG1ldGhvZCB0aGF0IHdpbGwgc2NoZWR1bGUgdGhlIGRvVGljayBjYWxsLiBJdCBtYXkgYmUgY2FsbGVkIHN5bmNocm9uZW91c2x5XG4gKiBvbmx5IGZvciBhIHN0YWNrLWRlcHRoIG9mIG9uZS4gT24gcmUtZW50cmFudCBjYWxscywgc3ViLXNlcXVlbnQgY2FsbHMgYXJlIHNjaGVkdWxlZCBmb3IgbmV4dCBtYWluIGxvb3AgdGlja3MuXG4gKlxuICogV2hlbiB0aGUgdGFzayBleGVjdXRpb24gKGB0aWNrYCBtZXRob2QpIGlzIGNhbGxlZCBpbiByZS1lbnRyYW50IHdheSB0aGlzIGlzIGRldGVjdGVkIGFuZFxuICogd2UgYXJlIGxpbWl0aW5nIHRoZSB0YXNrIGV4ZWN1dGlvbiBwZXIgY2FsbCBzdGFjayB0byBleGFjdGx5IG9uZSwgYnV0IHNjaGVkdWxpbmcvcG9zdC1wb25pbmcgZnVydGhlclxuICogdGFzayBwcm9jZXNzaW5nIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gKGFsc28ga25vd24gYXMgXCJuZXh0IHRpY2tcIiBpbiB0aGUgTm9kZS9KUyBydW50aW1lIGxpbmdvKS5cbiAqL1xuY2xhc3MgVGFza0xvb3Age1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ib3VuZFRpY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIHRoaXMuX2JvdW5kVGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIC8vIGNsZWFyIGFsbCB0aW1lcnMgYmVmb3JlIHVucmVnaXN0ZXJpbmcgZnJvbSBldmVudCBidXNcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7fVxuICBoYXNJbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrSW50ZXJ2YWw7XG4gIH1cbiAgaGFzTmV4dFRpY2soKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja1RpbWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBtaWxsaXMgLSBJbnRlcnZhbCB0aW1lIChtcylcbiAgICogQGV0dXJucyBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAqL1xuICBzZXRJbnRlcnZhbChtaWxsaXMpIHtcbiAgICBpZiAoIXRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMuX2JvdW5kVGljaywgbWlsbGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgY2xlYXJJbnRlcnZhbCgpIHtcbiAgICBpZiAodGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5fdGlja0ludGVydmFsKTtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRydWUgd2hlbiB0aW1lb3V0IHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgY2xlYXJOZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy5fdGlja1RpbWVyKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLl90aWNrVGltZXIpO1xuICAgICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBjYWxsIHRoZSBzdWJjbGFzcyBkb1RpY2sgaW1wbGVtZW50YXRpb24gaW4gdGhpcyBtYWluIGxvb3AgdGlja1xuICAgKiBvciBpbiB0aGUgbmV4dCBvbmUgKHZpYSBzZXRUaW1lb3V0KCwwKSkgaW4gY2FzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgKiBpbiB0aGlzIHRpY2sgKGluIGNhc2UgdGhpcyBpcyBhIHJlLWVudHJhbnQgY2FsbCkuXG4gICAqL1xuICB0aWNrKCkge1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQrKztcbiAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIC8vIHJlLWVudHJhbnQgY2FsbCB0byB0aWNrIGZyb20gcHJldmlvdXMgZG9UaWNrIGNhbGwgc3RhY2tcbiAgICAgIC8vIC0+IHNjaGVkdWxlIGEgY2FsbCBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIHRvIHByb2Nlc3MgdGhpcyB0YXNrIHByb2Nlc3NpbmcgcmVxdWVzdFxuICAgICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPiAxKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvbmx5IG9uZSB0aW1lciBleGlzdHMgYXQgYW55IHRpbWUgYXQgbWF4XG4gICAgICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgfVxuICB9XG4gIHRpY2tJbW1lZGlhdGUoKSB7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5fdGlja1RpbWVyID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHN1YmNsYXNzIHRvIGltcGxlbWVudCB0YXNrIGxvZ2ljXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZG9UaWNrKCkge31cbn1cblxuLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIGRlYWxpbmcgd2l0aCBidWZmZXIgbGVuZ3RoIHJldHJpZXZhbCBmb3IgZXhhbXBsZS5cbiAqXG4gKiBJbiBnZW5lcmFsLCBhIGhlbHBlciBhcm91bmQgSFRNTDUgTWVkaWFFbGVtZW50IFRpbWVSYW5nZXMgZ2F0aGVyZWQgZnJvbSBgYnVmZmVyZWRgIHByb3BlcnR5LlxuICpcbiAqIEFsc28gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9idWZmZXJlZFxuICovXG5cbmNvbnN0IG5vb3BCdWZmZXJlZCA9IHtcbiAgbGVuZ3RoOiAwLFxuICBzdGFydDogKCkgPT4gMCxcbiAgZW5kOiAoKSA9PiAwXG59O1xuY2xhc3MgQnVmZmVySGVscGVyIHtcbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICovXG4gIHN0YXRpYyBpc0J1ZmZlcmVkKG1lZGlhLCBwb3NpdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGNvbnN0IHZidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyZWQucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogdmJ1ZmZlcmVkLnN0YXJ0KGkpLFxuICAgICAgICAgICAgZW5kOiB2YnVmZmVyZWQuZW5kKGkpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsZW46IDAsXG4gICAgICBzdGFydDogcG9zLFxuICAgICAgZW5kOiBwb3MsXG4gICAgICBuZXh0U3RhcnQ6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICBwb3MgPSBNYXRoLm1heCgwLCBwb3MpO1xuICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcbiAgICBidWZmZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBjb25zdCBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBidWZmZXJlZDIgPSBbXTtcbiAgICBpZiAobWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgICAgY29uc3QgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCA8IG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgICAvLyBlLmcuICBbIDEsIDE1XSB3aXRoICBbIDIsOF0gPT4gWyAxLDE1XSAobm8gbmVlZCB0byBtb2RpZnkgbGFzdFJhbmdlLmVuZClcbiAgICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBiaWcgaG9sZVxuICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaXJzdCB2YWx1ZVxuICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJlZDIgPSBidWZmZXJlZDtcbiAgICB9XG4gICAgbGV0IGJ1ZmZlckxlbiA9IDA7XG5cbiAgICAvLyBidWZmZXJTdGFydE5leHQgY2FuIHBvc3NpYmx5IGJlIHVuZGVmaW5lZCBiYXNlZCBvbiB0aGUgY29uZGl0aW9uYWwgbG9naWMgYmVsb3dcbiAgICBsZXQgYnVmZmVyU3RhcnROZXh0O1xuXG4gICAgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cbiAgICBsZXQgYnVmZmVyU3RhcnQgPSBwb3M7XG4gICAgbGV0IGJ1ZmZlckVuZCA9IHBvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkMi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhcnQgPSBidWZmZXJlZDJbaV0uc3RhcnQ7XG4gICAgICBjb25zdCBlbmQgPSBidWZmZXJlZDJbaV0uZW5kO1xuICAgICAgLy8gbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xuICAgICAgaWYgKHBvcyArIG1heEhvbGVEdXJhdGlvbiA+PSBzdGFydCAmJiBwb3MgPCBlbmQpIHtcbiAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGJ1ZmZlckVuZCA9IGVuZDtcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xuICAgICAgfSBlbHNlIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPCBzdGFydCkge1xuICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsZW46IGJ1ZmZlckxlbixcbiAgICAgIHN0YXJ0OiBidWZmZXJTdGFydCB8fCAwLFxuICAgICAgZW5kOiBidWZmZXJFbmQgfHwgMCxcbiAgICAgIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYWZlIG1ldGhvZCB0byBnZXQgYnVmZmVyZWQgcHJvcGVydHkuXG4gICAqIFNvdXJjZUJ1ZmZlci5idWZmZXJlZCBtYXkgdGhyb3cgaWYgU291cmNlQnVmZmVyIGlzIHJlbW92ZWQgZnJvbSBpdCdzIE1lZGlhU291cmNlXG4gICAqL1xuICBzdGF0aWMgZ2V0QnVmZmVyZWQobWVkaWEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lZGlhLmJ1ZmZlcmVkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2ZhaWxlZCB0byBnZXQgbWVkaWEuYnVmZmVyZWQnLCBlKTtcbiAgICAgIHJldHVybiBub29wQnVmZmVyZWQ7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIENodW5rTWV0YWRhdGEge1xuICBjb25zdHJ1Y3RvcihsZXZlbCwgc24sIGlkLCBzaXplID0gMCwgcGFydCA9IC0xLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICB0aGlzLmxldmVsID0gdm9pZCAwO1xuICAgIHRoaXMuc24gPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplID0gdm9pZCAwO1xuICAgIHRoaXMucGFydGlhbCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zbXV4aW5nID0gZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICAgIGF1ZGlvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgICAgdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgICBhdWRpb3ZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpXG4gICAgfTtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgdGhpcy5zbiA9IHNuO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5wYXJ0aWFsID0gcGFydGlhbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IDAsXG4gICAgZXhlY3V0ZVN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVFbmQ6IDAsXG4gICAgZW5kOiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBjYykge1xuICBsZXQgZmlyc3RGcmFnID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRGcmFnID0gZnJhZ21lbnRzW2ldO1xuICAgIGlmIChjdXJyZW50RnJhZyAmJiBjdXJyZW50RnJhZy5jYyA9PT0gY2MpIHtcbiAgICAgIGZpcnN0RnJhZyA9IGN1cnJlbnRGcmFnO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXJzdEZyYWc7XG59XG5mdW5jdGlvbiBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpIHtcbiAgaWYgKGxhc3RMZXZlbC5kZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMuZW5kQ0MgPiBkZXRhaWxzLnN0YXJ0Q0MgfHwgbGFzdEZyYWcgJiYgbGFzdEZyYWcuY2MgPCBkZXRhaWxzLnN0YXJ0Q0MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcbmZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhwcmV2RGV0YWlscywgY3VyRGV0YWlscywgcmVmZXJlbmNlSW5kZXggPSAwKSB7XG4gIGNvbnN0IHByZXZGcmFncyA9IHByZXZEZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3QgY3VyRnJhZ3MgPSBjdXJEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKCFjdXJGcmFncy5sZW5ndGggfHwgIXByZXZGcmFncy5sZW5ndGgpIHtcbiAgICBsb2dnZXIubG9nKCdObyBmcmFnbWVudHMgdG8gYWxpZ24nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJldlN0YXJ0RnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MocHJldkZyYWdzLCBjdXJGcmFnc1swXS5jYyk7XG4gIGlmICghcHJldlN0YXJ0RnJhZyB8fCBwcmV2U3RhcnRGcmFnICYmICFwcmV2U3RhcnRGcmFnLnN0YXJ0UFRTKSB7XG4gICAgbG9nZ2VyLmxvZygnTm8gZnJhZyBpbiBwcmV2aW91cyBsZXZlbCB0byBhbGlnbiBvbicpO1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gcHJldlN0YXJ0RnJhZztcbn1cbmZ1bmN0aW9uIGFkanVzdEZyYWdtZW50U3RhcnQoZnJhZywgc2xpZGluZykge1xuICBpZiAoZnJhZykge1xuICAgIGNvbnN0IHN0YXJ0ID0gZnJhZy5zdGFydCArIHNsaWRpbmc7XG4gICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydDtcbiAgICBmcmFnLmVuZFBUUyA9IHN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0U2xpZGluZ1N0YXJ0KHNsaWRpbmcsIGRldGFpbHMpIHtcbiAgLy8gVXBkYXRlIHNlZ21lbnRzXG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnbWVudHNbaV0sIHNsaWRpbmcpO1xuICB9XG4gIC8vIFVwZGF0ZSBMTC1ITFMgcGFydHMgYXQgdGhlIGVuZCBvZiB0aGUgcGxheWxpc3RcbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChkZXRhaWxzLmZyYWdtZW50SGludCwgc2xpZGluZyk7XG4gIH1cbiAgZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG59XG5cbi8qKlxuICogVXNpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxhc3QgbGV2ZWwsIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgUFRTJyBvZiB0aGUgbmV3IGZyYWdtZW50cyBzbyB0aGF0IHRoZXkgZm9ybSBhXG4gKiBjb250aWd1b3VzIHN0cmVhbSB3aXRoIHRoZSBsYXN0IGZyYWdtZW50cy5cbiAqIFRoZSBQVFMgb2YgYSBmcmFnbWVudCBsZXRzIEhscy5qcyBrbm93IHdoZXJlIGl0IGZpdHMgaW50byBhIHN0cmVhbSAtIGJ5IGtub3dpbmcgZXZlcnkgUFRTLCB3ZSBrbm93IHdoaWNoIGZyYWdtZW50IHRvXG4gKiBkb3dubG9hZCBhdCBhbnkgZ2l2ZW4gdGltZS4gUFRTIGlzIG5vcm1hbGx5IGNvbXB1dGVkIHdoZW4gdGhlIGZyYWdtZW50IGlzIGRlbXV4ZWQsIHNvIHRha2luZyB0aGlzIHN0ZXAgc2F2ZXMgdXMgdGltZVxuICogYW5kIGFuIGV4dHJhIGRvd25sb2FkLlxuICogQHBhcmFtIGxhc3RGcmFnXG4gKiBAcGFyYW0gbGFzdExldmVsXG4gKiBAcGFyYW0gZGV0YWlsc1xuICovXG5mdW5jdGlvbiBhbGlnblN0cmVhbShsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSB7XG4gIGlmICghbGFzdExldmVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBsYXN0TGV2ZWwpO1xuICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgbGFzdExldmVsLmRldGFpbHMpIHtcbiAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxuICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgIC8vIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gICAgYWxpZ25QRFQoZGV0YWlscywgbGFzdExldmVsLmRldGFpbHMpO1xuICB9XG4gIGlmICghZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBsYXN0TGV2ZWwuZGV0YWlscyAmJiAhZGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAvLyBUcnkgdG8gYWxpZ24gb24gc24gc28gdGhhdCB3ZSBwaWNrIGEgYmV0dGVyIHN0YXJ0IGZyYWdtZW50LlxuICAgIC8vIERvIG5vdCBwZXJmb3JtIHRoaXMgb24gcGxheWxpc3RzIHdpdGggZGVsdGEgdXBkYXRlcyBhcyB0aGlzIGlzIG9ubHkgdG8gYWxpZ24gbGV2ZWxzIG9uIHN3aXRjaFxuICAgIC8vIGFuZCBhZGp1c3RTbGlkaW5nIG9ubHkgYWRqdXN0cyBmcmFnbWVudHMgYWZ0ZXIgc2tpcHBlZFNlZ21lbnRzLlxuICAgIGFkanVzdFNsaWRpbmcobGFzdExldmVsLmRldGFpbHMsIGRldGFpbHMpO1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBpZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgUFRTIG9mIGEgZnJhZ21lbnQgaW4gdGhlIGxhc3QgbGV2ZWwgd2hpY2ggc2hhcmVzIHRoZSBzYW1lXG4gKiBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICogQHBhcmFtIGxhc3RGcmFnIC0gVGhlIGxhc3QgRnJhZ21lbnQgd2hpY2ggc2hhcmVzIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2VcbiAqIEBwYXJhbSBsYXN0TGV2ZWwgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICovXG5mdW5jdGlvbiBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKSB7XG4gIGlmIChzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlRnJhZyA9IGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhsYXN0TGV2ZWwuZGV0YWlscywgZGV0YWlscyk7XG4gICAgaWYgKHJlZmVyZW5jZUZyYWcgJiYgaXNGaW5pdGVOdW1iZXIocmVmZXJlbmNlRnJhZy5zdGFydCkpIHtcbiAgICAgIGxvZ2dlci5sb2coYEFkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwgJHtkZXRhaWxzLnVybH1gKTtcbiAgICAgIGFkanVzdFNsaWRpbmdTdGFydChyZWZlcmVuY2VGcmFnLnN0YXJ0LCBkZXRhaWxzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUFRTIG9mIGEgbmV3IGxldmVsJ3MgZnJhZ21lbnRzIHVzaW5nIHRoZSBkaWZmZXJlbmNlIGluIFByb2dyYW0gRGF0ZSBUaW1lIGZyb20gdGhlIGxhc3QgbGV2ZWwuXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqIEBwYXJhbSBsYXN0RGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBsYXN0IGxvYWRlZCBsZXZlbFxuICovXG5mdW5jdGlvbiBhbGlnblBEVChkZXRhaWxzLCBsYXN0RGV0YWlscykge1xuICAvLyBUaGlzIGNoZWNrIHByb3RlY3RzIHRoZSB1bnNhZmUgXCIhXCIgdXNhZ2UgYmVsb3cgZm9yIG51bGwgcHJvZ3JhbSBkYXRlIHRpbWUgYWNjZXNzLlxuICBpZiAoIWxhc3REZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFsYXN0RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gaWYgbGFzdCBsZXZlbCBzbGlkaW5nIGlzIDEwMDAgYW5kIGl0cyBmaXJzdCBmcmFnIFBST0dSQU0tREFURS1USU1FIGlzIDIwMTctMDgtMjAgMToxMDowMCBBTVxuICAvLyBhbmQgaWYgbmV3IGRldGFpbHMgZmlyc3QgZnJhZyBQUk9HUkFNIERBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDggQU1cbiAgLy8gdGhlbiB3ZSBjYW4gZGVkdWNlIHRoYXQgcGxheWxpc3QgQiBzbGlkaW5nIGlzIDEwMDArOCA9IDEwMDhzXG4gIGNvbnN0IGxhc3RQRFQgPSBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lOyAvLyBoYXNQcm9ncmFtRGF0ZVRpbWUgY2hlY2sgYWJvdmUgbWFrZXMgdGhpcyBzYWZlLlxuICBjb25zdCBuZXdQRFQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gIC8vIGRhdGUgZGlmZiBpcyBpbiBtcy4gZnJhZy5zdGFydCBpcyBpbiBzZWNvbmRzXG4gIGNvbnN0IHNsaWRpbmcgPSAobmV3UERUIC0gbGFzdFBEVCkgLyAxMDAwICsgbGFzdERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICBpZiAoc2xpZGluZyAmJiBpc0Zpbml0ZU51bWJlcihzbGlkaW5nKSkge1xuICAgIGxvZ2dlci5sb2coYEFkanVzdGluZyBQVFMgdXNpbmcgcHJvZ3JhbURhdGVUaW1lIGRlbHRhICR7bmV3UERUIC0gbGFzdFBEVH1tcywgc2xpZGluZzoke3NsaWRpbmcudG9GaXhlZCgzKX0gJHtkZXRhaWxzLnVybH0gYCk7XG4gICAgYWRqdXN0U2xpZGluZ1N0YXJ0KHNsaWRpbmcsIGRldGFpbHMpO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlcyBhcHByb3ByaWF0ZSB0aW1lLWFsaWdubWVudCBiZXR3ZWVuIHJlbmRpdGlvbnMgYmFzZWQgb24gUERULiBVbmxpa2UgYGFsaWduUERUYCwgd2hpY2ggYWRqdXN0c1xuICogdGhlIHRpbWVsaW5lIGJhc2VkIG9uIHRoZSBkZWx0YSBiZXR3ZWVuIFBEVHMgb2YgdGhlIDB0aCBmcmFnbWVudCBvZiB0d28gcGxheWxpc3RzL2BMZXZlbERldGFpbHNgLFxuICogdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoZSB0aW1lbGluZXMgcmVwcmVzZW50ZWQgaW4gYHJlZkRldGFpbHNgIGFyZSBhY2N1cmF0ZSwgaW5jbHVkaW5nIHRoZSBQRFRzLFxuICogYW5kIHVzZXMgdGhlIFwid2FsbGNsb2NrXCIvUERUIHRpbWVsaW5lIGFzIGEgY3Jvc3MtcmVmZXJlbmNlIHRvIGBkZXRhaWxzYCwgYWRqdXN0aW5nIHRoZSBwcmVzZW50YXRpb25cbiAqIHRpbWVzL3RpbWVsaW5lcyBvZiBgZGV0YWlsc2AgYWNjb3JkaW5nbHkuXG4gKiBHaXZlbiB0aGUgYXN5bmNocm9ub3VzIG5hdHVyZSBvZiBmZXRjaGVzIGFuZCBpbml0aWFsIGxvYWRzIG9mIGxpdmUgYG1haW5gIGFuZCBhdWRpby9zdWJ0aXRsZSB0cmFja3MsXG4gKiB0aGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gZW5zdXJlIHRoZSBcImxvY2FsIHRpbWVsaW5lc1wiIG9mIGF1ZGlvL3N1YnRpdGxlIHRyYWNrc1xuICogYXJlIGFsaWduZWQgdG8gdGhlIG1haW4vdmlkZW8gdGltZWxpbmUsIHVzaW5nIFBEVCBhcyB0aGUgY3Jvc3MtcmVmZXJlbmNlL1wiYW5jaG9yXCIgdGhhdCBzaG91bGRcbiAqIGJlIGNvbnNpc3RlbnQgYWNyb3NzIHBsYXlsaXN0cywgcGVyIHRoZSBITFMgc3BlYy5cbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIHJlbmRpdGlvbiB5b3UnZCBsaWtlIHRvIHRpbWUtYWxpZ24gKGUuZy4gYW4gYXVkaW8gcmVuZGl0aW9uKS5cbiAqIEBwYXJhbSByZWZEZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIHJlZmVyZW5jZSByZW5kaXRpb24gd2l0aCBzdGFydCBhbmQgUERUIHRpbWVzIGZvciBhbGlnbm1lbnQuXG4gKi9cbmZ1bmN0aW9uIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKGRldGFpbHMsIHJlZkRldGFpbHMpIHtcbiAgaWYgKCFkZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSB8fCAhcmVmRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IHJlZkZyYWdtZW50cyA9IHJlZkRldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoIWZyYWdtZW50cy5sZW5ndGggfHwgIXJlZkZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgYSBkZWx0YSB0byBhcHBseSB0byBhbGwgZnJhZ21lbnRzIGFjY29yZGluZyB0byB0aGUgZGVsdGEgaW4gUERUIHRpbWVzIGFuZCBzdGFydCB0aW1lc1xuICAvLyBvZiBhIGZyYWdtZW50IGluIHRoZSByZWZlcmVuY2UgZGV0YWlscywgYW5kIGEgZnJhZ21lbnQgaW4gdGhlIHRhcmdldCBkZXRhaWxzIG9mIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkuXG4gIC8vIElmIGEgZnJhZ21lbnQgb2YgdGhlIHNhbWUgZGlzY29udGludWl0eSB3YXMgbm90IGZvdW5kIHVzZSB0aGUgbWlkZGxlIGZyYWdtZW50IG9mIGJvdGguXG4gIGNvbnN0IG1pZGRsZUZyYWcgPSBNYXRoLnJvdW5kKHJlZkZyYWdtZW50cy5sZW5ndGggLyAyKSAtIDE7XG4gIGNvbnN0IHJlZkZyYWcgPSByZWZGcmFnbWVudHNbbWlkZGxlRnJhZ107XG4gIGNvbnN0IGZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgcmVmRnJhZy5jYykgfHwgZnJhZ21lbnRzW01hdGgucm91bmQoZnJhZ21lbnRzLmxlbmd0aCAvIDIpIC0gMV07XG4gIGNvbnN0IHJlZlBEVCA9IHJlZkZyYWcucHJvZ3JhbURhdGVUaW1lO1xuICBjb25zdCB0YXJnZXRQRFQgPSBmcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgaWYgKHJlZlBEVCA9PT0gbnVsbCB8fCB0YXJnZXRQRFQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGVsdGEgPSAodGFyZ2V0UERUIC0gcmVmUERUKSAvIDEwMDAgLSAoZnJhZy5zdGFydCAtIHJlZkZyYWcuc3RhcnQpO1xuICBhZGp1c3RTbGlkaW5nU3RhcnQoZGVsdGEsIGRldGFpbHMpO1xufVxuXG5jbGFzcyBBRVNDcnlwdG8ge1xuICBjb25zdHJ1Y3RvcihzdWJ0bGUsIGl2KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5hZXNJViA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmFlc0lWID0gaXY7XG4gIH1cbiAgZGVjcnlwdChkYXRhLCBrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuZGVjcnlwdCh7XG4gICAgICBuYW1lOiAnQUVTLUNCQycsXG4gICAgICBpdjogdGhpcy5hZXNJVlxuICAgIH0sIGtleSwgZGF0YSk7XG4gIH1cbn1cblxuY2xhc3MgRmFzdEFFU0tleSB7XG4gIGNvbnN0cnVjdG9yKHN1YnRsZSwga2V5KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gIH1cbiAgZXhwYW5kS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7XG4gICAgICBuYW1lOiAnQUVTLUNCQydcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gIH1cbn1cblxuLy8gUEtDUzdcbmZ1bmN0aW9uIHJlbW92ZVBhZGRpbmcoYXJyYXkpIHtcbiAgY29uc3Qgb3V0cHV0Qnl0ZXMgPSBhcnJheS5ieXRlTGVuZ3RoO1xuICBjb25zdCBwYWRkaW5nQnl0ZXMgPSBvdXRwdXRCeXRlcyAmJiBuZXcgRGF0YVZpZXcoYXJyYXkuYnVmZmVyKS5nZXRVaW50OChvdXRwdXRCeXRlcyAtIDEpO1xuICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgcmV0dXJuIHNsaWNlVWludDgoYXJyYXksIDAsIG91dHB1dEJ5dGVzIC0gcGFkZGluZ0J5dGVzKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5jbGFzcyBBRVNEZWNyeXB0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJjb24gPSBbMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuICAgIHRoaXMuc3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLmludlN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5zQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgdGhpcy5rc1Jvd3MgPSAwO1xuICAgIHRoaXMua2V5U2l6ZSA9IDA7XG4gICAgdGhpcy5rZXlTY2hlZHVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmludktleVNjaGVkdWxlID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFRhYmxlKCk7XG4gIH1cblxuICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG4gIHVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgIGNvbnN0IG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG4gIGluaXRUYWJsZSgpIHtcbiAgICBjb25zdCBzQm94ID0gdGhpcy5zQm94O1xuICAgIGNvbnN0IGludlNCb3ggPSB0aGlzLmludlNCb3g7XG4gICAgY29uc3Qgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XG4gICAgY29uc3Qgc3ViTWl4MCA9IHN1Yk1peFswXTtcbiAgICBjb25zdCBzdWJNaXgxID0gc3ViTWl4WzFdO1xuICAgIGNvbnN0IHN1Yk1peDIgPSBzdWJNaXhbMl07XG4gICAgY29uc3Qgc3ViTWl4MyA9IHN1Yk1peFszXTtcbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgIGNvbnN0IGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHhpID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFtpXSA9IGkgPDwgMSBeIDB4MTFiO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGxldCBzeCA9IHhpIF4geGkgPDwgMSBeIHhpIDw8IDIgXiB4aSA8PCAzIF4geGkgPDwgNDtcbiAgICAgIHN4ID0gc3ggPj4+IDggXiBzeCAmIDB4ZmYgXiAweDYzO1xuICAgICAgc0JveFt4XSA9IHN4O1xuICAgICAgaW52U0JveFtzeF0gPSB4O1xuXG4gICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgICBjb25zdCB4MiA9IGRbeF07XG4gICAgICBjb25zdCB4NCA9IGRbeDJdO1xuICAgICAgY29uc3QgeDggPSBkW3g0XTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdWIvaW52U3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIGxldCB0ID0gZFtzeF0gKiAweDEwMSBeIHN4ICogMHgxMDEwMTAwO1xuICAgICAgc3ViTWl4MFt4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgc3ViTWl4MVt4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgICAgIHN1Yk1peDJbeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgICAgIHN1Yk1peDNbeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIHQgPSB4OCAqIDB4MTAxMDEwMSBeIHg0ICogMHgxMDAwMSBeIHgyICogMHgxMDEgXiB4ICogMHgxMDEwMTAwO1xuICAgICAgaW52U3ViTWl4MFtzeF0gPSB0IDw8IDI0IHwgdCA+Pj4gODtcbiAgICAgIGludlN1Yk1peDFbc3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xuICAgICAgaW52U3ViTWl4MltzeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcbiAgICAgIGlmICgheCkge1xuICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4cGFuZEtleShrZXlCdWZmZXIpIHtcbiAgICAvLyBjb252ZXJ0IGtleUJ1ZmZlciB0byBVaW50MzJBcnJheVxuICAgIGNvbnN0IGtleSA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGtleUJ1ZmZlcik7XG4gICAgbGV0IHNhbWVLZXkgPSB0cnVlO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCBrZXkubGVuZ3RoICYmIHNhbWVLZXkpIHtcbiAgICAgIHNhbWVLZXkgPSBrZXlbb2Zmc2V0XSA9PT0gdGhpcy5rZXlbb2Zmc2V0XTtcbiAgICAgIG9mZnNldCsrO1xuICAgIH1cbiAgICBpZiAoc2FtZUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICBjb25zdCBrZXlTaXplID0gdGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aDtcbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBrc1Jvd3MgPSB0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNDtcbiAgICBsZXQga3NSb3c7XG4gICAgbGV0IGludktzUm93O1xuICAgIGNvbnN0IGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIGNvbnN0IGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIGNvbnN0IHNib3ggPSB0aGlzLnNCb3g7XG4gICAgY29uc3QgcmNvbiA9IHRoaXMucmNvbjtcbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgIGxldCBwcmV2O1xuICAgIGxldCB0O1xuICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuICAgICAgICBwcmV2ID0ga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5W2tzUm93XTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ID0gcHJldjtcbiAgICAgIGlmIChrc1JvdyAlIGtleVNpemUgPT09IDApIHtcbiAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgdCA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuXG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTtcblxuICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICB0IF49IHJjb25ba3NSb3cgLyBrZXlTaXplIHwgMF0gPDwgMjQ7XG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID0gc2JveFt0ID4+PiAyNF0gPDwgMjQgfCBzYm94W3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBzYm94W3QgPj4+IDggJiAweGZmXSA8PCA4IHwgc2JveFt0ICYgMHhmZl07XG4gICAgICB9XG4gICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBwcmV2ID0gKGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KSA+Pj4gMDtcbiAgICB9XG4gICAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuICAgICAgaWYgKGludktzUm93ICYgMykge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG4gICAgICB9XG4gICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludlN1Yk1peDBbc2JveFt0ID4+PiAyNF1dIF4gaW52U3ViTWl4MVtzYm94W3QgPj4+IDE2ICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94W3QgPj4+IDggJiAweGZmXV0gXiBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcbiAgICAgIH1cbiAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxuICBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHdvcmQpIHtcbiAgICByZXR1cm4gd29yZCA8PCAyNCB8ICh3b3JkICYgMHhmZjAwKSA8PCA4IHwgKHdvcmQgJiAweGZmMDAwMCkgPj4gOCB8IHdvcmQgPj4+IDI0O1xuICB9XG4gIGRlY3J5cHQoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJVikge1xuICAgIGNvbnN0IG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgIGNvbnN0IGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZTtcbiAgICBjb25zdCBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuICAgIGNvbnN0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGNvbnN0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgY29uc3QgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBjb25zdCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGNvbnN0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgY29uc3QgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICBsZXQgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgIGxldCBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgbGV0IGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICBsZXQgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuICAgIGNvbnN0IGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcbiAgICBjb25zdCBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcbiAgICBsZXQgdDAsIHQxLCB0MiwgdDM7XG4gICAgbGV0IHMwLCBzMSwgczIsIHMzO1xuICAgIGxldCBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcbiAgICBsZXQga3NSb3csIGk7XG4gICAgY29uc3Qgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG4gICAgd2hpbGUgKG9mZnNldCA8IGlucHV0SW50MzIubGVuZ3RoKSB7XG4gICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICBpbnB1dFdvcmRzMSA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMV0pO1xuICAgICAgaW5wdXRXb3JkczIgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDJdKTtcbiAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG4gICAgICBzMCA9IGlucHV0V29yZHMwIF4gaW52S2V5U2NoZWR1bGVbMF07XG4gICAgICBzMSA9IGlucHV0V29yZHMzIF4gaW52S2V5U2NoZWR1bGVbMV07XG4gICAgICBzMiA9IGlucHV0V29yZHMyIF4gaW52S2V5U2NoZWR1bGVbMl07XG4gICAgICBzMyA9IGlucHV0V29yZHMxIF4gaW52S2V5U2NoZWR1bGVbM107XG4gICAgICBrc1JvdyA9IDQ7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcbiAgICAgICAgdDAgPSBpbnZTdWJNaXgwW3MwID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MxID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MyID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgdDEgPSBpbnZTdWJNaXgwW3MxID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MyID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MzID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgIHQyID0gaW52U3ViTWl4MFtzMiA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMyA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMCA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICB0MyA9IGludlN1Yk1peDBbczMgPj4+IDI0XSBeIGludlN1Yk1peDFbczAgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczEgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICAgIHMwID0gdDA7XG4gICAgICAgIHMxID0gdDE7XG4gICAgICAgIHMyID0gdDI7XG4gICAgICAgIHMzID0gdDM7XG4gICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xuICAgICAgfVxuXG4gICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcbiAgICAgIHQwID0gaW52U0JPWFtzMCA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMSA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMiA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIHQxID0gaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMiA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMyA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICB0MiA9IGludlNCT1hbczIgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczMgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczAgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgdDMgPSBpbnZTQk9YW3MzID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MwID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MxID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcblxuICAgICAgLy8gV3JpdGVcbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTtcblxuICAgICAgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG4gICAgICBpbml0VmVjdG9yMCA9IGlucHV0V29yZHMwO1xuICAgICAgaW5pdFZlY3RvcjEgPSBpbnB1dFdvcmRzMTtcbiAgICAgIGluaXRWZWN0b3IyID0gaW5wdXRXb3JkczI7XG4gICAgICBpbml0VmVjdG9yMyA9IGlucHV0V29yZHMzO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgNDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgfVxufVxuXG5jb25zdCBDSFVOS19TSVpFID0gMTY7IC8vIDE2IGJ5dGVzLCAxMjggYml0c1xuXG5jbGFzcyBEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIHtcbiAgICByZW1vdmVQS0NTN1BhZGRpbmcgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0bGUgPSBudWxsO1xuICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLmZhc3RBZXNLZXkgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVzZVNvZnR3YXJlID0gY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTO1xuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gcmVtb3ZlUEtDUzdQYWRkaW5nO1xuICAgIC8vIGJ1aWx0IGluIGRlY3J5cHRvciBleHBlY3RzIFBLQ1M3IHBhZGRpbmdcbiAgICBpZiAocmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBicm93c2VyQ3J5cHRvID0gc2VsZi5jcnlwdG87XG4gICAgICAgIGlmIChicm93c2VyQ3J5cHRvKSB7XG4gICAgICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdWJ0bGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudXNlU29mdHdhcmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICB9XG4gIGlzU3luYygpIHtcbiAgICByZXR1cm4gdGhpcy51c2VTb2Z0d2FyZTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50UmVzdWx0LFxuICAgICAgcmVtYWluZGVyRGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghY3VycmVudFJlc3VsdCB8fCByZW1haW5kZXJEYXRhKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGN1cnJlbnRSZXN1bHQpO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICBpZiAodGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIHJldHVybiByZW1vdmVQYWRkaW5nKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGlmICh0aGlzLnNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgaWYgKHRoaXMudXNlU29mdHdhcmUpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXksIGl2KTtcbiAgICAgICAgY29uc3QgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgaWYgKGRlY3J5cHRSZXN1bHQpIHtcbiAgICAgICAgICByZXNvbHZlKGRlY3J5cHRSZXN1bHQuYnVmZmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdbc29mdHdhcmVEZWNyeXB0XSBGYWlsZWQgdG8gZGVjcnlwdCBkYXRhJykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShkYXRhKSwga2V5LCBpdik7XG4gIH1cblxuICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHByb2dyZXNzaXZlLiBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIG1heSBub3QgcmV0dXJuIGEgcmVzdWx0IG9uIGVhY2ggY2FsbC4gQW55IGNhY2hlZFxuICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICBzb2Z0d2FyZURlY3J5cHQoZGF0YSwga2V5LCBpdikge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRJVixcbiAgICAgIGN1cnJlbnRSZXN1bHQsXG4gICAgICByZW1haW5kZXJEYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5sb2dPbmNlKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgIC8vIFRoZSBvdXRwdXQgaXMgc3RhZ2dlcmVkIGR1cmluZyBwcm9ncmVzc2l2ZSBwYXJzaW5nIC0gdGhlIGN1cnJlbnQgcmVzdWx0IGlzIGNhY2hlZCwgYW5kIGVtaXR0ZWQgb24gdGhlIG5leHQgY2FsbFxuICAgIC8vIFRoaXMgaXMgZG9uZSBpbiBvcmRlciB0byBzdHJpcCBQS0NTNyBwYWRkaW5nLCB3aGljaCBpcyBmb3VuZCBhdCB0aGUgZW5kIG9mIGVhY2ggc2VnbWVudC4gV2Ugb25seSBrbm93IHdlJ3ZlIHJlYWNoZWRcbiAgICAvLyB0aGUgZW5kIG9uIGZsdXNoKCksIGJ1dCBieSB0aGF0IHRpbWUgd2UgaGF2ZSBhbHJlYWR5IHJlY2VpdmVkIGFsbCBieXRlcyBmb3IgdGhlIHNlZ21lbnQuXG4gICAgLy8gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBkb2VzIG5vdCB3b3JrIHdpdGggV2ViQ3J5cHRvXG5cbiAgICBpZiAocmVtYWluZGVyRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkocmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEJ5dGUgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNiAoQUVTLTEyOCA9IDEyOCBiaXQgYmxvY2tzID0gMTYgYnl0ZXMpXG4gICAgY29uc3QgY3VycmVudENodW5rID0gdGhpcy5nZXRWYWxpZENodW5rKGRhdGEpO1xuICAgIGlmICghY3VycmVudENodW5rLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50SVYpIHtcbiAgICAgIGl2ID0gY3VycmVudElWO1xuICAgIH1cbiAgICBsZXQgc29mdHdhcmVEZWNyeXB0ZXIgPSB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyO1xuICAgIGlmICghc29mdHdhcmVEZWNyeXB0ZXIpIHtcbiAgICAgIHNvZnR3YXJlRGVjcnlwdGVyID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG5ldyBBRVNEZWNyeXB0b3IoKTtcbiAgICB9XG4gICAgc29mdHdhcmVEZWNyeXB0ZXIuZXhwYW5kS2V5KGtleSk7XG4gICAgY29uc3QgcmVzdWx0ID0gY3VycmVudFJlc3VsdDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBzb2Z0d2FyZURlY3J5cHRlci5kZWNyeXB0KGN1cnJlbnRDaHVuay5idWZmZXIsIDAsIGl2KTtcbiAgICB0aGlzLmN1cnJlbnRJViA9IHNsaWNlVWludDgoY3VycmVudENodW5rLCAtMTYpLmJ1ZmZlcjtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgd2ViQ3J5cHRvRGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgY29uc3Qgc3VidGxlID0gdGhpcy5zdWJ0bGU7XG4gICAgaWYgKHRoaXMua2V5ICE9PSBrZXkgfHwgIXRoaXMuZmFzdEFlc0tleSkge1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleShzdWJ0bGUsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkudGhlbihhZXNLZXkgPT4ge1xuICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICBpZiAoIXN1YnRsZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd3ZWIgY3J5cHRvIG5vdCBpbml0aWFsaXplZCcpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nT25jZSgnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICBjb25zdCBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKHN1YnRsZSwgbmV3IFVpbnQ4QXJyYXkoaXYpKTtcbiAgICAgIHJldHVybiBjcnlwdG8uZGVjcnlwdChkYXRhLmJ1ZmZlciwgYWVzS2V5KTtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgbG9nZ2VyLndhcm4oYFtkZWNyeXB0ZXJdOiBXZWJDcnlwdG8gRXJyb3IsIGRpc2FibGUgV2ViQ3J5cHRvIEFQSSwgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gdGhpcy5vbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYpO1xuICAgIH0pO1xuICB9XG4gIG9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdikge1xuICAgIHRoaXMudXNlU29mdHdhcmUgPSB0cnVlO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zb2Z0d2FyZURlY3J5cHQoZGF0YSwga2V5LCBpdik7XG4gICAgY29uc3QgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICBpZiAoZGVjcnlwdFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGRlY3J5cHRSZXN1bHQuYnVmZmVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkNyeXB0byBhbmQgc29mdHdhcmVEZWNyeXB0OiBmYWlsZWQgdG8gZGVjcnlwdCBkYXRhJyk7XG4gIH1cbiAgZ2V0VmFsaWRDaHVuayhkYXRhKSB7XG4gICAgbGV0IGN1cnJlbnRDaHVuayA9IGRhdGE7XG4gICAgY29uc3Qgc3BsaXRQb2ludCA9IGRhdGEubGVuZ3RoIC0gZGF0YS5sZW5ndGggJSBDSFVOS19TSVpFO1xuICAgIGlmIChzcGxpdFBvaW50ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgY3VycmVudENodW5rID0gc2xpY2VVaW50OChkYXRhLCAwLCBzcGxpdFBvaW50KTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IHNsaWNlVWludDgoZGF0YSwgc3BsaXRQb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q2h1bms7XG4gIH1cbiAgbG9nT25jZShtc2cpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKGBbZGVjcnlwdGVyXTogJHttc2d9YCk7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cblxuY29uc3QgVGltZVJhbmdlcyA9IHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uIChyKSB7XG4gICAgbGV0IGxvZyA9ICcnO1xuICAgIGNvbnN0IGxlbiA9IHIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSBgWyR7ci5zdGFydChpKS50b0ZpeGVkKDMpfS0ke3IuZW5kKGkpLnRvRml4ZWQoMyl9XWA7XG4gICAgfVxuICAgIHJldHVybiBsb2c7XG4gIH1cbn07XG5cbmNvbnN0IFN0YXRlID0ge1xuICBTVE9QUEVEOiAnU1RPUFBFRCcsXG4gIElETEU6ICdJRExFJyxcbiAgS0VZX0xPQURJTkc6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORzogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkc6ICdQQVJTSU5HJyxcbiAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgRU5ERUQ6ICdFTkRFRCcsXG4gIEVSUk9SOiAnRVJST1InLFxuICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gIFdBSVRJTkdfTEVWRUw6ICdXQUlUSU5HX0xFVkVMJ1xufTtcbmNsYXNzIEJhc2VTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgVGFza0xvb3Age1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCBsb2dQcmVmaXgsIHBsYXlsaXN0VHlwZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMucGxheWxpc3RUeXBlID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gMDtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5yZXRyeURhdGUgPSAwO1xuICAgIHRoaXMubGV2ZWxzID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5TG9hZGVyID0gdm9pZCAwO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMub252c2Vla2luZyA9IG51bGw7XG4gICAgdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgdGhpcy5sb2dQcmVmaXggPSAnJztcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgdGhpcy5wbGF5bGlzdFR5cGUgPSBwbGF5bGlzdFR5cGU7XG4gICAgdGhpcy5sb2dQcmVmaXggPSBsb2dQcmVmaXg7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgRnJhZ21lbnRMb2FkZXIoaGxzLmNvbmZpZyk7XG4gICAgdGhpcy5rZXlMb2FkZXIgPSBrZXlMb2FkZXI7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihobHMuY29uZmlnKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgfVxuICBkb1RpY2soKSB7XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuICBvblRpY2tFbmQoKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuYWJvcnQoKTtcbiAgICB0aGlzLmtleUxvYWRlci5hYm9ydCh0aGlzLnBsYXlsaXN0VHlwZSk7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWcgIT0gbnVsbCAmJiBmcmFnLmxvYWRlcikge1xuICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cbiAgX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykge1xuICAgIC8vIElmIHBsYXlsaXN0IGlzIGxpdmUsIHRoZXJlIGlzIGFub3RoZXIgYnVmZmVyZWQgcmFuZ2UgYWZ0ZXIgdGhlIGN1cnJlbnQgcmFuZ2UsIG5vdGhpbmcgYnVmZmVyZWQsIG1lZGlhIGlzIGRldGFjaGVkLFxuICAgIC8vIG9mIG5vdGhpbmcgbG9hZGluZy9sb2FkZWQgcmV0dXJuIGZhbHNlXG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlIHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8ICFidWZmZXJJbmZvLmVuZCB8fCAhdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0TGlzdCA9IGxldmVsRGV0YWlscy5wYXJ0TGlzdDtcbiAgICAvLyBTaW5jZSB0aGUgbGFzdCBwYXJ0IGlzbid0IGd1YXJhbnRlZWQgdG8gY29ycmVzcG9uZCB0byB0aGUgbGFzdCBwbGF5bGlzdCBzZWdtZW50IGZvciBMb3ctTGF0ZW5jeSBITFMsXG4gICAgLy8gY2hlY2sgaW5zdGVhZCBpZiB0aGUgbGFzdCBwYXJ0IGlzIGJ1ZmZlcmVkLlxuICAgIGlmIChwYXJ0TGlzdCAhPSBudWxsICYmIHBhcnRMaXN0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFzdFBhcnQgPSBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXTtcblxuICAgICAgLy8gQ2hlY2tpbmcgdGhlIG1pZHBvaW50IG9mIHRoZSBwYXJ0IGZvciBwb3RlbnRpYWwgbWFyZ2luIG9mIGVycm9yIGFuZCByZWxhdGVkIGlzc3Vlcy5cbiAgICAgIC8vIE5PVEU6IFRlY2huaWNhbGx5IEkgYmVsaWV2ZSBwYXJ0cyBjb3VsZCB5aWVsZCBjb250ZW50IHRoYXQgaXMgPCB0aGUgY29tcHV0ZWQgZHVyYXRpb24gKGluY2x1ZGluZyBwb3RlbnRpYWwgYSBkdXJhdGlvbiBvZiAwKVxuICAgICAgLy8gYW5kIHN0aWxsIGJlIHNwZWMtY29tcGxpYW50LCBzbyB0aGVyZSBtYXkgc3RpbGwgYmUgZWRnZSBjYXNlcyBoZXJlLiBMaWtld2lzZSwgdGhlcmUgY291bGQgYmUgaXNzdWVzIGluIGVuZCBvZiBzdHJlYW1cbiAgICAgIC8vIHBhcnQgbWlzbWF0Y2hlcyBmb3IgaW5kZXBlbmRlbnQgYXVkaW8gYW5kIHZpZGVvIHBsYXlsaXN0cy9zZWdtZW50cy5cbiAgICAgIGNvbnN0IGxhc3RQYXJ0QnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh0aGlzLm1lZGlhLCBsYXN0UGFydC5zdGFydCArIGxhc3RQYXJ0LmR1cmF0aW9uIC8gMik7XG4gICAgICByZXR1cm4gbGFzdFBhcnRCdWZmZXJlZDtcbiAgICB9XG4gICAgY29uc3QgcGxheWxpc3RUeXBlID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tsZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmlzRW5kTGlzdEFwcGVuZGVkKHBsYXlsaXN0VHlwZSk7XG4gIH1cbiAgZ2V0TGV2ZWxEZXRhaWxzKCkge1xuICAgIGlmICh0aGlzLmxldmVscyAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF90aGlzJGxldmVscyR0aGlzJGxldjtcbiAgICAgIHJldHVybiAoX3RoaXMkbGV2ZWxzJHRoaXMkbGV2ID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbExhc3RMb2FkZWRdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGV2ZWxzJHRoaXMkbGV2LmRldGFpbHM7XG4gICAgfVxuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAhPSBudWxsICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICB0aGlzLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXG4gICAgaWYgKG1lZGlhICYmIHRoaXMub252c2Vla2luZyAmJiB0aGlzLm9udmVuZGVkKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMua2V5TG9hZGVyKSB7XG4gICAgICB0aGlzLmtleUxvYWRlci5kZXRhY2goKTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gIH1cbiAgb25NZWRpYVNlZWtpbmcoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgZnJhZ0N1cnJlbnQsXG4gICAgICBtZWRpYSxcbiAgICAgIG1lZGlhQnVmZmVyLFxuICAgICAgc3RhdGVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiAwO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYUJ1ZmZlciA/IG1lZGlhQnVmZmVyIDogbWVkaWEsIGN1cnJlbnRUaW1lLCBjb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgdGhpcy5sb2coYG1lZGlhIHNlZWtpbmcgdG8gJHtpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkgPyBjdXJyZW50VGltZS50b0ZpeGVkKDMpIDogY3VycmVudFRpbWV9LCBzdGF0ZTogJHtzdGF0ZX1gKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9IGVsc2UgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICAvLyBTZWVraW5nIHdoaWxlIGZyYWcgbG9hZCBpcyBpbiBwcm9ncmVzc1xuICAgICAgY29uc3QgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICBjb25zdCBmcmFnU3RhcnRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCAtIHRvbGVyYW5jZTtcbiAgICAgIGNvbnN0IGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgLy8gaWYgc2Vla2luZyBvdXQgb2YgYnVmZmVyZWQgcmFuZ2Ugb3IgaW50byBuZXcgb25lXG4gICAgICBpZiAoIWJ1ZmZlckluZm8ubGVuIHx8IGZyYWdFbmRPZmZzZXQgPCBidWZmZXJJbmZvLnN0YXJ0IHx8IGZyYWdTdGFydE9mZnNldCA+IGJ1ZmZlckluZm8uZW5kKSB7XG4gICAgICAgIGNvbnN0IHBhc3RGcmFnbWVudCA9IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldDtcbiAgICAgICAgLy8gaWYgdGhlIHNlZWsgcG9zaXRpb24gaXMgb3V0c2lkZSB0aGUgY3VycmVudCBmcmFnbWVudCByYW5nZVxuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCBmcmFnU3RhcnRPZmZzZXQgfHwgcGFzdEZyYWdtZW50KSB7XG4gICAgICAgICAgaWYgKHBhc3RGcmFnbWVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIHdoaWxlIGZyYWdtZW50IGxvYWQgaW4gcHJvZ3Jlc3MsIGNhbmNlbCBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIC8vIFJlbW92ZSBnYXAgZnJhZ21lbnRzXG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKGN1cnJlbnRUaW1lLCBJbmZpbml0eSwgdGhpcy5wbGF5bGlzdFR5cGUsIHRydWUpO1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiAhYnVmZmVySW5mby5sZW4pIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIEFzeW5jIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIG9uTWVkaWFFbmRlZCgpIHtcbiAgICAvLyByZXNldCBzdGFydFBvc2l0aW9uIGFuZCBsYXN0Q3VycmVudFRpbWUgdG8gcmVzdGFydCBwbGF5YmFjayBAIHN0cmVhbSBiZWdpbm5pbmdcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gZGF0YS5zdGFydFRpbWVPZmZzZXQ7XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3llZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICBpZiAodGhpcy5mcmFnbWVudExvYWRlcikge1xuICAgICAgdGhpcy5mcmFnbWVudExvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmtleUxvYWRlcikge1xuICAgICAgdGhpcy5rZXlMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IHRoaXMuZGVjcnlwdGVyID0gdGhpcy5rZXlMb2FkZXIgPSB0aGlzLmZyYWdtZW50TG9hZGVyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3llZCgpO1xuICB9XG4gIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHRoaXMuX2xvYWRGcmFnRm9yUGxheWJhY2soZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9XG4gIF9sb2FkRnJhZ0ZvclBsYXliYWNrKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NDYWxsYmFjayA9IGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSR7ZGF0YS5wYXJ0ID8gJyBwOiAnICsgZGF0YS5wYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gd2FzIGRyb3BwZWQgZHVyaW5nIGRvd25sb2FkLmApO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZnJhZy5zdGF0cy5jaHVua0NvdW50Kys7XG4gICAgICB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKTtcbiAgICB9O1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oZGF0YSA9PiB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgaGVyZSB3ZSBwcm9iYWJseSBuZWVkZWQgdG8gYmFja3RyYWNrIG9yIGFyZSB3YWl0aW5nIGZvciBtb3JlIHBhcnRzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fCAhdGhpcy5mcmFnQ3VycmVudCAmJiBzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgncGF5bG9hZCcgaW4gZGF0YSkge1xuICAgICAgICB0aGlzLmxvZyhgTG9hZGVkIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfWApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgd2hvbGUgcGF5bG9hZDsgY29udHJvbGxlcnMgbm90IGltcGxlbWVudGluZyBwcm9ncmVzc2l2ZSBsb2FkaW5nIHJlY2VpdmUgZGF0YSBmcm9tIHRoaXMgY2FsbGJhY2tcbiAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndhcm4ocmVhc29uKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfSk7XG4gIH1cbiAgY2xlYXJUcmFja2VySWZOZWVkZWQoZnJhZykge1xuICAgIHZhciBfdGhpcyRtZWRpYUJ1ZmZlcjtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudFRyYWNrZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkcpIHtcbiAgICAgIC8vIExvd2VyIHRoZSBidWZmZXIgc2l6ZSBhbmQgdHJ5IGFnYWluXG4gICAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBmcmFnLnR5cGU7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcGxheWxpc3RUeXBlKTtcbiAgICAgIGNvbnN0IG1pbkZvcndhcmRCdWZmZXJMZW5ndGggPSBNYXRoLm1heChmcmFnLmR1cmF0aW9uLCBidWZmZXJlZEluZm8gPyBidWZmZXJlZEluZm8ubGVuIDogdGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgIGlmICh0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChtaW5Gb3J3YXJkQnVmZmVyTGVuZ3RoKSkge1xuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoKF90aGlzJG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhQnVmZmVyLmJ1ZmZlcmVkLmxlbmd0aCkgPT09IDApIHtcbiAgICAgIC8vIFN0b3AgZ2FwIGZvciBiYWQgdHJhY2tlciAvIGJ1ZmZlciBmbHVzaCBiZWhhdmlvclxuICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIH0gZWxzZSBpZiAoZnJhZ21lbnRUcmFja2VyLmhhc1BhcnRzKGZyYWcudHlwZSkpIHtcbiAgICAgIC8vIEluIGxvdyBsYXRlbmN5IG1vZGUsIHJlbW92ZSBmcmFnbWVudHMgZm9yIHdoaWNoIG9ubHkgc29tZSBwYXJ0cyB3ZXJlIGJ1ZmZlcmVkXG4gICAgICBmcmFnbWVudFRyYWNrZXIuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyh7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIHN0YXRzOiBmcmFnLnN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9KTtcbiAgICAgIGlmIChmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrTGl2ZVVwZGF0ZShkZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMudXBkYXRlZCAmJiAhZGV0YWlscy5saXZlKSB7XG4gICAgICAvLyBMaXZlIHN0cmVhbSBlbmRlZCwgdXBkYXRlIGZyYWdtZW50IHRyYWNrZXJcbiAgICAgIGNvbnN0IGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyh7XG4gICAgICAgIGZyYWc6IGxhc3RGcmFnbWVudCxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgc3RhdHM6IGxhc3RGcmFnbWVudC5zdGF0cyxcbiAgICAgICAgaWQ6IGxhc3RGcmFnbWVudC50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFkZXRhaWxzLmZyYWdtZW50c1swXSkge1xuICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0eXBlID0gbnVsbCkge1xuICAgIGlmICghKHN0YXJ0T2Zmc2V0IC0gZW5kT2Zmc2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXaGVuIGFsdGVybmF0ZSBhdWRpbyBpcyBwbGF5aW5nLCB0aGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBhdWRpbyBidWZmZXIuIE90aGVyd2lzZSxcbiAgICAvLyBwYXNzaW5nIGEgbnVsbCB0eXBlIGZsdXNoZXMgYm90aCBidWZmZXJzXG4gICAgY29uc3QgZmx1c2hTY29wZSA9IHtcbiAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgZW5kT2Zmc2V0LFxuICAgICAgdHlwZVxuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCBmbHVzaFNjb3BlKTtcbiAgfVxuICBfbG9hZEluaXRTZWdtZW50KGZyYWcsIGxldmVsKSB7XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnLCBsZXZlbCkudGhlbihkYXRhID0+IHtcbiAgICAgIGlmICghZGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhdGhpcy5sZXZlbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IGxvYWQgYWJvcnRlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaGxzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGF5bG9hZFxuICAgICAgfSA9IGRhdGE7XG4gICAgICBjb25zdCBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcbiAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdERhdGEgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIC8vIGRlY3J5cHQgaW5pdCBzZWdtZW50IGRhdGFcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlcikuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICBmcmFnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KS50aGVuKGRlY3J5cHRlZERhdGEgPT4ge1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICB0c3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYXRhLnBheWxvYWQgPSBkZWNyeXB0ZWREYXRhO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgICBobHMsXG4gICAgICAgIGxldmVsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVscycpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgIGZyYWcuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEucGF5bG9hZCk7XG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMuYnVmZmVyaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gc3RhdHMuYnVmZmVyaW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIC8vIFNpbGVuY2UgRlJBR19CVUZGRVJFRCBldmVudCBpZiBmcmFnQ3VycmVudCBpcyBudWxsXG4gICAgICBpZiAoZGF0YS5mcmFnID09PSBmcmFnQ3VycmVudCkge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19CVUZGRVJFRCwge1xuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIGZyYWc6IGZyYWdDdXJyZW50LFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndhcm4ocmVhc29uKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfSk7XG4gIH1cbiAgZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiAhZnJhZyB8fCAhZnJhZ0N1cnJlbnQgfHwgZnJhZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnQubGV2ZWwgfHwgZnJhZy5zbiAhPT0gZnJhZ0N1cnJlbnQuc24gfHwgZnJhZy51cmxJZCAhPT0gZnJhZ0N1cnJlbnQudXJsSWQ7XG4gIH1cbiAgZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCkge1xuICAgIHZhciBfZnJhZyRzdGFydFBUUywgX2ZyYWckZW5kUFRTLCBfdGhpcyRmcmFnQ3VycmVudCwgX3RoaXMkZnJhZ1ByZXZpb3VzO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIHRoaXMubG9nKGBCdWZmZXJlZCAke2ZyYWcudHlwZX0gc246ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHBhcnQ6ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mICR7dGhpcy5wbGF5bGlzdFR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyAnbGV2ZWwnIDogJ3RyYWNrJ30gJHtmcmFnLmxldmVsfSAoZnJhZzpbJHsoKF9mcmFnJHN0YXJ0UFRTID0gZnJhZy5zdGFydFBUUykgIT0gbnVsbCA/IF9mcmFnJHN0YXJ0UFRTIDogTmFOKS50b0ZpeGVkKDMpfS0keygoX2ZyYWckZW5kUFRTID0gZnJhZy5lbmRQVFMpICE9IG51bGwgPyBfZnJhZyRlbmRQVFMgOiBOYU4pLnRvRml4ZWQoMyl9XSA+IGJ1ZmZlcjoke21lZGlhID8gVGltZVJhbmdlcy50b1N0cmluZyhCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpKSA6ICcoZGV0YWNoZWQpJ30pYCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgZnJhZy50eXBlID09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gJiYgbWVkaWEuYnVmZmVyZWQubGVuZ3RoICYmICgoX3RoaXMkZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZnJhZ0N1cnJlbnQuc24pID09PSAoKF90aGlzJGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZnJhZ1ByZXZpb3VzLnNuKSkge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICB0aGlzLnNlZWtUb1N0YXJ0UG9zKCk7XG4gICAgfVxuICAgIHRoaXMudGljaygpO1xuICB9XG4gIHNlZWtUb1N0YXJ0UG9zKCkge31cbiAgX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWRFbmREYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIHBhcnRzTG9hZGVkXG4gICAgfSA9IGZyYWdMb2FkZWRFbmREYXRhO1xuICAgIC8vIElmIHdlIGRpZCBub3QgbG9hZCBwYXJ0cywgb3IgbG9hZGVkIGFsbCBwYXJ0cywgd2UgaGF2ZSBjb21wbGV0ZSAobm90IHBhcnRpYWwpIGZyYWdtZW50IGRhdGFcbiAgICBjb25zdCBjb21wbGV0ZSA9ICFwYXJ0c0xvYWRlZCB8fCBwYXJ0c0xvYWRlZC5sZW5ndGggPT09IDAgfHwgcGFydHNMb2FkZWQuc29tZShmcmFnTG9hZGVkID0+ICFmcmFnTG9hZGVkKTtcbiAgICBjb25zdCBjaHVua01ldGEgPSBuZXcgQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQgKyAxLCAwLCBwYXJ0ID8gcGFydC5pbmRleCA6IC0xLCAhY29tcGxldGUpO1xuICAgIHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGZyYWcpIHt9XG4gIF9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lID0gbnVsbCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIHZhciBfZnJhZyRkZWNyeXB0ZGF0YTtcbiAgICBjb25zdCBkZXRhaWxzID0gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCF0aGlzLmxldmVscyB8fCAhZGV0YWlscykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgbWlzc2luZyBsZXZlbCR7ZGV0YWlscyA/ICcnIDogJyBkZXRhaWwnfXNgKTtcbiAgICB9XG4gICAgbGV0IGtleUxvYWRpbmdQcm9taXNlID0gbnVsbDtcbiAgICBpZiAoZnJhZy5lbmNyeXB0ZWQgJiYgISgoX2ZyYWckZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhKSAhPSBudWxsICYmIF9mcmFnJGRlY3J5cHRkYXRhLmtleSkpIHtcbiAgICAgIHRoaXMubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dLCAke3RoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJ30gJHtmcmFnLmxldmVsfWApO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICBrZXlMb2FkaW5nUHJvbWlzZSA9IHRoaXMua2V5TG9hZGVyLmxvYWQoZnJhZykudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhLmZyYWcpKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuS0VZX0xPQURFRCwga2V5TG9hZGVkRGF0YSk7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuS0VZX0xPQURJTkcsIHtcbiAgICAgICAgZnJhZ1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBrZXlMb2FkaW5nUHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgZnJhZyBsb2FkIGFib3J0ZWQsIGNvbnRleHQgY2hhbmdlZCBpbiBLRVlfTE9BRElOR2ApKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFmcmFnLmVuY3J5cHRlZCAmJiBkZXRhaWxzLmVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmxvYWRDbGVhcihmcmFnLCBkZXRhaWxzLmVuY3J5cHRlZEZyYWdtZW50cyk7XG4gICAgfVxuICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBNYXRoLm1heChmcmFnLnN0YXJ0LCB0YXJnZXRCdWZmZXJUaW1lIHx8IDApO1xuICAgIGlmICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICBjb25zdCBwYXJ0TGlzdCA9IGRldGFpbHMucGFydExpc3Q7XG4gICAgICBpZiAocGFydExpc3QgJiYgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA+IGZyYWcuZW5kICYmIGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgICAgICAgZnJhZyA9IGRldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRJbmRleCA9IHRoaXMuZ2V0TmV4dFBhcnQocGFydExpc3QsIGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgICBpZiAocGFydEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbcGFydEluZGV4XTtcbiAgICAgICAgICB0aGlzLmxvZyhgTG9hZGluZyBwYXJ0IHNuOiAke2ZyYWcuc259IHA6ICR7cGFydC5pbmRleH0gY2M6ICR7ZnJhZy5jY30gb2YgcGxheWxpc3QgWyR7ZGV0YWlscy5zdGFydFNOfS0ke2RldGFpbHMuZW5kU059XSBwYXJ0cyBbMC0ke3BhcnRJbmRleH0tJHtwYXJ0TGlzdC5sZW5ndGggLSAxfV0gJHt0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjayd9OiAke2ZyYWcubGV2ZWx9LCB0YXJnZXQ6ICR7cGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpfWApO1xuICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHBhcnQuc3RhcnQgKyBwYXJ0LmR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgbGV0IF9yZXN1bHQ7XG4gICAgICAgICAgaWYgKGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgICBfcmVzdWx0ID0ga2V5TG9hZGluZ1Byb21pc2UudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFrZXlMb2FkZWREYXRhIHx8IHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoZnJhZywgcGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHQgPSB0aGlzLmRvRnJhZ1BhcnRzTG9hZChmcmFnLCBwYXJ0LCBsZXZlbCwgcHJvZ3Jlc3NDYWxsYmFjaykuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BRElORywge1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICB0YXJnZXRCdWZmZXJUaW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gRlJBR19MT0FESU5HIHBhcnRzYCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICghZnJhZy51cmwgfHwgdGhpcy5sb2FkZWRFbmRPZlBhcnRzKHBhcnRMaXN0LCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgICAgIC8vIEZyYWdtZW50IGhpbnQgaGFzIG5vIHBhcnRzXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZyhgTG9hZGluZyBmcmFnbWVudCAke2ZyYWcuc259IGNjOiAke2ZyYWcuY2N9ICR7ZGV0YWlscyA/ICdvZiBbJyArIGRldGFpbHMuc3RhcnRTTiArICctJyArIGRldGFpbHMuZW5kU04gKyAnXSAnIDogJyd9JHt0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjayd9OiAke2ZyYWcubGV2ZWx9LCB0YXJnZXQ6ICR7cGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpfWApO1xuICAgIC8vIERvbid0IHVwZGF0ZSBuZXh0TG9hZFBvc2l0aW9uIGZvciBmcmFnbWVudHMgd2hpY2ggYXJlIG5vdCBidWZmZXJlZFxuICAgIGlmIChpc0Zpbml0ZU51bWJlcihmcmFnLnNuKSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG5cbiAgICAvLyBMb2FkIGtleSBiZWZvcmUgc3RyZWFtaW5nIGZyYWdtZW50IGRhdGFcbiAgICBjb25zdCBkYXRhT25Qcm9ncmVzcyA9IHRoaXMuY29uZmlnLnByb2dyZXNzaXZlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGRhdGFPblByb2dyZXNzICYmIGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICByZXN1bHQgPSBrZXlMb2FkaW5nUHJvbWlzZS50aGVuKGtleUxvYWRlZERhdGEgPT4ge1xuICAgICAgICBpZiAoIWtleUxvYWRlZERhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YSA9PSBudWxsID8gdm9pZCAwIDoga2V5TG9hZGVkRGF0YS5mcmFnKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWQoZnJhZywgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB0aGlzLmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9hZCB1bmVuY3J5cHRlZCBmcmFnbWVudCBkYXRhIHdpdGggcHJvZ3Jlc3MgZXZlbnQsXG4gICAgICAvLyBvciBoYW5kbGUgZnJhZ21lbnQgcmVzdWx0IGFmdGVyIGtleSBhbmQgZnJhZ21lbnQgYXJlIGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgIHJlc3VsdCA9IFByb21pc2UuYWxsKFt0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWQoZnJhZywgZGF0YU9uUHJvZ3Jlc3MgPyBwcm9ncmVzc0NhbGxiYWNrIDogdW5kZWZpbmVkKSwga2V5TG9hZGluZ1Byb21pc2VdKS50aGVuKChbZnJhZ0xvYWRlZERhdGFdKSA9PiB7XG4gICAgICAgIGlmICghZGF0YU9uUHJvZ3Jlc3MgJiYgZnJhZ0xvYWRlZERhdGEgJiYgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soZnJhZ0xvYWRlZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnTG9hZGVkRGF0YTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURJTkcsIHtcbiAgICAgIGZyYWcsXG4gICAgICB0YXJnZXRCdWZmZXJUaW1lXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gRlJBR19MT0FESU5HYCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRvRnJhZ1BhcnRzTG9hZChmcmFnLCBmcm9tUGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICAgICAgY29uc3QgcGFydHNMb2FkZWQgPSBbXTtcbiAgICAgIGNvbnN0IGluaXRpYWxQYXJ0TGlzdCA9IChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5wYXJ0TGlzdDtcbiAgICAgIGNvbnN0IGxvYWRQYXJ0ID0gcGFydCA9PiB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIubG9hZFBhcnQoZnJhZywgcGFydCwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihwYXJ0TG9hZGVkRGF0YSA9PiB7XG4gICAgICAgICAgcGFydHNMb2FkZWRbcGFydC5pbmRleF0gPSBwYXJ0TG9hZGVkRGF0YTtcbiAgICAgICAgICBjb25zdCBsb2FkZWRQYXJ0ID0gcGFydExvYWRlZERhdGEucGFydDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgcGFydExvYWRlZERhdGEpO1xuICAgICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gZ2V0UGFydFdpdGgobGV2ZWwsIGZyYWcuc24sIHBhcnQuaW5kZXggKyAxKSB8fCBmaW5kUGFydChpbml0aWFsUGFydExpc3QsIGZyYWcuc24sIHBhcnQuaW5kZXggKyAxKTtcbiAgICAgICAgICBpZiAobmV4dFBhcnQpIHtcbiAgICAgICAgICAgIGxvYWRQYXJ0KG5leHRQYXJ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBsb2FkZWRQYXJ0LFxuICAgICAgICAgICAgICBwYXJ0c0xvYWRlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgfTtcbiAgICAgIGxvYWRQYXJ0KGZyb21QYXJ0KTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSB7XG4gICAgaWYgKCdkYXRhJyBpbiBlcnJvcikge1xuICAgICAgY29uc3QgZGF0YSA9IGVycm9yLmRhdGE7XG4gICAgICBpZiAoZXJyb3IuZGF0YSAmJiBkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVEKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRnJhZ0xvYWRBYm9ydGVkKGRhdGEuZnJhZywgZGF0YS5wYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaChjaHVua01ldGEpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgIGlmICghY29udGV4dCB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBpZiAoIXRoaXMuZnJhZ0N1cnJlbnQgJiYgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBsZXZlbFxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZnJhZy5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcbiAgICBpZiAocGFydCkge1xuICAgICAgcGFydC5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcbiAgICB9XG4gICAgdGhpcy51cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgY2h1bmtNZXRhLnBhcnRpYWwpO1xuICB9XG4gIGdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGZyYWdDdXJyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICBzbixcbiAgICAgIHBhcnQ6IHBhcnRJbmRleFxuICAgIH0gPSBjaHVua01ldGE7XG4gICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW2xldmVsSW5kZXhdKSkge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbHMgb2JqZWN0IHdhcyB1bnNldCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgJHtzbn0gb2YgbGV2ZWwgJHtsZXZlbEluZGV4fS4gVGhlIGN1cnJlbnQgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgY29uc3QgcGFydCA9IHBhcnRJbmRleCA+IC0xID8gZ2V0UGFydFdpdGgobGV2ZWwsIHNuLCBwYXJ0SW5kZXgpIDogbnVsbDtcbiAgICBjb25zdCBmcmFnID0gcGFydCA/IHBhcnQuZnJhZ21lbnQgOiBnZXRGcmFnbWVudFdpdGhTTihsZXZlbCwgc24sIGZyYWdDdXJyZW50KTtcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQgIT09IGZyYWcpIHtcbiAgICAgIGZyYWcuc3RhdHMgPSBmcmFnQ3VycmVudC5zdGF0cztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgbGV2ZWxcbiAgICB9O1xuICB9XG4gIGJ1ZmZlckZyYWdtZW50RGF0YShkYXRhLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEsIG5vQmFja3RyYWNraW5nKSB7XG4gICAgdmFyIF9idWZmZXI7XG4gICAgaWYgKCFkYXRhIHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGF0YTEsXG4gICAgICBkYXRhMlxuICAgIH0gPSBkYXRhO1xuICAgIGxldCBidWZmZXIgPSBkYXRhMTtcbiAgICBpZiAoZGF0YTEgJiYgZGF0YTIpIHtcbiAgICAgIC8vIENvbWJpbmUgdGhlIG1vb2YgKyBtZGF0IHNvIHRoYXQgd2UgYnVmZmVyIHdpdGggYSBzaW5nbGUgYXBwZW5kXG4gICAgICBidWZmZXIgPSBhcHBlbmRVaW50OEFycmF5KGRhdGExLCBkYXRhMik7XG4gICAgfVxuICAgIGlmICghKChfYnVmZmVyID0gYnVmZmVyKSAhPSBudWxsICYmIF9idWZmZXIubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWdtZW50ID0ge1xuICAgICAgdHlwZTogZGF0YS50eXBlLFxuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBjaHVua01ldGEsXG4gICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgIGRhdGE6IGJ1ZmZlclxuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywgc2VnbWVudCk7XG4gICAgaWYgKGRhdGEuZHJvcHBlZCAmJiBkYXRhLmluZGVwZW5kZW50ICYmICFwYXJ0KSB7XG4gICAgICBpZiAobm9CYWNrdHJhY2tpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgYnVmZmVyIHNvIHRoYXQgd2UgcmVsb2FkIHByZXZpb3VzIHNlZ21lbnRzIHNlcXVlbnRpYWxseSBpZiByZXF1aXJlZFxuICAgICAgdGhpcy5mbHVzaEJ1ZmZlckdhcChmcmFnKTtcbiAgICB9XG4gIH1cbiAgZmx1c2hCdWZmZXJHYXAoZnJhZykge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIGN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgY2xlYXIgdGhlIGJhY2sgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGJhY2t0cmFjayBhcyBtdWNoIGFzIG5lZWRlZFxuICAgIGlmICghQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lKSkge1xuICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZy5zdGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSBiYWNrLWJ1ZmZlciB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjayB0byBhbGxvdyBiYWNrIHRyYWNraW5nXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICBjb25zdCBmcmFnRHVyYXRpb24gPSBmcmFnLmR1cmF0aW9uO1xuICAgIGNvbnN0IHNlZ21lbnRGcmFjdGlvbiA9IE1hdGgubWluKHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgKiAyLCBmcmFnRHVyYXRpb24gKiAwLjI1KTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KE1hdGgubWluKGZyYWcuc3RhcnQgLSBzZWdtZW50RnJhY3Rpb24sIGJ1ZmZlckluZm8uZW5kIC0gc2VnbWVudEZyYWN0aW9uKSwgY3VycmVudFRpbWUgKyBzZWdtZW50RnJhY3Rpb24pO1xuICAgIGlmIChmcmFnLnN0YXJ0IC0gc3RhcnQgPiBzZWdtZW50RnJhY3Rpb24pIHtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0LCBmcmFnLnN0YXJ0KTtcbiAgICB9XG4gIH1cbiAgZ2V0RndkQnVmZmVySW5mbyhidWZmZXJhYmxlLCB0eXBlKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHBvcykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3MoYnVmZmVyYWJsZSwgcG9zLCB0eXBlKTtcbiAgfVxuICBnZXRGd2RCdWZmZXJJbmZvQXRQb3MoYnVmZmVyYWJsZSwgcG9zLCB0eXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIG1heEJ1ZmZlckhvbGVcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgcG9zLCBtYXhCdWZmZXJIb2xlKTtcbiAgICAvLyBXb3JrYXJvdW5kIGZsYXcgaW4gZ2V0dGluZyBmb3J3YXJkIGJ1ZmZlciB3aGVuIG1heEJ1ZmZlckhvbGUgaXMgc21hbGxlciB0aGFuIGdhcCBhdCBjdXJyZW50IHBvc1xuICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBidWZmZXJlZEZyYWdBdFBvcyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3MsIHR5cGUpO1xuICAgICAgaWYgKGJ1ZmZlcmVkRnJhZ0F0UG9zICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDwgYnVmZmVyZWRGcmFnQXRQb3MuZW5kKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXJhYmxlLCBwb3MsIE1hdGgubWF4KGJ1ZmZlckluZm8ubmV4dFN0YXJ0LCBtYXhCdWZmZXJIb2xlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJJbmZvO1xuICB9XG4gIGdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEJpdHJhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWdcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgbWF4QnVmTGVuO1xuICAgIGlmIChsZXZlbEJpdHJhdGUpIHtcbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihtYXhCdWZMZW4sIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICB9XG4gIHJlZHVjZU1heEJ1ZmZlckxlbmd0aCh0aHJlc2hvbGQpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBtaW5MZW5ndGggPSB0aHJlc2hvbGQgfHwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICBpZiAoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xuICAgICAgdGhpcy53YXJuKGBSZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0QXBwZW5kZWRGcmFnKHBvc2l0aW9uLCBwbGF5bGlzdFR5cGUgPSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgY29uc3QgZnJhZ09yUGFydCA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgaWYgKGZyYWdPclBhcnQgJiYgJ2ZyYWdtZW50JyBpbiBmcmFnT3JQYXJ0KSB7XG4gICAgICByZXR1cm4gZnJhZ09yUGFydC5mcmFnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdPclBhcnQ7XG4gIH1cbiAgZ2V0TmV4dEZyYWdtZW50KHBvcywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAoIWZyYWdMZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgbGV0IGZyYWc7XG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IGNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcbiAgICAgIGlmIChmcmFnTGVuIDwgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUpIHtcbiAgICAgICAgdGhpcy53YXJuKGBOb3QgZW5vdWdoIGZyYWdtZW50cyB0byBzdGFydCBwbGF5YmFjayAoaGF2ZTogJHtmcmFnTGVufSwgbmVlZDogJHtpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZX0pYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlYWwgZnJhZ21lbnQgc3RhcnQgdGltZXMgZm9yIGEgbGl2ZSBzdHJlYW0gYXJlIG9ubHkga25vd24gYWZ0ZXIgdGhlIFBUUyByYW5nZSBmb3IgdGhhdCBsZXZlbCBpcyBrbm93bi5cbiAgICAgIC8vIEluIG9yZGVyIHRvIGRpc2NvdmVyIHRoZSByYW5nZSwgd2UgbG9hZCB0aGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhhdCBsZXZlbCBhbmQgZGVtdXggaXQuXG4gICAgICAvLyBEbyBub3QgbG9hZCB1c2luZyBsaXZlIGxvZ2ljIGlmIHRoZSBzdGFydGluZyBmcmFnIGlzIHJlcXVlc3RlZCAtIHdlIHdhbnQgdG8gdXNlIGdldEZyYWdtZW50QXRQb3NpdGlvbigpIHNvIHRoYXRcbiAgICAgIC8vIHdlIGdldCB0aGUgZnJhZ21lbnQgbWF0Y2hpbmcgdGhhdCBzdGFydCB0aW1lXG4gICAgICBpZiAoIWxldmVsRGV0YWlscy5QVFNLbm93biAmJiAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgdGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBmcmFnID0gdGhpcy5nZXRJbml0aWFsTGl2ZUZyYWdtZW50KGxldmVsRGV0YWlscywgZnJhZ21lbnRzKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gZnJhZyA/IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgZnJhZy5zdGFydCA6IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvcyA8PSBzdGFydCkge1xuICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBsb2FkUG9zaXRpb24gYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgcnVuIGludG8gYW55IHNwZWNpYWwgY2FzZXMgYWxyZWFkeSwganVzdCBsb2FkIHRoZSBmcmFnbWVudCBtb3N0IGNsb3NlbHkgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBwb3NpdGlvblxuICAgIGlmICghZnJhZykge1xuICAgICAgY29uc3QgZW5kID0gY29uZmlnLmxvd0xhdGVuY3lNb2RlID8gbGV2ZWxEZXRhaWxzLnBhcnRFbmQgOiBsZXZlbERldGFpbHMuZnJhZ21lbnRFbmQ7XG4gICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24ocG9zLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQoZnJhZyk7XG4gIH1cbiAgaXNMb29wTG9hZGluZyhmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgY29uc3QgdHJhY2tlclN0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgcmV0dXJuICh0cmFja2VyU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuT0sgfHwgdHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgISFmcmFnLmdhcCkgJiYgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID4gdGFyZ2V0QnVmZmVyVGltZTtcbiAgfVxuICBnZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhmcmFnLCBsZXZlbERldGFpbHMsIGJ1ZmZlckluZm8sIHBsYXlsaXN0VHlwZSwgbWF4QnVmTGVuKSB7XG4gICAgY29uc3QgZ2FwU3RhcnQgPSBmcmFnLmdhcDtcbiAgICBjb25zdCBuZXh0RnJhZ21lbnQgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0aGlzLm5leHRMb2FkUG9zaXRpb24sIGxldmVsRGV0YWlscyk7XG4gICAgaWYgKG5leHRGcmFnbWVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5leHRGcmFnbWVudDtcbiAgICB9XG4gICAgZnJhZyA9IG5leHRGcmFnbWVudDtcbiAgICBpZiAoZ2FwU3RhcnQgJiYgZnJhZyAmJiAhZnJhZy5nYXAgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgIC8vIE1lZGlhIGJ1ZmZlcmVkIGFmdGVyIEdBUCB0YWdzIHNob3VsZCBub3QgbWFrZSB0aGUgbmV4dCBidWZmZXIgdGltZXJhbmdlIGV4Y2VlZCBmb3J3YXJkIGJ1ZmZlciBsZW5ndGhcbiAgICAgIGNvbnN0IG5leHRidWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3ModGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLCBidWZmZXJJbmZvLm5leHRTdGFydCwgcGxheWxpc3RUeXBlKTtcbiAgICAgIGlmIChuZXh0YnVmZmVySW5mbyAhPT0gbnVsbCAmJiBidWZmZXJJbmZvLmxlbiArIG5leHRidWZmZXJJbmZvLmxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgICAgLy8gUmV0dXJuaW5nIGhlcmUgbWlnaHQgcmVzdWx0IGluIG5vdCBmaW5kaW5nIGFuIGF1ZGlvIGFuZCB2aWRlbyBjYW5kaWF0ZSB0byBza2lwIHRvXG4gICAgICAgIHRoaXMubG9nKGBidWZmZXIgZnVsbCBhZnRlciBnYXBzIGluIFwiJHtwbGF5bGlzdFR5cGV9XCIgcGxheWxpc3Qgc3RhcnRpbmcgYXQgc246ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG4gIG1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQoZnJhZykge1xuICAgIC8vIElmIGFuIGluaXRTZWdtZW50IGlzIHByZXNlbnQsIGl0IG11c3QgYmUgYnVmZmVyZWQgZmlyc3RcbiAgICBpZiAoZnJhZyAhPSBudWxsICYmIGZyYWcuaW5pdFNlZ21lbnQgJiYgIShmcmFnICE9IG51bGwgJiYgZnJhZy5pbml0U2VnbWVudC5kYXRhKSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgcmV0dXJuIGZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG4gIGdldE5leHRQYXJ0KHBhcnRMaXN0LCBmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgbGV0IG5leHRQYXJ0ID0gLTE7XG4gICAgbGV0IGNvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICBsZXQgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcnRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gaW5kZXBlbmRlbnRBdHRyT21pdHRlZCAmJiAhcGFydC5pbmRlcGVuZGVudDtcbiAgICAgIGlmIChuZXh0UGFydCA+IC0xICYmIHRhcmdldEJ1ZmZlclRpbWUgPCBwYXJ0LnN0YXJ0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkID0gcGFydC5sb2FkZWQ7XG4gICAgICBpZiAobG9hZGVkKSB7XG4gICAgICAgIG5leHRQYXJ0ID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKChjb250aWd1b3VzIHx8IHBhcnQuaW5kZXBlbmRlbnQgfHwgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCkgJiYgcGFydC5mcmFnbWVudCA9PT0gZnJhZykge1xuICAgICAgICBuZXh0UGFydCA9IGk7XG4gICAgICB9XG4gICAgICBjb250aWd1b3VzID0gbG9hZGVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFBhcnQ7XG4gIH1cbiAgbG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGxhc3RQYXJ0ICYmIHRhcmdldEJ1ZmZlclRpbWUgPiBsYXN0UGFydC5zdGFydCAmJiBsYXN0UGFydC5sb2FkZWQ7XG4gIH1cblxuICAvKlxuICAgVGhpcyBtZXRob2QgaXMgdXNlZCBmaW5kIHRoZSBiZXN0IG1hdGNoaW5nIGZpcnN0IGZyYWdtZW50IGZvciBhIGxpdmUgcGxheWxpc3QuIFRoaXMgZnJhZ21lbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlXG4gICBcInNsaWRpbmdcIiBvZiB0aGUgcGxheWxpc3QsIHdoaWNoIGlzIGl0cyBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgcGxheWJhY2suIEFmdGVyIHNsaWRpbmcgd2UgY2FuIGNvbXB1dGUgdGhlIHJlYWxcbiAgIHN0YXJ0IGFuZCBlbmQgdGltZXMgZm9yIGVhY2ggZnJhZ21lbnQgaW4gdGhlIHBsYXlsaXN0IChhZnRlciB3aGljaCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCkuXG4gICovXG4gIGdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzLCBmcmFnbWVudHMpIHtcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICBsZXQgZnJhZyA9IG51bGw7XG4gICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgaWYgKGxldmVsRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgLy8gUHJlZmVyIHVzaW5nIFBEVCwgYmVjYXVzZSBpdCBjYW4gYmUgYWNjdXJhdGUgZW5vdWdoIHRvIGNob29zZSB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRob3V0IGtub3dpbmcgdGhlIGxldmVsIHNsaWRpbmdcbiAgICAgICAgdGhpcy5sb2coYExpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBQRFQ6ICR7ZnJhZ1ByZXZpb3VzLnByb2dyYW1EYXRlVGltZX1gKTtcbiAgICAgICAgZnJhZyA9IGZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgLy8gU04gZG9lcyBub3QgbmVlZCB0byBiZSBhY2N1cmF0ZSBiZXR3ZWVuIHJlbmRpdGlvbnMsIGJ1dCBkZXBlbmRpbmcgb24gdGhlIHBhY2thZ2luZyBpdCBtYXkgYmUgc28uXG4gICAgICAgIGNvbnN0IHRhcmdldFNOID0gZnJhZ1ByZXZpb3VzLnNuICsgMTtcbiAgICAgICAgaWYgKHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmIHRhcmdldFNOIDw9IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlJ3JlIHN0YXlpbmcgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlLCBzaW5jZSBQVFMgcmVzZXRzIHVwb24gYSBuZXcgcmFuZ2VcbiAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzLmNjID09PSBmcmFnTmV4dC5jYykge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgdGhpcy5sb2coYExpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogJHtmcmFnLnNufWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBzdGF5IHdpdGhpbiB0aGUgY29udGludWl0eSByYW5nZSBpZiBhdmFpbGFibGU7IG90aGVyd2lzZSB0aGUgZnJhZ21lbnRzIGluIHRoZSBwbGF5bGlzdFxuICAgICAgICAvLyB3aWxsIGhhdmUgdGhlIHdyb25nIHN0YXJ0IHRpbWVzXG4gICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgIGZyYWcgPSBmaW5kRnJhZ1dpdGhDQyhmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5jYyk7XG4gICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgQ0M6ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluZCBhIG5ldyBzdGFydCBmcmFnbWVudCB3aGVuIGZyYWdQcmV2aW91cyBpcyBudWxsXG4gICAgICBjb25zdCBsaXZlU3RhcnQgPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuICAgICAgaWYgKGxpdmVTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24obGl2ZVN0YXJ0LCB0aGlzLmJpdHJhdGVUZXN0ID8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kIDogbGV2ZWxEZXRhaWxzLmVkZ2UsIGxldmVsRGV0YWlscyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgLypcbiAgVGhpcyBtZXRob2QgZmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZ2l2ZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWdcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgZnJhZ1ByZXZpb3VzXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIGZyYWdtZW50cyxcbiAgICAgIGVuZFNOXG4gICAgfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudEhpbnRcbiAgICB9ID0gbGV2ZWxEZXRhaWxzO1xuICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgIGNvbnN0IHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuICAgIGNvbnN0IGxvYWRpbmdQYXJ0cyA9ICEhKGNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBwYXJ0TGlzdCAhPSBudWxsICYmIHBhcnRMaXN0Lmxlbmd0aCAmJiBmcmFnbWVudEhpbnQpO1xuICAgIGlmIChsb2FkaW5nUGFydHMgJiYgZnJhZ21lbnRIaW50ICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAvLyBJbmNsdWRlIGluY29tcGxldGUgZnJhZ21lbnQgd2l0aCBwYXJ0cyBhdCBlbmRcbiAgICAgIGZyYWdtZW50cyA9IGZyYWdtZW50cy5jb25jYXQoZnJhZ21lbnRIaW50KTtcbiAgICAgIGVuZFNOID0gZnJhZ21lbnRIaW50LnNuO1xuICAgIH1cbiAgICBsZXQgZnJhZztcbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICBjb25zdCBsb29rdXBUb2xlcmFuY2UgPSBidWZmZXJFbmQgPiBlbmQgLSB0b2xlcmFuY2UgPyAwIDogdG9sZXJhbmNlO1xuICAgICAgLy8gUmVtb3ZlIHRoZSB0b2xlcmFuY2UgaWYgaXQgd291bGQgcHV0IHRoZSBidWZmZXJFbmQgcGFzdCB0aGUgYWN0dWFsIGVuZCBvZiBzdHJlYW1cbiAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuICAgICAgZnJhZyA9IGZpbmRGcmFnbWVudEJ5UFRTKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGxvb2t1cFRvbGVyYW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGlmIChmcmFnKSB7XG4gICAgICBjb25zdCBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIC8vIE1vdmUgZnJhZ1ByZXZpb3VzIGZvcndhcmQgdG8gc3VwcG9ydCBmb3JjaW5nIHRoZSBuZXh0IGZyYWdtZW50IHRvIGxvYWRcbiAgICAgIC8vIHdoZW4gdGhlIGJ1ZmZlciBjYXRjaGVzIHVwIHRvIGEgcHJldmlvdXNseSBidWZmZXJlZCByYW5nZS5cbiAgICAgIGNvbnN0IGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5PSyB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCAmJiBmcmFnLmdhcCkge1xuICAgICAgICBmcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24gJiYgKCFsb2FkaW5nUGFydHMgfHwgcGFydExpc3RbMF0uZnJhZ21lbnQuc24gPiBmcmFnLnNuKSkge1xuICAgICAgICAvLyBGb3JjZSB0aGUgbmV4dCBmcmFnbWVudCB0byBsb2FkIGlmIHRoZSBwcmV2aW91cyBvbmUgd2FzIGFscmVhZHkgc2VsZWN0ZWQuIFRoaXMgY2FuIG9jY2FzaW9uYWxseSBoYXBwZW4gd2l0aFxuICAgICAgICAvLyBub24tdW5pZm9ybSBmcmFnbWVudCBkdXJhdGlvbnNcbiAgICAgICAgY29uc3Qgc2FtZUxldmVsID0gZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbDtcbiAgICAgICAgaWYgKHNhbWVMZXZlbCkge1xuICAgICAgICAgIGNvbnN0IG5leHRGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XG4gICAgICAgICAgaWYgKGZyYWcuc24gPCBlbmRTTiAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShuZXh0RnJhZykgIT09IEZyYWdtZW50U3RhdGUuT0spIHtcbiAgICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG4gIHN5bmNocm9uaXplVG9MaXZlRWRnZShsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCBzdGFydCA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgY29uc3QgZW5kID0gbGV2ZWxEZXRhaWxzLmVkZ2U7XG4gICAgY29uc3Qgd2l0aGluU2xpZGluZ1dpbmRvdyA9IGN1cnJlbnRUaW1lID49IHN0YXJ0IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgJiYgY3VycmVudFRpbWUgPD0gZW5kO1xuICAgIC8vIENvbnRpbnVlIGlmIHdlIGNhbiBzZWVrIGZvcndhcmQgdG8gc3luYyBwb3NpdGlvbiBvciBpZiBjdXJyZW50IHRpbWUgaXMgb3V0c2lkZSBvZiBzbGlkaW5nIHdpbmRvd1xuICAgIGlmIChsaXZlU3luY1Bvc2l0aW9uICE9PSBudWxsICYmIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbiAmJiAoY3VycmVudFRpbWUgPCBsaXZlU3luY1Bvc2l0aW9uIHx8ICF3aXRoaW5TbGlkaW5nV2luZG93KSkge1xuICAgICAgLy8gQ29udGludWUgaWYgYnVmZmVyIGlzIHN0YXJ2aW5nIG9yIGlmIGN1cnJlbnQgdGltZSBpcyBiZWhpbmQgbWF4IGxhdGVuY3lcbiAgICAgIGNvbnN0IG1heExhdGVuY3kgPSBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgaWYgKCF3aXRoaW5TbGlkaW5nV2luZG93ICYmIG1lZGlhLnJlYWR5U3RhdGUgPCA0IHx8IGN1cnJlbnRUaW1lIDwgZW5kIC0gbWF4TGF0ZW5jeSkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgc2VlayBpZiByZWFkeSBhbmQgdGhlcmUgaXMgbm90IGEgc2lnbmlmaWNhbnQgZm9yd2FyZCBidWZmZXIgYXZhaWxhYmxlIGZvciBwbGF5YmFja1xuICAgICAgICBpZiAobWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICAgIHRoaXMud2FybihgUGxheWJhY2s6ICR7Y3VycmVudFRpbWUudG9GaXhlZCgzKX0gaXMgbG9jYXRlZCB0b28gZmFyIGZyb20gdGhlIGVuZCBvZiBsaXZlIHNsaWRpbmcgcGxheWxpc3Q6ICR7ZW5kfSwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiAke2xpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKX1gKTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWxpZ25QbGF5bGlzdHMoZGV0YWlscywgcHJldmlvdXNEZXRhaWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgbGV2ZWxMYXN0TG9hZGVkLFxuICAgICAgZnJhZ1ByZXZpb3VzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbGFzdExldmVsID0gbGV2ZWxMYXN0TG9hZGVkICE9PSBudWxsID8gbGV2ZWxzW2xldmVsTGFzdExvYWRlZF0gOiBudWxsO1xuXG4gICAgLy8gRklYTUU6IElmIG5vdCBmb3IgYHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXNgIHJlcXVpcmluZyBmcmFnUHJldmlvdXMuY2MsXG4gICAgLy8gIHRoaXMgY291bGQgYWxsIGdvIGluIGxldmVsLWhlbHBlciBtZXJnZURldGFpbHMoKVxuICAgIGNvbnN0IGxlbmd0aCA9IGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgdGhpcy53YXJuKGBObyBmcmFnbWVudHMgaW4gbGl2ZSBwbGF5bGlzdGApO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGNvbnN0IGZpcnN0TGV2ZWxMb2FkID0gIXByZXZpb3VzRGV0YWlscztcbiAgICBjb25zdCBhbGlnbmVkID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBpc0Zpbml0ZU51bWJlcihzbGlkaW5nU3RhcnQpO1xuICAgIGlmIChmaXJzdExldmVsTG9hZCB8fCAhYWxpZ25lZCAmJiAhc2xpZGluZ1N0YXJ0KSB7XG4gICAgICBhbGlnblN0cmVhbShmcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgZGV0YWlscyk7XG4gICAgICBjb25zdCBhbGlnbmVkU2xpZGluZ1N0YXJ0ID0gZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICB0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiAke2FsaWduZWRTbGlkaW5nU3RhcnQudG9GaXhlZCgyKX0gc3RhcnQtc246ICR7cHJldmlvdXNEZXRhaWxzID8gcHJldmlvdXNEZXRhaWxzLnN0YXJ0U04gOiAnbmEnfS0+JHtkZXRhaWxzLnN0YXJ0U059IHByZXYtc246ICR7ZnJhZ1ByZXZpb3VzID8gZnJhZ1ByZXZpb3VzLnNuIDogJ25hJ30gZnJhZ21lbnRzOiAke2xlbmd0aH1gKTtcbiAgICAgIHJldHVybiBhbGlnbmVkU2xpZGluZ1N0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gc2xpZGluZ1N0YXJ0O1xuICB9XG4gIHdhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykge1xuICAgIC8vIFdhaXQgZm9yIExvdy1MYXRlbmN5IENETiBUdW5lLWluIHRvIGdldCBhbiB1cGRhdGVkIHBsYXlsaXN0XG4gICAgY29uc3QgYWR2YW5jZVBhcnRMaW1pdCA9IDM7XG4gICAgcmV0dXJuIGRldGFpbHMubGl2ZSAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMucGFydFRhcmdldCAmJiBkZXRhaWxzLnR1bmVJbkdvYWwgPiBNYXRoLm1heChkZXRhaWxzLnBhcnRIb2xkQmFjaywgZGV0YWlscy5wYXJ0VGFyZ2V0ICogYWR2YW5jZVBhcnRMaW1pdCk7XG4gIH1cbiAgc2V0U3RhcnRQb3NpdGlvbihkZXRhaWxzLCBzbGlkaW5nKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IHNsaWRpbmcpIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgLy8gVXNlIFBsYXlsaXN0IEVYVC1YLVNUQVJUOlRJTUUtT0ZGU0VUIHdoZW4gc2V0XG4gICAgICAvLyBQcmlvcml0aXplIE11bHRpdmFyaWFudCBQbGF5bGlzdCBvZmZzZXQgc28gdGhhdCBtYWluLCBhdWRpbywgYW5kIHN1YnRpdGxlIHN0cmVhbS1jb250cm9sbGVyIHN0YXJ0IHRpbWVzIG1hdGNoXG4gICAgICBjb25zdCBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID0gdGhpcy5zdGFydFRpbWVPZmZzZXQgIT09IG51bGw7XG4gICAgICBjb25zdCBzdGFydFRpbWVPZmZzZXQgPSBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID8gdGhpcy5zdGFydFRpbWVPZmZzZXQgOiBkZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgIT09IG51bGwgJiYgaXNGaW5pdGVOdW1iZXIoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gc2xpZGluZyArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCA8IDApIHtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uICs9IGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBzdGFydFBvc2l0aW9uID0gTWF0aC5taW4oTWF0aC5tYXgoc2xpZGluZywgc3RhcnRQb3NpdGlvbiksIHNsaWRpbmcgKyBkZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgICB0aGlzLmxvZyhgU3RhcnQgdGltZSBvZmZzZXQgJHtzdGFydFRpbWVPZmZzZXR9IGZvdW5kIGluICR7b2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdCA/ICdtdWx0aXZhcmlhbnQnIDogJ21lZGlhJ30gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIExlYXZlIHRoaXMuc3RhcnRQb3NpdGlvbiBhdCAtMSwgc28gdGhhdCB3ZSBjYW4gdXNlIGBnZXRJbml0aWFsTGl2ZUZyYWdtZW50YCBsb2dpYyB3aGVuIHN0YXJ0UG9zaXRpb24gaGFzXG4gICAgICAgIC8vIG5vdCBiZWVuIHNwZWNpZmllZCB2aWEgdGhlIGNvbmZpZyBvciBhbiBhcyBhbiBhcmd1bWVudCB0byBzdGFydExvYWQgKCMzNzM2KS5cbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgc2xpZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICB9XG4gIGdldExvYWRQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICBsZXQgcG9zID0gMDtcbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBtZWRpYSkge1xuICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHRMb2FkUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuICBoYW5kbGVGcmFnTG9hZEFib3J0ZWQoZnJhZywgcGFydCkge1xuICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50JyAmJiBmcmFnLnN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHdhcyBhYm9ydGVkYCk7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH1cbiAgfVxuICByZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKSB7XG4gICAgaWYgKCF0aGlzLmZyYWdDdXJyZW50IHx8ICF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG4gIG9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihmaWx0ZXJUeXBlLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuY2h1bmtNZXRhICYmICFkYXRhLmZyYWcpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGRhdGEuY2h1bmtNZXRhKTtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGRhdGEuZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBIYW5kbGUgZnJhZyBlcnJvciByZWxhdGVkIHRvIGNhbGxlcidzIGZpbHRlclR5cGVcbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSBmaWx0ZXJUeXBlIHx8ICF0aGlzLmxldmVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHZhciBfdGhpcyRmcmFnQ3VycmVudDI7XG4gICAgICB0aGlzLndhcm4oYEZyYWcgbG9hZCBlcnJvciBtdXN0IG1hdGNoIGN1cnJlbnQgZnJhZyB0byByZXRyeSAke2ZyYWcudXJsfSA+ICR7KF90aGlzJGZyYWdDdXJyZW50MiA9IHRoaXMuZnJhZ0N1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnQ3VycmVudDIudXJsfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnYXBUYWdFbmNvdW50ZXJlZCA9IGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQO1xuICAgIGlmIChnYXBUYWdFbmNvdW50ZXJlZCkge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcsIHRydWUpO1xuICAgIH1cbiAgICAvLyBrZWVwIHJldHJ5aW5nIHVudGlsIHRoZSBsaW1pdCB3aWxsIGJlIHJlYWNoZWRcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IGRhdGEuZXJyb3JBY3Rpb247XG4gICAgY29uc3Qge1xuICAgICAgYWN0aW9uLFxuICAgICAgcmV0cnlDb3VudCA9IDAsXG4gICAgICByZXRyeUNvbmZpZ1xuICAgIH0gPSBlcnJvckFjdGlvbiB8fCB7fTtcbiAgICBpZiAoZXJyb3JBY3Rpb24gJiYgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0ICYmIHJldHJ5Q29uZmlnKSB7XG4gICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCgoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpICE9IG51bGwgPyBfdGhpcyRsZXZlbExhc3RMb2FkZWQgOiBmcmFnLmxldmVsKTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgJHtmaWx0ZXJUeXBlfSAke2ZyYWcubGV2ZWx9IGVycm9yZWQgd2l0aCAke2RhdGEuZGV0YWlsc30sIHJldHJ5aW5nIGxvYWRpbmcgJHtyZXRyeUNvdW50ICsgMX0vJHtyZXRyeUNvbmZpZy5tYXhOdW1SZXRyeX0gaW4gJHtkZWxheX1tc2ApO1xuICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXRyeURhdGUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgfSBlbHNlIGlmIChyZXRyeUNvbmZpZyAmJiBlcnJvckFjdGlvbikge1xuICAgICAgdGhpcy5yZXNldEZyYWdtZW50RXJyb3JzKGZpbHRlclR5cGUpO1xuICAgICAgaWYgKHJldHJ5Q291bnQgPCByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSkge1xuICAgICAgICAvLyBOZXR3b3JrIHJldHJ5IGlzIHNraXBwZWQgd2hlbiBsZXZlbCBzd2l0Y2ggaXMgcHJlZmVycmVkXG4gICAgICAgIGlmICghZ2FwVGFnRW5jb3VudGVyZWQpIHtcbiAgICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGAke2RhdGEuZGV0YWlsc30gcmVhY2hlZCBvciBleGNlZWRlZCBtYXggcmV0cnkgKCR7cmV0cnlDb3VudH0pYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoZXJyb3JBY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yQWN0aW9uLmFjdGlvbikgPT09IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94KSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgIH1cbiAgICAvLyBQZXJmb3JtIG5leHQgYXN5bmMgdGljayBzb29uZXIgdG8gc3BlZWQgdXAgZXJyb3IgYWN0aW9uIHJlc29sdXRpb25cbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuICByZWR1Y2VMZW5ndGhBbmRGbHVzaEJ1ZmZlcihkYXRhKSB7XG4gICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBkYXRhLnBhcmVudDtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyLCBwbGF5bGlzdFR5cGUpO1xuICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgY29uc3QgYnVmZmVyZWQgPSBidWZmZXJlZEluZm8gJiYgYnVmZmVyZWRJbmZvLmxlbiA+IDAuNTtcbiAgICAgIGlmIChidWZmZXJlZCkge1xuICAgICAgICB0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChidWZmZXJlZEluZm8ubGVuKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsdXNoQnVmZmVyID0gIWJ1ZmZlcmVkO1xuICAgICAgaWYgKGZsdXNoQnVmZmVyKSB7XG4gICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICB0aGlzLndhcm4oYEJ1ZmZlciBmdWxsIGVycm9yIHdoaWxlIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggJHtwbGF5bGlzdFR5cGV9IGJ1ZmZlcmApO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZnJhZykge1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChkYXRhLmZyYWcpO1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkYXRhLmZyYWcuc3RhcnQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICByZXR1cm4gZmx1c2hCdWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXNldEZyYWdtZW50RXJyb3JzKGZpbHRlclR5cGUpIHtcbiAgICBpZiAoZmlsdGVyVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pIHtcbiAgICAgIC8vIFJlc2V0IGN1cnJlbnQgZnJhZ21lbnQgc2luY2UgYXVkaW8gdHJhY2sgYXVkaW8gaXMgZXNzZW50aWFsIGFuZCBtYXkgbm90IGhhdmUgYSBmYWlsLW92ZXIgdHJhY2tcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBGcmFnbWVudCBlcnJvcnMgdGhhdCByZXN1bHQgaW4gYSBsZXZlbCBzd2l0Y2ggb3IgcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgIC8vIHNob3VsZCByZXNldCB0aGUgc3RyZWFtIGNvbnRyb2xsZXIgc3RhdGUgdG8gaWRsZVxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgfVxuICBhZnRlckJ1ZmZlckZsdXNoZWQobWVkaWEsIGJ1ZmZlclR5cGUsIHBsYXlsaXN0VHlwZSkge1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgc3VjY2Vzc2Z1bCBidWZmZXIgZmx1c2hpbmcsIGZpbHRlciBmbHVzaGVkIGZyYWdtZW50cyBmcm9tIGJ1ZmZlcmVkRnJhZ3MgdXNlIG1lZGlhQnVmZmVyZWQgaW5zdGVhZCBvZiBtZWRpYVxuICAgIC8vIChzbyB0aGF0IHdlIHdpbGwgY2hlY2sgYWdhaW5zdCB2aWRlby5idWZmZXJlZCByYW5nZXMgaW4gY2FzZSBvZiBhbHQgYXVkaW8gdHJhY2spXG4gICAgY29uc3QgYnVmZmVyZWRUaW1lUmFuZ2VzID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGJ1ZmZlclR5cGUsIGJ1ZmZlcmVkVGltZVJhbmdlcywgcGxheWxpc3RUeXBlKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRMb2FkaW5nU3RhdGUoKSB7XG4gICAgdGhpcy5sb2coJ1Jlc2V0IGxvYWRpbmcgc3RhdGUnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cbiAgcmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQobGV2ZWwpIHtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IGZpcnN0IGZyYWcgcmVxdWVzdCBmYWlsZWRcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZGV0YWlscyA9IHRoaXMubGV2ZWxzID8gdGhpcy5sZXZlbHNbbGV2ZWxdLmRldGFpbHMgOiBudWxsO1xuICAgICAgaWYgKGRldGFpbHMgIT0gbnVsbCAmJiBkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGFydCBwb3NpdGlvbiBhbmQgcmV0dXJuIHRvIElETEUgdG8gcmVjb3ZlciBsaXZlIHN0YXJ0XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24oZGV0YWlscywgMCk7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzZXRXaGVuTWlzc2luZ0NvbnRleHQoY2h1bmtNZXRhKSB7XG4gICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDI7XG4gICAgdGhpcy53YXJuKGBUaGUgbG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50ICR7Y2h1bmtNZXRhLnNufSBvZiBsZXZlbCAke2NodW5rTWV0YS5sZXZlbH0uIFRoaXMgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuYCk7XG4gICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoKTtcbiAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKChfdGhpcyRsZXZlbExhc3RMb2FkZWQyID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpICE9IG51bGwgPyBfdGhpcyRsZXZlbExhc3RMb2FkZWQyIDogY2h1bmtNZXRhLmxldmVsKTtcbiAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gIH1cbiAgcmVtb3ZlVW5idWZmZXJlZEZyYWdzKHN0YXJ0ID0gMCkge1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnQsIEluZmluaXR5LCB0aGlzLnBsYXlsaXN0VHlwZSwgZmFsc2UsIHRydWUpO1xuICB9XG4gIHVwZGF0ZUxldmVsVGltaW5nKGZyYWcsIHBhcnQsIGxldmVsLCBwYXJ0aWFsKSB7XG4gICAgdmFyIF90aGlzJHRyYW5zbXV4ZXI7XG4gICAgY29uc3QgZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oJ2xldmVsLmRldGFpbHMgdW5kZWZpbmVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IE9iamVjdC5rZXlzKGZyYWcuZWxlbWVudGFyeVN0cmVhbXMpLnJlZHVjZSgocmVzdWx0LCB0eXBlKSA9PiB7XG4gICAgICBjb25zdCBpbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZER1cmF0aW9uID0gaW5mby5lbmRQVFMgLSBpbmZvLnN0YXJ0UFRTO1xuICAgICAgICBpZiAocGFyc2VkRHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIHRyYW5zbXV4ZXIgYWZ0ZXIgaXQncyBuZXh0IHRpbWUgb2Zmc2V0IGZhaWxlZCB0byBhZHZhbmNlIGJlY2F1c2UgZHVyYXRpb24gd2FzIDw9IDAuXG4gICAgICAgICAgLy8gVGhlIG5ldyB0cmFuc211eGVyIHdpbGwgYmUgY29uZmlndXJlZCB3aXRoIGEgdGltZSBvZmZzZXQgbWF0Y2hpbmcgdGhlIG5leHQgZnJhZ21lbnQgc3RhcnQsXG4gICAgICAgICAgLy8gcHJldmVudGluZyB0aGUgdGltZWxpbmUgZnJvbSBzaGlmdGluZy5cbiAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBwYXJzZSBmcmFnbWVudCAke2ZyYWcuc259ICR7dHlwZX0gZHVyYXRpb24gcmVsaWFibHkgKCR7cGFyc2VkRHVyYXRpb259KWApO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHJpZnQgPSBwYXJ0aWFsID8gMCA6IHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscywgZnJhZywgaW5mby5zdGFydFBUUywgaW5mby5lbmRQVFMsIGluZm8uc3RhcnREVFMsIGluZm8uZW5kRFRTKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsIHtcbiAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgIGxldmVsLFxuICAgICAgICAgIGRyaWZ0LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBzdGFydDogaW5mby5zdGFydFBUUyxcbiAgICAgICAgICBlbmQ6IGluZm8uZW5kUFRTXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgZmFsc2UpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgIH0gZWxzZSBpZiAoKChfdGhpcyR0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhbnNtdXhlci5lcnJvcikgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGb3VuZCBubyBtZWRpYSBpbiBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gcmVzZXR0aW5nIHRyYW5zbXV4ZXIgdG8gZmFsbGJhY2sgdG8gcGxheWxpc3QgdGltaW5nYCk7XG4gICAgICBpZiAobGV2ZWwuZnJhZ21lbnRFcnJvciA9PT0gMCkge1xuICAgICAgICAvLyBNYXJrIGFuZCB0cmFjayB0aGUgb2RkIGVtcHR5IHNlZ21lbnQgYXMgYSBnYXAgdG8gYXZvaWQgcmVsb2FkaW5nXG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcsIHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcmVhc29uOiBgRm91bmQgbm8gbWVkaWEgaW4gbXNuICR7ZnJhZy5zbn0gb2YgbGV2ZWwgXCIke2xldmVsLnVybH1cImBcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgLy8gRm9yIHRoaXMgZXJyb3IgZmFsbHRocm91Z2guIE1hcmtpbmcgcGFyc2VkIHdpbGwgYWxsb3cgYWR2YW5jaW5nIHRvIG5leHQgZnJhZ21lbnQuXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNFRCwge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9KTtcbiAgfVxuICByZXNldFRyYW5zbXV4ZXIoKSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgdGhpcy50cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlY292ZXJXb3JrZXJFcnJvcihkYXRhKSB7XG4gICAgaWYgKGRhdGEuZXZlbnQgPT09ICdkZW11eGVyV29ya2VyJykge1xuICAgICAgdmFyIF9yZWYsIF90aGlzJGxldmVsTGFzdExvYWRlZDMsIF90aGlzJGZyYWdDdXJyZW50MztcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoKF9yZWYgPSAoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkMyA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSAhPSBudWxsID8gX3RoaXMkbGV2ZWxMYXN0TG9hZGVkMyA6IChfdGhpcyRmcmFnQ3VycmVudDMgPSB0aGlzLmZyYWdDdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZnJhZ0N1cnJlbnQzLmxldmVsKSAhPSBudWxsID8gX3JlZiA6IDApO1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQgc3RhdGUobmV4dFN0YXRlKSB7XG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgdGhpcy5sb2coYCR7cHJldmlvdXNTdGF0ZX0tPiR7bmV4dFN0YXRlfWApO1xuICAgIH1cbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUJ1ZmZlcigpIHtcbiAgcmV0dXJuIHNlbGYuU291cmNlQnVmZmVyIHx8IHNlbGYuV2ViS2l0U291cmNlQnVmZmVyO1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gIGNvbnN0IG1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgY29uc3QgaXNUeXBlU3VwcG9ydGVkID0gbWVkaWFTb3VyY2UgJiYgdHlwZW9mIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUUsbXA0YS40MC4yXCInKTtcblxuICAvLyBpZiBTb3VyY2VCdWZmZXIgaXMgZXhwb3NlZCBlbnN1cmUgaXRzIEFQSSBpcyB2YWxpZFxuICAvLyBPbGRlciBicm93c2VycyBkbyBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcbiAgY29uc3Qgc291cmNlQnVmZmVyVmFsaWRBUEkgPSAhc291cmNlQnVmZmVyIHx8IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgJiYgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYXBwZW5kQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuICEhaXNUeXBlU3VwcG9ydGVkICYmICEhc291cmNlQnVmZmVyVmFsaWRBUEk7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBjaGFuZ2VUeXBlU3VwcG9ydGVkKCkge1xuICB2YXIgX3NvdXJjZUJ1ZmZlciRwcm90b3R5O1xuICBjb25zdCBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgcmV0dXJuIHR5cGVvZiAoc291cmNlQnVmZmVyID09IG51bGwgPyB2b2lkIDAgOiAoX3NvdXJjZUJ1ZmZlciRwcm90b3R5ID0gc291cmNlQnVmZmVyLnByb3RvdHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zb3VyY2VCdWZmZXIkcHJvdG90eS5jaGFuZ2VUeXBlKSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLy8gZW5zdXJlIHRoZSB3b3JrZXIgZW5kcyB1cCBpbiB0aGUgYnVuZGxlXG4vLyBJZiB0aGUgd29ya2VyIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgdGhpcyBnZXRzIGFsaWFzZWQgdG8gZW1wdHkuanNcbmZ1bmN0aW9uIGhhc1VNRFdvcmtlcigpIHtcbiAgcmV0dXJuIHR5cGVvZiBfX0hMU19XT1JLRVJfQlVORExFX18gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpbmplY3RXb3JrZXIoKSB7XG4gIGNvbnN0IGJsb2IgPSBuZXcgc2VsZi5CbG9iKFtgdmFyIGV4cG9ydHM9e307dmFyIG1vZHVsZT17ZXhwb3J0czpleHBvcnRzfTtmdW5jdGlvbiBkZWZpbmUoZil7ZigpfTtkZWZpbmUuYW1kPXRydWU7KCR7X19ITFNfV09SS0VSX0JVTkRMRV9fLnRvU3RyaW5nKCl9KSh0cnVlKTtgXSwge1xuICAgIHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnXG4gIH0pO1xuICBjb25zdCBvYmplY3RVUkwgPSBzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIGNvbnN0IHdvcmtlciA9IG5ldyBzZWxmLldvcmtlcihvYmplY3RVUkwpO1xuICByZXR1cm4ge1xuICAgIHdvcmtlcixcbiAgICBvYmplY3RVUkxcbiAgfTtcbn1cbmZ1bmN0aW9uIGxvYWRXb3JrZXIocGF0aCkge1xuICBjb25zdCBzY3JpcHRVUkwgPSBuZXcgc2VsZi5VUkwocGF0aCwgc2VsZi5sb2NhdGlvbi5ocmVmKS5ocmVmO1xuICBjb25zdCB3b3JrZXIgPSBuZXcgc2VsZi5Xb3JrZXIoc2NyaXB0VVJMKTtcbiAgcmV0dXJuIHtcbiAgICB3b3JrZXIsXG4gICAgc2NyaXB0VVJMXG4gIH07XG59XG5cbmZ1bmN0aW9uIGR1bW15VHJhY2sodHlwZSA9ICcnLCBpbnB1dFRpbWVTY2FsZSA9IDkwMDAwKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBpZDogLTEsXG4gICAgcGlkOiAtMSxcbiAgICBpbnB1dFRpbWVTY2FsZSxcbiAgICBzZXF1ZW5jZU51bWJlcjogLTEsXG4gICAgc2FtcGxlczogW10sXG4gICAgZHJvcHBlZDogMFxuICB9O1xufVxuXG5jbGFzcyBCYXNlQXVkaW9EZW11eGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYW1lSW5kZXggPSAwO1xuICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgdGhpcy5iYXNlUFRTID0gbnVsbDtcbiAgICB0aGlzLmluaXRQVFMgPSBudWxsO1xuICAgIHRoaXMubGFzdFBUUyA9IG51bGw7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHRoaXMuX2lkM1RyYWNrID0ge1xuICAgICAgdHlwZTogJ2lkMycsXG4gICAgICBpZDogMyxcbiAgICAgIHBpZDogLTEsXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoZGVhdWx0VGltZXN0YW1wKSB7XG4gICAgdGhpcy5pbml0UFRTID0gZGVhdWx0VGltZXN0YW1wO1xuICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gIH1cbiAgcmVzZXRDb250aWd1aXR5KCkge1xuICAgIHRoaXMuYmFzZVBUUyA9IG51bGw7XG4gICAgdGhpcy5sYXN0UFRTID0gbnVsbDtcbiAgICB0aGlzLmZyYW1lSW5kZXggPSAwO1xuICB9XG4gIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7fVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgZGVtdXgoZGF0YSwgdGltZU9mZnNldCkge1xuICAgIGlmICh0aGlzLmNhY2hlZERhdGEpIHtcbiAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMuY2FjaGVkRGF0YSwgZGF0YSk7XG4gICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgIH1cbiAgICBsZXQgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEgPyBpZDNEYXRhLmxlbmd0aCA6IDA7XG4gICAgbGV0IGxhc3REYXRhSW5kZXg7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgY29uc3QgdGltZXN0YW1wID0gaWQzRGF0YSA/IGdldFRpbWVTdGFtcChpZDNEYXRhKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBpZiAodGhpcy5iYXNlUFRTID09PSBudWxsIHx8IHRoaXMuZnJhbWVJbmRleCA9PT0gMCAmJiBpc0Zpbml0ZU51bWJlcih0aW1lc3RhbXApKSB7XG4gICAgICB0aGlzLmJhc2VQVFMgPSBpbml0UFRTRm4odGltZXN0YW1wLCB0aW1lT2Zmc2V0LCB0aGlzLmluaXRQVFMpO1xuICAgICAgdGhpcy5sYXN0UFRTID0gdGhpcy5iYXNlUFRTO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYXN0UFRTID09PSBudWxsKSB7XG4gICAgICB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFM7XG4gICAgfVxuXG4gICAgLy8gbW9yZSBleHByZXNzaXZlIHRoYW4gYWx0ZXJuYXRpdmU6IGlkM0RhdGE/Lmxlbmd0aFxuICAgIGlmIChpZDNEYXRhICYmIGlkM0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgcHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgIGR0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICBkYXRhOiBpZDNEYXRhLFxuICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgfSk7XG4gICAgfVxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLmNhblBhcnNlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLmZyYW1lSW5kZXgrKztcbiAgICAgICAgICB0aGlzLmxhc3RQVFMgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgbGFzdERhdGFJbmRleCA9IG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FuUGFyc2UkMihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIC8vIGFmdGVyIGEgSUQzLmNhblBhcnNlLCBhIGNhbGwgdG8gSUQzLmdldElEM0RhdGEgKnNob3VsZCogYWx3YXlzIHJldHVybnMgc29tZSBkYXRhXG4gICAgICAgIGlkM0RhdGEgPSBnZXRJRDNEYXRhKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgcHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgZHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCAmJiBsYXN0RGF0YUluZGV4ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGFydGlhbERhdGEgPSBzbGljZVVpbnQ4KGRhdGEsIGxhc3REYXRhSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLmNhY2hlZERhdGEsIHBhcnRpYWxEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBwYXJ0aWFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9UcmFjazogdHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiBkdW1teVRyYWNrKCksXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpXG4gICAgfTtcbiAgfVxuICBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgWyR7dGhpc31dIFRoaXMgZGVtdXhlciBkb2VzIG5vdCBzdXBwb3J0IFNhbXBsZS1BRVMgZGVjcnlwdGlvbmApKTtcbiAgfVxuICBmbHVzaCh0aW1lT2Zmc2V0KSB7XG4gICAgLy8gUGFyc2UgY2FjaGUgaW4gY2FzZSBvZiByZW1haW5pbmcgZnJhbWVzLlxuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmNhY2hlZERhdGE7XG4gICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmRlbXV4KGNhY2hlZERhdGEsIDApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2s6IGR1bW15VHJhY2soKSxcbiAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge31cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIFBUU1xuICogPHA+XG4gKiAgICB1c2UgdGltZXN0YW1wIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsIE5hTiBvciBJbmZpbml0eVxuICogPC9wPlxuICovXG5jb25zdCBpbml0UFRTRm4gPSAodGltZXN0YW1wLCB0aW1lT2Zmc2V0LCBpbml0UFRTKSA9PiB7XG4gIGlmIChpc0Zpbml0ZU51bWJlcih0aW1lc3RhbXApKSB7XG4gICAgcmV0dXJuIHRpbWVzdGFtcCAqIDkwO1xuICB9XG4gIGNvbnN0IGluaXQ5MGtIeiA9IGluaXRQVFMgPyBpbml0UFRTLmJhc2VUaW1lICogOTAwMDAgLyBpbml0UFRTLnRpbWVzY2FsZSA6IDA7XG4gIHJldHVybiB0aW1lT2Zmc2V0ICogOTAwMDAgKyBpbml0OTBrSHo7XG59O1xuXG4vKipcbiAqIEFEVFMgcGFyc2VyIGhlbHBlclxuICogQGxpbmsgaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAqL1xuZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICBsZXQgYWR0c09iamVjdFR5cGU7XG4gIGxldCBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleDtcbiAgbGV0IGFkdHNDaGFubmVsQ29uZmlnO1xuICBsZXQgY29uZmlnO1xuICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IG1hbmlmZXN0Q29kZWMgPSBhdWRpb0NvZGVjO1xuICBjb25zdCBhZHRzU2FtcGxpbmdSYXRlcyA9IFs5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLCAyNDAwMCwgMjIwNTAsIDE2MDAwLCAxMjAwMCwgMTEwMjUsIDgwMDAsIDczNTBdO1xuICAvLyBieXRlIDJcbiAgYWR0c09iamVjdFR5cGUgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweGMwKSA+Pj4gNikgKyAxO1xuICBjb25zdCBhZHRzU2FtcGxpbmdJbmRleCA9IChkYXRhW29mZnNldCArIDJdICYgMHgzYykgPj4+IDI7XG4gIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+IGFkdHNTYW1wbGluZ1JhdGVzLmxlbmd0aCAtIDEpIHtcbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgIHJlYXNvbjogYGludmFsaWQgQURUUyBzYW1wbGluZyBpbmRleDoke2FkdHNTYW1wbGluZ0luZGV4fWBcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgYWR0c0NoYW5uZWxDb25maWcgPSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4MDEpIDw8IDI7XG4gIC8vIGJ5dGUgM1xuICBhZHRzQ2hhbm5lbENvbmZpZyB8PSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4YzApID4+PiA2O1xuICBsb2dnZXIubG9nKGBtYW5pZmVzdCBjb2RlYzoke2F1ZGlvQ29kZWN9LCBBRFRTIHR5cGU6JHthZHRzT2JqZWN0VHlwZX0sIHNhbXBsaW5nSW5kZXg6JHthZHRzU2FtcGxpbmdJbmRleH1gKTtcbiAgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gIGlmICgvZmlyZWZveC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gICAgfVxuICAgIC8vIEFuZHJvaWQgOiBhbHdheXMgdXNlIEFBQ1xuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICB9IGVsc2Uge1xuICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAqL1xuICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgaWYgKGF1ZGlvQ29kZWMgJiYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSB8fCBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkgfHwgIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsaW5nSW5kZXggPj0gNikge1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gcGxheSBiYWNrIHdpdGggbG93IGZyZXF1ZW5jeSBBQUMgTEMgbW9ubyB3aGVuIGluaXRpYWxpemVkIHdpdGggSEUtQUFDLiAgVGhpcyBpcyBub3QgYSBwcm9ibGVtIHdpdGggc3RlcmVvLlxuICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEgJiYgKGFkdHNTYW1wbGluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5uZWxDb25maWcgPT09IDEgfHwgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpIHx8ICFhdWRpb0NvZGVjICYmIGFkdHNDaGFubmVsQ29uZmlnID09PSAxKSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgfVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgICB9XG4gIH1cbiAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgIDA6IE51bGxcbiAgICAxOiBBQUMgTWFpblxuICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgc2FtcGxpbmcgZnJlcVxuICAgIDA6IDk2MDAwIEh6XG4gICAgMTogODgyMDAgSHpcbiAgICAyOiA2NDAwMCBIelxuICAgIDM6IDQ4MDAwIEh6XG4gICAgNDogNDQxMDAgSHpcbiAgICA1OiAzMjAwMCBIelxuICAgIDY6IDI0MDAwIEh6XG4gICAgNzogMjIwNTAgSHpcbiAgICA4OiAxNjAwMCBIelxuICAgIDk6IDEyMDAwIEh6XG4gICAgMTA6IDExMDI1IEh6XG4gICAgMTE6IDgwMDAgSHpcbiAgICAxMjogNzM1MCBIelxuICAgIDEzOiBSZXNlcnZlZFxuICAgIDE0OiBSZXNlcnZlZFxuICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAqL1xuICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xuICAvLyBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4XG4gIGNvbmZpZ1swXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDBlKSA+PiAxO1xuICBjb25maWdbMV0gfD0gKGFkdHNTYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cbiAgY29uZmlnWzFdIHw9IGFkdHNDaGFubmVsQ29uZmlnIDw8IDM7XG4gIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSkge1xuICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4XG4gICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MGUpID4+IDE7XG4gICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcbiAgICBjb25maWdbM10gPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29uZmlnLFxuICAgIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGluZ1JhdGVzW2FkdHNTYW1wbGluZ0luZGV4XSxcbiAgICBjaGFubmVsQ291bnQ6IGFkdHNDaGFubmVsQ29uZmlnLFxuICAgIGNvZGVjOiAnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUsXG4gICAgbWFuaWZlc3RDb2RlY1xuICB9O1xufVxuZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuJDEoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGY2KSA9PT0gMHhmMDtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxID8gNyA6IDk7XG59XG5mdW5jdGlvbiBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExIHwgZGF0YVtvZmZzZXQgKyA0XSA8PCAzIHwgKGRhdGFbb2Zmc2V0ICsgNV0gJiAweGUwKSA+Pj4gNTtcbn1cbmZ1bmN0aW9uIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgNSA8IGRhdGEubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpIHtcbiAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgcmV0dXJuIG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4kMShkYXRhLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gY2FuUGFyc2UkMShkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgJiYgaXNIZWFkZXJQYXR0ZXJuJDEoZGF0YSwgb2Zmc2V0KSAmJiBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn1cbmZ1bmN0aW9uIHByb2JlJDEoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBBRFRTIGZyYW1lIGZvbGxvd3MgbGFzdCBBRFRTIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKGlzSGVhZGVyJDEoZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIEFEVFMgaGVhZGVyIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQURUUyBmcmFtZSBMZW5ndGhcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChmcmFtZUxlbmd0aCA8PSBoZWFkZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIkMShkYXRhLCBuZXdPZmZzZXQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGluaXRUcmFja0NvbmZpZyh0cmFjaywgb2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFjay5jb25maWcgPSBjb25maWcuY29uZmlnO1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBjb25maWcuc2FtcGxlcmF0ZTtcbiAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLmNvZGVjID0gY29uZmlnLmNvZGVjO1xuICAgIHRyYWNrLm1hbmlmZXN0Q29kZWMgPSBjb25maWcubWFuaWZlc3RDb2RlYztcbiAgICBsb2dnZXIubG9nKGBwYXJzZWQgY29kZWM6JHt0cmFjay5jb2RlY30sIHJhdGU6JHtjb25maWcuc2FtcGxlcmF0ZX0sIGNoYW5uZWxzOiR7Y29uZmlnLmNoYW5uZWxDb3VudH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RnJhbWVEdXJhdGlvbihzYW1wbGVyYXRlKSB7XG4gIHJldHVybiAxMDI0ICogOTAwMDAgLyBzYW1wbGVyYXRlO1xufVxuZnVuY3Rpb24gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpIHtcbiAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gIGNvbnN0IGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gcmV0cmlldmUgZnJhbWUgc2l6ZVxuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgLSBoZWFkZXJMZW5ndGg7XG4gICAgaWYgKGZyYW1lTGVuZ3RoID4gMCkge1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyTGVuZ3RoLFxuICAgICAgICBmcmFtZUxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICBjb25zdCBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICBjb25zdCBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gIGxldCB1bml0O1xuICBpZiAoaGVhZGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhbWVMZW5ndGgsXG4gICAgICBoZWFkZXJMZW5ndGhcbiAgICB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IF9sZW5ndGggPSBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aDtcbiAgICBjb25zdCBtaXNzaW5nID0gTWF0aC5tYXgoMCwgb2Zmc2V0ICsgX2xlbmd0aCAtIGRhdGEubGVuZ3RoKTtcbiAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUgJHtmcmFtZUluZGV4fSwgcHRzOiR7c3RhbXB9IGxlbmd0aEBvZmZzZXQvdG90YWw6ICR7ZnJhbWVMZW5ndGh9QCR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9IG1pc3Npbmc6ICR7bWlzc2luZ31gKTtcbiAgICBpZiAobWlzc2luZykge1xuICAgICAgdW5pdCA9IG5ldyBVaW50OEFycmF5KF9sZW5ndGggLSBoZWFkZXJMZW5ndGgpO1xuICAgICAgdW5pdC5zZXQoZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIGRhdGEubGVuZ3RoKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgX2xlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IF9zYW1wbGUgPSB7XG4gICAgICB1bml0LFxuICAgICAgcHRzOiBzdGFtcFxuICAgIH07XG4gICAgaWYgKCFtaXNzaW5nKSB7XG4gICAgICB0cmFjay5zYW1wbGVzLnB1c2goX3NhbXBsZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGU6IF9zYW1wbGUsXG4gICAgICBsZW5ndGg6IF9sZW5ndGgsXG4gICAgICBtaXNzaW5nXG4gICAgfTtcbiAgfVxuICAvLyBvdmVyZmxvdyBpbmNvbXBsZXRlIGhlYWRlclxuICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbiAgdW5pdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHVuaXQuc2V0KGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmxlbmd0aCksIDApO1xuICBjb25zdCBzYW1wbGUgPSB7XG4gICAgdW5pdCxcbiAgICBwdHM6IHN0YW1wXG4gIH07XG4gIHJldHVybiB7XG4gICAgc2FtcGxlLFxuICAgIGxlbmd0aCxcbiAgICBtaXNzaW5nOiAtMVxuICB9O1xufVxuXG4vKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cbmNsYXNzIEFBQ0RlbXV4ZXIgZXh0ZW5kcyBCYXNlQXVkaW9EZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9hZHRzJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ2FhYycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG5cbiAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdGhlIEFEVFMgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgY29uc3QgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgMCkgfHwgW107XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAocHJvYmUkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gY2FuUGFyc2UkMShkYXRhLCBvZmZzZXQpO1xuICB9XG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBpbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdHJhY2subWFuaWZlc3RDb2RlYyk7XG4gICAgY29uc3QgZnJhbWUgPSBhcHBlbmRGcmFtZSQxKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHRoaXMuYmFzZVBUUywgdGhpcy5mcmFtZUluZGV4KTtcbiAgICBpZiAoZnJhbWUgJiYgZnJhbWUubWlzc2luZyA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBlbXNnU2NoZW1lUGF0dGVybiA9IC9cXC9lbXNnWy0vXUlEMy9pO1xuY2xhc3MgTVA0RGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmlkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMudHh0VHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoKSB7fVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjayA9IGR1bW15VHJhY2soJ3ZpZGVvJywgMSk7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMuYXVkaW9UcmFjayA9IGR1bW15VHJhY2soJ2F1ZGlvJywgMSk7XG4gICAgY29uc3QgY2FwdGlvblRyYWNrID0gdGhpcy50eHRUcmFjayA9IGR1bW15VHJhY2soJ3RleHQnLCAxKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gZHVtbXlUcmFjaygnaWQzJywgMSk7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gMDtcbiAgICBpZiAoIShpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG4gICAgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgIGNvZGVjXG4gICAgICB9ID0gaW5pdERhdGEudmlkZW87XG4gICAgICB2aWRlb1RyYWNrLmlkID0gaWQ7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IGNhcHRpb25UcmFjay50aW1lc2NhbGUgPSB0aW1lc2NhbGU7XG4gICAgICB2aWRlb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgfVxuICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICBjb2RlY1xuICAgICAgfSA9IGluaXREYXRhLmF1ZGlvO1xuICAgICAgYXVkaW9UcmFjay5pZCA9IGlkO1xuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSB0aW1lc2NhbGU7XG4gICAgICBhdWRpb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgfVxuICAgIGNhcHRpb25UcmFjay5pZCA9IFJlbXV4ZXJUcmFja0lkQ29uZmlnLnRleHQ7XG4gICAgdmlkZW9UcmFjay5zYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgdmlkZW9UcmFjay5kdXJhdGlvbiA9IGF1ZGlvVHJhY2suZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgLy8gZW5zdXJlIHdlIGZpbmQgYSBtb29mIGJveCBpbiB0aGUgZmlyc3QgMTYga0JcbiAgICBkYXRhID0gZGF0YS5sZW5ndGggPiAxNjM4NCA/IGRhdGEuc3ViYXJyYXkoMCwgMTYzODQpIDogZGF0YTtcbiAgICByZXR1cm4gZmluZEJveChkYXRhLCBbJ21vb2YnXSkubGVuZ3RoID4gMDtcbiAgfVxuICBkZW11eChkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAvLyBMb2FkIGFsbCBkYXRhIGludG8gdGhlIGF2YyB0cmFjay4gVGhlIENNQUYgcmVtdXhlciB3aWxsIGxvb2sgZm9yIHRoZSBkYXRhIGluIHRoZSBzYW1wbGVzIG9iamVjdDsgdGhlIHJlc3Qgb2YgdGhlIGZpZWxkcyBkbyBub3QgbWF0dGVyXG4gICAgbGV0IHZpZGVvU2FtcGxlcyA9IGRhdGE7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrO1xuICAgIGlmICh0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgLy8gU3BsaXQgdGhlIGJ5dGVzdHJlYW0gaW50byB0d28gcmFuZ2VzOiBvbmUgZW5jb21wYXNzaW5nIGFsbCBkYXRhIHVwIHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBtb29mLCBhbmQgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIGd1YXJhbnRlZSB0aGF0IHdlJ3JlIHNlbmRpbmcgdmFsaWQgZGF0YSB0byBNU0UgLSB3aGVuIGRlbXV4aW5nIHByb2dyZXNzaXZlbHksIHdlIGhhdmUgbm8gZ3VhcmFudGVlXG4gICAgICAvLyB0aGF0IHRoZSBmZXRjaCBsb2FkZXIgZ2l2ZXMgdXMgZmx1c2ggbW9vZittZGF0IHBhaXJzLiBJZiB3ZSBwdXNoIGphZ2dlZCBkYXRhIHRvIE1TRSwgaXQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIHZpZGVvU2FtcGxlcyA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlZ21lbnRlZERhdGEgPSBzZWdtZW50VmFsaWRSYW5nZSh2aWRlb1NhbXBsZXMpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2VnbWVudGVkRGF0YS5yZW1haW5kZXI7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSBzZWdtZW50ZWREYXRhLnZhbGlkIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvU2FtcGxlcztcbiAgICB9XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICB0ZXh0VHJhY2suc2FtcGxlcyA9IHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuYXVkaW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiB0aGlzLnR4dFRyYWNrXG4gICAgfTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB0aW1lT2Zmc2V0ID0gdGhpcy50aW1lT2Zmc2V0O1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLnZpZGVvVHJhY2s7XG4gICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy50eHRUcmFjaztcbiAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB0aGlzLnJlbWFpbmRlckRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5leHRyYWN0SUQzVHJhY2sodmlkZW9UcmFjaywgdGhpcy50aW1lT2Zmc2V0KTtcbiAgICB0ZXh0VHJhY2suc2FtcGxlcyA9IHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGF1ZGlvVHJhY2s6IGR1bW15VHJhY2soKSxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKClcbiAgICB9O1xuICB9XG4gIGV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrO1xuICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbXNncyA9IGZpbmRCb3godmlkZW9UcmFjay5zYW1wbGVzLCBbJ2Vtc2cnXSk7XG4gICAgICBpZiAoZW1zZ3MpIHtcbiAgICAgICAgZW1zZ3MuZm9yRWFjaChkYXRhID0+IHtcbiAgICAgICAgICBjb25zdCBlbXNnSW5mbyA9IHBhcnNlRW1zZyhkYXRhKTtcbiAgICAgICAgICBpZiAoZW1zZ1NjaGVtZVBhdHRlcm4udGVzdChlbXNnSW5mby5zY2hlbWVJZFVyaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0cyA9IGlzRmluaXRlTnVtYmVyKGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWUpID8gZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSAvIGVtc2dJbmZvLnRpbWVTY2FsZSA6IHRpbWVPZmZzZXQgKyBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lRGVsdGEgLyBlbXNnSW5mby50aW1lU2NhbGU7XG4gICAgICAgICAgICBsZXQgZHVyYXRpb24gPSBlbXNnSW5mby5ldmVudER1cmF0aW9uID09PSAweGZmZmZmZmZmID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogZW1zZ0luZm8uZXZlbnREdXJhdGlvbiAvIGVtc2dJbmZvLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIC8vIFNhZmFyaSB0YWtlcyBhbnl0aGluZyA8PSAwLjAwMSBzZWNvbmRzIGFuZCBtYXBzIGl0IHRvIEluZmluaXR5XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPD0gMC4wMDEpIHtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZW1zZ0luZm8ucGF5bG9hZDtcbiAgICAgICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgIGRhdGE6IHBheWxvYWQsXG4gICAgICAgICAgICAgIGxlbjogcGF5bG9hZC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLmVtc2csXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkM1RyYWNrO1xuICB9XG4gIGRlbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUaGUgTVA0IGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTQU1QTEUtQUVTIGRlY3J5cHRpb24nKSk7XG4gIH1cbiAgZGVzdHJveSgpIHt9XG59XG5cbi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG5cbmxldCBjaHJvbWVWZXJzaW9uJDEgPSBudWxsO1xuY29uc3QgQml0cmF0ZXNNYXAgPSBbMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzg0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NiwgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwXTtcbmNvbnN0IFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xuY29uc3QgU2FtcGxlc0NvZWZmaWNpZW50cyA9IFtcbi8vIE1QRUcgMi41XG5bMCxcbi8vIFJlc2VydmVkXG43Mixcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sXG4vLyBSZXNlcnZlZFxuWzAsXG4vLyBSZXNlcnZlZFxuMCxcbi8vIExheWVyM1xuMCxcbi8vIExheWVyMlxuMCAvLyBMYXllcjFcbl0sXG4vLyBNUEVHIDJcblswLFxuLy8gUmVzZXJ2ZWRcbjcyLFxuLy8gTGF5ZXIzXG4xNDQsXG4vLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXSxcbi8vIE1QRUcgMVxuWzAsXG4vLyBSZXNlcnZlZFxuMTQ0LFxuLy8gTGF5ZXIzXG4xNDQsXG4vLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXV07XG5cbmNvbnN0IEJ5dGVzSW5TbG90ID0gWzAsXG4vLyBSZXNlcnZlZFxuMSxcbi8vIExheWVyM1xuMSxcbi8vIExheWVyMlxuNCAvLyBMYXllcjFcbl07XG5cbmZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxuICBpZiAob2Zmc2V0ICsgMjQgPiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWFkZXIgPSBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICBpZiAoaGVhZGVyICYmIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBoZWFkZXIuc2FtcGxlc1BlckZyYW1lICogOTAwMDAgLyBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICBjb25zdCBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgIGNvbnN0IHNhbXBsZSA9IHtcbiAgICAgIHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGgpLFxuICAgICAgcHRzOiBzdGFtcCxcbiAgICAgIGR0czogc3RhbXBcbiAgICB9O1xuICAgIHRyYWNrLmNvbmZpZyA9IFtdO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGhlYWRlci5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGhlYWRlci5zYW1wbGVSYXRlO1xuICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGUsXG4gICAgICBsZW5ndGg6IGhlYWRlci5mcmFtZUxlbmd0aCxcbiAgICAgIG1pc3Npbmc6IDBcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpIHtcbiAgY29uc3QgbXBlZ1ZlcnNpb24gPSBkYXRhW29mZnNldCArIDFdID4+IDMgJiAzO1xuICBjb25zdCBtcGVnTGF5ZXIgPSBkYXRhW29mZnNldCArIDFdID4+IDEgJiAzO1xuICBjb25zdCBiaXRSYXRlSW5kZXggPSBkYXRhW29mZnNldCArIDJdID4+IDQgJiAxNTtcbiAgY29uc3Qgc2FtcGxlUmF0ZUluZGV4ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiAyICYgMztcbiAgaWYgKG1wZWdWZXJzaW9uICE9PSAxICYmIGJpdFJhdGVJbmRleCAhPT0gMCAmJiBiaXRSYXRlSW5kZXggIT09IDE1ICYmIHNhbXBsZVJhdGVJbmRleCAhPT0gMykge1xuICAgIGNvbnN0IHBhZGRpbmdCaXQgPSBkYXRhW29mZnNldCArIDJdID4+IDEgJiAxO1xuICAgIGNvbnN0IGNoYW5uZWxNb2RlID0gZGF0YVtvZmZzZXQgKyAzXSA+PiA2O1xuICAgIGNvbnN0IGNvbHVtbkluQml0cmF0ZXMgPSBtcGVnVmVyc2lvbiA9PT0gMyA/IDMgLSBtcGVnTGF5ZXIgOiBtcGVnTGF5ZXIgPT09IDMgPyAzIDogNDtcbiAgICBjb25zdCBiaXRSYXRlID0gQml0cmF0ZXNNYXBbY29sdW1uSW5CaXRyYXRlcyAqIDE0ICsgYml0UmF0ZUluZGV4IC0gMV0gKiAxMDAwO1xuICAgIGNvbnN0IGNvbHVtbkluU2FtcGxlUmF0ZXMgPSBtcGVnVmVyc2lvbiA9PT0gMyA/IDAgOiBtcGVnVmVyc2lvbiA9PT0gMiA/IDEgOiAyO1xuICAgIGNvbnN0IHNhbXBsZVJhdGUgPSBTYW1wbGluZ1JhdGVNYXBbY29sdW1uSW5TYW1wbGVSYXRlcyAqIDMgKyBzYW1wbGVSYXRlSW5kZXhdO1xuICAgIGNvbnN0IGNoYW5uZWxDb3VudCA9IGNoYW5uZWxNb2RlID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcbiAgICBjb25zdCBzYW1wbGVDb2VmZmljaWVudCA9IFNhbXBsZXNDb2VmZmljaWVudHNbbXBlZ1ZlcnNpb25dW21wZWdMYXllcl07XG4gICAgY29uc3QgYnl0ZXNJblNsb3QgPSBCeXRlc0luU2xvdFttcGVnTGF5ZXJdO1xuICAgIGNvbnN0IHNhbXBsZXNQZXJGcmFtZSA9IHNhbXBsZUNvZWZmaWNpZW50ICogOCAqIGJ5dGVzSW5TbG90O1xuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gTWF0aC5mbG9vcihzYW1wbGVDb2VmZmljaWVudCAqIGJpdFJhdGUgLyBzYW1wbGVSYXRlICsgcGFkZGluZ0JpdCkgKiBieXRlc0luU2xvdDtcbiAgICBpZiAoY2hyb21lVmVyc2lvbiQxID09PSBudWxsKSB7XG4gICAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvaSk7XG4gICAgICBjaHJvbWVWZXJzaW9uJDEgPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gICAgY29uc3QgbmVlZENocm9tZUZpeCA9ICEhY2hyb21lVmVyc2lvbiQxICYmIGNocm9tZVZlcnNpb24kMSA8PSA4NztcbiAgICBpZiAobmVlZENocm9tZUZpeCAmJiBtcGVnTGF5ZXIgPT09IDIgJiYgYml0UmF0ZSA+PSAyMjQwMDAgJiYgY2hhbm5lbE1vZGUgPT09IDApIHtcbiAgICAgIC8vIFdvcmsgYXJvdW5kIGJ1ZyBpbiBDaHJvbWl1bSBieSBzZXR0aW5nIGNoYW5uZWxNb2RlIHRvIGR1YWwtY2hhbm5lbCAoMDEpIGluc3RlYWQgb2Ygc3RlcmVvICgwMClcbiAgICAgIGRhdGFbb2Zmc2V0ICsgM10gPSBkYXRhW29mZnNldCArIDNdIHwgMHg4MDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZVJhdGUsXG4gICAgICBjaGFubmVsQ291bnQsXG4gICAgICBmcmFtZUxlbmd0aCxcbiAgICAgIHNhbXBsZXNQZXJGcmFtZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZTApID09PSAweGUwICYmIChkYXRhW29mZnNldCArIDFdICYgMHgwNikgIT09IDB4MDA7XG59XG5mdW5jdGlvbiBpc0hlYWRlcihkYXRhLCBvZmZzZXQpIHtcbiAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgcmV0dXJuIG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICBjb25zdCBoZWFkZXJTaXplID0gNDtcbiAgcmV0dXJuIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpICYmIGhlYWRlclNpemUgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG59XG5mdW5jdGlvbiBwcm9iZShkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IE1QRUcgZnJhbWUgZm9sbG93cyBsYXN0IE1QRUcgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXG4gICAgY29uc3QgaGVhZGVyTGVuZ3RoID0gNDtcbiAgICAvLyBNUEVHIGZyYW1lIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xuICAgIGlmIChoZWFkZXIgIT0gbnVsbCAmJiBoZWFkZXIuZnJhbWVMZW5ndGgpIHtcbiAgICAgIGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlcihkYXRhLCBuZXdPZmZzZXQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiAqL1xuXG5jbGFzcyBFeHBHb2xvbWIge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy53b3JkID0gdm9pZCAwO1xuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBleGFtaW5lIGluIHRoaXMuZGF0YVxuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgLy8gdGhlIGN1cnJlbnQgd29yZCBiZWluZyBleGFtaW5lZFxuICAgIHRoaXMud29yZCA9IDA7IC8vIDp1aW50XG4gICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnRcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgbG9hZFdvcmQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBieXRlc0F2YWlsYWJsZSA9IHRoaXMuYnl0ZXNBdmFpbGFibGU7XG4gICAgY29uc3QgcG9zaXRpb24gPSBkYXRhLmJ5dGVMZW5ndGggLSBieXRlc0F2YWlsYWJsZTtcbiAgICBjb25zdCB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIGJ5dGVzQXZhaWxhYmxlKTtcbiAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYnl0ZXMgYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIHdvcmtpbmdCeXRlcy5zZXQoZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xuICAgIHRoaXMud29yZCA9IG5ldyBEYXRhVmlldyh3b3JraW5nQnl0ZXMuYnVmZmVyKS5nZXRVaW50MzIoMCk7XG4gICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBhdmFpbGFibGVCeXRlcztcbiAgfVxuXG4gIC8vIChjb3VudDppbnQpOnZvaWRcbiAgc2tpcEJpdHMoY291bnQpIHtcbiAgICBsZXQgc2tpcEJ5dGVzOyAvLyA6aW50XG4gICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgdGhpcy5ieXRlc0F2YWlsYWJsZSAqIDggKyB0aGlzLmJpdHNBdmFpbGFibGUpO1xuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiBjb3VudCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xuICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgIGNvdW50IC09IHNraXBCeXRlcyA8PCAzO1xuICAgICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBza2lwQnl0ZXM7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIChzaXplOmludCk6dWludFxuICByZWFkQml0cyhzaXplKSB7XG4gICAgbGV0IGJpdHMgPSBNYXRoLm1pbih0aGlzLmJpdHNBdmFpbGFibGUsIHNpemUpOyAvLyA6dWludFxuICAgIGNvbnN0IHZhbHUgPSB0aGlzLndvcmQgPj4+IDMyIC0gYml0czsgLy8gOnVpbnRcbiAgICBpZiAoc2l6ZSA+IDMyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgIH1cbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBiaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBiaXRzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgaWYgKGJpdHMgPiAwICYmIHRoaXMuYml0c0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1O1xuICAgIH1cbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgc2tpcExaKCkge1xuICAgIGxldCBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxuICAgIGZvciAobGVhZGluZ1plcm9Db3VudCA9IDA7IGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xuICAgICAgaWYgKCh0aGlzLndvcmQgJiAweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSAhPT0gMCkge1xuICAgICAgICAvLyB0aGUgZmlyc3QgYml0IG9mIHdvcmtpbmcgd29yZCBpcyAxXG4gICAgICAgIHRoaXMud29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcFVFRygpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcEVHKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dWludFxuICByZWFkVUVHKCkge1xuICAgIGNvbnN0IGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRFRygpIHtcbiAgICBjb25zdCB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcbiAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgIC8vIHRoZSBudW1iZXIgaXMgb2RkIGlmIHRoZSBsb3cgb3JkZXIgYml0IGlzIHNldFxuICAgICAgcmV0dXJuIDEgKyB2YWx1ID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXG4gICAgfVxuICB9XG5cbiAgLy8gU29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbiAgLy8gOkJvb2xlYW5cbiAgcmVhZEJvb2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVCeXRlKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVSW50KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAqL1xuICBza2lwU2NhbGluZ0xpc3QoY291bnQpIHtcbiAgICBsZXQgbGFzdFNjYWxlID0gODtcbiAgICBsZXQgbmV4dFNjYWxlID0gODtcbiAgICBsZXQgZGVsdGFTY2FsZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMucmVhZEVHKCk7XG4gICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgIH1cbiAgICAgIGxhc3RTY2FsZSA9IG5leHRTY2FsZSA9PT0gMCA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAqIGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiB1cGNvbWluZyB2aWRlbyBmcmFtZXMuXG4gICAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gcGFyc2VkIGZyb20gdGhlXG4gICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICogYXNzb2NpYXRlZCB2aWRlbyBmcmFtZXMuXG4gICAqL1xuICByZWFkU1BTKCkge1xuICAgIGxldCBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwO1xuICAgIGxldCBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwO1xuICAgIGxldCBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwO1xuICAgIGxldCBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7XG4gICAgbGV0IHNjYWxpbmdMaXN0Q291bnQ7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgcmVhZFVCeXRlID0gdGhpcy5yZWFkVUJ5dGUuYmluZCh0aGlzKTtcbiAgICBjb25zdCByZWFkQml0cyA9IHRoaXMucmVhZEJpdHMuYmluZCh0aGlzKTtcbiAgICBjb25zdCByZWFkVUVHID0gdGhpcy5yZWFkVUVHLmJpbmQodGhpcyk7XG4gICAgY29uc3QgcmVhZEJvb2xlYW4gPSB0aGlzLnJlYWRCb29sZWFuLmJpbmQodGhpcyk7XG4gICAgY29uc3Qgc2tpcEJpdHMgPSB0aGlzLnNraXBCaXRzLmJpbmQodGhpcyk7XG4gICAgY29uc3Qgc2tpcEVHID0gdGhpcy5za2lwRUcuYmluZCh0aGlzKTtcbiAgICBjb25zdCBza2lwVUVHID0gdGhpcy5za2lwVUVHLmJpbmQodGhpcyk7XG4gICAgY29uc3Qgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcbiAgICByZWFkVUJ5dGUoKTtcbiAgICBjb25zdCBwcm9maWxlSWRjID0gcmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG4gICAgcmVhZEJpdHMoNSk7IC8vIHByb2ZpbGVDb21wYXQgY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXG4gICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcbiAgICBza2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fCBwcm9maWxlSWRjID09PSAxMTAgfHwgcHJvZmlsZUlkYyA9PT0gMTIyIHx8IHByb2ZpbGVJZGMgPT09IDI0NCB8fCBwcm9maWxlSWRjID09PSA0NCB8fCBwcm9maWxlSWRjID09PSA4MyB8fCBwcm9maWxlSWRjID09PSA4NiB8fCBwcm9maWxlSWRjID09PSAxMTggfHwgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XG4gICAgICBjb25zdCBjaHJvbWFGb3JtYXRJZGMgPSByZWFkVUVHKCk7XG4gICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgIHNraXBCaXRzKDEpO1xuICAgICAgfSAvLyBzZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICBzY2FsaW5nTGlzdENvdW50ID0gY2hyb21hRm9ybWF0SWRjICE9PSAzID8gOCA6IDEyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgICAgIC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnWyBpIF1cbiAgICAgICAgICAgIGlmIChpIDwgNikge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoMTYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDY0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2tpcFVFRygpOyAvLyBsb2cyX21heF9mcmFtZV9udW1fbWludXM0XG4gICAgY29uc3QgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xuICAgIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDApIHtcbiAgICAgIHJlYWRVRUcoKTsgLy8gbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XG4gICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZ1xuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGRcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IHJlYWRVRUcoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7IGkrKykge1xuICAgICAgICBza2lwRUcoKTtcbiAgICAgIH0gLy8gb2Zmc2V0X2Zvcl9yZWZfZnJhbWVbIGkgXVxuICAgIH1cblxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgIGNvbnN0IHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgY29uc3QgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBjb25zdCBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgIHNraXBCaXRzKDEpO1xuICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgIH1cbiAgICBsZXQgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9JZGMgPSByZWFkVUJ5dGUoKTtcbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMSwgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEyLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQwLCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzI0LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMyLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzgwLCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxOCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTUsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzY0LCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNjAsIDk5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQsIDNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMywgMl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjU1OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gW3JlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKSwgcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2IC0gZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLSBmcmFtZUNyb3BSaWdodE9mZnNldCAqIDIpLFxuICAgICAgaGVpZ2h0OiAoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2IC0gKGZyYW1lTWJzT25seUZsYWcgPyAyIDogNCkgKiAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSxcbiAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICB9O1xuICB9XG4gIHJlYWRTbGljZVR5cGUoKSB7XG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcbiAgICB0aGlzLnJlYWRVRUcoKTtcbiAgICAvLyByZXR1cm4gc2xpY2VfdHlwZVxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNBTVBMRS1BRVMgZGVjcnlwdGVyXG4gKi9cblxuY2xhc3MgU2FtcGxlQWVzRGVjcnlwdGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywga2V5RGF0YSkge1xuICAgIHRoaXMua2V5RGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmtleURhdGEgPSBrZXlEYXRhO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihjb25maWcsIHtcbiAgICAgIHJlbW92ZVBLQ1M3UGFkZGluZzogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBkZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChlbmNyeXB0ZWREYXRhLCB0aGlzLmtleURhdGEua2V5LmJ1ZmZlciwgdGhpcy5rZXlEYXRhLml2LmJ1ZmZlcik7XG4gIH1cblxuICAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxuICBkZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGN1clVuaXQgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0O1xuICAgIGlmIChjdXJVbml0Lmxlbmd0aCA8PSAxNikge1xuICAgICAgLy8gTm8gZW5jcnlwdGVkIHBvcnRpb24gaW4gdGhpcyBzYW1wbGUgKGZpcnN0IDE2IGJ5dGVzIGlzIG5vdFxuICAgICAgLy8gZW5jcnlwdGVkLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0F1ZGlvVmlkZW8vQ29uY2VwdHVhbC9ITFNfU2FtcGxlX0VuY3J5cHRpb24vRW5jcnlwdGlvbi9FbmNyeXB0aW9uLmh0bWwpLFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gY3VyVW5pdC5zdWJhcnJheSgxNiwgY3VyVW5pdC5sZW5ndGggLSBjdXJVbml0Lmxlbmd0aCAlIDE2KTtcbiAgICBjb25zdCBlbmNyeXB0ZWRCdWZmZXIgPSBlbmNyeXB0ZWREYXRhLmJ1ZmZlci5zbGljZShlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQsIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCArIGVuY3J5cHRlZERhdGEubGVuZ3RoKTtcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyKS50aGVuKGRlY3J5cHRlZEJ1ZmZlciA9PiB7XG4gICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkQnVmZmVyKTtcbiAgICAgIGN1clVuaXQuc2V0KGRlY3J5cHRlZERhdGEsIDE2KTtcbiAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spO1xuICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQVZDIC0gZW5jcnlwdCBvbmUgMTYgYnl0ZXMgYmxvY2sgb3V0IG9mIHRlbiwgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMzJcbiAgZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSkge1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGFMZW4gPSBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gbmV3IEludDhBcnJheShlbmNyeXB0ZWREYXRhTGVuKTtcbiAgICBsZXQgb3V0cHV0UG9zID0gMDtcbiAgICBmb3IgKGxldCBpbnB1dFBvcyA9IDMyOyBpbnB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBpbnB1dFBvcyArPSAxNjAsIG91dHB1dFBvcyArPSAxNikge1xuICAgICAgZW5jcnlwdGVkRGF0YS5zZXQoZGVjb2RlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jcnlwdGVkRGF0YTtcbiAgfVxuICBnZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWREYXRhKSB7XG4gICAgY29uc3QgdWludDhEZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgbGV0IGlucHV0UG9zID0gMDtcbiAgICBmb3IgKGxldCBvdXRwdXRQb3MgPSAzMjsgb3V0cHV0UG9zIDwgZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XG4gICAgICBkZWNvZGVkRGF0YS5zZXQodWludDhEZWNyeXB0ZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWREYXRhO1xuICB9XG4gIGRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQpIHtcbiAgICBjb25zdCBkZWNvZGVkRGF0YSA9IGRpc2NhcmRFUEIoY3VyVW5pdC5kYXRhKTtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIpLnRoZW4oZGVjcnlwdGVkQnVmZmVyID0+IHtcbiAgICAgIGN1clVuaXQuZGF0YSA9IHRoaXMuZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkQnVmZmVyKTtcbiAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHNhbXBsZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWNyeXB0IHNhbXBsZXMgb2YgdHlwZSBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1clVuaXRzID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdHM7XG4gICAgICBmb3IgKDs7IHVuaXRJbmRleCsrKSB7XG4gICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VyVW5pdCA9IGN1clVuaXRzW3VuaXRJbmRleF07XG4gICAgICAgIGlmIChjdXJVbml0LmRhdGEubGVuZ3RoIDw9IDQ4IHx8IGN1clVuaXQudHlwZSAhPT0gMSAmJiBjdXJVbml0LnR5cGUgIT09IDUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQpO1xuICAgICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFBBQ0tFVF9MRU5HVEggPSAxODg7XG5jbGFzcyBUU0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICB0aGlzLl9hdmNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICB9XG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgY29uc3Qgc3luY09mZnNldCA9IFRTRGVtdXhlci5zeW5jT2Zmc2V0KGRhdGEpO1xuICAgIGlmIChzeW5jT2Zmc2V0ID4gMCkge1xuICAgICAgbG9nZ2VyLndhcm4oYE1QRUcyLVRTIGRldGVjdGVkIGJ1dCBmaXJzdCBzeW5jIHdvcmQgZm91bmQgQCBvZmZzZXQgJHtzeW5jT2Zmc2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gc3luY09mZnNldCAhPT0gLTE7XG4gIH1cbiAgc3RhdGljIHN5bmNPZmZzZXQoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGxldCBzY2Fud2luZG93ID0gTWF0aC5taW4oUEFDS0VUX0xFTkdUSCAqIDUsIGRhdGEubGVuZ3RoIC0gUEFDS0VUX0xFTkdUSCkgKyAxO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNjYW53aW5kb3cpIHtcbiAgICAgIC8vIGEgVFMgaW5pdCBzZWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDIgVFMgcGFja2V0czogUEFUIGFuZCBQTVQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgICBsZXQgZm91bmRQYXQgPSBmYWxzZTtcbiAgICAgIGxldCBwYWNrZXRTdGFydCA9IC0xO1xuICAgICAgbGV0IHRzUGFja2V0cyA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGxlbmd0aDsgaiArPSBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICAgIGlmIChkYXRhW2pdID09PSAweDQ3KSB7XG4gICAgICAgICAgdHNQYWNrZXRzKys7XG4gICAgICAgICAgaWYgKHBhY2tldFN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgICAgcGFja2V0U3RhcnQgPSBqO1xuICAgICAgICAgICAgLy8gRmlyc3Qgc3luYyB3b3JkIGZvdW5kIGF0IG9mZnNldCwgaW5jcmVhc2Ugc2NhbiBsZW5ndGggKCM1MjUxKVxuICAgICAgICAgICAgaWYgKHBhY2tldFN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgIHNjYW53aW5kb3cgPSBNYXRoLm1pbihwYWNrZXRTdGFydCArIFBBQ0tFVF9MRU5HVEggKiA5OSwgZGF0YS5sZW5ndGggLSBQQUNLRVRfTEVOR1RIKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm91bmRQYXQpIHtcbiAgICAgICAgICAgIGZvdW5kUGF0ID0gcGFyc2VQSUQoZGF0YSwgaikgPT09IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN5bmMgd29yZCBmb3VuZCBhdCAwIHdpdGggMyBwYWNrZXRzLCBvciBmb3VuZCBhdCBvZmZzZXQgbGVhc3QgMiBwYWNrZXRzIHVwIHRvIHNjYW53aW5kb3cgKCM1NTAxKVxuICAgICAgICAgIGlmIChmb3VuZFBhdCAmJiB0c1BhY2tldHMgPiAxICYmIChwYWNrZXRTdGFydCA9PT0gMCAmJiB0c1BhY2tldHMgPiAyIHx8IGogKyBQQUNLRVRfTEVOR1RIID4gc2NhbndpbmRvdykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWNrZXRTdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHNQYWNrZXRzKSB7XG4gICAgICAgICAgLy8gRXhpdCBpZiBzeW5jIHdvcmQgZm91bmQsIGJ1dCBkb2VzIG5vdCBjb250YWluIGNvbnRpZ3VvdXMgcGFja2V0cyAoIzU1MDEpXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHJhY2sgbW9kZWwgaW50ZXJuYWwgdG8gZGVtdXhlciB1c2VkIHRvIGRyaXZlIHJlbXV4aW5nIGlucHV0XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVHJhY2sodHlwZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbmVyOiB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXG4gICAgICB0eXBlLFxuICAgICAgaWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwLFxuICAgICAgZHVyYXRpb246IHR5cGUgPT09ICdhdWRpbycgPyBkdXJhdGlvbiA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5pdCBzZWdtZW50IG9uIHRoZSBkZW11eGVyL3JlbXV4ZXIgaW50ZXJmYWNlLiBOZWVkZWQgZm9yIGRpc2NvbnRpbnVpdGllcy90cmFjay1zd2l0Y2hlcyAob3IgYXQgc3RyZWFtIHN0YXJ0KVxuICAgKiBSZXNldHMgYWxsIGludGVybmFsIHRyYWNrIGluc3RhbmNlcyBvZiB0aGUgZGVtdXhlci5cbiAgICovXG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgdGhpcy5fYXZjVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3ZpZGVvJyk7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnYXVkaW8nLCB0cmFja0R1cmF0aW9uKTtcbiAgICB0aGlzLl9pZDNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnaWQzJyk7XG4gICAgdGhpcy5fdHh0VHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3RleHQnKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9ICdhYWMnO1xuXG4gICAgLy8gZmx1c2ggYW55IHBhcnRpYWwgY29udGVudFxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRyYWNrRHVyYXRpb247XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoKSB7fVxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2F1ZGlvVHJhY2ssXG4gICAgICBfYXZjVHJhY2ssXG4gICAgICBfaWQzVHJhY2tcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoX2F1ZGlvVHJhY2spIHtcbiAgICAgIF9hdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoX2F2Y1RyYWNrKSB7XG4gICAgICBfYXZjVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChfaWQzVHJhY2spIHtcbiAgICAgIF9pZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gIH1cbiAgZGVtdXgoZGF0YSwgdGltZU9mZnNldCwgaXNTYW1wbGVBZXMgPSBmYWxzZSwgZmx1c2ggPSBmYWxzZSkge1xuICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IHBlcztcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy5fYXZjVHJhY2s7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLl90eHRUcmFjaztcbiAgICBsZXQgYXZjSWQgPSB2aWRlb1RyYWNrLnBpZDtcbiAgICBsZXQgYXZjRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgYXVkaW9JZCA9IGF1ZGlvVHJhY2sucGlkO1xuICAgIGxldCBpZDNJZCA9IGlkM1RyYWNrLnBpZDtcbiAgICBsZXQgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgIGxldCBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgdW5rbm93blBJRCA9IG51bGw7XG4gICAgbGV0IHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkO1xuICAgIGxldCBwbXRJZCA9IHRoaXMuX3BtdElkO1xuICAgIGxldCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLnJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGVuIDwgUEFDS0VUX0xFTkdUSCAmJiAhZmx1c2gpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gTWF0aC5tYXgoMCwgVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSkpO1xuICAgIGxlbiAtPSAobGVuIC0gc3luY09mZnNldCkgJSBQQUNLRVRfTEVOR1RIO1xuICAgIGlmIChsZW4gPCBkYXRhLmJ5dGVMZW5ndGggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgbGVuLCBkYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoIC0gbGVuKTtcbiAgICB9XG5cbiAgICAvLyBsb29wIHRocm91Z2ggVFMgcGFja2V0c1xuICAgIGxldCB0c1BhY2tldEVycm9ycyA9IDA7XG4gICAgZm9yIChsZXQgc3RhcnQgPSBzeW5jT2Zmc2V0OyBzdGFydCA8IGxlbjsgc3RhcnQgKz0gUEFDS0VUX0xFTkdUSCkge1xuICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweDQ3KSB7XG4gICAgICAgIGNvbnN0IHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICBjb25zdCBwaWQgPSBwYXJzZVBJRChkYXRhLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuXG4gICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxuICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTtcbiAgICAgICAgICAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgICBjYXNlIGF2Y0lkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFWQ1BFUyh2aWRlb1RyYWNrLCB0ZXh0VHJhY2ssIHBlcywgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF2Y0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF2Y0RhdGEpIHtcbiAgICAgICAgICAgICAgYXZjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkpO1xuICAgICAgICAgICAgICBhdmNEYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhdWRpb0lkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2FhYyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBQUNQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTVBFR1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXVkaW9EYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQzSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkM0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgICAgaWQzRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkpO1xuICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKTtcblxuICAgICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0cmFjayBpZCBpZiB0cmFjayBQSUQgZm91bmQgd2hpbGUgcGFyc2luZyBQTVRcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgICAgIC8vIHRyYWNrIFBJRCB0cmFuc2llbnRseSBkaXNhcHBlYXJzIGZyb20gdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpbiBjYXNlIG9mIHRyYW5zaWVudCBtaXNzaW5nIGF1ZGlvIHNhbXBsZXMgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgICAgLy8gTk9URSB0aGlzIGlzIG9ubHkgdGhlIFBJRCBvZiB0aGUgdHJhY2sgYXMgZm91bmQgaW4gVFMsXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhcmUgbm90IHVzaW5nIHRoaXMgZm9yIE1QNCB0cmFjayBJRHMuXG4gICAgICAgICAgICAgIGF2Y0lkID0gcGFyc2VkUElEcy5hdmM7XG4gICAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLnBpZCA9IGF2Y0lkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgICAgICBpZiAoYXVkaW9JZCA+IDApIHtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLnBpZCA9IGF1ZGlvSWQ7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSBwYXJzZWRQSURzLnNlZ21lbnRDb2RlYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZDNJZCA9IHBhcnNlZFBJRHMuaWQzO1xuICAgICAgICAgICAgICBpZiAoaWQzSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWQzVHJhY2sucGlkID0gaWQzSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHVua25vd25QSUQgIT09IG51bGwgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBNUEVHLVRTIFBNVCBmb3VuZCBhdCAke3N0YXJ0fSBhZnRlciB1bmtub3duIFBJRCAnJHt1bmtub3duUElEfScuIEJhY2t0cmFja2luZyB0byBzeW5jIGJ5dGUgQCR7c3luY09mZnNldH0gdG8gcGFyc2UgYWxsIFRTIHBhY2tldHMuYCk7XG4gICAgICAgICAgICAgICAgdW5rbm93blBJRCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMHgxMTpcbiAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmtub3duUElEID0gcGlkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRzUGFja2V0RXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0c1BhY2tldEVycm9ycyA+IDApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGb3VuZCAke3RzUGFja2V0RXJyb3JzfSBUUyBwYWNrZXQvcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIDB4NDdgKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSBhdmNEYXRhO1xuICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICBjb25zdCBkZW11eFJlc3VsdCA9IHtcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2tcbiAgICB9O1xuICAgIGlmIChmbHVzaCkge1xuICAgICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBkZW11eFJlc3VsdDtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICByZW1haW5kZXJEYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmRlbXV4KHJlbWFpbmRlckRhdGEsIC0xLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdmlkZW9UcmFjazogdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiB0aGlzLl90eHRUcmFja1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhyZXN1bHQpO1xuICAgIGlmICh0aGlzLnNhbXBsZUFlcykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdChyZXN1bHQsIHRoaXMuc2FtcGxlQWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBleHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2tcbiAgICB9ID0gZGVtdXhSZXN1bHQ7XG4gICAgY29uc3QgYXZjRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICBjb25zdCBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgY29uc3QgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGE7XG4gICAgLy8gdHJ5IHRvIHBhcnNlIGxhc3QgUEVTIHBhY2tldHNcbiAgICBsZXQgcGVzO1xuICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgIHRoaXMucGFyc2VBVkNQRVModmlkZW9UcmFjaywgdGV4dFRyYWNrLCBwZXMsIHRydWUpO1xuICAgICAgdmlkZW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGF2Y0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgdmlkZW9UcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhdWRpb0RhdGEgIT0gbnVsbCAmJiBhdWRpb0RhdGEuc2l6ZSkge1xuICAgICAgICBsb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGVpdGhlciBhdWRpb0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIH1cbiAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpKSB7XG4gICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBpZDNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgIH1cbiAgfVxuICBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgZGVtdXhSZXN1bHQgPSB0aGlzLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIHRydWUsICF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSk7XG4gICAgY29uc3Qgc2FtcGxlQWVzID0gdGhpcy5zYW1wbGVBZXMgPSBuZXcgU2FtcGxlQWVzRGVjcnlwdGVyKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBrZXlEYXRhKTtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpO1xuICB9XG4gIGRlY3J5cHQoZGVtdXhSZXN1bHQsIHNhbXBsZUFlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFja1xuICAgICAgfSA9IGRlbXV4UmVzdWx0O1xuICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcyAmJiBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgKCkgPT4ge1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gIH1cbiAgcGFyc2VBVkNQRVModHJhY2ssIHRleHRUcmFjaywgcGVzLCBsYXN0KSB7XG4gICAgY29uc3QgdW5pdHMgPSB0aGlzLnBhcnNlQVZDTkFMdSh0cmFjaywgcGVzLmRhdGEpO1xuICAgIGxldCBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZTtcbiAgICBsZXQgcHVzaDtcbiAgICBsZXQgc3BzZm91bmQgPSBmYWxzZTtcbiAgICAvLyBmcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICBwZXMuZGF0YSA9IG51bGw7XG5cbiAgICAvLyBpZiBuZXcgTkFMIHVuaXRzIGZvdW5kIGFuZCBsYXN0IHNhbXBsZSBzdGlsbCB0aGVyZSwgbGV0J3MgcHVzaCAuLi5cbiAgICAvLyB0aGlzIGhlbHBzIHBhcnNpbmcgc3RyZWFtcyB3aXRoIG1pc3NpbmcgQVVEIChvbmx5IGRvIHRoaXMgaWYgQVVEIG5ldmVyIGZvdW5kKVxuICAgIGlmIChhdmNTYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xuICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgIH1cbiAgICB1bml0cy5mb3JFYWNoKHVuaXQgPT4ge1xuICAgICAgdmFyIF9hdmNTYW1wbGUyO1xuICAgICAgc3dpdGNoICh1bml0LnR5cGUpIHtcbiAgICAgICAgLy8gTkRSXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsZXQgaXNrZXkgPSBmYWxzZTtcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgc2xpY2UgdHlwZSB0byBkZXRlY3QgS0YgaW4gY2FzZSBTUFMgZm91bmQgaW4gc2FtZSBwYWNrZXQgKGFueSBrZXlmcmFtZSBpcyBwcmVjZWRlZCBieSBTUFMgLi4uKVxuICAgICAgICAgICAgaWYgKHNwc2ZvdW5kICYmIGRhdGEubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgICAgICBjb25zdCBzbGljZVR5cGUgPSBuZXcgRXhwR29sb21iKGRhdGEpLnJlYWRTbGljZVR5cGUoKTtcbiAgICAgICAgICAgICAgLy8gMiA6IEkgc2xpY2UsIDQgOiBTSSBzbGljZSwgNyA6IEkgc2xpY2UsIDk6IFNJIHNsaWNlXG4gICAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgICAgIC8vIEkgc2xpY2U6IEEgc2xpY2UgdGhhdCBpcyBub3QgYW4gU0kgc2xpY2UgdGhhdCBpcyBkZWNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seS5cbiAgICAgICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgICAgaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDQgfHwgc2xpY2VUeXBlID09PSA3IHx8IHNsaWNlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIGlza2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlza2V5KSB7XG4gICAgICAgICAgICAgIHZhciBfYXZjU2FtcGxlO1xuICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vbi1rZXlmcmFtZSBkYXRhIGFscmVhZHksIHRoYXQgY2Fubm90IGJlbG9uZyB0byB0aGUgc2FtZSBmcmFtZSBhcyBhIGtleWZyYW1lLCBzbyBmb3JjZSBhIHB1c2hcbiAgICAgICAgICAgICAgaWYgKChfYXZjU2FtcGxlID0gYXZjU2FtcGxlKSAhPSBudWxsICYmIF9hdmNTYW1wbGUuZnJhbWUgJiYgIWF2Y1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgICAgICBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gaXNrZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIElEUlxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vbi1rZXlmcmFtZSBkYXRhIGFscmVhZHksIHRoYXQgY2Fubm90IGJlbG9uZyB0byB0aGUgc2FtZSBmcmFtZSBhcyBhIGtleWZyYW1lLCBzbyBmb3JjZSBhIHB1c2hcbiAgICAgICAgICBpZiAoKF9hdmNTYW1wbGUyID0gYXZjU2FtcGxlKSAhPSBudWxsICYmIF9hdmNTYW1wbGUyLmZyYW1lICYmICFhdmNTYW1wbGUua2V5KSB7XG4gICAgICAgICAgICBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU0VJXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KHVuaXQuZGF0YSwgMSwgcGVzLnB0cywgdGV4dFRyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBTUFNcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIHNwc2ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xuICAgICAgICAgICAgY29uc3Qgc3BzID0gdW5pdC5kYXRhO1xuICAgICAgICAgICAgY29uc3QgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIoc3BzKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdHJhY2suc3BzID0gW3Nwc107XG4gICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgY29kZWNhcnJheSA9IHNwcy5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgIGxldCBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBQUFNcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmICghdHJhY2sucHBzKSB7XG4gICAgICAgICAgICB0cmFjay5wcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIHRyYWNrLmF1ZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChhdmNTYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICBjb25zdCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgIGlmIChsYXN0ICYmIGF2Y1NhbXBsZSkge1xuICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldExhc3ROYWxVbml0KHNhbXBsZXMpIHtcbiAgICB2YXIgX2F2Y1NhbXBsZTM7XG4gICAgbGV0IGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlO1xuICAgIGxldCBsYXN0VW5pdDtcbiAgICAvLyB0cnkgdG8gZmFsbGJhY2sgdG8gcHJldmlvdXMgc2FtcGxlIGlmIGN1cnJlbnQgb25lIGlzIGVtcHR5XG4gICAgaWYgKCFhdmNTYW1wbGUgfHwgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXZjU2FtcGxlID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAoKF9hdmNTYW1wbGUzID0gYXZjU2FtcGxlKSAhPSBudWxsICYmIF9hdmNTYW1wbGUzLnVuaXRzKSB7XG4gICAgICBjb25zdCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgIGxhc3RVbml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfVxuICBwYXJzZUFWQ05BTHUodHJhY2ssIGFycmF5KSB7XG4gICAgY29uc3QgbGVuID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgICBsZXQgc3RhdGUgPSB0cmFjay5uYWx1U3RhdGUgfHwgMDtcbiAgICBjb25zdCBsYXN0U3RhdGUgPSBzdGF0ZTtcbiAgICBjb25zdCB1bml0cyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IG92ZXJmbG93O1xuICAgIGxldCB1bml0VHlwZTtcbiAgICBsZXQgbGFzdFVuaXRTdGFydCA9IC0xO1xuICAgIGxldCBsYXN0VW5pdFR5cGUgPSAwO1xuICAgIC8vIGxvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNwZWNpYWwgdXNlIGNhc2Ugd2hlcmUgd2UgZm91bmQgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgZXhhY3RseSBhdCB0aGUgZW5kIG9mIHByZXZpb3VzIFBFUyBwYWNrZXRcbiAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgbGFzdFVuaXRUeXBlID0gYXJyYXlbMF0gJiAweDFmO1xuICAgICAgc3RhdGUgPSAwO1xuICAgICAgaSA9IDE7XG4gICAgfVxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDApIHtcbiAgICAgICAgICBjb25zdCB1bml0ID0ge1xuICAgICAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgaSAtIHN0YXRlIC0gMSksXG4gICAgICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGVcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgY29uc3QgbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAmJiBpIDw9IDQgLSBsYXN0U3RhdGUpIHtcbiAgICAgICAgICAgICAgLy8gc3RhcnQgZGVsaW1pdGVyIG92ZXJsYXBwaW5nIGJldHdlZW4gUEVTIHBhY2tldHNcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgaWYgKGxhc3RVbml0LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSBsYXN0VW5pdC5kYXRhLnN1YmFycmF5KDAsIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cbiAgICAgICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XG4gICAgICAgICAgICAgIGxhc3RVbml0LnN0YXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgbGFzdFVuaXRTdGFydCA9IGk7XG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXG4gICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwICYmIHN0YXRlID49IDApIHtcbiAgICAgIGNvbnN0IHVuaXQgPSB7XG4gICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGxlbiksXG4gICAgICAgIHR5cGU6IGxhc3RVbml0VHlwZSxcbiAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICB9O1xuICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gbm8gTkFMdSBmb3VuZFxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgY29uc3QgbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICB0bXAuc2V0KGFycmF5LCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gdW5pdHM7XG4gIH1cbiAgcGFyc2VBQUNQRVModHJhY2ssIHBlcykge1xuICAgIGxldCBzdGFydE9mZnNldCA9IDA7XG4gICAgY29uc3QgYWFjT3ZlckZsb3cgPSB0aGlzLmFhY092ZXJGbG93O1xuICAgIGxldCBkYXRhID0gcGVzLmRhdGE7XG4gICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgIGNvbnN0IGZyYW1lTWlzc2luZ0J5dGVzID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgIGNvbnN0IHNhbXBsZUxlbmd0aCA9IGFhY092ZXJGbG93LnNhbXBsZS51bml0LmJ5dGVMZW5ndGg7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke3NhbXBsZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcbiAgICAgIGlmIChmcmFtZU1pc3NpbmdCeXRlcyA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoc2FtcGxlTGVuZ3RoICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdG1wLnNldChhYWNPdmVyRmxvdy5zYW1wbGUudW5pdCwgMCk7XG4gICAgICAgIHRtcC5zZXQoZGF0YSwgc2FtcGxlTGVuZ3RoKTtcbiAgICAgICAgZGF0YSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZyYW1lT3ZlcmZsb3dCeXRlcyA9IHNhbXBsZUxlbmd0aCAtIGZyYW1lTWlzc2luZ0J5dGVzO1xuICAgICAgICBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5zZXQoZGF0YS5zdWJhcnJheSgwLCBmcmFtZU1pc3NpbmdCeXRlcyksIGZyYW1lT3ZlcmZsb3dCeXRlcyk7XG4gICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNPdmVyRmxvdy5zYW1wbGUpO1xuICAgICAgICBzdGFydE9mZnNldCA9IGFhY092ZXJGbG93Lm1pc3Npbmc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgbGV0IG9mZnNldDtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgaWYgKGlzSGVhZGVyJDEoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICBpZiAob2Zmc2V0ICE9PSBzdGFydE9mZnNldCkge1xuICAgICAgbGV0IHJlYXNvbjtcbiAgICAgIGNvbnN0IHJlY292ZXJhYmxlID0gb2Zmc2V0IDwgbGVuIC0gMTtcbiAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICByZWFzb24gPSBgQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OiR7b2Zmc2V0fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFzb24gPSAnTm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgbG9nZ2VyLndhcm4oYHBhcnNpbmcgZXJyb3I6ICR7cmVhc29ufWApO1xuICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgbGV2ZWxSZXRyeTogcmVjb3ZlcmFibGUsXG4gICAgICAgIGVycm9yLFxuICAgICAgICByZWFzb25cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZWNvdmVyYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGluaXRUcmFja0NvbmZpZyh0cmFjaywgdGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB0aGlzLmF1ZGlvQ29kZWMpO1xuICAgIGxldCBwdHM7XG4gICAgaWYgKHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHRzID0gcGVzLnB0cztcbiAgICB9IGVsc2UgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICAvLyBpZiBsYXN0IEFBQyBmcmFtZSBpcyBvdmVyZmxvd2luZywgd2Ugc2hvdWxkIGVuc3VyZSB0aW1lc3RhbXBzIGFyZSBjb250aWd1b3VzOlxuICAgICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxuICAgICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gICAgICBwdHMgPSBhYWNPdmVyRmxvdy5zYW1wbGUucHRzICsgZnJhbWVEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBBQUMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2NhbiBmb3IgYWFjIHNhbXBsZXNcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgbGV0IGZyYW1lO1xuICAgIHdoaWxlIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGZyYW1lID0gYXBwZW5kRnJhbWUkMSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgIGlmICghZnJhbWUubWlzc2luZykge1xuICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIGZvciAoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICAgIGlmIChpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IGZyYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VNUEVHUEVTKHRyYWNrLCBwZXMpIHtcbiAgICBjb25zdCBkYXRhID0gcGVzLmRhdGE7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IHB0cyA9IHBlcy5wdHM7XG4gICAgaWYgKHB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dnZXIud2FybignW3RzZGVtdXhlcl06IE1QRUcgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKSB7XG4gICAgaWYgKHBlcy5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBJRDMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlkM1NhbXBsZSA9IF9leHRlbmRzKHt9LCBwZXMsIHtcbiAgICAgIHR5cGU6IHRoaXMuX2F2Y1RyYWNrID8gTWV0YWRhdGFTY2hlbWEuZW1zZyA6IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgIH0pO1xuICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaChpZDNTYW1wbGUpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBVkNTYW1wbGUoa2V5LCBwdHMsIGR0cywgZGVidWcpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXksXG4gICAgZnJhbWU6IGZhbHNlLFxuICAgIHB0cyxcbiAgICBkdHMsXG4gICAgdW5pdHM6IFtdLFxuICAgIGRlYnVnLFxuICAgIGxlbmd0aDogMFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VQSUQoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cbiAgcmV0dXJuICgoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtvZmZzZXQgKyAyXTtcbn1cbmZ1bmN0aW9uIHBhcnNlUEFUKGRhdGEsIG9mZnNldCkge1xuICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG59XG5mdW5jdGlvbiBwYXJzZVBNVChkYXRhLCBvZmZzZXQsIHR5cGVTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBhdWRpbzogLTEsXG4gICAgYXZjOiAtMSxcbiAgICBpZDM6IC0xLFxuICAgIHNlZ21lbnRDb2RlYzogJ2FhYydcbiAgfTtcbiAgY29uc3Qgc2VjdGlvbkxlbmd0aCA9IChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gIGNvbnN0IHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgY29uc3QgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgb2Zmc2V0ICs9IDEyICsgcHJvZ3JhbUluZm9MZW5ndGg7XG4gIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgIGNvbnN0IHBpZCA9IHBhcnNlUElEKGRhdGEsIG9mZnNldCk7XG4gICAgc3dpdGNoIChkYXRhW29mZnNldF0pIHtcbiAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgQUFDIHdpdGggQUVTLTEyOC1DQkMgZnJhbWUgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW0nKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAweDBmOlxuICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQUFDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXG4gICAgICBjYXNlIDB4MTU6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmlkMyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweGRiOlxuICAgICAgICAvLyBTQU1QTEUtQUVTIEFWQ1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnSC4yNjQgd2l0aCBBRVMtMTI4LUNCQyBzbGljZSBlbmNyeXB0aW9uIGZvdW5kIGluIHVuZW5jcnlwdGVkIHN0cmVhbScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDB4MWI6XG4gICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF2YyA9IHBpZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXG4gICAgICBjYXNlIDB4MDM6XG4gICAgICBjYXNlIDB4MDQ6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ01QRUcgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHR5cGVTdXBwb3J0ZWQubXBlZyAhPT0gdHJ1ZSAmJiB0eXBlU3VwcG9ydGVkLm1wMyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICByZXN1bHQuc2VnbWVudENvZGVjID0gJ21wMyc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4MjQ6XG4gICAgICAgIGxvZ2dlci53YXJuKCdVbnN1cHBvcnRlZCBIRVZDIHN0cmVhbSB0eXBlIGZvdW5kJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XG4gICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgIG9mZnNldCArPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XSkgKyA1O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZVBFUyhzdHJlYW0pIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgZnJhZztcbiAgbGV0IHBlc0xlbjtcbiAgbGV0IHBlc0hkckxlbjtcbiAgbGV0IHBlc1B0cztcbiAgbGV0IHBlc0R0cztcbiAgY29uc3QgZGF0YSA9IHN0cmVhbS5kYXRhO1xuICAvLyBzYWZldHkgY2hlY2tcbiAgaWYgKCFzdHJlYW0gfHwgc3RyZWFtLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIHdlIG1pZ2h0IG5lZWQgdXAgdG8gMTkgYnl0ZXMgdG8gcmVhZCBQRVMgaGVhZGVyXG4gIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xuICAvLyB1c3VhbGx5IG9ubHkgb25lIG1lcmdlIGlzIG5lZWRlZCAoYW5kIHRoaXMgaXMgcmFyZSAuLi4pXG4gIHdoaWxlIChkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhWzBdLmxlbmd0aCArIGRhdGFbMV0ubGVuZ3RoKTtcbiAgICBuZXdEYXRhLnNldChkYXRhWzBdKTtcbiAgICBuZXdEYXRhLnNldChkYXRhWzFdLCBkYXRhWzBdLmxlbmd0aCk7XG4gICAgZGF0YVswXSA9IG5ld0RhdGE7XG4gICAgZGF0YS5zcGxpY2UoMSwgMSk7XG4gIH1cbiAgLy8gcmV0cmlldmUgUFRTL0RUUyBmcm9tIGZpcnN0IGZyYWdtZW50XG4gIGZyYWcgPSBkYXRhWzBdO1xuICBjb25zdCBwZXNQcmVmaXggPSAoZnJhZ1swXSA8PCAxNikgKyAoZnJhZ1sxXSA8PCA4KSArIGZyYWdbMl07XG4gIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgLy8gaWYgUEVTIHBhcnNlZCBsZW5ndGggaXMgbm90IHplcm8gYW5kIGdyZWF0ZXIgdGhhbiB0b3RhbCByZWNlaXZlZCBsZW5ndGgsIHN0b3AgcGFyc2luZy4gUEVTIG1pZ2h0IGJlIHRydW5jYXRlZFxuICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcbiAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBlc0ZsYWdzID0gZnJhZ1s3XTtcbiAgICBpZiAocGVzRmxhZ3MgJiAweGMwKSB7XG4gICAgICAvKiBQRVMgaGVhZGVyIGRlc2NyaWJlZCBoZXJlIDogaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgIHBlc1B0cyA9IChmcmFnWzldICYgMHgwZSkgKiA1MzY4NzA5MTIgK1xuICAgICAgLy8gMSA8PCAyOVxuICAgICAgKGZyYWdbMTBdICYgMHhmZikgKiA0MTk0MzA0ICtcbiAgICAgIC8vIDEgPDwgMjJcbiAgICAgIChmcmFnWzExXSAmIDB4ZmUpICogMTYzODQgK1xuICAgICAgLy8gMSA8PCAxNFxuICAgICAgKGZyYWdbMTJdICYgMHhmZikgKiAxMjggK1xuICAgICAgLy8gMSA8PCA3XG4gICAgICAoZnJhZ1sxM10gJiAweGZlKSAvIDI7XG4gICAgICBpZiAocGVzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MGUpICogNTM2ODcwOTEyICtcbiAgICAgICAgLy8gMSA8PCAyOVxuICAgICAgICAoZnJhZ1sxNV0gJiAweGZmKSAqIDQxOTQzMDQgK1xuICAgICAgICAvLyAxIDw8IDIyXG4gICAgICAgIChmcmFnWzE2XSAmIDB4ZmUpICogMTYzODQgK1xuICAgICAgICAvLyAxIDw8IDE0XG4gICAgICAgIChmcmFnWzE3XSAmIDB4ZmYpICogMTI4ICtcbiAgICAgICAgLy8gMSA8PCA3XG4gICAgICAgIChmcmFnWzE4XSAmIDB4ZmUpIC8gMjtcbiAgICAgICAgaWYgKHBlc1B0cyAtIHBlc0R0cyA+IDYwICogOTAwMDApIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgJHtNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApfXMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbWApO1xuICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgfVxuICAgIH1cbiAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgIC8vIDkgYnl0ZXMgOiA2IGJ5dGVzIGZvciBQRVMgaGVhZGVyICsgMyBieXRlcyBmb3IgUEVTIGV4dGVuc2lvblxuICAgIGxldCBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuICAgIGlmIChzdHJlYW0uc2l6ZSA8PSBwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgLy8gcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgY29uc3QgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcbiAgICBmb3IgKGxldCBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbjsgaisrKSB7XG4gICAgICBmcmFnID0gZGF0YVtqXTtcbiAgICAgIGxldCBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQgPiBsZW4pIHtcbiAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgLT0gbGVuO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgIGxlbiAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVzRGF0YS5zZXQoZnJhZywgaSk7XG4gICAgICBpICs9IGxlbjtcbiAgICB9XG4gICAgaWYgKHBlc0xlbikge1xuICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXG4gICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHBlc0RhdGEsXG4gICAgICBwdHM6IHBlc1B0cyxcbiAgICAgIGR0czogcGVzRHRzLFxuICAgICAgbGVuOiBwZXNMZW5cbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCBhdmNUcmFjaykge1xuICBpZiAoYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCAmJiBhdmNTYW1wbGUuZnJhbWUpIHtcbiAgICAvLyBpZiBzYW1wbGUgZG9lcyBub3QgaGF2ZSBQVFMvRFRTLCBwYXRjaCB3aXRoIGxhc3Qgc2FtcGxlIFBUUy9EVFNcbiAgICBpZiAoYXZjU2FtcGxlLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBzYW1wbGVzID0gYXZjVHJhY2suc2FtcGxlcztcbiAgICAgIGNvbnN0IG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgaWYgKG5iU2FtcGxlcykge1xuICAgICAgICBjb25zdCBsYXN0U2FtcGxlID0gc2FtcGxlc1tuYlNhbXBsZXMgLSAxXTtcbiAgICAgICAgYXZjU2FtcGxlLnB0cyA9IGxhc3RTYW1wbGUucHRzO1xuICAgICAgICBhdmNTYW1wbGUuZHRzID0gbGFzdFNhbXBsZS5kdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcm9wcGluZyBzYW1wbGVzLCBubyB0aW1lc3RhbXAgZm91bmRcbiAgICAgICAgYXZjVHJhY2suZHJvcHBlZCsrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGF2Y1RyYWNrLnNhbXBsZXMucHVzaChhdmNTYW1wbGUpO1xuICB9XG4gIGlmIChhdmNTYW1wbGUuZGVidWcubGVuZ3RoKSB7XG4gICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNUDMgZGVtdXhlclxuICovXG5jbGFzcyBNUDNEZW11eGVyIGV4dGVuZHMgQmFzZUF1ZGlvRGVtdXhlciB7XG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICBzdXBlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0ge1xuICAgICAgY29udGFpbmVyOiAnYXVkaW8vbXBlZycsXG4gICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgaWQ6IDIsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzZWdtZW50Q29kZWM6ICdtcDMnLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgZHVyYXRpb246IHRyYWNrRHVyYXRpb24sXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGRhdGEgY29udGFpbnMgSUQzIHRpbWVzdGFtcCBhbmQgTVBFRyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICBjb25zdCBpZDNEYXRhID0gZ2V0SUQzRGF0YShkYXRhLCAwKSB8fCBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG4gICAgZm9yIChsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChwcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ01QRUcgQXVkaW8gc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgfVxuICBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuYmFzZVBUUyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgdGhpcy5iYXNlUFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICB9XG59XG5cbi8qKlxuICogIEFBQyBoZWxwZXJcbiAqL1xuXG5jbGFzcyBBQUMge1xuICBzdGF0aWMgZ2V0U2lsZW50RnJhbWUoY29kZWMsIGNoYW5uZWxDb3VudCkge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgIGNhc2UgJ21wNGEuNDAuMic6XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4OGVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODAsIDB4MmMsIDB4ODAsIDB4MDgsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MDAsIDB4YjIsIDB4MDAsIDB4MjAsIDB4MDgsIDB4ZTBdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGhhbmRsZSBIRS1BQUMgYmVsb3cgKG1wNGEuNDAuNSAvIG1wNGEuNDAuMjkpXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGUgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIE1QNCBCb3hcbiAqL1xuXG5jb25zdCBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbmNsYXNzIE1QNCB7XG4gIHN0YXRpYyBpbml0KCkge1xuICAgIE1QNC50eXBlcyA9IHtcbiAgICAgIGF2YzE6IFtdLFxuICAgICAgLy8gY29kaW5nbmFtZVxuICAgICAgYXZjQzogW10sXG4gICAgICBidHJ0OiBbXSxcbiAgICAgIGRpbmY6IFtdLFxuICAgICAgZHJlZjogW10sXG4gICAgICBlc2RzOiBbXSxcbiAgICAgIGZ0eXA6IFtdLFxuICAgICAgaGRscjogW10sXG4gICAgICBtZGF0OiBbXSxcbiAgICAgIG1kaGQ6IFtdLFxuICAgICAgbWRpYTogW10sXG4gICAgICBtZmhkOiBbXSxcbiAgICAgIG1pbmY6IFtdLFxuICAgICAgbW9vZjogW10sXG4gICAgICBtb292OiBbXSxcbiAgICAgIG1wNGE6IFtdLFxuICAgICAgJy5tcDMnOiBbXSxcbiAgICAgIG12ZXg6IFtdLFxuICAgICAgbXZoZDogW10sXG4gICAgICBwYXNwOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdXG4gICAgfTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIE1QNC50eXBlc1tpXSA9IFtpLmNoYXJDb2RlQXQoMCksIGkuY2hhckNvZGVBdCgxKSwgaS5jaGFyQ29kZUF0KDIpLCBpLmNoYXJDb2RlQXQoMyldO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LCAweDZmLCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgXSk7XG5cbiAgICBjb25zdCBhdWRpb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4NzMsIDB4NmYsIDB4NzUsIDB4NmUsXG4gICAgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDUzLCAweDZmLCAweDc1LCAweDZlLCAweDY0LCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXG4gICAgXSk7XG5cbiAgICBNUDQuSERMUl9UWVBFUyA9IHtcbiAgICAgIHZpZGVvOiB2aWRlb0hkbHIsXG4gICAgICBhdWRpbzogYXVkaW9IZGxyXG4gICAgfTtcbiAgICBjb25zdCBkcmVmID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgLy8gZW50cnlfY291bnRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLFxuICAgIC8vIGVudHJ5X3NpemVcbiAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLFxuICAgIC8vICd1cmwnIHR5cGVcbiAgICAweDAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfZmxhZ3NcbiAgICBdKTtcblxuICAgIGNvbnN0IHN0Y28gPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICBdKTtcblxuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pO1xuXG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMSxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gICAgXSk7XG5cbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBiYWxhbmNlXG4gICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxuICAgIF0pO1xuXG4gICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOyAvLyBlbnRyeV9jb3VudFxuXG4gICAgY29uc3QgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuICAgIGNvbnN0IGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuICAgIGNvbnN0IG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBtYWpvckJyYW5kLCBtaW5vclZlcnNpb24sIG1ham9yQnJhbmQsIGF2YzFCcmFuZCk7XG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XG4gIH1cbiAgc3RhdGljIGJveCh0eXBlLCAuLi5wYXlsb2FkKSB7XG4gICAgbGV0IHNpemUgPSA4O1xuICAgIGxldCBpID0gcGF5bG9hZC5sZW5ndGg7XG4gICAgY29uc3QgbGVuID0gaTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgICByZXN1bHRbMV0gPSBzaXplID4+IDE2ICYgMHhmZjtcbiAgICByZXN1bHRbMl0gPSBzaXplID4+IDggJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gICAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcbiAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxuICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBoZGxyKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9XG4gIHN0YXRpYyBtZGF0KGRhdGEpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XG4gIH1cbiAgc3RhdGljIG1kaGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsXG4gICAgLy8gdGltZXNjYWxlXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHg1NSwgMHhjNCxcbiAgICAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgIDB4MDAsIDB4MDBdKSk7XG4gIH1cbiAgc3RhdGljIG1kaWEodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRpYSwgTVA0Lm1kaGQodHJhY2sudGltZXNjYWxlLCB0cmFjay5kdXJhdGlvbiksIE1QNC5oZGxyKHRyYWNrLnR5cGUpLCBNUDQubWluZih0cmFjaykpO1xuICB9XG4gIHN0YXRpYyBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgc2VxdWVuY2VOdW1iZXIgPj4gMjQsIHNlcXVlbmNlTnVtYmVyID4+IDE2ICYgMHhmZiwgc2VxdWVuY2VOdW1iZXIgPj4gOCAmIDB4ZmYsIHNlcXVlbmNlTnVtYmVyICYgMHhmZiAvLyBzZXF1ZW5jZV9udW1iZXJcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgbWluZih0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBtb29mKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XG4gIH1cbiAgc3RhdGljIG1vb3YodHJhY2tzKSB7XG4gICAgbGV0IGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgfVxuICBzdGF0aWMgbXZleCh0cmFja3MpIHtcbiAgICBsZXQgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleCwgLi4uYm94ZXNdKTtcbiAgfVxuICBzdGF0aWMgbXZoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsXG4gICAgLy8gdGltZXNjYWxlXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAvLyAxLjAgcmF0ZVxuICAgIDB4MDEsIDB4MDAsXG4gICAgLy8gMS4wIHZvbHVtZVxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICBdKTtcblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH1cbiAgc3RhdGljIHNkdHAodHJhY2spIHtcbiAgICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCk7XG4gICAgbGV0IGk7XG4gICAgbGV0IGZsYWdzO1xuICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXG4gICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICBieXRlc1tpICsgNF0gPSBmbGFncy5kZXBlbmRzT24gPDwgNCB8IGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyIHwgZmxhZ3MuaGFzUmVkdW5kYW5jeTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGJ5dGVzKTtcbiAgfVxuICBzdGF0aWMgc3RibCh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XG4gIH1cbiAgc3RhdGljIGF2YzEodHJhY2spIHtcbiAgICBsZXQgc3BzID0gW107XG4gICAgbGV0IHBwcyA9IFtdO1xuICAgIGxldCBpO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBsZW47XG4gICAgLy8gYXNzZW1ibGUgdGhlIFNQU3NcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBzcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgIHNwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuXG4gICAgICAvLyBTUFNcbiAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnBwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHBwcy5wdXNoKGxlbiA+Pj4gOCAmIDB4ZmYpO1xuICAgICAgcHBzLnB1c2gobGVuICYgMHhmZik7XG4gICAgICBwcHMgPSBwcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgYXZjYyA9IE1QNC5ib3goTVA0LnR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb25cbiAgICBzcHNbM10sXG4gICAgLy8gcHJvZmlsZVxuICAgIHNwc1s0XSxcbiAgICAvLyBwcm9maWxlIGNvbXBhdFxuICAgIHNwc1s1XSxcbiAgICAvLyBsZXZlbFxuICAgIDB4ZmMgfCAzLFxuICAgIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgMHhlMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW3RyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgIF0pLmNvbmNhdChwcHMpKSk7IC8vIFwiUFBTXCJcbiAgICBjb25zdCB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICBjb25zdCBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF07XG4gICAgY29uc3QgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLFxuICAgIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHByZV9kZWZpbmVkXG4gICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZixcbiAgICAvLyB3aWR0aFxuICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZixcbiAgICAvLyBoZWlnaHRcbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgIC8vIGhvcml6cmVzb2x1dGlvblxuICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsXG4gICAgLy8gdmVydHJlc29sdXRpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBmcmFtZV9jb3VudFxuICAgIDB4MTIsIDB4NjQsIDB4NjEsIDB4NjksIDB4NmMsXG4gICAgLy8gZGFpbHltb3Rpb24vaGxzLmpzXG4gICAgMHg3OSwgMHg2ZCwgMHg2ZiwgMHg3NCwgMHg2OSwgMHg2ZiwgMHg2ZSwgMHgyZiwgMHg2OCwgMHg2YywgMHg3MywgMHgyZSwgMHg2YSwgMHg3MywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBjb21wcmVzc29ybmFtZVxuICAgIDB4MDAsIDB4MTgsXG4gICAgLy8gZGVwdGggPSAyNFxuICAgIDB4MTEsIDB4MTFdKSxcbiAgICAvLyBwcmVfZGVmaW5lZCA9IC0xXG4gICAgYXZjYywgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsXG4gICAgLy8gYnVmZmVyU2l6ZURCXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCxcbiAgICAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSxcbiAgICAvLyBhdmdCaXRyYXRlXG4gICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW2hTcGFjaW5nID4+IDI0LFxuICAgIC8vIGhTcGFjaW5nXG4gICAgaFNwYWNpbmcgPj4gMTYgJiAweGZmLCBoU3BhY2luZyA+PiA4ICYgMHhmZiwgaFNwYWNpbmcgJiAweGZmLCB2U3BhY2luZyA+PiAyNCxcbiAgICAvLyB2U3BhY2luZ1xuICAgIHZTcGFjaW5nID4+IDE2ICYgMHhmZiwgdlNwYWNpbmcgPj4gOCAmIDB4ZmYsIHZTcGFjaW5nICYgMHhmZl0pKSk7XG4gIH1cbiAgc3RhdGljIGVzZHModHJhY2spIHtcbiAgICBjb25zdCBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG5cbiAgICAweDAzLFxuICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDB4MTcgKyBjb25maWdsZW4sXG4gICAgLy8gbGVuZ3RoXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBlc19pZFxuICAgIDB4MDAsXG4gICAgLy8gc3RyZWFtX3ByaW9yaXR5XG5cbiAgICAweDA0LFxuICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDB4MGYgKyBjb25maWdsZW4sXG4gICAgLy8gbGVuZ3RoXG4gICAgMHg0MCxcbiAgICAvLyBjb2RlYyA6IG1wZWc0X2F1ZGlvXG4gICAgMHgxNSxcbiAgICAvLyBzdHJlYW1fdHlwZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gYnVmZmVyX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIG1heEJpdHJhdGVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGF2Z0JpdHJhdGVcblxuICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdCh0cmFjay5jb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTsgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxuICB9XG5cbiAgc3RhdGljIG1wNGEodHJhY2spIHtcbiAgICBjb25zdCBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsXG4gICAgLy8gY2hhbm5lbGNvdW50XG4gICAgMHgwMCwgMHgxMCxcbiAgICAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWQyXG4gICAgc2FtcGxlcmF0ZSA+PiA4ICYgMHhmZiwgc2FtcGxlcmF0ZSAmIDB4ZmYsXG4gICAgLy9cbiAgICAweDAwLCAweDAwXSksIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xuICB9XG4gIHN0YXRpYyBtcDModHJhY2spIHtcbiAgICBjb25zdCBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsXG4gICAgLy8gY2hhbm5lbGNvdW50XG4gICAgMHgwMCwgMHgxMCxcbiAgICAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWQyXG4gICAgc2FtcGxlcmF0ZSA+PiA4ICYgMHhmZiwgc2FtcGxlcmF0ZSAmIDB4ZmYsXG4gICAgLy9cbiAgICAweDAwLCAweDAwXSkpO1xuICB9XG4gIHN0YXRpYyBzdHNkKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdGtoZCh0cmFjaykge1xuICAgIGNvbnN0IGlkID0gdHJhY2suaWQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiAqIHRyYWNrLnRpbWVzY2FsZTtcbiAgICBjb25zdCB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwNyxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICBpZCA+PiAyNCAmIDB4ZmYsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZixcbiAgICAvLyB0cmFja19JRFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCwgdXBwZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBsYXllclxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gYWx0ZXJuYXRlX2dyb3VwXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsIDB4MDAsIDB4MDAsXG4gICAgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIDB4MDAsIDB4MDAgLy8gaGVpZ2h0XG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIHRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICBjb25zdCBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayk7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICBjb25zdCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLCBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgaWQgPj4gMjQsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZiAvLyB0cmFja19JRFxuICAgIF0pKSwgTVA0LmJveChNUDQudHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweGZmXSkpLCBNUDQudHJ1bih0cmFjaywgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArIDE2ICtcbiAgICAvLyB0ZmhkXG4gICAgMjAgK1xuICAgIC8vIHRmZHRcbiAgICA4ICtcbiAgICAvLyB0cmFmIGhlYWRlclxuICAgIDE2ICtcbiAgICAvLyBtZmhkXG4gICAgOCArXG4gICAgLy8gbW9vZiBoZWFkZXJcbiAgICA4KSxcbiAgICAvLyBtZGF0IGhlYWRlclxuICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gICAqIEBwYXJhbSB0cmFjayBhIHRyYWNrIGRlZmluaXRpb25cbiAgICovXG4gIHN0YXRpYyB0cmFrKHRyYWNrKSB7XG4gICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gIH1cbiAgc3RhdGljIHRyZXgodHJhY2spIHtcbiAgICBjb25zdCBpZCA9IHRyYWNrLmlkO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmV4LCBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgaWQgPj4gMjQsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZixcbiAgICAvLyB0cmFja19JRFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyB0cnVuKHRyYWNrLCBvZmZzZXQpIHtcbiAgICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICBjb25zdCBsZW4gPSBzYW1wbGVzLmxlbmd0aDtcbiAgICBjb25zdCBhcnJheWxlbiA9IDEyICsgMTYgKiBsZW47XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheWxlbik7XG4gICAgbGV0IGk7XG4gICAgbGV0IHNhbXBsZTtcbiAgICBsZXQgZHVyYXRpb247XG4gICAgbGV0IHNpemU7XG4gICAgbGV0IGZsYWdzO1xuICAgIGxldCBjdHM7XG4gICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICBhcnJheS5zZXQoW3RyYWNrLnR5cGUgPT09ICd2aWRlbycgPyAweDAxIDogMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDEgZm9yIHZpZGVvIHdpdGggc2lnbmVkLWludCBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAweDAwLCAweDBmLCAweDAxLFxuICAgIC8vIGZsYWdzXG4gICAgbGVuID4+PiAyNCAmIDB4ZmYsIGxlbiA+Pj4gMTYgJiAweGZmLCBsZW4gPj4+IDggJiAweGZmLCBsZW4gJiAweGZmLFxuICAgIC8vIHNhbXBsZV9jb3VudFxuICAgIG9mZnNldCA+Pj4gMjQgJiAweGZmLCBvZmZzZXQgPj4+IDE2ICYgMHhmZiwgb2Zmc2V0ID4+PiA4ICYgMHhmZiwgb2Zmc2V0ICYgMHhmZiAvLyBkYXRhX29mZnNldFxuICAgIF0sIDApO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgIGR1cmF0aW9uID0gc2FtcGxlLmR1cmF0aW9uO1xuICAgICAgc2l6ZSA9IHNhbXBsZS5zaXplO1xuICAgICAgZmxhZ3MgPSBzYW1wbGUuZmxhZ3M7XG4gICAgICBjdHMgPSBzYW1wbGUuY3RzO1xuICAgICAgYXJyYXkuc2V0KFtkdXJhdGlvbiA+Pj4gMjQgJiAweGZmLCBkdXJhdGlvbiA+Pj4gMTYgJiAweGZmLCBkdXJhdGlvbiA+Pj4gOCAmIDB4ZmYsIGR1cmF0aW9uICYgMHhmZixcbiAgICAgIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgc2l6ZSA+Pj4gMjQgJiAweGZmLCBzaXplID4+PiAxNiAmIDB4ZmYsIHNpemUgPj4+IDggJiAweGZmLCBzaXplICYgMHhmZixcbiAgICAgIC8vIHNhbXBsZV9zaXplXG4gICAgICBmbGFncy5pc0xlYWRpbmcgPDwgMiB8IGZsYWdzLmRlcGVuZHNPbiwgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYgfCBmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQgfCBmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSB8IGZsYWdzLmlzTm9uU3luYywgZmxhZ3MuZGVncmFkUHJpbyAmIDB4ZjAgPDwgOCwgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MGYsXG4gICAgICAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgIGN0cyA+Pj4gMjQgJiAweGZmLCBjdHMgPj4+IDE2ICYgMHhmZiwgY3RzID4+PiA4ICYgMHhmZiwgY3RzICYgMHhmZiAvLyBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAgIF0sIDEyICsgMTYgKiBpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRydW4sIGFycmF5KTtcbiAgfVxuICBzdGF0aWMgaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgIE1QNC5pbml0KCk7XG4gICAgfVxuICAgIGNvbnN0IG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNUDQuRlRZUC5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XG4gICAgcmVzdWx0LnNldChNUDQuRlRZUCk7XG4gICAgcmVzdWx0LnNldChtb3ZpZSwgTVA0LkZUWVAuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuTVA0LnR5cGVzID0gdm9pZCAwO1xuTVA0LkhETFJfVFlQRVMgPSB2b2lkIDA7XG5NUDQuU1RUUyA9IHZvaWQgMDtcbk1QNC5TVFNDID0gdm9pZCAwO1xuTVA0LlNUQ08gPSB2b2lkIDA7XG5NUDQuU1RTWiA9IHZvaWQgMDtcbk1QNC5WTUhEID0gdm9pZCAwO1xuTVA0LlNNSEQgPSB2b2lkIDA7XG5NUDQuU1RTRCA9IHZvaWQgMDtcbk1QNC5GVFlQID0gdm9pZCAwO1xuTVA0LkRJTkYgPSB2b2lkIDA7XG5cbmNvbnN0IE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiA9IDkwMDAwO1xuZnVuY3Rpb24gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgZGVzdFNjYWxlLCBzcmNCYXNlID0gMSwgcm91bmQgPSBmYWxzZSkge1xuICBjb25zdCByZXN1bHQgPSBiYXNlVGltZSAqIGRlc3RTY2FsZSAqIHNyY0Jhc2U7IC8vIGVxdWl2YWxlbnQgdG8gYCh2YWx1ZSAqIHNjYWxlKSAvICgxIC8gYmFzZSlgXG4gIHJldHVybiByb3VuZCA/IE1hdGgucm91bmQocmVzdWx0KSA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbVNjYWxlKGJhc2VUaW1lLCBkZXN0U2NhbGUsIHNyY1NjYWxlID0gMSwgcm91bmQgPSBmYWxzZSkge1xuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgZGVzdFNjYWxlLCAxIC8gc3JjU2NhbGUsIHJvdW5kKTtcbn1cbmZ1bmN0aW9uIHRvTXNGcm9tTXBlZ1RzQ2xvY2soYmFzZVRpbWUsIHJvdW5kID0gZmFsc2UpIHtcbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIDEwMDAsIDEgLyBNUEVHX1RTX0NMT0NLX0ZSRVFfSFosIHJvdW5kKTtcbn1cbmZ1bmN0aW9uIHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlKGJhc2VUaW1lLCBzcmNTY2FsZSA9IDEpIHtcbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgMSAvIHNyY1NjYWxlKTtcbn1cblxuY29uc3QgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiA9IDEwICogMTAwMDsgLy8gMTAgc2Vjb25kc1xuY29uc3QgQUFDX1NBTVBMRVNfUEVSX0ZSQU1FID0gMTAyNDtcbmNvbnN0IE1QRUdfQVVESU9fU0FNUExFX1BFUl9GUkFNRSA9IDExNTI7XG5sZXQgY2hyb21lVmVyc2lvbiA9IG51bGw7XG5sZXQgc2FmYXJpV2Via2l0VmVyc2lvbiA9IG51bGw7XG5jbGFzcyBNUDRSZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yID0gJycpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdFBUUyA9IG51bGw7XG4gICAgdGhpcy5faW5pdERUUyA9IG51bGw7XG4gICAgdGhpcy5uZXh0QXZjRHRzID0gbnVsbDtcbiAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG51bGw7XG4gICAgdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gbnVsbDtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICBpZiAoY2hyb21lVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgICBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCspL2kpO1xuICAgICAgc2FmYXJpV2Via2l0VmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge31cbiAgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdFRpbWVTdGFtcCkge1xuICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IGluaXRQVFMgJiBpbml0RFRTIHJlc2V0Jyk7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBkZWZhdWx0VGltZVN0YW1wO1xuICB9XG4gIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICBsb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiByZXNldCBuZXh0IHRpbWVzdGFtcCcpO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudCgpIHtcbiAgICBsb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiBJU0dlbmVyYXRlZCBmbGFnIHJlc2V0Jyk7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKSB7XG4gICAgbGV0IHJvbGxvdmVyRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBzdGFydFBUUyA9IHZpZGVvU2FtcGxlcy5yZWR1Y2UoKG1pblBUUywgc2FtcGxlKSA9PiB7XG4gICAgICBjb25zdCBkZWx0YSA9IHNhbXBsZS5wdHMgLSBtaW5QVFM7XG4gICAgICBpZiAoZGVsdGEgPCAtNDI5NDk2NzI5Nikge1xuICAgICAgICAvLyAyXjMyLCBzZWUgUFRTTm9ybWFsaXplIGZvciByZWFzb25pbmcsIGJ1dCB3ZSdyZSBoaXR0aW5nIGEgcm9sbG92ZXIgaGVyZSwgYW5kIHdlIGRvbid0IHdhbnQgdGhhdCB0byBpbXBhY3QgdGhlIHRpbWVPZmZzZXQgY2FsY3VsYXRpb25cbiAgICAgICAgcm9sbG92ZXJEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVQdHMobWluUFRTLCBzYW1wbGUucHRzKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgIHJldHVybiBtaW5QVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2FtcGxlLnB0cztcbiAgICAgIH1cbiAgICB9LCB2aWRlb1NhbXBsZXNbMF0ucHRzKTtcbiAgICBpZiAocm9sbG92ZXJEZXRlY3RlZCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdQVFMgcm9sbG92ZXIgZGV0ZWN0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0UFRTO1xuICB9XG4gIHJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmx1c2gsIHBsYXlsaXN0VHlwZSkge1xuICAgIGxldCB2aWRlbztcbiAgICBsZXQgYXVkaW87XG4gICAgbGV0IGluaXRTZWdtZW50O1xuICAgIGxldCB0ZXh0O1xuICAgIGxldCBpZDM7XG4gICAgbGV0IGluZGVwZW5kZW50O1xuICAgIGxldCBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIGxldCB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuXG4gICAgLy8gSWYgd2UncmUgcmVtdXhpbmcgYXVkaW8gYW5kIHZpZGVvIHByb2dyZXNzaXZlbHksIHdhaXQgdW50aWwgd2UndmUgcmVjZWl2ZWQgZW5vdWdoIHNhbXBsZXMgZm9yIGVhY2ggdHJhY2sgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHN5bmNocm9uaXplIHRoZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcy4gV2Uga25vdyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHdpbGwgaGF2ZSBzYW1wbGVzIGlmIHRoZSBcInBpZFwiXG4gICAgLy8gcGFyYW1ldGVyIGlzIGdyZWF0ZXIgdGhhbiAtMS4gVGhlIHBpZCBpcyBzZXQgd2hlbiB0aGUgUE1UIGlzIHBhcnNlZCwgd2hpY2ggY29udGFpbnMgdGhlIHRyYWNrcyBsaXN0LlxuICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBpbml0U2VnbWVudCBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZCwgb3Igd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIGEgc2VnbWVudCAoZmx1c2gpLFxuICAgIC8vIHRoZW4gd2UgY2FuIHJlbXV4IG9uZSB0cmFjayB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvdGhlci5cbiAgICBjb25zdCBoYXNBdWRpbyA9IGF1ZGlvVHJhY2sucGlkID4gLTE7XG4gICAgY29uc3QgaGFzVmlkZW8gPSB2aWRlb1RyYWNrLnBpZCA+IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgZW5vdWdoQXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZW5vdWdoVmlkZW9TYW1wbGVzID0gZmx1c2ggJiYgbGVuZ3RoID4gMCB8fCBsZW5ndGggPiAxO1xuICAgIGNvbnN0IGNhblJlbXV4QXZjID0gKCFoYXNBdWRpbyB8fCBlbm91Z2hBdWRpb1NhbXBsZXMpICYmICghaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzKSB8fCB0aGlzLklTR2VuZXJhdGVkIHx8IGZsdXNoO1xuICAgIGlmIChjYW5SZW11eEF2Yykge1xuICAgICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1ZpZGVvQ29udGlndW91cyA9IHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXM7XG4gICAgICBsZXQgZmlyc3RLZXlGcmFtZUluZGV4ID0gLTE7XG4gICAgICBsZXQgZmlyc3RLZXlGcmFtZVBUUztcbiAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgZmlyc3RLZXlGcmFtZUluZGV4ID0gZmluZEtleWZyYW1lSW5kZXgodmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgaWYgKCFpc1ZpZGVvQ29udGlndW91cyAmJiB0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgaW5kZXBlbmRlbnQgPSB0cnVlO1xuICAgICAgICAgIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPiAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgW21wNC1yZW11eGVyXTogRHJvcHBlZCAke2ZpcnN0S2V5RnJhbWVJbmRleH0gb3V0IG9mICR7bGVuZ3RofSB2aWRlbyBzYW1wbGVzIGR1ZSB0byBhIG1pc3Npbmcga2V5ZnJhbWVgKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXMuc2xpY2UoZmlyc3RLZXlGcmFtZUluZGV4KTtcbiAgICAgICAgICAgIHZpZGVvVHJhY2suZHJvcHBlZCArPSBmaXJzdEtleUZyYW1lSW5kZXg7XG4gICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gKHZpZGVvVHJhY2suc2FtcGxlc1swXS5wdHMgLSBzdGFydFBUUykgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgICAgZmlyc3RLZXlGcmFtZVBUUyA9IHZpZGVvVGltZU9mZnNldDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbbXA0LXJlbXV4ZXJdOiBObyBrZXlmcmFtZSBmb3VuZCBvdXQgb2YgJHtsZW5ndGh9IHZpZGVvIHNhbXBsZXNgKTtcbiAgICAgICAgICAgIGluZGVwZW5kZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzICYmIGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIC8vIHRpbWVPZmZzZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIG9mZnNldCBvZiB0aGUgZmlyc3QgdGltZXN0YW1wIG9mIHRoaXMgZnJhZ21lbnQgKGZpcnN0IERUUylcbiAgICAgICAgICAvLyBpZiBmaXJzdCBhdWRpbyBEVFMgaXMgbm90IGFsaWduZWQgd2l0aCBmaXJzdCB2aWRlbyBEVFMgdGhlbiB3ZSBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnRcbiAgICAgICAgICAvLyB3aGVuIHByb3ZpZGluZyB0aW1lT2Zmc2V0IHRvIHJlbXV4QXVkaW8gLyByZW11eFZpZGVvLiBpZiB3ZSBkb24ndCBkbyB0aGF0LCB0aGVyZSBtaWdodCBiZSBhIHBlcm1hbmVudCAvIHNtYWxsXG4gICAgICAgICAgLy8gZHJpZnQgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtc1xuICAgICAgICAgIGNvbnN0IHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgY29uc3QgdHNEZWx0YSA9IG5vcm1hbGl6ZVB0cyhhdWRpb1RyYWNrLnNhbXBsZXNbMF0ucHRzLCBzdGFydFBUUykgLSBzdGFydFBUUztcbiAgICAgICAgICBjb25zdCBhdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEgPSB0c0RlbHRhIC8gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICBhdWRpb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhKTtcbiAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgLWF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXJwb3NlZnVsbHkgcmVtdXhpbmcgYXVkaW8gYmVmb3JlIHZpZGVvLCBzbyB0aGF0IHJlbXV4VmlkZW8gY2FuIHVzZSBuZXh0QXVkaW9QdHMsIHdoaWNoIGlzIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cbiAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcykge1xuICAgICAgICAgIC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCBhdWRpbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXG4gICAgICAgICAgaWYgKCFhdWRpb1RyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdWRpbyA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzIHx8IHBsYXlsaXN0VHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gPyB2aWRlb1RpbWVPZmZzZXQgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tMZW5ndGggPSBhdWRpbyA/IGF1ZGlvLmVuZFBUUyAtIGF1ZGlvLnN0YXJ0UFRTIDogMDtcbiAgICAgICAgICAgIC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCB2aWRlbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXG4gICAgICAgICAgICBpZiAoIXZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGUpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ1ttcDQtcmVtdXhlcl06IHJlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgdmlkZW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZGVvID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgaXNWaWRlb0NvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGlzVmlkZW9Db250aWd1b3VzLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lID0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgIHZpZGVvLmluZGVwZW5kZW50ID0gZmlyc3RLZXlGcmFtZUluZGV4ICE9PSAtMTtcbiAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lUFRTID0gZmlyc3RLZXlGcmFtZVBUUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG93IElEMyBhbmQgdGV4dCB0byByZW11eCwgZXZlbiBpZiBtb3JlIGF1ZGlvL3ZpZGVvIHNhbXBsZXMgYXJlIHJlcXVpcmVkXG4gICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQgJiYgdGhpcy5faW5pdFBUUyAmJiB0aGlzLl9pbml0RFRTKSB7XG4gICAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgaWQzID0gZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXMoaWQzVHJhY2ssIHRpbWVPZmZzZXQsIHRoaXMuX2luaXRQVFMsIHRoaXMuX2luaXREVFMpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICB0ZXh0ID0gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCB0aGlzLl9pbml0UFRTKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvLFxuICAgICAgdmlkZW8sXG4gICAgICBpbml0U2VnbWVudCxcbiAgICAgIGluZGVwZW5kZW50LFxuICAgICAgdGV4dCxcbiAgICAgIGlkM1xuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXM7XG4gICAgY29uc3QgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdHJhY2tzID0ge307XG4gICAgY29uc3QgX2luaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGxldCBjb21wdXRlUFRTRFRTID0gIV9pbml0UFRTIHx8IGFjY3VyYXRlVGltZU9mZnNldDtcbiAgICBsZXQgY29udGFpbmVyID0gJ2F1ZGlvL21wNCc7XG4gICAgbGV0IGluaXRQVFM7XG4gICAgbGV0IGluaXREVFM7XG4gICAgbGV0IHRpbWVzY2FsZTtcbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGxldCdzIHVzZSBhdWRpbyBzYW1wbGluZyByYXRlIGFzIE1QNCB0aW1lIHNjYWxlLlxuICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgdGhlcmUgaXMgYSBpbnRlZ2VyIG5iIG9mIGF1ZGlvIGZyYW1lcyBwZXIgYXVkaW8gc2FtcGxlICgxMDI0IGZvciBBQUMpXG4gICAgICAvLyB1c2luZyBhdWRpbyBzYW1wbGluZyByYXRlIGhlcmUgaGVscHMgaGF2aW5nIGFuIGludGVnZXIgTVA0IGZyYW1lIGR1cmF0aW9uXG4gICAgICAvLyB0aGlzIGF2b2lkcyBwb3RlbnRpYWwgcm91bmRpbmcgaXNzdWUgYW5kIEFWIHN5bmMgaXNzdWVcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5zYW1wbGVyYXRlO1xuICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICAgICAgICBjb250YWluZXIgPSAnYXVkaW8vbXBlZyc7XG4gICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlU3VwcG9ydGVkLm1wMykge1xuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgaWQ6ICdhdWRpbycsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBjb2RlYzogYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0eXBlU3VwcG9ydGVkLm1wZWcgPyBuZXcgVWludDhBcnJheSgwKSA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIGlmICghX2luaXRQVFMgfHwgdGltZXNjYWxlICE9PSBfaW5pdFBUUy50aW1lc2NhbGUpIHtcbiAgICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2YgdGhpcyBkZW11eGluZyBjb250ZXh0LiBmb3IgYXVkaW8sIFBUUyA9IERUU1xuICAgICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcHV0ZVBUU0RUUyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgaW5wdXQgdGltZSBzY2FsZSBhcyBNUDQgdmlkZW8gdGltZXNjYWxlXG4gICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IE1QNC5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRpbWVzY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIGlmICghX2luaXRQVFMgfHwgdGltZXNjYWxlICE9PSBfaW5pdFBUUy50aW1lc2NhbGUpIHtcbiAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1NhbXBsZXMpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gTWF0aC5yb3VuZCh0aW1lc2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oaW5pdERUUywgbm9ybWFsaXplUHRzKHZpZGVvU2FtcGxlc1swXS5kdHMsIHN0YXJ0UFRTKSAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUywgc3RhcnRQVFMgLSBzdGFydE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcHV0ZVBUU0RUUyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh0cmFja3MpLmxlbmd0aCkge1xuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aGlzLl9pbml0UFRTID0ge1xuICAgICAgICAgIGJhc2VUaW1lOiBpbml0UFRTLFxuICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXREVFMgPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXREVFMsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRQVFMgPSB0aW1lc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFja3MsXG4gICAgICAgIGluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmVtdXhWaWRlbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCkge1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgY29uc3Qgb3V0cHV0U2FtcGxlcyA9IFtdO1xuICAgIGNvbnN0IG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgbGV0IG5leHRBdmNEdHMgPSB0aGlzLm5leHRBdmNEdHM7XG4gICAgbGV0IG9mZnNldCA9IDg7XG4gICAgbGV0IG1wNFNhbXBsZUR1cmF0aW9uID0gdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uO1xuICAgIGxldCBmaXJzdERUUztcbiAgICBsZXQgbGFzdERUUztcbiAgICBsZXQgbWluUFRTID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhQVFMgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IHNvcnRTYW1wbGVzID0gZmFsc2U7XG5cbiAgICAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdmNEdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHB0cyA9IHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgICBjb25zdCBjdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5kdHMsIGlucHV0U2FtcGxlc1swXS5wdHMpO1xuICAgICAgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuICAgICAgbmV4dEF2Y0R0cyA9IHB0cyAtIGN0cztcbiAgICB9XG5cbiAgICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gICAgLy8gUFRTTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgIGNvbnN0IGluaXRUaW1lID0gaW5pdFBUUy5iYXNlVGltZSAqIHRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRUaW1lLCBuZXh0QXZjRHRzKTtcbiAgICAgIHNhbXBsZS5kdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLmR0cyAtIGluaXRUaW1lLCBuZXh0QXZjRHRzKTtcbiAgICAgIGlmIChzYW1wbGUuZHRzIDwgaW5wdXRTYW1wbGVzW2kgPiAwID8gaSAtIDEgOiBpXS5kdHMpIHtcbiAgICAgICAgc29ydFNhbXBsZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNvcnQgdmlkZW8gc2FtcGxlcyBieSBEVFMgdGhlbiBQVFMgdGhlbiBkZW11eCBpZCBvcmRlclxuICAgIGlmIChzb3J0U2FtcGxlcykge1xuICAgICAgaW5wdXRTYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgY29uc3QgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgICBjb25zdCBkZWx0YXB0cyA9IGEucHRzIC0gYi5wdHM7XG4gICAgICAgIHJldHVybiBkZWx0YWR0cyB8fCBkZWx0YXB0cztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCBmaXJzdC9sYXN0IERUU1xuICAgIGZpcnN0RFRTID0gaW5wdXRTYW1wbGVzWzBdLmR0cztcbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXS5kdHM7XG5cbiAgICAvLyBTYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuICAgIGNvbnN0IGlucHV0RHVyYXRpb24gPSBsYXN0RFRTIC0gZmlyc3REVFM7XG4gICAgY29uc3QgYXZlcmFnZVNhbXBsZUR1cmF0aW9uID0gaW5wdXREdXJhdGlvbiA/IE1hdGgucm91bmQoaW5wdXREdXJhdGlvbiAvIChuYlNhbXBsZXMgLSAxKSkgOiBtcDRTYW1wbGVEdXJhdGlvbiB8fCB0cmFjay5pbnB1dFRpbWVTY2FsZSAvIDMwO1xuXG4gICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgIC8vIGNoZWNrIHRpbWVzdGFtcCBjb250aW51aXR5IGFjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgICAgY29uc3QgZGVsdGEgPSBmaXJzdERUUyAtIG5leHRBdmNEdHM7XG4gICAgICBjb25zdCBmb3VuZEhvbGUgPSBkZWx0YSA+IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGZvdW5kT3ZlcmxhcCA9IGRlbHRhIDwgLTE7XG4gICAgICBpZiAoZm91bmRIb2xlIHx8IGZvdW5kT3ZlcmxhcCkge1xuICAgICAgICBpZiAoZm91bmRIb2xlKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEFWQzogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhLCB0cnVlKX0gbXMgKCR7ZGVsdGF9ZHRzKSBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkLCBmaWxsaW5nIGl0YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEFWQzogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKC1kZWx0YSwgdHJ1ZSl9IG1zICgke2RlbHRhfWR0cykgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kT3ZlcmxhcCB8fCBuZXh0QXZjRHRzID49IGlucHV0U2FtcGxlc1swXS5wdHMpIHtcbiAgICAgICAgICBmaXJzdERUUyA9IG5leHRBdmNEdHM7XG4gICAgICAgICAgY29uc3QgZmlyc3RQVFMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzIC0gZGVsdGE7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzWzBdLmR0cyA9IGZpcnN0RFRTO1xuICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5wdHMgPSBmaXJzdFBUUztcbiAgICAgICAgICBsb2dnZXIubG9nKGBWaWRlbzogRmlyc3QgUFRTL0RUUyBhZGp1c3RlZDogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGZpcnN0UFRTLCB0cnVlKX0vJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGZpcnN0RFRTLCB0cnVlKX0sIGRlbHRhOiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZGVsdGEsIHRydWUpfSBtc2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZpcnN0RFRTID0gTWF0aC5tYXgoMCwgZmlyc3REVFMpO1xuICAgIGxldCBuYk5hbHUgPSAwO1xuICAgIGxldCBuYWx1TGVuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICAvLyBjb21wdXRlIHRvdGFsL2F2YyBzYW1wbGUgbGVuZ3RoIGFuZCBuYiBvZiBOQUwgdW5pdHNcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIGNvbnN0IHVuaXRzID0gc2FtcGxlLnVuaXRzO1xuICAgICAgY29uc3QgbmJVbml0cyA9IHVuaXRzLmxlbmd0aDtcbiAgICAgIGxldCBzYW1wbGVMZW4gPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgc2FtcGxlTGVuICs9IHVuaXRzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICBuYk5hbHUgKz0gbmJVbml0cztcbiAgICAgIHNhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47XG5cbiAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgc2FtcGxlLmR0cyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIGZpcnN0RFRTKTtcbiAgICAgIG1pblBUUyA9IE1hdGgubWluKHNhbXBsZS5wdHMsIG1pblBUUyk7XG4gICAgICBtYXhQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCBtYXhQVFMpO1xuICAgIH1cbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW25iU2FtcGxlcyAtIDFdLmR0cztcblxuICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICBjb25zdCBtZGF0U2l6ZSA9IG5hbHVMZW4gKyA0ICogbmJOYWx1ICsgODtcbiAgICBsZXQgbWRhdDtcbiAgICB0cnkge1xuICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIHZpZGVvIG1kYXQgJHttZGF0U2l6ZX1gXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcbiAgICBsZXQgc3RyZXRjaGVkTGFzdEZyYW1lID0gZmFsc2U7XG4gICAgbGV0IG1pbkR0c0RlbHRhID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtaW5QdHNEZWx0YSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4RHRzRGVsdGEgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heFB0c0RlbHRhID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIGNvbnN0IGF2Y1NhbXBsZVVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgbGV0IG1wNFNhbXBsZUxlbmd0aCA9IDA7XG4gICAgICAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG4gICAgICBmb3IgKGxldCBqID0gMCwgbmJVbml0cyA9IGF2Y1NhbXBsZVVuaXRzLmxlbmd0aDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBjb25zdCB1bml0ID0gYXZjU2FtcGxlVW5pdHNbal07XG4gICAgICAgIGNvbnN0IHVuaXREYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICBjb25zdCB1bml0RGF0YUxlbiA9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIHVuaXREYXRhTGVuKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIG1kYXQuc2V0KHVuaXREYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gdW5pdERhdGFMZW47XG4gICAgICAgIG1wNFNhbXBsZUxlbmd0aCArPSA0ICsgdW5pdERhdGFMZW47XG4gICAgICB9XG5cbiAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgbGV0IHB0c0RlbHRhO1xuICAgICAgaWYgKGkgPCBuYlNhbXBsZXMgLSAxKSB7XG4gICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gaW5wdXRTYW1wbGVzW2kgKyAxXS5kdHMgLSBhdmNTYW1wbGUuZHRzO1xuICAgICAgICBwdHNEZWx0YSA9IGlucHV0U2FtcGxlc1tpICsgMV0ucHRzIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBsYXN0RnJhbWVEdXJhdGlvbiA9IGkgPiAwID8gYXZjU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tpIC0gMV0uZHRzIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICBwdHNEZWx0YSA9IGkgPiAwID8gYXZjU2FtcGxlLnB0cyAtIGlucHV0U2FtcGxlc1tpIC0gMV0ucHRzIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2sgJiYgdGhpcy5uZXh0QXVkaW9QdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgIC8vIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXG4gICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgY29uc3QgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihjb25maWcubWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSk7XG4gICAgICAgICAgY29uc3QgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBtaW5QVFMgKyBhdWRpb1RyYWNrTGVuZ3RoICogdGltZVNjYWxlIDogdGhpcy5uZXh0QXVkaW9QdHMpIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJldGNoZWRMYXN0RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgW21wNC1yZW11eGVyXTogSXQgaXMgYXBwcm94aW1hdGVseSAke2RlbHRhVG9GcmFtZUVuZCAvIDkwfSBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiAke21wNFNhbXBsZUR1cmF0aW9uIC8gOTB9IG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cyk7XG4gICAgICBtaW5EdHNEZWx0YSA9IE1hdGgubWluKG1pbkR0c0RlbHRhLCBtcDRTYW1wbGVEdXJhdGlvbik7XG4gICAgICBtYXhEdHNEZWx0YSA9IE1hdGgubWF4KG1heER0c0RlbHRhLCBtcDRTYW1wbGVEdXJhdGlvbik7XG4gICAgICBtaW5QdHNEZWx0YSA9IE1hdGgubWluKG1pblB0c0RlbHRhLCBwdHNEZWx0YSk7XG4gICAgICBtYXhQdHNEZWx0YSA9IE1hdGgubWF4KG1heFB0c0RlbHRhLCBwdHNEZWx0YSk7XG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobmV3IE1wNFNhbXBsZShhdmNTYW1wbGUua2V5LCBtcDRTYW1wbGVEdXJhdGlvbiwgbXA0U2FtcGxlTGVuZ3RoLCBjb21wb3NpdGlvblRpbWVPZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKG91dHB1dFNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbiA8IDcwKSB7XG4gICAgICAgICAgLy8gQ2hyb21lIHdvcmthcm91bmQsIG1hcmsgZmlyc3Qgc2FtcGxlIGFzIGJlaW5nIGEgUmFuZG9tIEFjY2VzcyBQb2ludCAoa2V5ZnJhbWUpIHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcbiAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICAgICAgY29uc3QgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xuICAgICAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICAgICAgZmxhZ3MuaXNOb25TeW5jID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzYWZhcmlXZWJraXRWZXJzaW9uKSB7XG4gICAgICAgIC8vIEZpeCBmb3IgXCJDTk4gc3BlY2lhbCByZXBvcnQsIHdpdGggQ0NcIiBpbiB0ZXN0LXN0cmVhbXMgKFNhZmFyaSBicm93c2VyIG9ubHkpXG4gICAgICAgIC8vIElnbm9yZSBEVFMgd2hlbiBmcmFtZSBkdXJhdGlvbnMgYXJlIGlycmVndWxhci4gU2FmYXJpIE1TRSBkb2VzIG5vdCBoYW5kbGUgdGhpcyBsZWFkaW5nIHRvIGdhcHMuXG4gICAgICAgIGlmIChtYXhQdHNEZWx0YSAtIG1pblB0c0RlbHRhIDwgbWF4RHRzRGVsdGEgLSBtaW5EdHNEZWx0YSAmJiBhdmVyYWdlU2FtcGxlRHVyYXRpb24gLyBtYXhEdHNEZWx0YSA8IDAuMDI1ICYmIG91dHB1dFNhbXBsZXNbMF0uY3RzID09PSAwKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ0ZvdW5kIGlycmVndWxhciBnYXBzIGluIHNhbXBsZSBkdXJhdGlvbi4gVXNpbmcgUFRTIGluc3RlYWQgb2YgRFRTIHRvIGRldGVybWluZSBNUDQgc2FtcGxlIGR1cmF0aW9uLicpO1xuICAgICAgICAgIGxldCBkdHMgPSBmaXJzdERUUztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dER0cyA9IGR0cyArIG91dHB1dFNhbXBsZXNbaV0uZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBwdHMgPSBkdHMgKyBvdXRwdXRTYW1wbGVzW2ldLmN0cztcbiAgICAgICAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0UHRzID0gbmV4dER0cyArIG91dHB1dFNhbXBsZXNbaSArIDFdLmN0cztcbiAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5kdXJhdGlvbiA9IG5leHRQdHMgLSBwdHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXRTYW1wbGVzW2ldLmR1cmF0aW9uID0gaSA/IG91dHB1dFNhbXBsZXNbaSAtIDFdLmR1cmF0aW9uIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5jdHMgPSAwO1xuICAgICAgICAgICAgZHRzID0gbmV4dER0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbmV4dCBBVkMgc2FtcGxlIERUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgRFRTICsgbGFzdCBzYW1wbGUgZHVyYXRpb24gKGluIFBFUyB0aW1lc2NhbGUpXG4gICAgbXA0U2FtcGxlRHVyYXRpb24gPSBzdHJldGNoZWRMYXN0RnJhbWUgfHwgIW1wNFNhbXBsZUR1cmF0aW9uID8gYXZlcmFnZVNhbXBsZUR1cmF0aW9uIDogbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5uZXh0QXZjRHRzID0gbmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gdHJ1ZTtcbiAgICBjb25zdCBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMsIF9leHRlbmRzKHt9LCB0cmFjaywge1xuICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgIH0pKTtcbiAgICBjb25zdCB0eXBlID0gJ3ZpZGVvJztcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBtaW5QVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmRQVFM6IChtYXhQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IG5leHRBdmNEdHMgLyB0aW1lU2NhbGUsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkOiB0cmFjay5kcm9wcGVkXG4gICAgfTtcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB2aWRlb1RpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycgPyBBQUNfU0FNUExFU19QRVJfRlJBTUUgOiBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUU7XG4gICAgY29uc3QgaW5wdXRTYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uICogc2NhbGVGYWN0b3I7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgY29uc3QgcmF3TVBFRyA9IHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG4gICAgY29uc3Qgb3V0cHV0U2FtcGxlcyA9IFtdO1xuICAgIGNvbnN0IGFsaWduZWRXaXRoVmlkZW8gPSB2aWRlb1RpbWVPZmZzZXQgIT09IHVuZGVmaW5lZDtcbiAgICBsZXQgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICBsZXQgb2Zmc2V0ID0gcmF3TVBFRyA/IDAgOiA4O1xuICAgIGxldCBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cyB8fCAtMTtcblxuICAgIC8vIHdpbmRvdy5hdWRpb1NhbXBsZXMgPyB3aW5kb3cuYXVkaW9TYW1wbGVzLnB1c2goaW5wdXRTYW1wbGVzLm1hcChzID0+IHMucHRzKSkgOiAod2luZG93LmF1ZGlvU2FtcGxlcyA9IFtpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpXSk7XG5cbiAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcbiAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAvLyB0aGlzIGhlbHBzIGVuc3VyaW5nIGF1ZGlvIGNvbnRpbnVpdHlcbiAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG4gICAgY29uc3QgdGltZU9mZnNldE1wZWdUUyA9IHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBpbml0VGltZSA9IGluaXRQVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBjb250aWd1b3VzID0gY29udGlndW91cyB8fCBpbnB1dFNhbXBsZXMubGVuZ3RoICYmIG5leHRBdWRpb1B0cyA+IDAgJiYgKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0TXBlZ1RTIC0gbmV4dEF1ZGlvUHRzKSA8IDkwMDAgfHwgTWF0aC5hYnMobm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5wdHMgLSBpbml0VGltZSwgdGltZU9mZnNldE1wZWdUUykgLSBuZXh0QXVkaW9QdHMpIDwgMjAgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcblxuICAgIC8vIGNvbXB1dGUgbm9ybWFsaXplZCBQVFNcbiAgICBpbnB1dFNhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0VGltZSwgdGltZU9mZnNldE1wZWdUUyk7XG4gICAgfSk7XG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdWRpb1B0cyA8IDApIHtcbiAgICAgIC8vIGZpbHRlciBvdXQgc2FtcGxlIHdpdGggbmVnYXRpdmUgUFRTIHRoYXQgYXJlIG5vdCBwbGF5YWJsZSBhbnl3YXlcbiAgICAgIC8vIGlmIHdlIGRvbid0IHJlbW92ZSB0aGVzZSBuZWdhdGl2ZSBzYW1wbGVzLCB0aGV5IHdpbGwgc2hpZnQgYWxsIGF1ZGlvIHNhbXBsZXMgZm9yd2FyZC5cbiAgICAgIC8vIGxlYWRpbmcgdG8gYXVkaW8gb3ZlcmxhcCBiZXR3ZWVuIGN1cnJlbnQgLyBuZXh0IGZyYWdtZW50XG4gICAgICBpbnB1dFNhbXBsZXMgPSBpbnB1dFNhbXBsZXMuZmlsdGVyKHNhbXBsZSA9PiBzYW1wbGUucHRzID49IDApO1xuXG4gICAgICAvLyBpbiBjYXNlIGFsbCBzYW1wbGVzIGhhdmUgbmVnYXRpdmUgUFRTLCBhbmQgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dCwgcmV0dXJuIG5vd1xuICAgICAgaWYgKCFpbnB1dFNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2aWRlb1RpbWVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgLy8gU2V0IHRoZSBzdGFydCB0byAwIHRvIG1hdGNoIHZpZGVvIHNvIHRoYXQgc3RhcnQgZ2FwcyBsYXJnZXIgdGhhbiBpbnB1dFNhbXBsZUR1cmF0aW9uIGFyZSBmaWxsZWQgd2l0aCBzaWxlbmNlXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGFjY3VyYXRlVGltZU9mZnNldCAmJiAhYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAvLyBXaGVuIG5vdCBzZWVraW5nLCBub3QgbGl2ZSwgYW5kIExldmVsRGV0YWlscy5QVFNLbm93biwgdXNlIGZyYWdtZW50IHN0YXJ0IGFzIHByZWRpY3RlZCBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9QdHMgPSBNYXRoLm1heCgwLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGZyYWdzIGFyZSBub3QgY29udGlndW91cyBhbmQgaWYgd2UgY2FudCB0cnVzdCB0aW1lIG9mZnNldCwgbGV0J3MgdXNlIGZpcnN0IHNhbXBsZSBQVFMgYXMgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gaW5wdXRTYW1wbGVzWzBdLnB0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYXVkaW8gdHJhY2sgaXMgbWlzc2luZyBzYW1wbGVzLCB0aGUgZnJhbWVzIHNlZW0gdG8gZ2V0IFwibGVmdC1zaGlmdGVkXCIgd2l0aGluIHRoZVxuICAgIC8vIHJlc3VsdGluZyBtcDQgc2VnbWVudCwgY2F1c2luZyBzeW5jIGlzc3VlcyBhbmQgbGVhdmluZyBnYXBzIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIHNlZ21lbnQuXG4gICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxuICAgIC8vIFdoZW4gcG9zc2libGUsIHdlIGluamVjdCBhIHNpbGVudCBmcmFtZTsgd2hlbiB0aGF0J3Mgbm90IHBvc3NpYmxlLCB3ZSBkdXBsaWNhdGUgdGhlIGxhc3RcbiAgICAvLyBmcmFtZS5cblxuICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICBjb25zdCBtYXhBdWRpb0ZyYW1lc0RyaWZ0ID0gdGhpcy5jb25maWcubWF4QXVkaW9GcmFtZXNEcmlmdDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBuZXh0UHRzID0gbmV4dEF1ZGlvUHRzOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxuICAgICAgICBjb25zdCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICAgIGNvbnN0IHB0cyA9IHNhbXBsZS5wdHM7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gcHRzIC0gbmV4dFB0cztcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLmFicygxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSk7XG5cbiAgICAgICAgLy8gV2hlbiByZW11eGluZyB3aXRoIHZpZGVvLCBpZiB3ZSdyZSBvdmVybGFwcGluZyBieSBtb3JlIHRoYW4gYSBkdXJhdGlvbiwgZHJvcCB0aGlzIHNhbXBsZSB0byBzdGF5IGluIHN5bmNcbiAgICAgICAgaWYgKGRlbHRhIDw9IC1tYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJiBhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBBdWRpbyBmcmFtZSBAICR7KHB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMgb3ZlcmxhcHMgbmV4dEF1ZGlvUHRzIGJ5ICR7TWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSl9IG1zLmApO1xuICAgICAgICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBuZXh0UHRzID0gcHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG5cbiAgICAgICAgLy8gSW5zZXJ0IG1pc3NpbmcgZnJhbWVzIGlmOlxuICAgICAgICAvLyAxOiBXZSdyZSBtb3JlIHRoYW4gbWF4QXVkaW9GcmFtZXNEcmlmdCBmcmFtZSBhd2F5XG4gICAgICAgIC8vIDI6IE5vdCBtb3JlIHRoYW4gTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiBhd2F5XG4gICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXG4gICAgICAgIC8vIDQ6IHJlbXV4aW5nIHdpdGggdmlkZW8gKHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA+PSBtYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJiBkdXJhdGlvbiA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gJiYgYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAgIGxldCBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgIC8vIEFkanVzdCBuZXh0UHRzIHNvIHRoYXQgc2lsZW50IHNhbXBsZXMgYXJlIGFsaWduZWQgd2l0aCBtZWRpYSBwdHMuIFRoaXMgd2lsbCBwcmV2ZW50IG1lZGlhIHNhbXBsZXMgZnJvbVxuICAgICAgICAgIC8vIGxhdGVyIGJlaW5nIHNoaWZ0ZWQgaWYgbmV4dFB0cyBpcyBiYXNlZCBvbiB0aW1lT2Zmc2V0IGFuZCBkZWx0YSBpcyBub3QgYSBtdWx0aXBsZSBvZiBpbnB1dFNhbXBsZUR1cmF0aW9uLlxuICAgICAgICAgIG5leHRQdHMgPSBwdHMgLSBtaXNzaW5nICogaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBpZiAobmV4dFB0cyA8IDApIHtcbiAgICAgICAgICAgIG1pc3NpbmctLTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbmV4dFB0cztcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYFttcDQtcmVtdXhlcl06IEluamVjdGluZyAke21pc3Npbmd9IGF1ZGlvIGZyYW1lIEAgJHsobmV4dFB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMgZHVlIHRvICR7TWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSl9IG1zIGdhcC5gKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1pc3Npbmc7IGorKykge1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhbXAgPSBNYXRoLm1heChuZXh0UHRzLCAwKTtcbiAgICAgICAgICAgIGxldCBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IFVuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAwLCB7XG4gICAgICAgICAgICAgIHVuaXQ6IGZpbGxGcmFtZSxcbiAgICAgICAgICAgICAgcHRzOiBuZXdTdGFtcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNhbXBsZS5wdHMgPSBuZXh0UHRzO1xuICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmaXJzdFBUUyA9IG51bGw7XG4gICAgbGV0IGxhc3RQVFMgPSBudWxsO1xuICAgIGxldCBtZGF0O1xuICAgIGxldCBtZGF0U2l6ZSA9IDA7XG4gICAgbGV0IHNhbXBsZUxlbmd0aCA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgd2hpbGUgKHNhbXBsZUxlbmd0aC0tKSB7XG4gICAgICBtZGF0U2l6ZSArPSBpbnB1dFNhbXBsZXNbc2FtcGxlTGVuZ3RoXS51bml0LmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSAwLCBfbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDsgaiA8IF9uYlNhbXBsZXM7IGorKykge1xuICAgICAgY29uc3QgYXVkaW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbal07XG4gICAgICBjb25zdCB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgIGxldCBwdHMgPSBhdWRpb1NhbXBsZS5wdHM7XG4gICAgICBpZiAobGFzdFBUUyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCBzZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBzYW1wbGUgdG8gdGhlIFwicmVhbFwiIGR1cmF0aW9uOyB0aGUgUFRTIGRpZmYgd2l0aFxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICAgIGNvbnN0IHByZXZTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW2ogLSAxXTtcbiAgICAgICAgcHJldlNhbXBsZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoKHB0cyAtIGxhc3RQVFMpIC8gc2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICBwdHMgPSBuZXh0QXVkaW9QdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhdWRpb1NhbXBsZXNcbiAgICAgICAgZmlyc3RQVFMgPSBwdHM7XG4gICAgICAgIGlmIChtZGF0U2l6ZSA+IDApIHtcbiAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1kYXQgdHlwZSkgKi9cbiAgICAgICAgICBtZGF0U2l6ZSArPSBvZmZzZXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgICAgICAgIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0ICR7bWRhdFNpemV9YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmF3TVBFRykge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1kYXQuc2V0KHVuaXQsIG9mZnNldCk7XG4gICAgICBjb25zdCB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47XG4gICAgICAvLyBEZWZhdWx0IHRoZSBzYW1wbGUncyBkdXJhdGlvbiB0byB0aGUgY29tcHV0ZWQgbXA0U2FtcGxlRHVyYXRpb24sIHdoaWNoIHdpbGwgZWl0aGVyIGJlIDEwMjQgZm9yIEFBQyBvciAxMTUyIGZvciBNUEVHXG4gICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgMSBzYW1wbGUsIHRoaXMgd2lsbCBiZSB0aGUgZHVyYXRpb24uIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHRoZSBkdXJhdGlvblxuICAgICAgLy8gYmVjb21lcyB0aGUgUFRTIGRpZmYgd2l0aCB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobmV3IE1wNFNhbXBsZSh0cnVlLCBtcDRTYW1wbGVEdXJhdGlvbiwgdW5pdExlbiwgMCkpO1xuICAgICAgbGFzdFBUUyA9IHB0cztcbiAgICB9XG5cbiAgICAvLyBXZSBjb3VsZCBlbmQgdXAgd2l0aCBubyBhdWRpbyBzYW1wbGVzIGlmIGFsbCBpbnB1dCBzYW1wbGVzIHdlcmUgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJldmlvdXNseSByZW11eGVkIG9uZXNcbiAgICBjb25zdCBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcbiAgICBpZiAoIW5iU2FtcGxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSBuZXh0IGF1ZGlvIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG4gICAgY29uc3QgbGFzdFNhbXBsZSA9IG91dHB1dFNhbXBsZXNbb3V0cHV0U2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IGxhc3RQVFMgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGUuZHVyYXRpb247XG5cbiAgICAvLyBTZXQgdGhlIHRyYWNrIHNhbXBsZXMgZnJvbSBpbnB1dFNhbXBsZXMgdG8gb3V0cHV0U2FtcGxlcyBiZWZvcmUgcmVtdXhpbmdcbiAgICBjb25zdCBtb29mID0gcmF3TVBFRyA/IG5ldyBVaW50OEFycmF5KDApIDogTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3RQVFMgLyBzY2FsZUZhY3RvciwgX2V4dGVuZHMoe30sIHRyYWNrLCB7XG4gICAgICBzYW1wbGVzOiBvdXRwdXRTYW1wbGVzXG4gICAgfSkpO1xuXG4gICAgLy8gQ2xlYXIgdGhlIHRyYWNrIHNhbXBsZXMuIFRoaXMgYWxzbyBjbGVhcnMgdGhlIHNhbXBsZXMgYXJyYXkgaW4gdGhlIGRlbXV4ZXIsIHNpbmNlIHRoZSByZWZlcmVuY2UgaXMgc2hhcmVkXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gZmlyc3RQVFMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBlbmQgPSBuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCB0eXBlID0gJ2F1ZGlvJztcbiAgICBjb25zdCBhdWRpb0RhdGEgPSB7XG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IHN0YXJ0LFxuICAgICAgZW5kUFRTOiBlbmQsXG4gICAgICBzdGFydERUUzogc3RhcnQsXG4gICAgICBlbmREVFM6IGVuZCxcbiAgICAgIHR5cGUsXG4gICAgICBoYXNBdWRpbzogdHJ1ZSxcbiAgICAgIGhhc1ZpZGVvOiBmYWxzZSxcbiAgICAgIG5iOiBuYlNhbXBsZXNcbiAgICB9O1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIHJldHVybiBhdWRpb0RhdGE7XG4gIH1cbiAgcmVtdXhFbXB0eUF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpIHtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICBjb25zdCBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cztcbiAgICAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcbiAgICBjb25zdCBpbml0RFRTID0gdGhpcy5faW5pdERUUztcbiAgICBjb25zdCBpbml0OTBrSHogPSBpbml0RFRTLmJhc2VUaW1lICogOTAwMDAgLyBpbml0RFRTLnRpbWVzY2FsZTtcbiAgICBjb25zdCBzdGFydERUUyA9IChuZXh0QXVkaW9QdHMgIT09IG51bGwgPyBuZXh0QXVkaW9QdHMgOiB2aWRlb0RhdGEuc3RhcnREVFMgKiBpbnB1dFRpbWVTY2FsZSkgKyBpbml0OTBrSHo7XG4gICAgY29uc3QgZW5kRFRTID0gdmlkZW9EYXRhLmVuZERUUyAqIGlucHV0VGltZVNjYWxlICsgaW5pdDkwa0h6O1xuICAgIC8vIG9uZSBzYW1wbGUncyBkdXJhdGlvbiB2YWx1ZVxuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBzY2FsZUZhY3RvciAqIEFBQ19TQU1QTEVTX1BFUl9GUkFNRTtcbiAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXG4gICAgY29uc3QgbmJTYW1wbGVzID0gTWF0aC5jZWlsKChlbmREVFMgLSBzdGFydERUUykgLyBmcmFtZUR1cmF0aW9uKTtcbiAgICAvLyBzaWxlbnQgZnJhbWVcbiAgICBjb25zdCBzaWxlbnRGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgIGxvZ2dlci53YXJuKCdbbXA0LXJlbXV4ZXJdOiByZW11eCBlbXB0eSBBdWRpbycpO1xuICAgIC8vIENhbid0IHJlbXV4IGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgc2lsZW50IGZyYW1lLi4uXG4gICAgaWYgKCFzaWxlbnRGcmFtZSkge1xuICAgICAgbG9nZ2VyLnRyYWNlKCdbbXA0LXJlbXV4ZXJdOiBVbmFibGUgdG8gcmVtdXhFbXB0eUF1ZGlvIHNpbmNlIHdlIHdlcmUgdW5hYmxlIHRvIGdldCBhIHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2FtcGxlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgIHVuaXQ6IHNpbGVudEZyYW1lLFxuICAgICAgICBwdHM6IHN0YW1wLFxuICAgICAgICBkdHM6IHN0YW1wXG4gICAgICB9KTtcbiAgICB9XG4gICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgcmV0dXJuIHRoaXMucmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgZmFsc2UpO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVQdHModmFsdWUsIHJlZmVyZW5jZSkge1xuICBsZXQgb2Zmc2V0O1xuICBpZiAocmVmZXJlbmNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgIC8vIC0gMl4zM1xuICAgIG9mZnNldCA9IC04NTg5OTM0NTkyO1xuICB9IGVsc2Uge1xuICAgIC8vICsgMl4zM1xuICAgIG9mZnNldCA9IDg1ODk5MzQ1OTI7XG4gIH1cbiAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICBpZiBkaWZmIGJldHdlZW4gdmFsdWUgYW5kIHJlZmVyZW5jZSBpcyBiaWdnZXIgdGhhbiBoYWxmIG9mIHRoZSBhbXBsaXR1ZGUgKDJeMzIpIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgIHZhbHVlICs9IG9mZnNldDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBmaW5kS2V5ZnJhbWVJbmRleChzYW1wbGVzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzYW1wbGVzW2ldLmtleSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKHRyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTLCBpbml0RFRTKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3Qgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZSwgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICAgIHNhbXBsZS5kdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLmR0cyAtIGluaXREVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSAvIGluaXREVFMudGltZXNjYWxlLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gIH1cbiAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGVzXG4gIH07XG59XG5mdW5jdGlvbiBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyh0cmFjaywgdGltZU9mZnNldCwgaW5pdFBUUykge1xuICBjb25zdCBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRQVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gIH1cbiAgdHJhY2suc2FtcGxlcy5zb3J0KChhLCBiKSA9PiBhLnB0cyAtIGIucHRzKTtcbiAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGVzXG4gIH07XG59XG5jbGFzcyBNcDRTYW1wbGUge1xuICBjb25zdHJ1Y3Rvcihpc0tleWZyYW1lLCBkdXJhdGlvbiwgc2l6ZSwgY3RzKSB7XG4gICAgdGhpcy5zaXplID0gdm9pZCAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5jdHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mbGFncyA9IHZvaWQgMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmN0cyA9IGN0cztcbiAgICB0aGlzLmZsYWdzID0gbmV3IE1wNFNhbXBsZUZsYWdzKGlzS2V5ZnJhbWUpO1xuICB9XG59XG5jbGFzcyBNcDRTYW1wbGVGbGFncyB7XG4gIGNvbnN0cnVjdG9yKGlzS2V5ZnJhbWUpIHtcbiAgICB0aGlzLmlzTGVhZGluZyA9IDA7XG4gICAgdGhpcy5pc0RlcGVuZGVkT24gPSAwO1xuICAgIHRoaXMuaGFzUmVkdW5kYW5jeSA9IDA7XG4gICAgdGhpcy5kZWdyYWRQcmlvID0gMDtcbiAgICB0aGlzLmRlcGVuZHNPbiA9IDE7XG4gICAgdGhpcy5pc05vblN5bmMgPSAxO1xuICAgIHRoaXMuZGVwZW5kc09uID0gaXNLZXlmcmFtZSA/IDIgOiAxO1xuICAgIHRoaXMuaXNOb25TeW5jID0gaXNLZXlmcmFtZSA/IDAgOiAxO1xuICB9XG59XG5cbmNsYXNzIFBhc3NUaHJvdWdoUmVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXREYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFBUUyA9IG51bGw7XG4gICAgdGhpcy5pbml0VHJhY2tzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7fVxuICByZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUykge1xuICAgIHRoaXMuaW5pdFBUUyA9IGRlZmF1bHRJbml0UFRTO1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICB9XG4gIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkZWNyeXB0ZGF0YSkge1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQocGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkpO1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gdHJ1ZTtcbiAgfVxuICBnZW5lcmF0ZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSB7XG4gICAgbGV0IHtcbiAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCEoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSkge1xuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbml0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG5cbiAgICAvLyBHZXQgY29kZWMgZnJvbSBpbml0U2VnbWVudCBvciBmYWxsYmFjayB0byBkZWZhdWx0XG4gICAgaWYgKCFhdWRpb0NvZGVjKSB7XG4gICAgICBhdWRpb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhpbml0RGF0YS5hdWRpbywgRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKTtcbiAgICB9XG4gICAgaWYgKCF2aWRlb0NvZGVjKSB7XG4gICAgICB2aWRlb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhpbml0RGF0YS52aWRlbywgRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tzID0ge307XG4gICAgaWYgKGluaXREYXRhLmF1ZGlvICYmIGluaXREYXRhLnZpZGVvKSB7XG4gICAgICB0cmFja3MuYXVkaW92aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMgKyAnLCcgKyB2aWRlb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdtYWluJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdhdWRpbydcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbidcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IGluaXRTZWdtZW50IGRvZXMgbm90IGNvbnRhaW4gbW9vdiBvciB0cmFrIGJveGVzLicpO1xuICAgIH1cbiAgICB0aGlzLmluaXRUcmFja3MgPSB0cmFja3M7XG4gIH1cbiAgcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgdmFyIF9pbml0RGF0YSwgX2luaXREYXRhMjtcbiAgICBsZXQge1xuICAgICAgaW5pdFBUUyxcbiAgICAgIGxhc3RFbmRUaW1lXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgYXVkaW86IHVuZGVmaW5lZCxcbiAgICAgIHZpZGVvOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB0ZXh0VHJhY2ssXG4gICAgICBpZDM6IGlkM1RyYWNrLFxuICAgICAgaW5pdFNlZ21lbnQ6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IHlldCBzZXQgYSBsYXN0RW5kRFRTLCBvciBpdCB3YXMgcmVzZXQsIHNldCBpdCB0byB0aGUgcHJvdmlkZWQgdGltZU9mZnNldC4gV2Ugd2FudCB0byB1c2UgdGhlXG4gICAgLy8gbGFzdEVuZERUUyBvdmVyIHRpbWVPZmZzZXQgd2hlbmV2ZXIgcG9zc2libGU7IGR1cmluZyBwcm9ncmVzc2l2ZSBwbGF5YmFjaywgdGhlIG1lZGlhIHNvdXJjZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAvLyB0aGUgbWVkaWEgZHVyYXRpb24gKHdoaWNoIGlzIHdoYXQgdGltZU9mZnNldCBpcyBwcm92aWRlZCBhcykgYmVmb3JlIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgbmV4dCBjaHVuay5cbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGxhc3RFbmRUaW1lKSkge1xuICAgICAgbGFzdEVuZFRpbWUgPSB0aGlzLmxhc3RFbmRUaW1lID0gdGltZU9mZnNldCB8fCAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBiaW5hcnkgc2VnbWVudCBkYXRhIGlzIGFkZGVkIHRvIHRoZSB2aWRlb1RyYWNrIGluIHRoZSBtcDRkZW11eGVyLiBXZSBkb24ndCBjaGVjayB0byBzZWUgaWYgdGhlIGRhdGEgaXMgb25seVxuICAgIC8vIGF1ZGlvIG9yIHZpZGVvIChvciBib3RoKTsgYWRkaW5nIGl0IHRvIHZpZGVvIHdhcyBhbiBhcmJpdHJhcnkgY2hvaWNlLlxuICAgIGNvbnN0IGRhdGEgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgaWYgKCEoZGF0YSAhPSBudWxsICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgaW5pdFNlZ21lbnQgPSB7XG4gICAgICBpbml0UFRTOiB1bmRlZmluZWQsXG4gICAgICB0aW1lc2NhbGU6IDFcbiAgICB9O1xuICAgIGxldCBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgaWYgKCEoKF9pbml0RGF0YSA9IGluaXREYXRhKSAhPSBudWxsICYmIF9pbml0RGF0YS5sZW5ndGgpKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoZGF0YSk7XG4gICAgICBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgfVxuICAgIGlmICghKChfaW5pdERhdGEyID0gaW5pdERhdGEpICE9IG51bGwgJiYgX2luaXREYXRhMi5sZW5ndGgpKSB7XG4gICAgICAvLyBXZSBjYW4ndCByZW11eCBpZiB0aGUgaW5pdFNlZ21lbnQgY291bGQgbm90IGJlIGdlbmVyYXRlZFxuICAgICAgbG9nZ2VyLndhcm4oJ1twYXNzdGhyb3VnaC1yZW11eGVyLnRzXTogRmFpbGVkIHRvIGdlbmVyYXRlIGluaXRTZWdtZW50LicpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZW1pdEluaXRTZWdtZW50KSB7XG4gICAgICBpbml0U2VnbWVudC50cmFja3MgPSB0aGlzLmluaXRUcmFja3M7XG4gICAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9IGdldER1cmF0aW9uKGRhdGEsIGluaXREYXRhKTtcbiAgICBjb25zdCBzdGFydERUUyA9IGdldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhKTtcbiAgICBjb25zdCBkZWNvZGVUaW1lID0gc3RhcnREVFMgPT09IG51bGwgPyB0aW1lT2Zmc2V0IDogc3RhcnREVFM7XG4gICAgaWYgKGlzSW52YWxpZEluaXRQdHMoaW5pdFBUUywgZGVjb2RlVGltZSwgdGltZU9mZnNldCwgZHVyYXRpb24pIHx8IGluaXRTZWdtZW50LnRpbWVzY2FsZSAhPT0gaW5pdFBUUy50aW1lc2NhbGUgJiYgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICBpbml0U2VnbWVudC5pbml0UFRTID0gZGVjb2RlVGltZSAtIHRpbWVPZmZzZXQ7XG4gICAgICBpZiAoaW5pdFBUUyAmJiBpbml0UFRTLnRpbWVzY2FsZSA9PT0gMSkge1xuICAgICAgICBsb2dnZXIud2FybihgQWRqdXN0aW5nIGluaXRQVFMgYnkgJHtpbml0U2VnbWVudC5pbml0UFRTIC0gaW5pdFBUUy5iYXNlVGltZX1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFMgPSB7XG4gICAgICAgIGJhc2VUaW1lOiBpbml0U2VnbWVudC5pbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGU6IDFcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGF1ZGlvVHJhY2sgPyBkZWNvZGVUaW1lIC0gaW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlIDogbGFzdEVuZFRpbWU7XG4gICAgY29uc3QgZW5kVGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuICAgIG9mZnNldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhLCBpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGUpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgIHRoaXMubGFzdEVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybignRHVyYXRpb24gcGFyc2VkIGZyb20gbXA0IHNob3VsZCBiZSBncmVhdGVyIHRoYW4gemVybycpO1xuICAgICAgdGhpcy5yZXNldE5leHRUaW1lc3RhbXAoKTtcbiAgICB9XG4gICAgY29uc3QgaGFzQXVkaW8gPSAhIWluaXREYXRhLmF1ZGlvO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gISFpbml0RGF0YS52aWRlbztcbiAgICBsZXQgdHlwZSA9ICcnO1xuICAgIGlmIChoYXNBdWRpbykge1xuICAgICAgdHlwZSArPSAnYXVkaW8nO1xuICAgIH1cbiAgICBpZiAoaGFzVmlkZW8pIHtcbiAgICAgIHR5cGUgKz0gJ3ZpZGVvJztcbiAgICB9XG4gICAgY29uc3QgdHJhY2sgPSB7XG4gICAgICBkYXRhMTogZGF0YSxcbiAgICAgIHN0YXJ0UFRTOiBzdGFydFRpbWUsXG4gICAgICBzdGFydERUUzogc3RhcnRUaW1lLFxuICAgICAgZW5kUFRTOiBlbmRUaW1lLFxuICAgICAgZW5kRFRTOiBlbmRUaW1lLFxuICAgICAgdHlwZSxcbiAgICAgIGhhc0F1ZGlvLFxuICAgICAgaGFzVmlkZW8sXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICAgIHJlc3VsdC5hdWRpbyA9IHRyYWNrLnR5cGUgPT09ICdhdWRpbycgPyB0cmFjayA6IHVuZGVmaW5lZDtcbiAgICByZXN1bHQudmlkZW8gPSB0cmFjay50eXBlICE9PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LmluaXRTZWdtZW50ID0gaW5pdFNlZ21lbnQ7XG4gICAgcmVzdWx0LmlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTLCBpbml0UFRTKTtcbiAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQudGV4dCA9IGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRleHRUcmFjaywgdGltZU9mZnNldCwgaW5pdFBUUyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzSW52YWxpZEluaXRQdHMoaW5pdFBUUywgc3RhcnREVFMsIHRpbWVPZmZzZXQsIGR1cmF0aW9uKSB7XG4gIGlmIChpbml0UFRTID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSW5pdFBUUyBpcyBpbnZhbGlkIHdoZW4gZGlzdGFuY2UgZnJvbSBwcm9ncmFtIHdvdWxkIGJlIG1vcmUgdGhhbiBzZWdtZW50IGR1cmF0aW9uIG9yIGEgbWluaW11bSBvZiBvbmUgc2Vjb25kXG4gIGNvbnN0IG1pbkR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIDEpO1xuICBjb25zdCBzdGFydFRpbWUgPSBzdGFydERUUyAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgcmV0dXJuIE1hdGguYWJzKHN0YXJ0VGltZSAtIHRpbWVPZmZzZXQpID4gbWluRHVyYXRpb247XG59XG5mdW5jdGlvbiBnZXRQYXJzZWRUcmFja0NvZGVjKHRyYWNrLCB0eXBlKSB7XG4gIGNvbnN0IHBhcnNlZENvZGVjID0gdHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrLmNvZGVjO1xuICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMubGVuZ3RoID4gNCkge1xuICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgfVxuICAvLyBTaW5jZSBtcDQtdG9vbHMgY2Fubm90IHBhcnNlIGZ1bGwgY29kZWMgc3RyaW5nIChzZWUgJ1RPRE86IFBhcnNlIGNvZGVjIGRldGFpbHMnLi4uIGluIG1wNC10b29scylcbiAgLy8gUHJvdmlkZSBkZWZhdWx0cyBiYXNlZCBvbiBjb2RlYyB0eXBlXG4gIC8vIFRoaXMgYWxsb3dzIGZvciBzb21lIHBsYXliYWNrIG9mIHNvbWUgZm1wNCBwbGF5bGlzdHMgd2l0aG91dCBDT0RFQ1MgZGVmaW5lZCBpbiBtYW5pZmVzdFxuICBpZiAocGFyc2VkQ29kZWMgPT09ICdodmMxJyB8fCBwYXJzZWRDb2RlYyA9PT0gJ2hldjEnKSB7XG4gICAgcmV0dXJuICdodmMxLjEuNi5MMTIwLjkwJztcbiAgfVxuICBpZiAocGFyc2VkQ29kZWMgPT09ICdhdjAxJykge1xuICAgIHJldHVybiAnYXYwMS4wLjA0TS4wOCc7XG4gIH1cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnYXZjMScgfHwgdHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgcmV0dXJuICdhdmMxLjQyZTAxZSc7XG4gIH1cbiAgcmV0dXJuICdtcDRhLjQwLjUnO1xufVxuXG5sZXQgbm93O1xuLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG50cnkge1xuICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xufSBjYXRjaCAoZXJyKSB7XG4gIGxvZ2dlci5kZWJ1ZygnVW5hYmxlIHRvIHVzZSBQZXJmb3JtYW5jZSBBUEkgb24gdGhpcyBlbnZpcm9ubWVudCcpO1xuICBub3cgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5EYXRlLm5vdztcbn1cbmNvbnN0IG11eENvbmZpZyA9IFt7XG4gIGRlbXV4OiBNUDREZW11eGVyLFxuICByZW11eDogUGFzc1Rocm91Z2hSZW11eGVyXG59LCB7XG4gIGRlbXV4OiBUU0RlbXV4ZXIsXG4gIHJlbXV4OiBNUDRSZW11eGVyXG59LCB7XG4gIGRlbXV4OiBBQUNEZW11eGVyLFxuICByZW11eDogTVA0UmVtdXhlclxufSwge1xuICBkZW11eDogTVAzRGVtdXhlcixcbiAgcmVtdXg6IE1QNFJlbXV4ZXJcbn1dO1xuY2xhc3MgVHJhbnNtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQpIHtcbiAgICB0aGlzLmFzeW5jID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy52ZW5kb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlbXV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW11eGVyID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMucHJvYmUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy50cmFuc211eENvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgfVxuICBjb25maWd1cmUodHJhbnNtdXhDb25maWcpIHtcbiAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdHJhbnNtdXhDb25maWc7XG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5yZXNldCgpO1xuICAgIH1cbiAgfVxuICBwdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBjaHVua01ldGEsIHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgbGV0IHVpbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICB0cmFuc211eENvbmZpZ1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb250aWd1b3VzLFxuICAgICAgZGlzY29udGludWl0eSxcbiAgICAgIHRyYWNrU3dpdGNoLFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGluaXRTZWdtZW50Q2hhbmdlXG4gICAgfSA9IHN0YXRlIHx8IGN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjLFxuICAgICAgZGVmYXVsdEluaXRQdHMsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGluaXRTZWdtZW50RGF0YVxuICAgIH0gPSB0cmFuc211eENvbmZpZztcbiAgICBjb25zdCBrZXlEYXRhID0gZ2V0RW5jcnlwdGlvblR5cGUodWludERhdGEsIGRlY3J5cHRkYXRhKTtcbiAgICBpZiAoa2V5RGF0YSAmJiBrZXlEYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICBjb25zdCBkZWNyeXB0ZXIgPSB0aGlzLmdldERlY3J5cHRlcigpO1xuICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBzeW5jaHJvbm91czsgd2ViQ3J5cHRvIGlzIG5vdFxuICAgICAgaWYgKGRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHByb2dyZXNzaXZlLiBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIG1heSBub3QgcmV0dXJuIGEgcmVzdWx0IG9uIGVhY2ggY2FsbC4gQW55IGNhY2hlZFxuICAgICAgICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICAgICAgICBsZXQgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5zb2Z0d2FyZURlY3J5cHQodWludERhdGEsIGtleURhdGEua2V5LmJ1ZmZlciwga2V5RGF0YS5pdi5idWZmZXIpO1xuICAgICAgICAvLyBGb3IgTG93LUxhdGVuY3kgSExTIFBhcnRzLCBkZWNyeXB0IGluIHBsYWNlLCBzaW5jZSBwYXJ0IHBhcnNpbmcgaXMgZXhwZWN0ZWQgb24gcHVzaCBwcm9ncmVzc1xuICAgICAgICBjb25zdCBsb2FkaW5nUGFydHMgPSBjaHVua01ldGEucGFydCA+IC0xO1xuICAgICAgICBpZiAobG9hZGluZ1BhcnRzKSB7XG4gICAgICAgICAgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IGRlY3J5cHRlci53ZWJDcnlwdG9EZWNyeXB0KHVpbnREYXRhLCBrZXlEYXRhLmtleS5idWZmZXIsIGtleURhdGEuaXYuYnVmZmVyKS50aGVuKGRlY3J5cHRlZERhdGEgPT4ge1xuICAgICAgICAgIC8vIENhbGxpbmcgcHVzaCBoZXJlIGlzIGltcG9ydGFudDsgaWYgZmx1c2goKSBpcyBjYWxsZWQgd2hpbGUgdGhpcyBpcyBzdGlsbCByZXNvbHZpbmcsIHRoaXMgZW5zdXJlcyB0aGF0XG4gICAgICAgICAgLy8gdGhlIGRlY3J5cHRlZCBkYXRhIGhhcyBiZWVuIHRyYW5zbXV4ZWRcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnB1c2goZGVjcnlwdGVkRGF0YSwgbnVsbCwgY2h1bmtNZXRhKTtcbiAgICAgICAgICB0aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGlvblByb21pc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc2V0TXV4ZXJzID0gdGhpcy5uZWVkc1Byb2JpbmcoZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpO1xuICAgIGlmIChyZXNldE11eGVycykge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIodWludERhdGEpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBbdHJhbnNtdXhlcl0gJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2ggfHwgaW5pdFNlZ21lbnRDaGFuZ2UgfHwgcmVzZXRNdXhlcnMpIHtcbiAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uLCBkZWNyeXB0ZGF0YSk7XG4gICAgfVxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlIHx8IHJlc2V0TXV4ZXJzKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgfVxuICAgIGlmICghY29udGlndW91cykge1xuICAgICAgdGhpcy5yZXNldENvbnRpZ3VpdHkoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cmFuc211eCh1aW50RGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgY3VycmVudFN0YXRlLmNvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIGN1cnJlbnRTdGF0ZS5kaXNjb250aW51aXR5ID0gZmFsc2U7XG4gICAgY3VycmVudFN0YXRlLnRyYWNrU3dpdGNoID0gZmFsc2U7XG4gICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBEdWUgdG8gZGF0YSBjYWNoaW5nLCBmbHVzaCBjYWxscyBjYW4gcHJvZHVjZSBtb3JlIHRoYW4gb25lIFRyYW5zbXV4ZXJSZXN1bHQgKGhlbmNlIHRoZSBBcnJheSB0eXBlKVxuICBmbHVzaChjaHVua01ldGEpIHtcbiAgICBjb25zdCBzdGF0cyA9IGNodW5rTWV0YS50cmFuc211eGluZztcbiAgICBzdGF0cy5leGVjdXRlU3RhcnQgPSBub3coKTtcbiAgICBjb25zdCB7XG4gICAgICBkZWNyeXB0ZXIsXG4gICAgICBjdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgIGRlY3J5cHRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGRlY3J5cHRpb25Qcm9taXNlKSB7XG4gICAgICAvLyBVcG9uIHJlc29sdXRpb24sIHRoZSBkZWNyeXB0aW9uIHByb21pc2UgY2FsbHMgcHVzaCgpIGFuZCByZXR1cm5zIGl0cyBUcmFuc211eGVyUmVzdWx0IHVwIHRoZSBzdGFjay4gVGhlcmVmb3JlXG4gICAgICAvLyBvbmx5IGZsdXNoaW5nIGlzIHJlcXVpcmVkIGZvciBhc3luYyBkZWNyeXB0aW9uXG4gICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNtdXhSZXN1bHRzID0gW107XG4gICAgY29uc3Qge1xuICAgICAgdGltZU9mZnNldFxuICAgIH0gPSBjdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBpZiAoZGVjcnlwdGVyKSB7XG4gICAgICAvLyBUaGUgZGVjcnlwdGVyIG1heSBoYXZlIGRhdGEgY2FjaGVkLCB3aGljaCBuZWVkcyB0byBiZSBkZW11eGVkLiBJbiB0aGlzIGNhc2Ugd2UnbGwgaGF2ZSB0d28gVHJhbnNtdXhSZXN1bHRzXG4gICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGNhc2UgdGhhdCB3ZSByZWNlaXZlIG9ubHkgMSBwdXNoIGNhbGwgZm9yIGEgc2VnbWVudCAoZWl0aGVyIGZvciBub24tcHJvZ3Jlc3NpdmUgZG93bmxvYWRzLFxuICAgICAgLy8gb3IgZm9yIHByb2dyZXNzaXZlIGRvd25sb2FkcyB3aXRoIHNtYWxsIHNlZ21lbnRzKVxuICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5mbHVzaCgpO1xuICAgICAgaWYgKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgLy8gUHVzaCBhbHdheXMgcmV0dXJucyBhIFRyYW5zbXV4ZXJSZXN1bHQgaWYgZGVjcnlwdGRhdGEgaXMgbnVsbFxuICAgICAgICB0cmFuc211eFJlc3VsdHMucHVzaCh0aGlzLnB1c2goZGVjcnlwdGVkRGF0YSwgbnVsbCwgY2h1bmtNZXRhKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRlbXV4ZXIsXG4gICAgICByZW11eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICAvLyBJZiBwcm9iaW5nIGZhaWxlZCwgdGhlbiBIbHMuanMgaGFzIGJlZW4gZ2l2ZW4gY29udGVudCBpdHMgbm90IGFibGUgdG8gaGFuZGxlXG4gICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICByZXR1cm4gW2VtcHR5UmVzdWx0KGNodW5rTWV0YSldO1xuICAgIH1cbiAgICBjb25zdCBkZW11eFJlc3VsdE9yUHJvbWlzZSA9IGRlbXV4ZXIuZmx1c2godGltZU9mZnNldCk7XG4gICAgaWYgKGlzUHJvbWlzZShkZW11eFJlc3VsdE9yUHJvbWlzZSkpIHtcbiAgICAgIC8vIERlY3J5cHQgZmluYWwgU0FNUExFLUFFUyBzYW1wbGVzXG4gICAgICByZXR1cm4gZGVtdXhSZXN1bHRPclByb21pc2UudGhlbihkZW11eFJlc3VsdCA9PiB7XG4gICAgICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuICAgICAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0T3JQcm9taXNlLCBjaHVua01ldGEpO1xuICAgIHJldHVybiB0cmFuc211eFJlc3VsdHM7XG4gIH1cbiAgZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfSA9IGRlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHtcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRpbWVPZmZzZXRcbiAgICB9ID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBsb2dnZXIubG9nKGBbdHJhbnNtdXhlci50c106IEZsdXNoZWQgZnJhZ21lbnQgJHtjaHVua01ldGEuc259JHtjaHVua01ldGEucGFydCA+IC0xID8gJyBwOiAnICsgY2h1bmtNZXRhLnBhcnQgOiAnJ30gb2YgbGV2ZWwgJHtjaHVua01ldGEubGV2ZWx9YCk7XG4gICAgY29uc3QgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cnVlLCB0aGlzLmlkKTtcbiAgICB0cmFuc211eFJlc3VsdHMucHVzaCh7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YVxuICAgIH0pO1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5leGVjdXRlRW5kID0gbm93KCk7XG4gIH1cbiAgcmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVtdXhlcixcbiAgICAgIHJlbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgcmVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gIH1cbiAgcmVzZXRDb250aWd1aXR5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbXV4ZXIsXG4gICAgICByZW11eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbXV4ZXIucmVzZXRDb250aWd1aXR5KCk7XG4gICAgcmVtdXhlci5yZXNldE5leHRUaW1lc3RhbXAoKTtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbiwgZGVjcnlwdGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyLFxuICAgICAgcmVtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcbiAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkZWNyeXB0ZGF0YSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW11eGVyKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5yZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICB0cmFuc211eChkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc211eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2tcbiAgICB9ID0gdGhpcy5kZW11eGVyLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIGZhbHNlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpO1xuICAgIGNvbnN0IHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmFsc2UsIHRoaXMuaWQpO1xuICAgIHJldHVybiB7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YVxuICAgIH07XG4gIH1cbiAgdHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVtdXhlci5kZW11eFNhbXBsZUFlcyhkYXRhLCBkZWNyeXB0RGF0YSwgdGltZU9mZnNldCkudGhlbihkZW11eFJlc3VsdCA9PiB7XG4gICAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlci5yZW11eChkZW11eFJlc3VsdC5hdWRpb1RyYWNrLCBkZW11eFJlc3VsdC52aWRlb1RyYWNrLCBkZW11eFJlc3VsdC5pZDNUcmFjaywgZGVtdXhSZXN1bHQudGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZhbHNlLCB0aGlzLmlkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgICBjaHVua01ldGFcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uZmlndXJlVHJhbnNtdXhlcihkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgb2JzZXJ2ZXIsXG4gICAgICB0eXBlU3VwcG9ydGVkLFxuICAgICAgdmVuZG9yXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgIGxldCBtdXg7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG11eENvbmZpZ1tpXS5kZW11eC5wcm9iZShkYXRhKSkge1xuICAgICAgICBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11eCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgZGVtdXhlciBieSBwcm9iaW5nIGZyYWdtZW50IGRhdGEnKTtcbiAgICB9XG4gICAgLy8gc28gbGV0J3MgY2hlY2sgdGhhdCBjdXJyZW50IHJlbXV4ZXIgYW5kIGRlbXV4ZXIgYXJlIHN0aWxsIHZhbGlkXG4gICAgY29uc3QgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBjb25zdCByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuICAgIGNvbnN0IFJlbXV4ZXIgPSBtdXgucmVtdXg7XG4gICAgY29uc3QgRGVtdXhlciA9IG11eC5kZW11eDtcbiAgICBpZiAoIXJlbXV4ZXIgfHwgIShyZW11eGVyIGluc3RhbmNlb2YgUmVtdXhlcikpIHtcbiAgICAgIHRoaXMucmVtdXhlciA9IG5ldyBSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvcik7XG4gICAgfVxuICAgIGlmICghZGVtdXhlciB8fCAhKGRlbXV4ZXIgaW5zdGFuY2VvZiBEZW11eGVyKSkge1xuICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICB0aGlzLnByb2JlID0gRGVtdXhlci5wcm9iZTtcbiAgICB9XG4gIH1cbiAgbmVlZHNQcm9iaW5nKGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgb3IgdHJhY2sgc3dpdGNoXG4gICAgLy8gd2UgbWlnaHQgc3dpdGNoIGZyb20gY29udGVudCB0eXBlIChBQUMgY29udGFpbmVyIHRvIFRTIGNvbnRhaW5lciwgb3IgVFMgdG8gZm1wNCBmb3IgZXhhbXBsZSlcbiAgICByZXR1cm4gIXRoaXMuZGVtdXhlciB8fCAhdGhpcy5yZW11eGVyIHx8IGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2g7XG4gIH1cbiAgZ2V0RGVjcnlwdGVyKCkge1xuICAgIGxldCBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICBpZiAoIWRlY3J5cHRlcikge1xuICAgICAgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY3J5cHRlcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblR5cGUoZGF0YSwgZGVjcnlwdERhdGEpIHtcbiAgbGV0IGVuY3J5cHRpb25UeXBlID0gbnVsbDtcbiAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdERhdGEgIT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5rZXkgIT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5pdiAhPT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5tZXRob2QgIT0gbnVsbCkge1xuICAgIGVuY3J5cHRpb25UeXBlID0gZGVjcnlwdERhdGE7XG4gIH1cbiAgcmV0dXJuIGVuY3J5cHRpb25UeXBlO1xufVxuY29uc3QgZW1wdHlSZXN1bHQgPSBjaHVua01ldGEgPT4gKHtcbiAgcmVtdXhSZXN1bHQ6IHt9LFxuICBjaHVua01ldGFcbn0pO1xuZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgcmV0dXJuICd0aGVuJyBpbiBwICYmIHAudGhlbiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuY2xhc3MgVHJhbnNtdXhDb25maWcge1xuICBjb25zdHJ1Y3RvcihhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBpbml0U2VnbWVudERhdGEsIGR1cmF0aW9uLCBkZWZhdWx0SW5pdFB0cykge1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0U2VnbWVudERhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRJbml0UHRzID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLmluaXRTZWdtZW50RGF0YSA9IGluaXRTZWdtZW50RGF0YTtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdGhpcy5kZWZhdWx0SW5pdFB0cyA9IGRlZmF1bHRJbml0UHRzIHx8IG51bGw7XG4gIH1cbn1cbmNsYXNzIFRyYW5zbXV4U3RhdGUge1xuICBjb25zdHJ1Y3RvcihkaXNjb250aW51aXR5LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRyYWNrU3dpdGNoLCB0aW1lT2Zmc2V0LCBpbml0U2VnbWVudENoYW5nZSkge1xuICAgIHRoaXMuZGlzY29udGludWl0eSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2N1cmF0ZVRpbWVPZmZzZXQgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFja1N3aXRjaCA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0U2VnbWVudENoYW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRpc2NvbnRpbnVpdHkgPSBkaXNjb250aW51aXR5O1xuICAgIHRoaXMuY29udGlndW91cyA9IGNvbnRpZ3VvdXM7XG4gICAgdGhpcy5hY2N1cmF0ZVRpbWVPZmZzZXQgPSBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gICAgdGhpcy50cmFja1N3aXRjaCA9IHRyYWNrU3dpdGNoO1xuICAgIHRoaXMudGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgdGhpcy5pbml0U2VnbWVudENoYW5nZSA9IGluaXRTZWdtZW50Q2hhbmdlO1xuICB9XG59XG5cbnZhciBldmVudGVtaXR0ZXIzID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXHQgICwgcHJlZml4ID0gJ34nO1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuXHQgKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBFdmVudHMoKSB7fVxuXG5cdC8vXG5cdC8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG5cdC8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuXHQvLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuXHQvLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcblx0Ly8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG5cdC8vXG5cdGlmIChPYmplY3QuY3JlYXRlKSB7XG5cdCAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0ICAvL1xuXHQgIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG5cdCAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cblx0ICAvL1xuXHQgIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuXHQgIHRoaXMuZm4gPSBmbjtcblx0ICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXHQgIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cblx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuXHQgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0ICB9XG5cblx0ICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcblx0ICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuXHQgIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG5cdCAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcblx0ICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cblx0ICByZXR1cm4gZW1pdHRlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhciBldmVudCBieSBuYW1lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcblx0ICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuXHQgIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcblx0ICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuXHQgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcblx0ICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcblx0ICogbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG5cdCAgdmFyIG5hbWVzID0gW11cblx0ICAgICwgZXZlbnRzXG5cdCAgICAsIG5hbWU7XG5cblx0ICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuXHQgIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuXHQgICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuXHQgIH1cblxuXHQgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdCAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG5hbWVzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG5cdCAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cblx0ICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG5cdCAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuXHQgICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcblx0ICB9XG5cblx0ICByZXR1cm4gZWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG5cdCAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG5cdCAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuXHQgIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuXHQgIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG5cdCAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG5cdCAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG5cdCAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcblx0ICAgICwgYXJnc1xuXHQgICAgLCBpO1xuXG5cdCAgaWYgKGxpc3RlbmVycy5mbikge1xuXHQgICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cblx0ICAgIHN3aXRjaCAobGVuKSB7XG5cdCAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcblx0ICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcblx0ICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG5cdCAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcblx0ICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcblx0ICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHQgICAgfVxuXG5cdCAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuXHQgICAgICAsIGo7XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuXHQgICAgICBzd2l0Y2ggKGxlbikge1xuXHQgICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcblx0ICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuXHQgICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuXHQgICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcblx0ICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG5cdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcblx0ICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cblx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG5cdCAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cblx0ICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcblx0ICBpZiAoIWZuKSB7XG5cdCAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cblx0ICBpZiAobGlzdGVuZXJzLmZuKSB7XG5cdCAgICBpZiAoXG5cdCAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcblx0ICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuXHQgICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG5cdCAgICApIHtcblx0ICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoXG5cdCAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuXHQgICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcblx0ICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcblx0ICAgICAgKSB7XG5cdCAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICAvL1xuXHQgICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuXHQgICAgLy9cblx0ICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG5cdCAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG5cdCAgdmFyIGV2dDtcblxuXHQgIGlmIChldmVudCkge1xuXHQgICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblx0ICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG5cdCAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Ly9cblx0Ly8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cblx0Ly9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuXHQvL1xuXHQvLyBFeHBvc2UgdGhlIHByZWZpeC5cblx0Ly9cblx0RXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG5cdC8vXG5cdC8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG5cdC8vXG5cdEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cblx0Ly9cblx0Ly8gRXhwb3NlIHRoZSBtb2R1bGUuXG5cdC8vXG5cdHtcblx0ICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblx0fSBcbn0gKGV2ZW50ZW1pdHRlcjMpKTtcblxudmFyIGV2ZW50ZW1pdHRlcjNFeHBvcnRzID0gZXZlbnRlbWl0dGVyMy5leHBvcnRzO1xudmFyIEV2ZW50RW1pdHRlciA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhldmVudGVtaXR0ZXIzRXhwb3J0cyk7XG5cbmNvbnN0IE1lZGlhU291cmNlJDEgPSBnZXRNZWRpYVNvdXJjZSgpIHx8IHtcbiAgaXNUeXBlU3VwcG9ydGVkOiAoKSA9PiBmYWxzZVxufTtcbmNsYXNzIFRyYW5zbXV4ZXJJbnRlcmZhY2Uge1xuICBjb25zdHJ1Y3RvcihobHMsIGlkLCBvblRyYW5zbXV4Q29tcGxldGUsIG9uRmx1c2gpIHtcbiAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICB0aGlzLnBhcnQgPSBudWxsO1xuICAgIHRoaXMudXNlV29ya2VyID0gdm9pZCAwO1xuICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5vbndtc2cgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9uRmx1c2ggPSB2b2lkIDA7XG4gICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy51c2VXb3JrZXIgPSAhIWNvbmZpZy5lbmFibGVXb3JrZXI7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSBvblRyYW5zbXV4Q29tcGxldGU7XG4gICAgdGhpcy5vbkZsdXNoID0gb25GbHVzaDtcbiAgICBjb25zdCBmb3J3YXJkTWVzc2FnZSA9IChldiwgZGF0YSkgPT4ge1xuICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICBkYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICBkYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgIGlmIChldiA9PT0gRXZlbnRzLkVSUk9SKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBkYXRhLmVycm9yO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihldiwgZGF0YSk7XG4gICAgfTtcblxuICAgIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gICAgdGhpcy5vYnNlcnZlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLm9ic2VydmVyLm9uKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oRXZlbnRzLkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgY29uc3QgdHlwZVN1cHBvcnRlZCA9IHtcbiAgICAgIG1wNDogTWVkaWFTb3VyY2UkMS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UkMS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wZWcnKSxcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UkMS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKVxuICAgIH07XG4gICAgLy8gbmF2aWdhdG9yLnZlbmRvciBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZSBpbiBXZWIgV29ya2VyXG4gICAgLy8gcmVmZXIgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dvcmtlckdsb2JhbFNjb3BlL25hdmlnYXRvclxuICAgIGNvbnN0IHZlbmRvciA9IG5hdmlnYXRvci52ZW5kb3I7XG4gICAgaWYgKHRoaXMudXNlV29ya2VyICYmIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBjYW5DcmVhdGVXb3JrZXIgPSBjb25maWcud29ya2VyUGF0aCB8fCBoYXNVTURXb3JrZXIoKTtcbiAgICAgIGlmIChjYW5DcmVhdGVXb3JrZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoY29uZmlnLndvcmtlclBhdGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYGxvYWRpbmcgV2ViIFdvcmtlciAke2NvbmZpZy53b3JrZXJQYXRofSBmb3IgXCIke2lkfVwiYCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQgPSBsb2FkV29ya2VyKGNvbmZpZy53b3JrZXJQYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgaW5qZWN0aW5nIFdlYiBXb3JrZXIgZm9yIFwiJHtpZH1cImApO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gaW5qZWN0V29ya2VyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub253bXNnID0gZXYgPT4gdGhpcy5vbldvcmtlck1lc3NhZ2UoZXYpO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHdvcmtlclxuICAgICAgICAgIH0gPSB0aGlzLndvcmtlckNvbnRleHQ7XG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICAgICAgd29ya2VyLm9uZXJyb3IgPSBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHtldmVudC5tZXNzYWdlfSAgKCR7ZXZlbnQuZmlsZW5hbWV9OiR7ZXZlbnQubGluZW5vfSlgKTtcbiAgICAgICAgICAgIGNvbmZpZy5lbmFibGVXb3JrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBFcnJvciBpbiBcIiR7aWR9XCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lYCk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGV2ZW50OiAnZGVtdXhlcldvcmtlcicsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBjbWQ6ICdpbml0JyxcbiAgICAgICAgICAgIHR5cGVTdXBwb3J0ZWQ6IHR5cGVTdXBwb3J0ZWQsXG4gICAgICAgICAgICB2ZW5kb3I6IHZlbmRvcixcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGNvbmZpZzogSlNPTi5zdHJpbmdpZnkoY29uZmlnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3Igc2V0dGluZyB1cCBcIiR7aWR9XCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lYCwgZXJyKTtcbiAgICAgICAgICB0aGlzLnJlc2V0V29ya2VyKCk7XG4gICAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyID0gbmV3IFRyYW5zbXV4ZXIodGhpcy5vYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVyKHRoaXMub2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yLCBpZCk7XG4gIH1cbiAgcmVzZXRXb3JrZXIoKSB7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3b3JrZXIsXG4gICAgICAgIG9iamVjdFVSTFxuICAgICAgfSA9IHRoaXMud29ya2VyQ29udGV4dDtcbiAgICAgIGlmIChvYmplY3RVUkwpIHtcbiAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgIH1cbiAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgd29ya2VyLm9uZXJyb3IgPSBudWxsO1xuICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V29ya2VyKCk7XG4gICAgICB0aGlzLm9ud21zZyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuICBwdXNoKGRhdGEsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZnJhZywgcGFydCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBkZWZhdWx0SW5pdFBUUykge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudCwgX2xhc3RGcmFnJGluaXRTZWdtZW50O1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBwYXJ0ID8gcGFydC5zdGFydCA6IGZyYWcuc3RhcnQ7XG4gICAgLy8gVE9ETzogcHVzaCBcImNsZWFyLWxlYWRcIiBkZWNyeXB0IGRhdGEgZm9yIHVuZW5jcnlwdGVkIGZyYWdtZW50cyBpbiBzdHJlYW1zIHdpdGggZW5jcnlwdGVkIG9uZXNcbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG4gICAgY29uc3QgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpO1xuICAgIGNvbnN0IHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiBjaHVua01ldGEubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKTtcbiAgICBjb25zdCBzbkRpZmYgPSBsYXN0RnJhZyA/IGNodW5rTWV0YS5zbiAtIGxhc3RGcmFnLnNuIDogLTE7XG4gICAgY29uc3QgcGFydERpZmYgPSB0aGlzLnBhcnQgPyBjaHVua01ldGEucGFydCAtIHRoaXMucGFydC5pbmRleCA6IC0xO1xuICAgIGNvbnN0IHByb2dyZXNzaXZlID0gc25EaWZmID09PSAwICYmIGNodW5rTWV0YS5pZCA+IDEgJiYgY2h1bmtNZXRhLmlkID09PSAobGFzdEZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RGcmFnLnN0YXRzLmNodW5rQ291bnQpO1xuICAgIGNvbnN0IGNvbnRpZ3VvdXMgPSAhdHJhY2tTd2l0Y2ggJiYgKHNuRGlmZiA9PT0gMSB8fCBzbkRpZmYgPT09IDAgJiYgKHBhcnREaWZmID09PSAxIHx8IHByb2dyZXNzaXZlICYmIHBhcnREaWZmIDw9IDApKTtcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmICh0cmFja1N3aXRjaCB8fCBzbkRpZmYgfHwgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBmcmFnLnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgfVxuICAgIGlmIChwYXJ0ICYmIChwYXJ0RGlmZiB8fCAhY29udGlndW91cykpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgaW5pdFNlZ21lbnRDaGFuZ2UgPSAhKGxhc3RGcmFnICYmICgoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQudXJsKSA9PT0gKChfbGFzdEZyYWckaW5pdFNlZ21lbnQgPSBsYXN0RnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sYXN0RnJhZyRpbml0U2VnbWVudC51cmwpKTtcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBUcmFuc211eFN0YXRlKGRpc2NvbnRpbnVpdHksIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJhY2tTd2l0Y2gsIHRpbWVPZmZzZXQsIGluaXRTZWdtZW50Q2hhbmdlKTtcbiAgICBpZiAoIWNvbnRpZ3VvdXMgfHwgZGlzY29udGludWl0eSB8fCBpbml0U2VnbWVudENoYW5nZSkge1xuICAgICAgbG9nZ2VyLmxvZyhgW3RyYW5zbXV4ZXItaW50ZXJmYWNlLCAke2ZyYWcudHlwZX1dOiBTdGFydGluZyBuZXcgdHJhbnNtdXggc2Vzc2lvbiBmb3Igc246ICR7Y2h1bmtNZXRhLnNufSBwOiAke2NodW5rTWV0YS5wYXJ0fSBsZXZlbDogJHtjaHVua01ldGEubGV2ZWx9IGlkOiAke2NodW5rTWV0YS5pZH1cbiAgICAgICAgZGlzY29udGludWl0eTogJHtkaXNjb250aW51aXR5fVxuICAgICAgICB0cmFja1N3aXRjaDogJHt0cmFja1N3aXRjaH1cbiAgICAgICAgY29udGlndW91czogJHtjb250aWd1b3VzfVxuICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6ICR7YWNjdXJhdGVUaW1lT2Zmc2V0fVxuICAgICAgICB0aW1lT2Zmc2V0OiAke3RpbWVPZmZzZXR9XG4gICAgICAgIGluaXRTZWdtZW50Q2hhbmdlOiAke2luaXRTZWdtZW50Q2hhbmdlfWApO1xuICAgICAgY29uc3QgY29uZmlnID0gbmV3IFRyYW5zbXV4Q29uZmlnKGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50RGF0YSwgZHVyYXRpb24sIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcihjb25maWcpO1xuICAgIH1cbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG5cbiAgICAvLyBGcmFncyB3aXRoIHNuIG9mICdpbml0U2VnbWVudCcgYXJlIG5vdCB0cmFuc211eGVkXG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgLy8gcG9zdCBmcmFnbWVudCBwYXlsb2FkIGFzIHRyYW5zZmVyYWJsZSBvYmplY3RzIGZvciBBcnJheUJ1ZmZlciAobm8gY29weSlcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdkZW11eCcsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAgICBjaHVua01ldGEsXG4gICAgICAgIHN0YXRlXG4gICAgICB9LCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBbZGF0YV0gOiBbXSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICBjb25zdCB0cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSk7XG4gICAgICBpZiAoaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICB0cmFuc211eGVyLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgdHJhbnNtdXhSZXN1bHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUoZGF0YSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCAndHJhbnNtdXhlci1pbnRlcmZhY2UgcHVzaCBlcnJvcicpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc211eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2ZsdXNoJyxcbiAgICAgICAgY2h1bmtNZXRhXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIGxldCB0cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgICAgIGNvbnN0IGFzeW5jRmx1c2ggPSBpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpO1xuICAgICAgaWYgKGFzeW5jRmx1c2ggfHwgdHJhbnNtdXhlci5hc3luYykge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgICB0cmFuc211eFJlc3VsdCA9IFByb21pc2UucmVzb2x2ZSh0cmFuc211eFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNtdXhSZXN1bHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KGRhdGEsIGNodW5rTWV0YSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCAndHJhbnNtdXhlci1pbnRlcmZhY2UgZmx1c2ggZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KHRyYW5zbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgcmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgY2h1bmtNZXRhLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnI6IGVycm9yLFxuICAgICAgcmVhc29uXG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlRmx1c2hSZXN1bHQocmVzdWx0cywgY2h1bmtNZXRhKSB7XG4gICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0KTtcbiAgICB9KTtcbiAgICB0aGlzLm9uRmx1c2goY2h1bmtNZXRhKTtcbiAgfVxuICBvbldvcmtlck1lc3NhZ2UoZXYpIHtcbiAgICBjb25zdCBkYXRhID0gZXYuZGF0YTtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF90aGlzJHdvcmtlckNvbnRleHQ7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0VVJMID0gKF90aGlzJHdvcmtlckNvbnRleHQgPSB0aGlzLndvcmtlckNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR3b3JrZXJDb250ZXh0Lm9iamVjdFVSTDtcbiAgICAgICAgICBpZiAob2JqZWN0VVJMKSB7XG4gICAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdHJhbnNtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3RyYW5zbXV4Q29tcGxldGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2ZsdXNoJzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMub25GbHVzaChkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIHBhc3MgbG9ncyBmcm9tIHRoZSB3b3JrZXIgdGhyZWFkIHRvIHRoZSBtYWluIGxvZ2dlclxuICAgICAgY2FzZSAnd29ya2VyTG9nJzpcbiAgICAgICAgaWYgKGxvZ2dlcltkYXRhLmRhdGEubG9nVHlwZV0pIHtcbiAgICAgICAgICBsb2dnZXJbZGF0YS5kYXRhLmxvZ1R5cGVdKGRhdGEuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdjb25maWd1cmUnLFxuICAgICAgICBjb25maWdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlci5jb25maWd1cmUoY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpIHtcbiAgICByZXN1bHQuY2h1bmtNZXRhLnRyYW5zbXV4aW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUocmVzdWx0KTtcbiAgfVxufVxuXG5jb25zdCBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TID0gMjUwO1xuY29uc3QgTUFYX1NUQVJUX0dBUF9KVU1QID0gMi4wO1xuY29uc3QgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMgPSAwLjE7XG5jb25zdCBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCA9IDAuMDU7XG5jbGFzcyBHYXBDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBtZWRpYSwgZnJhZ21lbnRUcmFja2VyLCBobHMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2Vla2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBsYXloZWFkIGlzIHN0dWNrIHdpdGhpbiBhIGdhcCwgYW5kIGlmIHNvLCBhdHRlbXB0cyB0byBmcmVlIGl0LlxuICAgKiBBIGdhcCBpcyBhbiB1bmJ1ZmZlcmVkIHJhbmdlIGJldHdlZW4gdHdvIGJ1ZmZlcmVkIHJhbmdlcyAob3IgdGhlIHN0YXJ0IGFuZCB0aGUgZmlyc3QgYnVmZmVyZWQgcmFuZ2UpLlxuICAgKlxuICAgKiBAcGFyYW0gbGFzdEN1cnJlbnRUaW1lIC0gUHJldmlvdXNseSByZWFkIHBsYXloZWFkIHBvc2l0aW9uXG4gICAqL1xuICBwb2xsKGxhc3RDdXJyZW50VGltZSwgYWN0aXZlRnJhZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1lZGlhLFxuICAgICAgc3RhbGxlZFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50VGltZSxcbiAgICAgIHNlZWtpbmdcbiAgICB9ID0gbWVkaWE7XG4gICAgY29uc3Qgc2Vla2VkID0gdGhpcy5zZWVraW5nICYmICFzZWVraW5nO1xuICAgIGNvbnN0IGJlZ2luU2VlayA9ICF0aGlzLnNlZWtpbmcgJiYgc2Vla2luZztcbiAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nO1xuXG4gICAgLy8gVGhlIHBsYXloZWFkIGlzIG1vdmluZywgbm8tb3BcbiAgICBpZiAoY3VycmVudFRpbWUgIT09IGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICBpZiAoc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgIGNvbnN0IF9zdGFsbGVkRHVyYXRpb24gPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhbGxlZDtcbiAgICAgICAgICBsb2dnZXIud2FybihgcGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQCR7Y3VycmVudFRpbWV9LCBhZnRlciAke01hdGgucm91bmQoX3N0YWxsZWREdXJhdGlvbil9bXNgKTtcbiAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFyIHN0YWxsZWQgc3RhdGUgd2hlbiBiZWdpbm5pbmcgb3IgZmluaXNoaW5nIHNlZWtpbmcgc28gdGhhdCB3ZSBkb24ndCByZXBvcnQgc3RhbGxzIGNvbWluZyBvdXQgb2YgYSBzZWVrXG4gICAgaWYgKGJlZ2luU2VlayB8fCBzZWVrZWQpIHtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIHBsYXloZWFkIHNob3VsZCBub3QgYmUgbW92aW5nXG4gICAgaWYgKG1lZGlhLnBhdXNlZCAmJiAhc2Vla2luZyB8fCBtZWRpYS5lbmRlZCB8fCBtZWRpYS5wbGF5YmFja1JhdGUgPT09IDAgfHwgIUJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBidWZmZXJJbmZvLmxlbiA+IDA7XG4gICAgY29uc3QgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgMDtcblxuICAgIC8vIFRoZXJlIGlzIG5vIHBsYXlhYmxlIGJ1ZmZlciAoc2Vla2VkLCB3YWl0aW5nIGZvciBidWZmZXIpXG4gICAgaWYgKCFpc0J1ZmZlcmVkICYmICFuZXh0U3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlZWtpbmcpIHtcbiAgICAgIC8vIFdhaXRpbmcgZm9yIHNlZWtpbmcgaW4gYSBidWZmZXJlZCByYW5nZSB0byBjb21wbGV0ZVxuICAgICAgY29uc3QgaGFzRW5vdWdoQnVmZmVyID0gYnVmZmVySW5mby5sZW4gPiBNQVhfU1RBUlRfR0FQX0pVTVA7XG4gICAgICAvLyBOZXh0IGJ1ZmZlcmVkIHJhbmdlIGlzIHRvbyBmYXIgYWhlYWQgdG8ganVtcCB0byB3aGlsZSBzdGlsbCBzZWVraW5nXG4gICAgICBjb25zdCBub0J1ZmZlckdhcCA9ICFuZXh0U3RhcnQgfHwgYWN0aXZlRnJhZyAmJiBhY3RpdmVGcmFnLnN0YXJ0IDw9IGN1cnJlbnRUaW1lIHx8IG5leHRTdGFydCAtIGN1cnJlbnRUaW1lID4gTUFYX1NUQVJUX0dBUF9KVU1QICYmICF0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGhhc0Vub3VnaEJ1ZmZlciB8fCBub0J1ZmZlckdhcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZXNldCBtb3ZlZCBzdGF0ZSB3aGVuIHNlZWtpbmcgdG8gYSBwb2ludCBpbiBvciBiZWZvcmUgYSBnYXBcbiAgICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIHN0YXJ0IGdhcHMgaWYgd2UgaGF2ZW4ndCBwbGF5ZWQsIGJ1dCB0aGUgbGFzdCBwb2xsIGRldGVjdGVkIHRoZSBzdGFydCBvZiBhIHN0YWxsXG4gICAgLy8gVGhlIGFkZGl0aW9uIHBvbGwgZ2l2ZXMgdGhlIGJyb3dzZXIgYSBjaGFuY2UgdG8ganVtcCB0aGUgZ2FwIGZvciB1c1xuICAgIGlmICghdGhpcy5tb3ZlZCAmJiB0aGlzLnN0YWxsZWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICAgIC8vIEp1bXAgc3RhcnQgZ2FwcyB3aXRoaW4ganVtcCB0aHJlc2hvbGRcbiAgICAgIGNvbnN0IHN0YXJ0SnVtcCA9IE1hdGgubWF4KG5leHRTdGFydCwgYnVmZmVySW5mby5zdGFydCB8fCAwKSAtIGN1cnJlbnRUaW1lO1xuXG4gICAgICAvLyBXaGVuIGpvaW5pbmcgYSBsaXZlIHN0cmVhbSB3aXRoIGF1ZGlvIHRyYWNrcywgYWNjb3VudCBmb3IgbGl2ZSBwbGF5bGlzdCB3aW5kb3cgc2xpZGluZyBieSBhbGxvd2luZ1xuICAgICAgLy8gYSBsYXJnZXIganVtcCBvdmVyIHN0YXJ0IGdhcHMgY2F1c2VkIGJ5IHRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBidWZmZXJpbmcgYSBzdGFydCBmcmFnbWVudFxuICAgICAgLy8gdGhhdCBiZWdpbnMgb3ZlciAxIHRhcmdldCBkdXJhdGlvbiBhZnRlciB0aGUgdmlkZW8gc3RhcnQgcG9zaXRpb24uXG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVscyA/IHRoaXMuaGxzLmxldmVsc1t0aGlzLmhscy5jdXJyZW50TGV2ZWxdIDogbnVsbDtcbiAgICAgIGNvbnN0IGlzTGl2ZSA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJGRldGFpbHMubGl2ZTtcbiAgICAgIGNvbnN0IG1heFN0YXJ0R2FwSnVtcCA9IGlzTGl2ZSA/IGxldmVsLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyIDogTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgY29uc3QgcGFydGlhbE9yR2FwID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChzdGFydEp1bXAgPiAwICYmIChzdGFydEp1bXAgPD0gbWF4U3RhcnRHYXBKdW1wIHx8IHBhcnRpYWxPckdhcCkpIHtcbiAgICAgICAgdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbE9yR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRyYWNraW5nIHN0YWxsIHRpbWVcbiAgICBjb25zdCB0bm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoc3RhbGxlZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhbGxlZER1cmF0aW9uID0gdG5vdyAtIHN0YWxsZWQ7XG4gICAgaWYgKCFzZWVraW5nICYmIHN0YWxsZWREdXJhdGlvbiA+PSBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxuICAgICAgdGhpcy5fcmVwb3J0U3RhbGwoYnVmZmVySW5mbyk7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBidWZmZXJlZFdpdGhIb2xlcyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlcmVkV2l0aEhvbGVzLCBzdGFsbGVkRHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdHMgYW5kIGF0dGVtcHRzIHRvIGZpeCBrbm93biBidWZmZXIgc3RhbGxpbmcgaXNzdWVzLlxuICAgKiBAcGFyYW0gYnVmZmVySW5mbyAtIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAgICogQHBhcmFtIHN0YWxsZWREdXJhdGlvbk1zIC0gVGhlIGFtb3VudCBvZiB0aW1lIEhscy5qcyBoYXMgYmVlbiBzdGFsbGluZyBmb3IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uTXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBmcmFnbWVudFRyYWNrZXIsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICBpZiAocGFydGlhbCkge1xuICAgICAgLy8gVHJ5IHRvIHNraXAgb3ZlciB0aGUgYnVmZmVyIGhvbGUgY2F1c2VkIGJ5IGEgcGFydGlhbCBmcmFnbWVudFxuICAgICAgLy8gVGhpcyBtZXRob2QgaXNuJ3QgbGltaXRlZCBieSB0aGUgc2l6ZSBvZiB0aGUgZ2FwIGJldHdlZW4gYnVmZmVyZWQgcmFuZ2VzXG4gICAgICBjb25zdCB0YXJnZXRUaW1lID0gdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCk7XG4gICAgICAvLyB3ZSByZXR1cm4gaGVyZSBpbiB0aGlzIGNhc2UsIG1lYW5pbmdcbiAgICAgIC8vIHRoZSBicmFuY2ggYmVsb3cgb25seSBleGVjdXRlcyB3aGVuIHdlIGhhdmVuJ3Qgc2Vla2VkIHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICBpZiAodGFyZ2V0VGltZSB8fCAhdGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZW4ndCBoYWQgdG8gc2tpcCBvdmVyIGEgYnVmZmVyIGhvbGUgb2YgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgLy8gd2UgbWF5IGp1c3QgaGF2ZSB0byBcIm51ZGdlXCIgdGhlIHBsYXlsaXN0IGFzIHRoZSBicm93c2VyIGRlY29kaW5nL3JlbmRlcmluZyBlbmdpbmVcbiAgICAvLyBuZWVkcyB0byBjcm9zcyBzb21lIHNvcnQgb2YgdGhyZXNob2xkIGNvdmVyaW5nIGFsbCBzb3VyY2UtYnVmZmVycyBjb250ZW50XG4gICAgLy8gdG8gc3RhcnQgcGxheWluZyBwcm9wZXJseS5cbiAgICBpZiAoKGJ1ZmZlckluZm8ubGVuID4gY29uZmlnLm1heEJ1ZmZlckhvbGUgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgLSBjdXJyZW50VGltZSA8IGNvbmZpZy5tYXhCdWZmZXJIb2xlKSAmJiBzdGFsbGVkRHVyYXRpb25NcyA+IGNvbmZpZy5oaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwKSB7XG4gICAgICBsb2dnZXIud2FybignVHJ5aW5nIHRvIG51ZGdlIHBsYXloZWFkIG92ZXIgYnVmZmVyLWhvbGUnKTtcbiAgICAgIC8vIFRyeSB0byBudWRnZSBjdXJyZW50VGltZSBvdmVyIGEgYnVmZmVyIGhvbGUgaWYgd2UndmUgYmVlbiBzdGFsbGluZyBmb3IgdGhlIGNvbmZpZ3VyZWQgYW1vdW50IG9mIHNlY29uZHNcbiAgICAgIC8vIFdlIG9ubHkgdHJ5IHRvIGp1bXAgdGhlIGhvbGUgaWYgaXQncyB1bmRlciB0aGUgY29uZmlndXJlZCBzaXplXG4gICAgICAvLyBSZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgdGhpcy5fdHJ5TnVkZ2VCdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBCVUZGRVJfU1RBTExFRF9FUlJPUiBldmVudCwgYnV0IG9ubHkgb25jZSBwZXIgc3RhbGwgcGVyaW9kLlxuICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXBvcnRTdGFsbChidWZmZXJJbmZvKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgbWVkaWEsXG4gICAgICBzdGFsbFJlcG9ydGVkXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkICYmIG1lZGlhKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFBsYXliYWNrIHN0YWxsaW5nIGF0IEAke21lZGlhLmN1cnJlbnRUaW1lfSBkdWUgdG8gbG93IGJ1ZmZlciAoJHtKU09OLnN0cmluZ2lmeShidWZmZXJJbmZvKX0pYCk7XG4gICAgICBsb2dnZXIud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVySW5mby5sZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICogQHBhcmFtIHBhcnRpYWwgLSBUaGUgcGFydGlhbCBmcmFnbWVudCBmb3VuZCBhdCB0aGUgY3VycmVudCB0aW1lICh3aGVyZSBwbGF5YmFjayBpcyBzdGFsbGluZykuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIGhscyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjdXJyZW50VGltZSBpcyBiZXR3ZWVuIHVuYnVmZmVyZWQgcmVnaW9ucyBvZiBwYXJ0aWFsIGZyYWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgPCBidWZmZXJJbmZvLnN0YXJ0ID8gYnVmZmVySW5mby5zdGFydCA6IGJ1ZmZlckluZm8ubmV4dFN0YXJ0O1xuICAgIGlmIChzdGFydFRpbWUpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ2ZWQgPSBidWZmZXJJbmZvLmxlbiA8PSBjb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgIGNvbnN0IHdhaXRpbmcgPSBidWZmZXJJbmZvLmxlbiA+IDAgJiYgYnVmZmVySW5mby5sZW4gPCAxICYmIG1lZGlhLnJlYWR5U3RhdGUgPCAzO1xuICAgICAgY29uc3QgZ2FwTGVuZ3RoID0gc3RhcnRUaW1lIC0gY3VycmVudFRpbWU7XG4gICAgICBpZiAoZ2FwTGVuZ3RoID4gMCAmJiAoYnVmZmVyU3RhcnZlZCB8fCB3YWl0aW5nKSkge1xuICAgICAgICAvLyBPbmx5IGFsbG93IGxhcmdlIGdhcHMgdG8gYmUgc2tpcHBlZCBpZiBpdCBpcyBhIHN0YXJ0IGdhcCwgb3IgYWxsIGZyYWdtZW50cyBpbiBza2lwIHJhbmdlIGFyZSBwYXJ0aWFsXG4gICAgICAgIGlmIChnYXBMZW5ndGggPiBjb25maWcubWF4QnVmZmVySG9sZSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZyYWdtZW50VHJhY2tlclxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGxldCBzdGFydEdhcCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjdXJyZW50VGltZSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRGcmFnID0gZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZygwLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgICAgIGlmIChzdGFydEZyYWcgJiYgc3RhcnRUaW1lIDwgc3RhcnRGcmFnLmVuZCkge1xuICAgICAgICAgICAgICBzdGFydEdhcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RhcnRHYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHJvdmlzaW9uZWQgPSBwYXJ0aWFsIHx8IGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UHJvdmlzaW9uZWQpIHtcbiAgICAgICAgICAgICAgbGV0IG1vcmVUb0xvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGV0IHBvcyA9IHN0YXJ0UHJvdmlzaW9uZWQuZW5kO1xuICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlzaW9uZWQgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3Zpc2lvbmVkKSB7XG4gICAgICAgICAgICAgICAgICBwb3MgKz0gcHJvdmlzaW9uZWQuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1vcmVUb0xvYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtb3JlVG9Mb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJULCBjdXJyZW50VGltZSArIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTKTtcbiAgICAgICAgbG9nZ2VyLndhcm4oYHNraXBwaW5nIGhvbGUsIGFkanVzdGluZyBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgICAgaWYgKHBhcnRpYWwgJiYgIXBhcnRpYWwuZ2FwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBmcmFnOiBwYXJ0aWFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGFkdmFuY2luZyB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lIGJ5IGEgc21hbGwgYW1vdW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeU51ZGdlQnVmZmVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIGhscyxcbiAgICAgIG1lZGlhLFxuICAgICAgbnVkZ2VSZXRyeVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHRoaXMubnVkZ2VSZXRyeSsrO1xuICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIChudWRnZVJldHJ5ICsgMSkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICAvLyBwbGF5YmFjayBzdGFsbGVkIGluIGJ1ZmZlcmVkIGFyZWEgLi4uIGxldCdzIG51ZGdlIGN1cnJlbnRUaW1lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTnVkZ2luZyAnY3VycmVudFRpbWUnIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHt0YXJnZXRUaW1lfWApO1xuICAgICAgbG9nZ2VyLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEAke2N1cnJlbnRUaW1lfSBhZnRlciAke2NvbmZpZy5udWRnZU1heFJldHJ5fSBudWRnZXNgKTtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwkMiA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuY2xhc3MgU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEJhc2VTdHJlYW1Db250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikge1xuICAgIHN1cGVyKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIsICdbc3RyZWFtLWNvbnRyb2xsZXJdJywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5sZXZlbCA9IC0xO1xuICAgIHRoaXMuX2ZvcmNlU3RhcnRMb2FkID0gZmFsc2U7XG4gICAgdGhpcy5hbHRBdWRpbyA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG4gICAgdGhpcy5vbnZwbGF5aW5nID0gbnVsbDtcbiAgICB0aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgdGhpcy5mcmFnTGFzdEticHMgPSAwO1xuICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSBmYWxzZTtcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGluZygpO1xuICB9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxhc3RDdXJyZW50VGltZSxcbiAgICAgICAgaGxzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQyKTtcbiAgICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGxvYWQgbGV2ZWxcbiAgICAgICAgbGV0IHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcbiAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKGhscy5jb25maWcudGVzdEJhbmR3aWR0aCAmJiB0aGlzLmxldmVscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSBobHMubmV4dEF1dG9MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXG4gICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuICAgICAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBzdGFydExldmVsO1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIHVuZGVmaW5lZCBidXQgbGFzdEN1cnJlbnRUaW1lIHNldCwgc2V0IHN0YXJ0UG9zaXRpb24gdG8gbGFzdCBjdXJyZW50VGltZVxuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5sb2coYE92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCR7bGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICBzdXBlci5zdG9wTG9hZCgpO1xuICB9XG4gIGRvVGljaygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19MRVZFTDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfbGV2ZWxzJGxldmVsO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICAgIGxldmVsXG4gICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgZGV0YWlscyA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogKF9sZXZlbHMkbGV2ZWwgPSBsZXZlbHNbbGV2ZWxdKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVscyRsZXZlbC5kZXRhaWxzO1xuICAgICAgICAgIGlmIChkZXRhaWxzICYmICghZGV0YWlscy5saXZlIHx8IHRoaXMubGV2ZWxMYXN0TG9hZGVkID09PSB0aGlzLmxldmVsKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhscy5uZXh0TG9hZExldmVsICE9PSB0aGlzLmxldmVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgICAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQodGhpcy5sZXZlbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICB9XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuICBvblRpY2tFbmQoKSB7XG4gICAgc3VwZXIub25UaWNrRW5kKCk7XG4gICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgIHRoaXMuY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuICBkb1RpY2tJZGxlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIGxldmVsTGFzdExvYWRlZCxcbiAgICAgIGxldmVscyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgbmV4dExvYWRMZXZlbDogbGV2ZWxcbiAgICB9ID0gaGxzO1xuXG4gICAgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgIGlmIChsZXZlbExhc3RMb2FkZWQgPT09IG51bGwgfHwgIW1lZGlhICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBcIm1haW5cIiBsZXZlbCBpcyBhdWRpby1vbmx5IGJ1dCB3ZSBhcmUgbG9hZGluZyBhbiBhbHRlcm5hdGUgdHJhY2sgaW4gdGhlIHNhbWUgZ3JvdXAsIGRvIG5vdCBsb2FkIGFueXRoaW5nXG4gICAgaWYgKHRoaXMuYWx0QXVkaW8gJiYgdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW2xldmVsXSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWxJbmZvID0gbGV2ZWxzW2xldmVsXTtcblxuICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0RGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgaWYgKGxhc3REZXRhaWxzICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIGxhc3REZXRhaWxzKSkge1xuICAgICAgY29uc3QgZGF0YSA9IHt9O1xuICAgICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgZGF0YS50eXBlID0gJ3ZpZGVvJztcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9FT1MsIGRhdGEpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgaWYgKGhscy5sb2FkTGV2ZWwgIT09IGxldmVsICYmIGhscy5tYW51YWxMZXZlbCA9PT0gLTEpIHtcbiAgICAgIHRoaXMubG9nKGBBZGFwdGluZyB0byBsZXZlbCAke2xldmVsfSBmcm9tIGxldmVsICR7dGhpcy5sZXZlbH1gKTtcbiAgICB9XG4gICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCB8fCBsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcblxuICAgIC8vIGNvbXB1dGUgbWF4IEJ1ZmZlciBMZW5ndGggdGhhdCB3ZSBjb3VsZCBnZXQgZnJvbSB0aGlzIGxvYWQgbGV2ZWwsIGJhc2VkIG9uIGxldmVsIGJpdHJhdGUuIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gNjAgTUIgYW5kIG1vcmUgdGhhbiAzMHNcbiAgICBjb25zdCBtYXhCdWZMZW4gPSB0aGlzLmdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEluZm8ubWF4Qml0cmF0ZSk7XG5cbiAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCAmJiB0aGlzLmJhY2t0cmFja0ZyYWdtZW50LnN0YXJ0ID4gYnVmZmVySW5mby5lbmQpIHtcbiAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRCdWZmZXJUaW1lID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA/IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQuc3RhcnQgOiBidWZmZXJJbmZvLmVuZDtcbiAgICBsZXQgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KHRhcmdldEJ1ZmZlclRpbWUsIGxldmVsRGV0YWlscyk7XG4gICAgLy8gQXZvaWQgYmFja3RyYWNraW5nIGJ5IGxvYWRpbmcgYW4gZWFybGllciBzZWdtZW50IGluIHN0cmVhbXMgd2l0aCBzZWdtZW50cyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGEga2V5IGZyYW1lIChmbGFnZ2VkIGJ5IGBjb3VsZEJhY2t0cmFja2ApXG4gICAgaWYgKHRoaXMuY291bGRCYWNrdHJhY2sgJiYgIXRoaXMuZnJhZ1ByZXZpb3VzICYmIGZyYWcgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50JyAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSAhPT0gRnJhZ21lbnRTdGF0ZS5PSykge1xuICAgICAgdmFyIF90aGlzJGJhY2t0cmFja0ZyYWdtZTtcbiAgICAgIGNvbnN0IGJhY2t0cmFja1NuID0gKChfdGhpcyRiYWNrdHJhY2tGcmFnbWUgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSAhPSBudWxsID8gX3RoaXMkYmFja3RyYWNrRnJhZ21lIDogZnJhZykuc247XG4gICAgICBjb25zdCBmcmFnSWR4ID0gYmFja3RyYWNrU24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIGNvbnN0IGJhY2t0cmFja0ZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2ZyYWdJZHggLSAxXTtcbiAgICAgIGlmIChiYWNrdHJhY2tGcmFnICYmIGZyYWcuY2MgPT09IGJhY2t0cmFja0ZyYWcuY2MpIHtcbiAgICAgICAgZnJhZyA9IGJhY2t0cmFja0ZyYWc7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGJhY2t0cmFja0ZyYWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCAmJiBidWZmZXJJbmZvLmxlbikge1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIEF2b2lkIGxvb3AgbG9hZGluZyBieSB1c2luZyBuZXh0TG9hZFBvc2l0aW9uIHNldCBmb3IgYmFja3RyYWNraW5nIGFuZCBza2lwcGluZyBjb25zZWN1dGl2ZSBHQVAgdGFnc1xuICAgIGlmIChmcmFnICYmIHRoaXMuaXNMb29wTG9hZGluZyhmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgY29uc3QgZ2FwU3RhcnQgPSBmcmFnLmdhcDtcbiAgICAgIGlmICghZ2FwU3RhcnQpIHtcbiAgICAgICAgLy8gQ2xlYW51cCB0aGUgZnJhZ21lbnQgdHJhY2tlciBiZWZvcmUgdHJ5aW5nIHRvIGZpbmQgdGhlIG5leHQgdW5idWZmZXJlZCBmcmFnbWVudFxuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW8gPyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU87XG4gICAgICAgIGNvbnN0IG1lZGlhQnVmZmVyID0gKHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyA/IHRoaXMudmlkZW9CdWZmZXIgOiB0aGlzLm1lZGlhQnVmZmVyKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWFCdWZmZXIpIHtcbiAgICAgICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGZyYWcsIGxldmVsRGV0YWlscywgYnVmZmVySW5mbywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgbWF4QnVmTGVuKTtcbiAgICB9XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmcmFnLmluaXRTZWdtZW50ICYmICFmcmFnLmluaXRTZWdtZW50LmRhdGEgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIGZyYWcgPSBmcmFnLmluaXRTZWdtZW50O1xuICAgIH1cbiAgICB0aGlzLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbEluZm8sIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9XG4gIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIC8vIENoZWNrIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgdGhpcy5sb2coYEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBpcyBiZWluZyBkb3dubG9hZGVkIHRvIHRlc3QgYml0cmF0ZSBhbmQgd2lsbCBub3QgYmUgYnVmZmVyZWRgKTtcbiAgICAgICAgdGhpcy5fbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnLCBsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHN1cGVyLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJUcmFja2VySWZOZWVkZWQoZnJhZyk7XG4gICAgfVxuICB9XG4gIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICB9XG4gIGZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnKSB7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhmcmFnLmVuZCArIDAuNSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLypcbiAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgLSBwYXVzZSBwbGF5YmFjayBpZiBwbGF5aW5nXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxuICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICovXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoKCkge1xuICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gIH1cblxuICAvKipcbiAgICogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2s6XG4gICAqIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcbiAgICogd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcbiAgICogd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICovXG4gIG5leHRMZXZlbFN3aXRjaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIC8vIGVuc3VyZSB0aGF0IG1lZGlhIGlzIGRlZmluZWQgYW5kIHRoYXQgbWV0YWRhdGEgYXJlIGF2YWlsYWJsZSAodG8gcmV0cmlldmUgY3VycmVudFRpbWUpXG4gICAgaWYgKG1lZGlhICE9IG51bGwgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgbGV0IGZldGNoZGVsYXk7XG4gICAgICBjb25zdCBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50ICYmIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydCA+IDEpIHtcbiAgICAgICAgLy8gZmx1c2ggYnVmZmVyIHByZWNlZGluZyBjdXJyZW50IGZyYWdtZW50IChmbHVzaCB1bnRpbCBjdXJyZW50IGZyYWdtZW50IHN0YXJ0IG9mZnNldClcbiAgICAgICAgLy8gbWludXMgMXMgdG8gYXZvaWQgdmlkZW8gZnJlZXppbmcsIHRoYXQgY291bGQgaGFwcGVuIGlmIHdlIGZsdXNoIGtleWZyYW1lIG9mIGN1cnJlbnQgdmlkZW8gLi4uXG4gICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydCAtIDEpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKTtcbiAgICAgIGlmIChsZXZlbERldGFpbHMgIT0gbnVsbCAmJiBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAvLyBEbyBub3QgZmx1c2ggaW4gbGl2ZSBzdHJlYW0gd2l0aCBsb3cgYnVmZmVyXG4gICAgICAgIGlmICghYnVmZmVySW5mbyB8fCBidWZmZXJJbmZvLmxlbiA8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWEucGF1c2VkICYmIGxldmVscykge1xuICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcbiAgICAgICAgY29uc3QgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsO1xuICAgICAgICBjb25zdCBuZXh0TGV2ZWwgPSBsZXZlbHNbbmV4dExldmVsSWRdO1xuICAgICAgICBjb25zdCBmcmFnTGFzdEticHMgPSB0aGlzLmZyYWdMYXN0S2JwcztcbiAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwubWF4Qml0cmF0ZSAvICgxMDAwICogZnJhZ0xhc3RLYnBzKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgfVxuICAgICAgLy8gdGhpcy5sb2coJ2ZldGNoZGVsYXk6JytmZXRjaGRlbGF5KTtcbiAgICAgIC8vIGZpbmQgYnVmZmVyIHJhbmdlIHRoYXQgd2lsbCBiZSByZWFjaGVkIG9uY2UgbmV3IGZyYWdtZW50IHdpbGwgYmUgZmV0Y2hlZFxuICAgICAgY29uc3QgYnVmZmVyZWRGcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUgKyBmZXRjaGRlbGF5KTtcbiAgICAgIGlmIChidWZmZXJlZEZyYWcpIHtcbiAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xuICAgICAgICBjb25zdCBuZXh0QnVmZmVyZWRGcmFnID0gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcoYnVmZmVyZWRGcmFnKTtcbiAgICAgICAgaWYgKG5leHRCdWZmZXJlZEZyYWcpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7XG4gICAgICAgICAgLy8gc3RhcnQgZmx1c2ggcG9zaXRpb24gaXMgaW4gbmV4dCBidWZmZXJlZCBmcmFnLiBMZWF2ZSBzb21lIHBhZGRpbmcgZm9yIG5vbi1pbmRlcGVuZGVudCBzZWdtZW50cyBhbmQgc21vb3RoZXIgcGxheWJhY2suXG4gICAgICAgICAgY29uc3QgbWF4U3RhcnQgPSBuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTID8gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUyA6IG5leHRCdWZmZXJlZEZyYWcuc3RhcnQ7XG4gICAgICAgICAgY29uc3QgZnJhZ0R1cmF0aW9uID0gbmV4dEJ1ZmZlcmVkRnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBzdGFydFB0cyA9IE1hdGgubWF4KGJ1ZmZlcmVkRnJhZy5lbmQsIG1heFN0YXJ0ICsgTWF0aC5taW4oTWF0aC5tYXgoZnJhZ0R1cmF0aW9uIC0gdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZ0R1cmF0aW9uICogMC41KSwgZnJhZ0R1cmF0aW9uICogMC43NSkpO1xuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0UHRzLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFib3J0Q3VycmVudEZyYWcoKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZ0N1cnJlbnQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuS0VZX0xPQURJTkc6XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElORzpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgICBjYXNlIFN0YXRlLlBBUlNFRDpcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICB9XG4gIGZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgc3VwZXIuZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHRoaXMuYWx0QXVkaW8gPyAndmlkZW8nIDogbnVsbCk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgc3VwZXIub25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKTtcbiAgICBjb25zdCBtZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZwbGF5aW5nID0gdGhpcy5vbk1lZGlhUGxheWluZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252c2Vla2VkID0gdGhpcy5vbk1lZGlhU2Vla2VkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG5ldyBHYXBDb250cm9sbGVyKHRoaXMuY29uZmlnLCBtZWRpYSwgdGhpcy5mcmFnbWVudFRyYWNrZXIsIHRoaXMuaGxzKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhICYmIHRoaXMub252cGxheWluZyAmJiB0aGlzLm9udnNlZWtlZCkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG4gICAgaWYgKHRoaXMuZ2FwQ29udHJvbGxlcikge1xuICAgICAgdGhpcy5nYXBDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgfVxuICBvbk1lZGlhUGxheWluZygpIHtcbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgb25NZWRpYVNlZWtlZCgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmxvZyhgTWVkaWEgc2Vla2VkIHRvICR7Y3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICB9XG5cbiAgICAvLyBJZiBzZWVrZWQgd2FzIGlzc3VlZCBiZWZvcmUgYnVmZmVyIHdhcyBhcHBlbmRlZCBkbyBub3QgdGljayBpbW1lZGlhdGVseVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwgfHwgYnVmZmVySW5mby5sZW4gPT09IDApIHtcbiAgICAgIHRoaXMud2FybihgTWFpbiBmb3J3YXJkIGJ1ZmZlciBsZW5ndGggb24gXCJzZWVrZWRcIiBldmVudCAke2J1ZmZlckluZm8gPyBidWZmZXJJbmZvLmxlbiA6ICdlbXB0eSd9KWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR19DSEFOR0VEIHRyaWdnZXJpbmdcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgIHRoaXMubG9nKCdUcmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9SRVNFVCwgdW5kZWZpbmVkKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5mcmFnUGxheWluZyA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMuYWx0QXVkaW8gPSB0aGlzLmF1ZGlvT25seSA9IGZhbHNlO1xuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBsZXQgYWFjID0gZmFsc2U7XG4gICAgbGV0IGhlYWFjID0gZmFsc2U7XG4gICAgbGV0IGNvZGVjO1xuICAgIGRhdGEubGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcbiAgICAgIGNvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xKSB7XG4gICAgICAgICAgYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgaGVhYWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gYWFjICYmIGhlYWFjICYmICFjaGFuZ2VUeXBlU3VwcG9ydGVkKCk7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgdGhpcy5sb2coJ0JvdGggQUFDL0hFLUFBQyBhdWRpbyBmb3VuZCBpbiBsZXZlbHM7IGRlY2xhcmluZyBsZXZlbCBjb2RlYyBhcyBIRS1BQUMnKTtcbiAgICB9XG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICB9XG4gIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuSURMRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tkYXRhLmxldmVsXTtcbiAgICBpZiAoIWxldmVsLmRldGFpbHMgfHwgbGV2ZWwuZGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBkYXRhLmxldmVsIHx8IHRoaXMud2FpdEZvckNkblR1bmVJbihsZXZlbC5kZXRhaWxzKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2N1ckxldmVsJGRldGFpbHM7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV3TGV2ZWxJZCA9IGRhdGEubGV2ZWw7XG4gICAgY29uc3QgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICBjb25zdCBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsICR7bmV3TGV2ZWxJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYExldmVsICR7bmV3TGV2ZWxJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0ke25ld0RldGFpbHMubGFzdFBhcnRTbiA/IGBbcGFydC0ke25ld0RldGFpbHMubGFzdFBhcnRTbn0tJHtuZXdEZXRhaWxzLmxhc3RQYXJ0SW5kZXh9XWAgOiAnJ30sIGNjIFske25ld0RldGFpbHMuc3RhcnRDQ30sICR7bmV3RGV0YWlscy5lbmRDQ31dIGR1cmF0aW9uOiR7ZHVyYXRpb259YCk7XG4gICAgY29uc3QgY3VyTGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxJZF07XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKSkge1xuICAgICAgaWYgKChmcmFnQ3VycmVudC5sZXZlbCAhPT0gZGF0YS5sZXZlbCB8fCBmcmFnQ3VycmVudC51cmxJZCAhPT0gY3VyTGV2ZWwudXJsSWQpICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF9jdXJMZXZlbCRkZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscykgIT0gbnVsbCAmJiBfY3VyTGV2ZWwkZGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmNoZWNrTGl2ZVVwZGF0ZShuZXdEZXRhaWxzKTtcbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIGN1ckxldmVsLmRldGFpbHMpO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1VQREFURUQsIHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBsZXZlbDogbmV3TGV2ZWxJZFxuICAgIH0pO1xuXG4gICAgLy8gb25seSBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihuZXdEZXRhaWxzKSkge1xuICAgICAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgIH0gZWxzZSBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLnN5bmNocm9uaXplVG9MaXZlRWRnZShuZXdEZXRhaWxzKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSB3aWxsIG5vdCBiZSBidWZmZXJlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKGBEcm9wcGluZyBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gYWZ0ZXIgbGV2ZWwgZGV0YWlscyB3ZXJlIHJlc2V0YCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuXG4gICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgY29uc3QgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgIGNvbnN0IGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7XG5cbiAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgLy8gdGhpcy5sb2coYFRyYW5zbXV4aW5nICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnLmxldmVsfSwgY2MgJHtmcmFnLmNjfWApO1xuICAgIGNvbnN0IHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgfHwgbmV3IFRyYW5zbXV4ZXJJbnRlcmZhY2UodGhpcy5obHMsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgIGNvbnN0IHBhcnRJbmRleCA9IHBhcnQgPyBwYXJ0LmluZGV4IDogLTE7XG4gICAgY29uc3QgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50LCBwYXlsb2FkLmJ5dGVMZW5ndGgsIHBhcnRJbmRleCwgcGFydGlhbCk7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICB0cmFuc211eGVyLnB1c2gocGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgY29uc3QgZnJvbUFsdEF1ZGlvID0gdGhpcy5hbHRBdWRpbztcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnQ3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVzdHJveSB0cmFuc211eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICAgIC8vIFJlc2V0IGF1ZGlvIHRyYW5zbXV4ZXIgc28gd2hlbiBzd2l0Y2hpbmcgYmFjayB0byBtYWluIGF1ZGlvIHdlJ3JlIG5vdCBzdGlsbCBhcHBlbmRpbmcgd2hlcmUgd2UgbGVmdCBvZmZcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy8gSWYgc3dpdGNoaW5nIGZyb20gYWx0IHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgaWYgKGZyb21BbHRBdWRpbykge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgdHlwZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgICB9XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIGRhdGEpO1xuICAgIH1cbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIGNvbnN0IGFsdEF1ZGlvID0gISF0aGlzLmhscy5hdWRpb1RyYWNrc1t0cmFja0lkXS51cmw7XG4gICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICBjb25zdCB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgICAvLyBpZiB3ZSBzd2l0Y2hlZCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcbiAgICAgIGlmICh2aWRlb0J1ZmZlciAmJiB0aGlzLm1lZGlhQnVmZmVyICE9PSB2aWRlb0J1ZmZlcikge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWx0QXVkaW8gPSBhbHRBdWRpbztcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB0cmFja3MgPSBkYXRhLnRyYWNrcztcbiAgICBsZXQgbWVkaWFUcmFjaztcbiAgICBsZXQgbmFtZTtcbiAgICBsZXQgYWx0ZXJuYXRlID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0eXBlIGluIHRyYWNrcykge1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICBuYW1lID0gdHlwZTtcbiAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xuICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHZpZGVvVHJhY2suYnVmZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsdGVybmF0ZSAmJiBtZWRpYVRyYWNrKSB7XG4gICAgICB0aGlzLmxvZyhgQWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgJHtuYW1lfS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdgKTtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAvLyBJZiBhIGxldmVsIHN3aXRjaCB3YXMgcmVxdWVzdGVkIHdoaWxlIGEgZnJhZ21lbnQgd2FzIGJ1ZmZlcmluZywgaXQgd2lsbCBlbWl0IHRoZSBGUkFHX0JVRkZFUkVEIGV2ZW50IHVwb24gY29tcGxldGlvblxuICAgICAgLy8gQXZvaWQgc2V0dGluZyBzdGF0ZSBiYWNrIHRvIElETEUsIHNpbmNlIHRoYXQgd2lsbCBpbnRlcmZlcmUgd2l0aCBhIGxldmVsIHN3aXRjaFxuICAgICAgdGhpcy53YXJuKGBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogJHt0aGlzLnN0YXRlfWApO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBzdGF0cy50b3RhbCAvIChzdGF0cy5idWZmZXJpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5maXJzdCkpO1xuICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgfVxuICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRjb250ZXh0O1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihQbGF5bGlzdExldmVsVHlwZS5NQUlOLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyBsZXZlbCwgaWYgbGV2ZWwgY29udHJvbGxlciBpcyBub3QgcmV0cnlpbmcgdG8gbG9hZCBsZXZlbCwgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMICYmICgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGNvbnRleHQudHlwZSkgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICBpZiAoIWRhdGEucGFyZW50IHx8IGRhdGEucGFyZW50ICE9PSAnbWFpbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgICB0aGlzLnJlY292ZXJXb3JrZXJFcnJvcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gIGNoZWNrQnVmZmVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgZ2FwQ29udHJvbGxlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWdhcENvbnRyb2xsZXIgfHwgIW1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmVkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSB8fCAhQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKS5sZW5ndGgpIHtcbiAgICAgIC8vIFJlc29sdmUgZ2FwcyB1c2luZyB0aGUgbWFpbiBidWZmZXIsIHdob3NlIHJhbmdlcyBhcmUgdGhlIGludGVyc2VjdGlvbnMgb2YgdGhlIEEvViBzb3VyY2VidWZmZXJzXG4gICAgICBjb25zdCBhY3RpdmVGcmFnID0gdGhpcy5zdGF0ZSAhPT0gU3RhdGUuSURMRSA/IHRoaXMuZnJhZ0N1cnJlbnQgOiBudWxsO1xuICAgICAgZ2FwQ29udHJvbGxlci5wb2xsKHRoaXMubGFzdEN1cnJlbnRUaW1lLCBhY3RpdmVGcmFnKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfVxuICBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIG9uQnVmZmVyRmx1c2hlZChldmVudCwge1xuICAgIHR5cGVcbiAgfSkge1xuICAgIGlmICh0eXBlICE9PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gfHwgdGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW8pIHtcbiAgICAgIGNvbnN0IG1lZGlhQnVmZmVyID0gKHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyA/IHRoaXMudmlkZW9CdWZmZXIgOiB0aGlzLm1lZGlhQnVmZmVyKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIH1cbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICB9XG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBzZWVrVG9TdGFydFBvcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgdGhpcy5sb2coYGNvdWxkIG5vdCBzZWVrIHRvICR7c3RhcnRQb3NpdGlvbn0sIGFscmVhZHkgc2Vla2luZyBhdCAke2N1cnJlbnRUaW1lfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICBjb25zdCBidWZmZXJTdGFydCA9IGJ1ZmZlcmVkLmxlbmd0aCA/IGJ1ZmZlcmVkLnN0YXJ0KDApIDogMDtcbiAgICAgIGNvbnN0IGRlbHRhID0gYnVmZmVyU3RhcnQgLSBzdGFydFBvc2l0aW9uO1xuICAgICAgaWYgKGRlbHRhID4gMCAmJiAoZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8IGRlbHRhIDwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpIHtcbiAgICAgICAgdGhpcy5sb2coYGFkanVzdGluZyBzdGFydCBwb3NpdGlvbiBieSAke2RlbHRhfSB0byBtYXRjaCBidWZmZXIgc3RhcnRgKTtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBzZWVrIHRvIHRhcmdldCBzdGFydCBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259IGZyb20gY3VycmVudCB0aW1lICR7Y3VycmVudFRpbWV9YCk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuICB9XG4gIF9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCkge1xuICAgIGxldCBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3YXAgJiYgYXVkaW9Db2RlYykge1xuICAgICAgdGhpcy5sb2coJ1N3YXBwaW5nIGF1ZGlvIGNvZGVjJyk7XG4gICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVkaW9Db2RlYztcbiAgfVxuICBfbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnLCBsZXZlbCkge1xuICAgIGZyYWcuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoIWRhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICBjb25zdCBzdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICAvLyBCaXRyYXRlIHRlc3RzIGZyYWdtZW50cyBhcmUgbmVpdGhlciBwYXJzZWQgbm9yIGJ1ZmZlcmVkXG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuICAgIGNvbnN0IGlkID0gJ21haW4nO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgY2h1bmtNZXRhXG4gICAgfSA9IHRyYW5zbXV4UmVzdWx0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgbGV2ZWxcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICB2aWRlbyxcbiAgICAgIHRleHQsXG4gICAgICBpZDMsXG4gICAgICBpbml0U2VnbWVudFxuICAgIH0gPSByZW11eFJlc3VsdDtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGxldmVsO1xuICAgIC8vIFRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBoYW5kbGVzIGF1ZGlvIGJ1ZmZlcmluZyBpZiBIbHMuanMgaXMgcGxheWluZyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBhdWRpbyA9IHRoaXMuYWx0QXVkaW8gPyB1bmRlZmluZWQgOiByZW11eFJlc3VsdC5hdWRpbztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgICAgY29uc3QgbWFwRnJhZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50IHx8IGZyYWc7XG4gICAgICAgIHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGxldmVsLCBpbml0U2VnbWVudC50cmFja3MsIG1hcEZyYWdtZW50LCBjaHVua01ldGEpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwge1xuICAgICAgICAgIGZyYWc6IG1hcEZyYWdtZW50LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIHdvdWxkIGJlIG5pY2UgaWYgTnVtYmVyLmlzRmluaXRlIGFjdGVkIGFzIGEgdHlwZWd1YXJkLCBidXQgaXQgZG9lc24ndC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEwMDM4XG4gICAgICBjb25zdCBpbml0UFRTID0gaW5pdFNlZ21lbnQuaW5pdFBUUztcbiAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IGluaXRTZWdtZW50LnRpbWVzY2FsZTtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihpbml0UFRTKSkge1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgICAgdGltZXNjYWxlXG4gICAgICAgIH07XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5JTklUX1BUU19GT1VORCwge1xuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgYnVmZmVyaW5nIGlmIGJhY2t0cmFja2luZyB0aGlzIGZyYWdtZW50XG4gICAgaWYgKHZpZGVvICYmIGRldGFpbHMgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgY29uc3QgcHJldkZyYWcgPSBkZXRhaWxzLmZyYWdtZW50c1tmcmFnLnNuIC0gMSAtIGRldGFpbHMuc3RhcnRTTl07XG4gICAgICBjb25zdCBpc0ZpcnN0RnJhZ21lbnQgPSBmcmFnLnNuID09PSBkZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBpc0ZpcnN0SW5EaXNjb250aW51aXR5ID0gIXByZXZGcmFnIHx8IGZyYWcuY2MgPiBwcmV2RnJhZy5jYztcbiAgICAgIGlmIChyZW11eFJlc3VsdC5pbmRlcGVuZGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFNcbiAgICAgICAgfSA9IHZpZGVvO1xuICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbdmlkZW8udHlwZV0gPSB7XG4gICAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgICAgZW5kRFRTXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmlkZW8uZmlyc3RLZXlGcmFtZSAmJiB2aWRlby5pbmRlcGVuZGVudCAmJiBjaHVua01ldGEuaWQgPT09IDEgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmlkZW8uZHJvcHBlZCAmJiB2aWRlby5pbmRlcGVuZGVudCkge1xuICAgICAgICAgICAgLy8gQmFja3RyYWNrIGlmIGRyb3BwZWQgZnJhbWVzIGNyZWF0ZSBhIGdhcCBhZnRlciBjdXJyZW50VGltZVxuXG4gICAgICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9IChidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgOiB0aGlzLmdldExvYWRQb3NpdGlvbigpKSArIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSB2aWRlby5maXJzdEtleUZyYW1lUFRTID8gdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA6IHN0YXJ0UFRTO1xuICAgICAgICAgICAgaWYgKCFpc0ZpcnN0RnJhZ21lbnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHN0YXJ0VGltZSAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICAvLyBNYXJrIHNlZ21lbnQgd2l0aCBhIGdhcCB0byBhdm9pZCBsb29wIGxvYWRpbmdcbiAgICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHZpZGVvIHN0cmVhbSBzdGFydCB0byBmcmFnbWVudCBzdGFydCBzbyB0aGF0IHRydW5jYXRlZCBzYW1wbGVzIGRvIG5vdCBkaXN0b3J0IHRoZSB0aW1lbGluZSwgYW5kIG1hcmsgaXQgcGFydGlhbFxuICAgICAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh2aWRlby50eXBlLCBmcmFnLnN0YXJ0LCBlbmRQVFMsIGZyYWcuc3RhcnQsIGVuZERUUywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odmlkZW8udHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEodmlkZW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSwgaXNGaXJzdEZyYWdtZW50IHx8IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpO1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0RnJhZ21lbnQgfHwgaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAvLyBNYXJrIHNlZ21lbnQgd2l0aCBhIGdhcCB0byBhdm9pZCBsb29wIGxvYWRpbmdcbiAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICBlbmREVFNcbiAgICAgIH0gPSBhdWRpbztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG4gICAgaWYgKGRldGFpbHMgJiYgaWQzICE9IG51bGwgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPSBudWxsICYmIF9pZDMkc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRJRDMgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgICBzYW1wbGVzOiBpZDMuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAoZGV0YWlscyAmJiB0ZXh0KSB7XG4gICAgICBjb25zdCBlbWl0dGVkVGV4dCA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIHNhbXBsZXM6IHRleHQuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICB9XG4gIH1cbiAgX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvT25seSA9ICEhdHJhY2tzLmF1ZGlvICYmICF0cmFja3MudmlkZW87XG5cbiAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiAhdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgY29uc3Qge1xuICAgICAgYXVkaW8sXG4gICAgICB2aWRlbyxcbiAgICAgIGF1ZGlvdmlkZW9cbiAgICB9ID0gdHJhY2tzO1xuICAgIGlmIChhdWRpbykge1xuICAgICAgbGV0IGF1ZGlvQ29kZWMgPSBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3QsXG4gICAgICAgIC8vIGZvcmNlIEhFLUFBQywgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgaXQuXG4gICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbSwgb3IgaW4gRmlyZWZveFxuICAgICAgICBpZiAoYXVkaW8ubWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgIGlmICh1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xICYmIGF1ZGlvLmNvbnRhaW5lciAhPT0gJ2F1ZGlvL21wZWcnKSB7XG4gICAgICAgIC8vIEV4Y2x1ZGUgbXBlZyBhdWRpb1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgIHRoaXMubG9nKGBBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byAke2F1ZGlvQ29kZWN9YCk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvQ29kZWMgJiYgY3VycmVudExldmVsLmF1ZGlvQ29kZWMgIT09IGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5sb2coYFN3YXBwaW5nIG1hbmlmZXN0IGF1ZGlvIGNvZGVjIFwiJHtjdXJyZW50TGV2ZWwuYXVkaW9Db2RlY31cIiBmb3IgXCIke2F1ZGlvQ29kZWN9XCJgKTtcbiAgICAgIH1cbiAgICAgIGF1ZGlvLmxldmVsQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgICAgYXVkaW8uaWQgPSAnbWFpbic7XG4gICAgICB0aGlzLmxvZyhgSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjoke2F1ZGlvLmNvbnRhaW5lcn0sIGNvZGVjc1tzZWxlY3RlZC9sZXZlbC9wYXJzZWRdPVske2F1ZGlvQ29kZWMgfHwgJyd9LyR7Y3VycmVudExldmVsLmF1ZGlvQ29kZWMgfHwgJyd9LyR7YXVkaW8uY29kZWN9XWApO1xuICAgIH1cbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIHZpZGVvLmxldmVsQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcbiAgICAgIHZpZGVvLmlkID0gJ21haW4nO1xuICAgICAgdGhpcy5sb2coYEluaXQgdmlkZW8gYnVmZmVyLCBjb250YWluZXI6JHt2aWRlby5jb250YWluZXJ9LCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHtjdXJyZW50TGV2ZWwudmlkZW9Db2RlYyB8fCAnJ30vJHt2aWRlby5jb2RlY31dYCk7XG4gICAgfVxuICAgIGlmIChhdWRpb3ZpZGVvKSB7XG4gICAgICB0aGlzLmxvZyhgSW5pdCBhdWRpb3ZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOiR7YXVkaW92aWRlby5jb250YWluZXJ9LCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHtjdXJyZW50TGV2ZWwuYXR0cnMuQ09ERUNTIHx8ICcnfS8ke2F1ZGlvdmlkZW8uY29kZWN9XWApO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgIC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxuICAgIE9iamVjdC5rZXlzKHRyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIGNvbnN0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHtcbiAgICAgICAgICB0eXBlOiB0cmFja05hbWUsXG4gICAgICAgICAgZGF0YTogaW5pdFNlZ21lbnQsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICB9XG4gIGJhY2t0cmFjayhmcmFnKSB7XG4gICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgLy8gQ2F1c2VzIGZpbmRGcmFnbWVudHMgdG8gYmFja3RyYWNrIHRocm91Z2ggZnJhZ21lbnRzIHRvIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0O1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG4gIGNoZWNrRnJhZ21lbnRDaGFuZ2VkKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICBsZXQgZnJhZ1BsYXlpbmdDdXJyZW50ID0gbnVsbDtcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDEgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG5cbiAgICAgIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUpKSB7XG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lICsgMC4xKSkge1xuICAgICAgICAvKiBlbnN1cmUgdGhhdCBGUkFHX0NIQU5HRUQgZXZlbnQgaXMgdHJpZ2dlcmVkIGF0IHN0YXJ0dXAsXG4gICAgICAgICAgd2hlbiBmaXJzdCB2aWRlbyBmcmFtZSBpcyBkaXNwbGF5ZWQgYW5kIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgICAgICAgICBhZGQgYSB0b2xlcmFuY2Ugb2YgMTAwbXMsIGluIGNhc2UgY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsXG4gICAgICAgICAgY2hlY2sgaWYgY3VycmVudCBwb3MrMTAwbXMgaXMgYnVmZmVyZWQgYW5kIHVzZSB0aGF0IGJ1ZmZlciByYW5nZVxuICAgICAgICAgIGZvciBGUkFHX0NIQU5HRUQgZXZlbnQgcmVwb3J0aW5nICovXG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nID0gdGhpcy5mcmFnUGxheWluZztcbiAgICAgICAgY29uc3QgZnJhZ0N1cnJlbnRMZXZlbCA9IGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcbiAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZ0N1cnJlbnQuc24gIT09IGZyYWdQbGF5aW5nLnNuIHx8IGZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnQ3VycmVudExldmVsIHx8IGZyYWdQbGF5aW5nQ3VycmVudC51cmxJZCAhPT0gZnJhZ1BsYXlpbmcudXJsSWQpIHtcbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmdDdXJyZW50O1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQ0hBTkdFRCwge1xuICAgICAgICAgICAgZnJhZzogZnJhZ1BsYXlpbmdDdXJyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENIRUQsIHtcbiAgICAgICAgICAgICAgbGV2ZWw6IGZyYWdDdXJyZW50TGV2ZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbmV4dExldmVsKCkge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0IGN1cnJlbnRGcmFnKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdQbGF5aW5nIHx8IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgICAgaWYgKGZyYWcgJiYgaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpICYmIGlzRmluaXRlTnVtYmVyKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICBjb25zdCBlcG9jTXMgPSBmcmFnLnByb2dyYW1EYXRlVGltZSArIChjdXJyZW50VGltZSAtIGZyYWcuc3RhcnQpICogMTAwMDtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGVwb2NNcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjdXJyZW50TGV2ZWwoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0IG5leHRCdWZmZXJlZEZyYWcoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGZvcmNlU3RhcnRMb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVN0YXJ0TG9hZDtcbiAgfVxufVxuXG4vKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbmNsYXNzIEVXTUEge1xuICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICBjb25zdHJ1Y3RvcihoYWxmTGlmZSwgZXN0aW1hdGUgPSAwLCB3ZWlnaHQgPSAwKSB7XG4gICAgdGhpcy5oYWxmTGlmZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFscGhhXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhbGZMaWZlID0gaGFsZkxpZmU7XG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IGVzdGltYXRlO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gd2VpZ2h0O1xuICB9XG4gIHNhbXBsZSh3ZWlnaHQsIHZhbHVlKSB7XG4gICAgY29uc3QgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xuICAgIHRoaXMudG90YWxXZWlnaHRfICs9IHdlaWdodDtcbiAgfVxuICBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cbiAgZ2V0RXN0aW1hdGUoKSB7XG4gICAgaWYgKHRoaXMuYWxwaGFfKSB7XG4gICAgICBjb25zdCB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICBpZiAoemVyb0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gIH1cbn1cblxuLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuXG5jbGFzcyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcbiAgY29uc3RydWN0b3Ioc2xvdywgZmFzdCwgZGVmYXVsdEVzdGltYXRlLCBkZWZhdWx0VFRGQiA9IDEwMCkge1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm1pbldlaWdodF8gPSB2b2lkIDA7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IHZvaWQgMDtcbiAgICB0aGlzLnNsb3dfID0gdm9pZCAwO1xuICAgIHRoaXMuZmFzdF8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSB2b2lkIDA7XG4gICAgdGhpcy50dGZiXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSBkZWZhdWx0VFRGQjtcbiAgICB0aGlzLnR0ZmJfID0gbmV3IEVXTUEoc2xvdyk7XG4gIH1cbiAgdXBkYXRlKHNsb3csIGZhc3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBzbG93XyxcbiAgICAgIGZhc3RfLFxuICAgICAgdHRmYl9cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoc2xvd18uaGFsZkxpZmUgIT09IHNsb3cpIHtcbiAgICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93LCBzbG93Xy5nZXRFc3RpbWF0ZSgpLCBzbG93Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gICAgaWYgKGZhc3RfLmhhbGZMaWZlICE9PSBmYXN0KSB7XG4gICAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCwgZmFzdF8uZ2V0RXN0aW1hdGUoKSwgZmFzdF8uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgfVxuICAgIGlmICh0dGZiXy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgdGhpcy50dGZiXyA9IG5ldyBFV01BKHNsb3csIHR0ZmJfLmdldEVzdGltYXRlKCksIHR0ZmJfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgfVxuICBzYW1wbGUoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XG4gICAgY29uc3QgbnVtQml0cyA9IDggKiBudW1CeXRlcztcbiAgICAvLyB3ZWlnaHQgaXMgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgIGNvbnN0IGR1cmF0aW9uUyA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgIC8vIHZhbHVlIGlzIGJhbmR3aWR0aCBpbiBiaXRzL3NcbiAgICBjb25zdCBiYW5kd2lkdGhJbkJwcyA9IG51bUJpdHMgLyBkdXJhdGlvblM7XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gICAgdGhpcy5zbG93Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gIH1cbiAgc2FtcGxlVFRGQih0dGZiKSB7XG4gICAgLy8gd2VpZ2h0IGlzIGZyZXF1ZW5jeSBjdXJ2ZSBhcHBsaWVkIHRvIFRURkIgaW4gc2Vjb25kc1xuICAgIC8vIChsb25nZXIgdGltZXMgaGF2ZSBsZXNzIHdlaWdodCB3aXRoIGV4cGVjdGVkIGlucHV0IHVuZGVyIDEgc2Vjb25kKVxuICAgIGNvbnN0IHNlY29uZHMgPSB0dGZiIC8gMTAwMDtcbiAgICBjb25zdCB3ZWlnaHQgPSBNYXRoLnNxcnQoMikgKiBNYXRoLmV4cCgtTWF0aC5wb3coc2Vjb25kcywgMikgLyAyKTtcbiAgICB0aGlzLnR0ZmJfLnNhbXBsZSh3ZWlnaHQsIE1hdGgubWF4KHR0ZmIsIDUpKTtcbiAgfVxuICBjYW5Fc3RpbWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mYXN0Xy5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgfVxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfVxuICBnZXRFc3RpbWF0ZVRURkIoKSB7XG4gICAgaWYgKHRoaXMudHRmYl8uZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnR0ZmJfLmdldEVzdGltYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRUVEZCXztcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHt9XG59XG5cbmNsYXNzIEFickNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAwO1xuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IDA7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB0aGlzLm9uQ2hlY2sgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgdGhpcy5id0VzdGltYXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSBuZXcgRXdtYUJhbmRXaWR0aEVzdGltYXRvcihjb25maWcuYWJyRXdtYVNsb3dWb0QsIGNvbmZpZy5hYnJFd21hRmFzdFZvRCwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLm9uQ2hlY2sgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgfVxuICBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJHBhcnQ7XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICB0aGlzLnBhcnRDdXJyZW50ID0gKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpICE9IG51bGwgPyBfZGF0YSRwYXJ0IDogbnVsbDtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssIDEwMCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIGdldFRpbWVUb0xvYWRGcmFnKHRpbWVUb0ZpcnN0Qnl0ZVNlYywgYmFuZHdpZHRoLCBmcmFnU2l6ZUJpdHMsIGlzU3dpdGNoKSB7XG4gICAgY29uc3QgZnJhZ0xvYWRTZWMgPSB0aW1lVG9GaXJzdEJ5dGVTZWMgKyBmcmFnU2l6ZUJpdHMgLyBiYW5kd2lkdGg7XG4gICAgY29uc3QgcGxheWxpc3RMb2FkU2VjID0gaXNTd2l0Y2ggPyB0aGlzLmxhc3RMZXZlbExvYWRTZWMgOiAwO1xuICAgIHJldHVybiBmcmFnTG9hZFNlYyArIHBsYXlsaXN0TG9hZFNlYztcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvdGFsLFxuICAgICAgYndFc3RpbWF0ZVxuICAgIH0gPSBkYXRhLnN0YXRzO1xuICAgIC8vIFRvdGFsIGlzIHRoZSBieXRlbGVuZ3RoIGFuZCBid0VzdGltYXRlIGluIGJpdHMvc2VjXG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHRvdGFsKSAmJiBpc0Zpbml0ZU51bWJlcihid0VzdGltYXRlKSkge1xuICAgICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gOCAqIHRvdGFsIC8gYndFc3RpbWF0ZTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnVwZGF0ZShjb25maWcuYWJyRXdtYVNsb3dMaXZlLCBjb25maWcuYWJyRXdtYUZhc3RMaXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QpO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgICBUaGlzIG1ldGhvZCBtb25pdG9ycyB0aGUgZG93bmxvYWQgcmF0ZSBvZiB0aGUgY3VycmVudCBmcmFnbWVudCwgYW5kIHdpbGwgZG93bnN3aXRjaCBpZiB0aGF0IGZyYWdtZW50IHdpbGwgbm90IGxvYWRcbiAgICAgIHF1aWNrbHkgZW5vdWdoIHRvIHByZXZlbnQgdW5kZXJidWZmZXJpbmdcbiAgICAqL1xuICBfYWJhbmRvblJ1bGVzQ2hlY2soKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnQ6IGZyYWcsXG4gICAgICBwYXJ0Q3VycmVudDogcGFydCxcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dG9MZXZlbEVuYWJsZWQsXG4gICAgICBtZWRpYVxuICAgIH0gPSBobHM7XG4gICAgaWYgKCFmcmFnIHx8ICFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjtcbiAgICBjb25zdCB0aW1lTG9hZGluZyA9IG5vdyAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgLy8gSWYgZnJhZyBsb2FkaW5nIGlzIGFib3J0ZWQsIGNvbXBsZXRlLCBvciBmcm9tIGxvd2VzdCBsZXZlbCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQgfHwgc3RhdHMubG9hZGVkICYmIHN0YXRzLmxvYWRlZCA9PT0gc3RhdHMudG90YWwgfHwgZnJhZy5sZXZlbCA9PT0gMCkge1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgY2hlY2sgb25seSBydW5zIGlmIHdlJ3JlIGluIEFCUiBtb2RlIGFuZCBhY3R1YWxseSBwbGF5aW5nXG4gICAgaWYgKCFhdXRvTGV2ZWxFbmFibGVkIHx8IG1lZGlhLnBhdXNlZCB8fCAhbWVkaWEucGxheWJhY2tSYXRlIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gICAgY29uc3QgcGxheWJhY2tSYXRlID0gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKTtcbiAgICAvLyBUbyBtYWludGFpbiBzdGFibGUgYWRhcHRpdmUgcGxheWJhY2ssIG9ubHkgYmVnaW4gbW9uaXRvcmluZyBmcmFnIGxvYWRpbmcgYWZ0ZXIgaGFsZiBvciBtb3JlIG9mIGl0cyBwbGF5YmFjayBkdXJhdGlvbiBoYXMgcGFzc2VkXG4gICAgaWYgKHRpbWVMb2FkaW5nIDw9IE1hdGgubWF4KHR0ZmJFc3RpbWF0ZSwgMTAwMCAqIChkdXJhdGlvbiAvIChwbGF5YmFja1JhdGUgKiAyKSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuICAgIGNvbnN0IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IGJ1ZmZlckluZm8ubGVuIC8gcGxheWJhY2tSYXRlO1xuICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiBsZXNzIHRoYW4gMiBmcmFnbWVudCBsZW5ndGhzIGFyZSBidWZmZXJlZFxuICAgIGlmIChidWZmZXJTdGFydmF0aW9uRGVsYXkgPj0gMiAqIGR1cmF0aW9uIC8gcGxheWJhY2tSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR0ZmIgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICBjb25zdCBsb2FkZWRGaXJzdEJ5dGUgPSBzdGF0cy5sb2FkZWQgJiYgdHRmYiA+IC0xO1xuICAgIGNvbnN0IGJ3RXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgbWluQXV0b0xldmVsXG4gICAgfSA9IGhscztcbiAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICBjb25zdCBleHBlY3RlZExlbiA9IHN0YXRzLnRvdGFsIHx8IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChkdXJhdGlvbiAqIGxldmVsLm1heEJpdHJhdGUgLyA4KSk7XG4gICAgbGV0IHRpbWVTdHJlYW1pbmcgPSB0aW1lTG9hZGluZyAtIHR0ZmI7XG4gICAgaWYgKHRpbWVTdHJlYW1pbmcgPCAxICYmIGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgdGltZVN0cmVhbWluZyA9IE1hdGgubWluKHRpbWVMb2FkaW5nLCBzdGF0cy5sb2FkZWQgKiA4IC8gYndFc3RpbWF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRSYXRlID0gbG9hZGVkRmlyc3RCeXRlID8gc3RhdHMubG9hZGVkICogMTAwMCAvIHRpbWVTdHJlYW1pbmcgOiAwO1xuICAgIC8vIGZyYWdMb2FkRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBidWZmZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICBjb25zdCBmcmFnTG9hZGVkRGVsYXkgPSBsb2FkUmF0ZSA/IChleHBlY3RlZExlbiAtIHN0YXRzLmxvYWRlZCkgLyBsb2FkUmF0ZSA6IGV4cGVjdGVkTGVuICogOCAvIGJ3RXN0aW1hdGUgKyB0dGZiRXN0aW1hdGUgLyAxMDAwO1xuICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiB0aGUgdGltZSB0byBmaW5pc2ggbG9hZGluZyB0aGUgY3VycmVudCBmcmFnbWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIGFtb3VudCBvZiBidWZmZXIgbGVmdFxuICAgIGlmIChmcmFnTG9hZGVkRGVsYXkgPD0gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ3ZSA9IGxvYWRSYXRlID8gbG9hZFJhdGUgKiA4IDogYndFc3RpbWF0ZTtcbiAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBuZXh0TG9hZExldmVsO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGxhcmdlc3Qgb25lIHRoYXQgYXZvaWRzIHJlYnVmZmVyaW5nXG4gICAgZm9yIChuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDE7IG5leHRMb2FkTGV2ZWwgPiBtaW5BdXRvTGV2ZWw7IG5leHRMb2FkTGV2ZWwtLSkge1xuICAgICAgLy8gY29tcHV0ZSB0aW1lIHRvIGxvYWQgbmV4dCBmcmFnbWVudCBhdCBsb3dlciBsZXZlbFxuICAgICAgLy8gOCA9IGJpdHMgcGVyIGJ5dGUgKGJwcy9CcHMpXG4gICAgICBjb25zdCBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLm1heEJpdHJhdGU7XG4gICAgICBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSB0aGlzLmdldFRpbWVUb0xvYWRGcmFnKHR0ZmJFc3RpbWF0ZSAvIDEwMDAsIGJ3ZSwgZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlLCAhbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmRldGFpbHMpO1xuICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgYXQgbG93ZXN0IGxldmVsIGluc3RlYWQgb2YgY29udGludWluZ1xuICAgIC8vIHRvIGxvYWQgdGhlIGN1cnJlbnQgb25lXG4gICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA+PSBmcmFnTG9hZGVkRGVsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBlc3RpbWF0ZWQgbG9hZCB0aW1lIG9mIG5ldyBzZWdtZW50IGlzIGNvbXBsZXRlbHkgdW5yZWFzb25hYmxlLCBpZ25vcmUgYW5kIGRvIG5vdCBlbWVyZ2VuY3kgc3dpdGNoIGRvd25cbiAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID4gZHVyYXRpb24gKiAxMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMubmV4dExvYWRMZXZlbCA9IG5leHRMb2FkTGV2ZWw7XG4gICAgaWYgKGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgLy8gSWYgdGhlcmUgaGFzIGJlZW4gbG9hZGluZyBwcm9ncmVzcywgc2FtcGxlIGJhbmR3aWR0aCB1c2luZyBsb2FkaW5nIHRpbWUgb2Zmc2V0IGJ5IG1pbmltdW0gVFRGQiB0aW1lXG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZSh0aW1lTG9hZGluZyAtIE1hdGgubWluKHR0ZmJFc3RpbWF0ZSwgdHRmYiksIHN0YXRzLmxvYWRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIG5vIGxvYWRpbmcgcHJvZ3Jlc3MsIHNhbXBsZSBUVEZCXG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIodGltZUxvYWRpbmcpO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICBsb2dnZXIud2FybihgW2Ficl0gRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGlzIGxvYWRpbmcgdG9vIHNsb3dseTtcbiAgICAgIFRpbWUgdG8gdW5kZXJidWZmZXI6ICR7YnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMyl9IHNcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGN1cnJlbnQgZnJhZ21lbnQ6ICR7ZnJhZ0xvYWRlZERlbGF5LnRvRml4ZWQoMyl9IHNcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGRvd24gc3dpdGNoIGZyYWdtZW50OiAke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDMpfSBzXG4gICAgICBUVEZCIGVzdGltYXRlOiAke3R0ZmJ9XG4gICAgICBDdXJyZW50IEJXIGVzdGltYXRlOiAke2lzRmluaXRlTnVtYmVyKGJ3RXN0aW1hdGUpID8gKGJ3RXN0aW1hdGUgLyAxMDI0KS50b0ZpeGVkKDMpIDogJ1Vua25vd24nfSBLYi9zXG4gICAgICBOZXcgQlcgZXN0aW1hdGU6ICR7KHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKSAvIDEwMjQpLnRvRml4ZWQoMyl9IEtiL3NcbiAgICAgIEFib3J0aW5nIGFuZCBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXh0TG9hZExldmVsfWApO1xuICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgfVxuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgc3RhdHNcbiAgICB9KTtcbiAgfVxuICBvbkZyYWdMb2FkZWQoZXZlbnQsIHtcbiAgICBmcmFnLFxuICAgIHBhcnRcbiAgfSkge1xuICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQihzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlnbm9yZUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcblxuICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGFydCA/IHBhcnQuZHVyYXRpb24gOiBmcmFnLmR1cmF0aW9uO1xuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBjb25zdCBsb2FkZWRCeXRlcyA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuYnl0ZXMgOiAwKSArIHN0YXRzLmxvYWRlZDtcbiAgICAgIGNvbnN0IGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZHVyYXRpb247XG4gICAgICBsZXZlbC5sb2FkZWQgPSB7XG4gICAgICAgIGJ5dGVzOiBsb2FkZWRCeXRlcyxcbiAgICAgICAgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uXG4gICAgICB9O1xuICAgICAgbGV2ZWwucmVhbEJpdHJhdGUgPSBNYXRoLnJvdW5kKDggKiBsb2FkZWRCeXRlcyAvIGxvYWRlZER1cmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIGNvbnN0IGZyYWdCdWZmZXJlZERhdGEgPSB7XG4gICAgICAgIHN0YXRzLFxuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9O1xuICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChFdmVudHMuRlJBR19CVUZGRVJFRCwgZnJhZ0J1ZmZlcmVkRGF0YSk7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBzdGF0cyA9IHBhcnQgIT0gbnVsbCAmJiBwYXJ0LnN0YXRzLmxvYWRlZCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlnbm9yZUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFVzZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHBhcnNpbmcgYW5kIHJlcXVlc3QgaW5zdGVhZCBvZiBidWZmZXJpbmcgYW5kIHJlcXVlc3QgdG8gY29tcHV0ZSBmcmFnTG9hZGluZ1Byb2Nlc3Npbmc7XG4gICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgYnVmZmVyIGFwcGVuZGluZyBvbmx5IGhhcHBlbnMgb25jZSBtZWRpYSBpcyBhdHRhY2hlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoXG4gICAgLy8gaXMgdXNlZC4gSWYgd2UgdXNlZCBidWZmZXJpbmcgaW4gdGhhdCBjYXNlLCBvdXIgQlcgZXN0aW1hdGUgc2FtcGxlIHdpbGwgYmUgdmVyeSBsYXJnZS5cbiAgICBjb25zdCBwcm9jZXNzaW5nTXMgPSBzdGF0cy5wYXJzaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgLSBNYXRoLm1pbihzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCwgdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKSk7XG4gICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUocHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IHByb2Nlc3NpbmdNcyAvIDEwMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgfVxuICB9XG4gIGlnbm9yZUZyYWdtZW50KGZyYWcpIHtcbiAgICAvLyBPbmx5IGNvdW50IG5vbi1hbHQtYXVkaW8gZnJhZ3Mgd2hpY2ggd2VyZSBhY3R1YWxseSBidWZmZXJlZCBpbiBvdXIgQlcgY2FsY3VsYXRpb25zXG4gICAgcmV0dXJuIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnO1xuICB9XG4gIGNsZWFyVGltZXIoKSB7XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICB9XG5cbiAgLy8gcmV0dXJuIG5leHQgYXV0byBsZXZlbFxuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICAgIGNvbnN0IGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvcjtcbiAgICAvLyBpbiBjYXNlIG5leHQgYXV0byBsZXZlbCBoYXMgYmVlbiBmb3JjZWQsIGFuZCBidyBub3QgYXZhaWxhYmxlIG9yIG5vdCByZWxpYWJsZSwgcmV0dXJuIGZvcmNlZCB2YWx1ZVxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICFid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICBsZXQgbmV4dEFCUkF1dG9MZXZlbCA9IHRoaXMuZ2V0TmV4dEFCUkF1dG9MZXZlbCgpO1xuICAgIC8vIHVzZSBmb3JjZWQgYXV0byBsZXZlbCB3aGVuIEFCUiBzZWxlY3RlZCBsZXZlbCBoYXMgZXJyb3JlZFxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IE1hdGgubWF4KGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCkgJiYgbGV2ZWxzW2ZvcmNlZEF1dG9MZXZlbF0ubG9hZEVycm9yIDw9IGxldmVsc1tuZXh0QUJSQXV0b0xldmVsXS5sb2FkRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgZm9yY2VkIGF1dG8gbGV2ZWwgaGFzIGJlZW4gZGVmaW5lZCwgdXNlIGl0IHRvIGNhcCBBQlIgY29tcHV0ZWQgcXVhbGl0eSBsZXZlbFxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXh0QUJSQXV0b0xldmVsID0gTWF0aC5taW4oZm9yY2VkQXV0b0xldmVsLCBuZXh0QUJSQXV0b0xldmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gIH1cbiAgZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudCxcbiAgICAgIHBhcnRDdXJyZW50LFxuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgY29uZmlnLFxuICAgICAgbWluQXV0b0xldmVsLFxuICAgICAgbWVkaWFcbiAgICB9ID0gaGxzO1xuICAgIGNvbnN0IGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG5cbiAgICAvLyBwbGF5YmFja1JhdGUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBwbGF5YmFjayByYXRlOyBpZiBtZWRpYS5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xuICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG4gICAgY29uc3QgcGxheWJhY2tSYXRlID0gbWVkaWEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwID8gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKSA6IDEuMDtcbiAgICBjb25zdCBhdmdidyA9IHRoaXMuYndFc3RpbWF0b3IgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcbiAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgdGhlIHdhbGwtY2xvY2sgdGltZSBsZWZ0IHVudGlsIHRoZSBwbGF5YmFjayBidWZmZXIgaXMgZXhoYXVzdGVkLlxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgIGNvbnN0IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAwKSAvIHBsYXliYWNrUmF0ZTtcblxuICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgbGV0IGJlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgY29uZmlnLmFickJhbmRXaWR0aEZhY3RvciwgY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yKTtcbiAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgfVxuICAgIGxvZ2dlci50cmFjZShgW2Ficl0gJHtidWZmZXJTdGFydmF0aW9uRGVsYXkgPyAncmVidWZmZXJpbmcgZXhwZWN0ZWQnIDogJ2J1ZmZlciBpcyBlbXB0eSd9LCBmaW5kaW5nIG9wdGltYWwgcXVhbGl0eSBsZXZlbGApO1xuICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICAvLyBpZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgbG9naWMgd2lsbCByZXR1cm4gMFxuICAgIGxldCBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSkgOiBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgIGxldCBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3I7XG4gICAgbGV0IGJ3VXBGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG4gICAgaWYgKCFidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcbiAgICAgIGNvbnN0IGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICBpZiAoYml0cmF0ZVRlc3REZWxheSkge1xuICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxuICAgICAgICAvLyBtYXggdmlkZW8gbG9hZGluZyBkZWxheSB1c2VkIGluICBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uIDpcbiAgICAgICAgLy8gaW4gdGhhdCBtb2RlIEFCUiBjb250cm9sbGVyIHdpbGwgZW5zdXJlIHRoYXQgdmlkZW8gbG9hZGluZyB0aW1lIChpZSB0aGUgdGltZSB0byBmZXRjaCB0aGUgZmlyc3QgZnJhZ21lbnQgYXQgbG93ZXN0IHF1YWxpdHkgbGV2ZWwgK1xuICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXG4gICAgICAgIC8vIGNhcCBtYXhMb2FkaW5nRGVsYXkgYW5kIGVuc3VyZSBpdCBpcyBub3QgYmlnZ2VyICd0aGFuIGJpdHJhdGUgdGVzdCcgZnJhZyBkdXJhdGlvblxuICAgICAgICBjb25zdCBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSkgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xuICAgICAgICBtYXhTdGFydmF0aW9uRGVsYXkgPSBtYXhMb2FkaW5nRGVsYXkgLSBiaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICBsb2dnZXIudHJhY2UoYFthYnJdIGJpdHJhdGUgdGVzdCB0b29rICR7TWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSl9bXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byAke01hdGgucm91bmQoMTAwMCAqIG1heFN0YXJ2YXRpb25EZWxheSl9IG1zYCk7XG4gICAgICAgIC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxuICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBiZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXkgKyBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLCAwKTtcbiAgfVxuICBmaW5kQmVzdExldmVsKGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIG1heEZldGNoRHVyYXRpb24sIGJ3RmFjdG9yLCBid1VwRmFjdG9yKSB7XG4gICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgcGFydEN1cnJlbnQsXG4gICAgICBsYXN0TG9hZGVkRnJhZ0xldmVsOiBjdXJyZW50TGV2ZWxcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcy5obHM7XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbY3VycmVudExldmVsXTtcbiAgICBjb25zdCBsaXZlID0gISEobGV2ZWwgIT0gbnVsbCAmJiAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSAhPSBudWxsICYmIF9sZXZlbCRkZXRhaWxzLmxpdmUpO1xuICAgIGNvbnN0IGN1cnJlbnRDb2RlY1NldCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5jb2RlY1NldDtcbiAgICBjb25zdCBjdXJyZW50RnJhZ0R1cmF0aW9uID0gcGFydEN1cnJlbnQgPyBwYXJ0Q3VycmVudC5kdXJhdGlvbiA6IGZyYWdDdXJyZW50ID8gZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwO1xuICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZVNlYyA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCkgLyAxMDAwO1xuICAgIGxldCBsZXZlbFNraXBwZWRNaW4gPSBtaW5BdXRvTGV2ZWw7XG4gICAgbGV0IGxldmVsU2tpcHBlZE1heCA9IC0xO1xuICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1tpXTtcbiAgICAgIGlmICghbGV2ZWxJbmZvIHx8IGN1cnJlbnRDb2RlY1NldCAmJiBsZXZlbEluZm8uY29kZWNTZXQgIT09IGN1cnJlbnRDb2RlY1NldCkge1xuICAgICAgICBpZiAobGV2ZWxJbmZvKSB7XG4gICAgICAgICAgbGV2ZWxTa2lwcGVkTWluID0gTWF0aC5taW4oaSwgbGV2ZWxTa2lwcGVkTWluKTtcbiAgICAgICAgICBsZXZlbFNraXBwZWRNYXggPSBNYXRoLm1heChpLCBsZXZlbFNraXBwZWRNYXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsU2tpcHBlZE1heCAhPT0gLTEpIHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKGBbYWJyXSBTa2lwcGVkIGxldmVsKHMpICR7bGV2ZWxTa2lwcGVkTWlufS0ke2xldmVsU2tpcHBlZE1heH0gd2l0aCBDT0RFQ1M6XCIke2xldmVsc1tsZXZlbFNraXBwZWRNYXhdLmF0dHJzLkNPREVDU31cIjsgbm90IGNvbXBhdGlibGUgd2l0aCBcIiR7bGV2ZWwuYXR0cnMuQ09ERUNTfVwiYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICAgIGNvbnN0IGF2Z0R1cmF0aW9uID0gKHBhcnRDdXJyZW50ID8gbGV2ZWxEZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbERldGFpbHMucGFydFRhcmdldCA6IGxldmVsRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbikgfHwgY3VycmVudEZyYWdEdXJhdGlvbjtcbiAgICAgIGxldCBhZGp1c3RlZGJ3O1xuICAgICAgLy8gZm9sbG93IGFsZ29yaXRobSBjYXB0dXJlZCBmcm9tIHN0YWdlZnJpZ2h0IDpcbiAgICAgIC8vIGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYXYvKy9tYXN0ZXIvbWVkaWEvbGlic3RhZ2VmcmlnaHQvaHR0cGxpdmUvTGl2ZVNlc3Npb24uY3BwXG4gICAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICAgIC8vIGNvbnNpZGVyIG9ubHkgODAlIG9mIHRoZSBhdmFpbGFibGUgYmFuZHdpZHRoLCBidXQgaWYgd2UgYXJlIHN3aXRjaGluZyB1cCxcbiAgICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAvLyBzd2l0Y2hpbmcgYmFjay5cbiAgICAgIGlmIChpIDw9IGN1cnJlbnRMZXZlbCkge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpdHJhdGUgPSBsZXZlbHNbaV0ubWF4Qml0cmF0ZTtcbiAgICAgIGNvbnN0IGZldGNoRHVyYXRpb24gPSB0aGlzLmdldFRpbWVUb0xvYWRGcmFnKHR0ZmJFc3RpbWF0ZVNlYywgYWRqdXN0ZWRidywgYml0cmF0ZSAqIGF2Z0R1cmF0aW9uLCBsZXZlbERldGFpbHMgPT09IHVuZGVmaW5lZCk7XG4gICAgICBsb2dnZXIudHJhY2UoYFthYnJdIGxldmVsOiR7aX0gYWRqdXN0ZWRidy1iaXRyYXRlOiR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3IC0gYml0cmF0ZSl9IGF2Z0R1cmF0aW9uOiR7YXZnRHVyYXRpb24udG9GaXhlZCgxKX0gbWF4RmV0Y2hEdXJhdGlvbjoke21heEZldGNoRHVyYXRpb24udG9GaXhlZCgxKX0gZmV0Y2hEdXJhdGlvbjoke2ZldGNoRHVyYXRpb24udG9GaXhlZCgxKX1gKTtcbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmIChcbiAgICAgIC8vIGZyYWdtZW50IGZldGNoRHVyYXRpb24gdW5rbm93biBPUiBsaXZlIHN0cmVhbSBPUiBmcmFnbWVudCBmZXRjaER1cmF0aW9uIGxlc3MgdGhhbiBtYXggYWxsb3dlZCBmZXRjaCBkdXJhdGlvbiwgdGhlbiB0aGlzIGxldmVsIG1hdGNoZXNcbiAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgc3RhcnRMZXZlbCA9IC0xIChiaXRyYXRlVGVzdCkgb24gbGl2ZSBzdHJlYW1zIDogaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBub3QgZXhpdCBsb29wIHNvIHRoYXQgZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxuICAgICAgZmV0Y2hEdXJhdGlvbiA9PT0gMCB8fCAhaXNGaW5pdGVOdW1iZXIoZmV0Y2hEdXJhdGlvbikgfHwgbGl2ZSAmJiAhdGhpcy5iaXRyYXRlVGVzdERlbGF5IHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKSkge1xuICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgfVxufVxuXG5jbGFzcyBDaHVua0NhY2hlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICB9XG4gIHB1c2goY2h1bmspIHtcbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLmRhdGFMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNodW5rcyxcbiAgICAgIGRhdGFMZW5ndGhcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghY2h1bmtzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH0gZWxzZSBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmVzdWx0ID0gY2h1bmtzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjb25jYXRVaW50OEFycmF5cyhjaHVua3MsIGRhdGFMZW5ndGgpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmNodW5rcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCkge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwkMSA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuY2xhc3MgQXVkaW9TdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSB7XG4gICAgc3VwZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgJ1thdWRpby1zdHJlYW0tY29udHJvbGxlcl0nLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy52aWRlb1RyYWNrQ0MgPSAtMTtcbiAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gLTE7XG4gICAgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuXG4gIC8vIElOSVRfUFRTX0ZPVU5EIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB2aWRlbyB0cmFjayBwYXJzZWQgaW4gdGhlIHN0cmVhbS1jb250cm9sbGVyIGhhcyBhIG5ldyBQVFMgdmFsdWVcbiAgb25Jbml0UHRzRm91bmQoZXZlbnQsIHtcbiAgICBmcmFnLFxuICAgIGlkLFxuICAgIGluaXRQVFMsXG4gICAgdGltZXNjYWxlXG4gIH0pIHtcbiAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBuZXcgSU5JVCBQVFNcbiAgICAvLyBDYW4gY2hhbmdlIGR1ZSBsZXZlbCBzd2l0Y2hcbiAgICBpZiAoaWQgPT09ICdtYWluJykge1xuICAgICAgY29uc3QgY2MgPSBmcmFnLmNjO1xuICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0ge1xuICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coYEluaXRQVFMgZm9yIGNjOiAke2NjfSBmb3VuZCBmcm9tIG1haW46ICR7aW5pdFBUU31gKTtcbiAgICAgIHRoaXMudmlkZW9UcmFja0NDID0gY2M7XG4gICAgICAvLyBJZiB3ZSBhcmUgd2FpdGluZywgdGljayBpbW1lZGlhdGVseSB0byB1bmJsb2NrIGF1ZGlvIGZyYWdtZW50IHRyYW5zbXV4aW5nXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwkMSk7XG4gICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIHRoaXMubG9nKGBPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgc3RhcnRQb3NpdGlvbiA9IGxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIGRvVGljaygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX1RSQUNLOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9sZXZlbHMkdHJhY2tJZDtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsZXZlbHMsXG4gICAgICAgICAgICB0cmFja0lkXG4gICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgZGV0YWlscyA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogKF9sZXZlbHMkdHJhY2tJZCA9IGxldmVsc1t0cmFja0lkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbHMkdHJhY2tJZC5kZXRhaWxzO1xuICAgICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdSZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCh0aGlzLnRyYWNrSWQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfSU5JVF9QVFM6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xuICAgICAgICAgIGNvbnN0IHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YTtcbiAgICAgICAgICBpZiAod2FpdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgICAgICB9ID0gd2FpdGluZ0RhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0UFRTW2ZyYWcuY2NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGNhY2hlLmZsdXNoKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHN1cGVyLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZpZGVvVHJhY2tDQyAhPT0gdGhpcy53YWl0aW5nVmlkZW9DQykge1xuICAgICAgICAgICAgICAvLyBEcm9wIHdhaXRpbmcgZnJhZ21lbnQgaWYgdmlkZW9UcmFja0NDIGhhcyBjaGFuZ2VkIHNpbmNlIHdhaXRpbmdGcmFnbWVudCB3YXMgc2V0IGFuZCBpbml0UFRTIHdhcyBub3QgZm91bmRcbiAgICAgICAgICAgICAgdGhpcy5sb2coYFdhaXRpbmcgZnJhZ21lbnQgY2MgKCR7ZnJhZy5jY30pIGNhbmNlbGxlZCBiZWNhdXNlIHZpZGVvIGlzIGF0IGNjICR7dGhpcy52aWRlb1RyYWNrQ0N9YCk7XG4gICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIERyb3Agd2FpdGluZyBmcmFnbWVudCBpZiBhbiBlYXJsaWVyIGZyYWdtZW50IGlzIG5lZWRlZFxuICAgICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcG9zLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgICAgICAgICAgY29uc3Qgd2FpdGluZ0ZyYWdtZW50QXRQb3NpdGlvbiA9IGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJJbmZvLmVuZCwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZyk7XG4gICAgICAgICAgICAgIGlmICh3YWl0aW5nRnJhZ21lbnRBdFBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKGBXYWl0aW5nIGZyYWdtZW50IGNjICgke2ZyYWcuY2N9KSBAICR7ZnJhZy5zdGFydH0gY2FuY2VsbGVkIGJlY2F1c2UgYW5vdGhlciBmcmFnbWVudCBhdCAke2J1ZmZlckluZm8uZW5kfSBpcyBuZWVkZWRgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyV2FpdGluZ0ZyYWdtZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH1cbiAgY2xlYXJXYWl0aW5nRnJhZ21lbnQoKSB7XG4gICAgY29uc3Qgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuICAgIGlmICh3YWl0aW5nRGF0YSkge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQod2FpdGluZ0RhdGEuZnJhZyk7XG4gICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgIHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgfVxuICByZXNldExvYWRpbmdTdGF0ZSgpIHtcbiAgICB0aGlzLmNsZWFyV2FpdGluZ0ZyYWdtZW50KCk7XG4gICAgc3VwZXIucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgfVxuICBvblRpY2tFbmQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIShtZWRpYSAhPSBudWxsICYmIG1lZGlhLnJlYWR5U3RhdGUpKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfVxuICBkb1RpY2tJZGxlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIGxldmVscyxcbiAgICAgIG1lZGlhLFxuICAgICAgdHJhY2tJZFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW3RyYWNrSWRdKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIG5vdCBlbmFibGVkXG4gICAgLy8gZXhpdCBsb29wXG4gICAgLy8gPT4gaWYgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuICAgIGlmICghbWVkaWEgJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBjb25zdCB0cmFja0RldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICBpZiAoIXRyYWNrRGV0YWlscyB8fCB0cmFja0RldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gdHJhY2tJZCB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4odHJhY2tEZXRhaWxzKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmFibGUgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgaWYgKHRoaXMuYnVmZmVyRmx1c2hlZCAmJiBidWZmZXJhYmxlKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKGJ1ZmZlcmFibGUsIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKGJ1ZmZlcmFibGUsIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKTtcbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBidWZmZXJlZFRyYWNrLFxuICAgICAgc3dpdGNoaW5nVHJhY2tcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXN3aXRjaGluZ1RyYWNrICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIHRyYWNrRGV0YWlscykpIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCB7XG4gICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYWluQnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLnZpZGVvQnVmZmVyID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWEsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIGNvbnN0IGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuICAgIGNvbnN0IG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJJbmZvID09IG51bGwgPyB2b2lkIDAgOiBtYWluQnVmZmVySW5mby5sZW4pO1xuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4gJiYgIXN3aXRjaGluZ1RyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3Qgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgbGV0IHRhcmdldEJ1ZmZlclRpbWUgPSBidWZmZXJJbmZvLmVuZDtcbiAgICBpZiAoc3dpdGNoaW5nVHJhY2sgJiYgbWVkaWEpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICBpZiAoYnVmZmVyZWRUcmFjayAmJiBzd2l0Y2hpbmdUcmFjay5hdHRycyAhPT0gYnVmZmVyZWRUcmFjay5hdHRycykge1xuICAgICAgICB0YXJnZXRCdWZmZXJUaW1lID0gcG9zO1xuICAgICAgfVxuICAgICAgLy8gaWYgY3VycmVudFRpbWUgKHBvcykgaXMgbGVzcyB0aGFuIGFsdCBhdWRpbyBwbGF5bGlzdCBzdGFydCB0aW1lLCBpdCBtZWFucyB0aGF0IGFsdCBhdWRpbyBpcyBhaGVhZCBvZiBjdXJyZW50VGltZVxuICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xuICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgIGlmIChidWZmZXJJbmZvLmVuZCA+IHN0YXJ0IHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5sb2coJ0FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnQgKyAwLjA1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgdHJhY2tEZXRhaWxzKTtcbiAgICBsZXQgYXRHYXAgPSBmYWxzZTtcbiAgICAvLyBBdm9pZCBsb29wIGxvYWRpbmcgYnkgdXNpbmcgbmV4dExvYWRQb3NpdGlvbiBzZXQgZm9yIGJhY2t0cmFja2luZyBhbmQgc2tpcHBpbmcgY29uc2VjdXRpdmUgR0FQIHRhZ3NcbiAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgIGF0R2FwID0gISFmcmFnLmdhcDtcbiAgICAgIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGZyYWcsIHRyYWNrRGV0YWlscywgYnVmZmVySW5mbywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgbWF4QnVmTGVuKTtcbiAgICB9XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBhdWRpbyB1cCB0byBvbmUgdGFyZ2V0IGR1cmF0aW9uIGFoZWFkIG9mIG1haW4gYnVmZmVyXG4gICAgY29uc3QgYXRCdWZmZXJTeW5jTGltaXQgPSBtYWluQnVmZmVySW5mbyAmJiBmcmFnLnN0YXJ0ID4gbWFpbkJ1ZmZlckluZm8uZW5kICsgdHJhY2tEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmIChhdEJ1ZmZlclN5bmNMaW1pdCB8fFxuICAgIC8vIE9yIHdhaXQgZm9yIG1haW4gYnVmZmVyIGFmdGVyIGJ1ZmZpbmcgc29tZSBhdWRpb1xuICAgICEobWFpbkJ1ZmZlckluZm8gIT0gbnVsbCAmJiBtYWluQnVmZmVySW5mby5sZW4pICYmIGJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICAvLyBDaGVjayBmcmFnbWVudC10cmFja2VyIGZvciBtYWluIGZyYWdtZW50cyBzaW5jZSBHQVAgc2VnbWVudHMgZG8gbm90IHNob3cgdXAgaW4gYnVmZmVySW5mb1xuICAgICAgY29uc3QgbWFpbkZyYWcgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhmcmFnLnN0YXJ0LCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgIGlmIChtYWluRnJhZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBCcmlkZ2UgZ2FwcyBpbiBtYWluIGJ1ZmZlclxuICAgICAgYXRHYXAgfHwgKGF0R2FwID0gISFtYWluRnJhZy5nYXAgfHwgISFhdEJ1ZmZlclN5bmNMaW1pdCAmJiBtYWluQnVmZmVySW5mby5sZW4gPT09IDApO1xuICAgICAgaWYgKGF0QnVmZmVyU3luY0xpbWl0ICYmICFhdEdhcCB8fCBhdEdhcCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCA8IG1haW5GcmFnLmVuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsSW5mbywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gIH1cbiAgZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICBjb25zdCBtYXhDb25maWdCdWZmZXIgPSBzdXBlci5nZXRNYXhCdWZmZXJMZW5ndGgoKTtcbiAgICBpZiAoIW1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXhDb25maWdCdWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtYXhDb25maWdCdWZmZXIsIG1haW5CdWZmZXJMZW5ndGgpLCB0aGlzLmNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgc3VwZXIub25NZWRpYURldGFjaGluZygpO1xuICB9XG4gIG9uQXVkaW9UcmFja3NVcGRhdGVkKGV2ZW50LCB7XG4gICAgYXVkaW9UcmFja3NcbiAgfSkge1xuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5sZXZlbHMgPSBhdWRpb1RyYWNrcy5tYXAobWVkaWFQbGF5bGlzdCA9PiBuZXcgTGV2ZWwobWVkaWFQbGF5bGlzdCkpO1xuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoZnJhZ0N1cnJlbnQuc3RhcnQpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgLy8gZGVzdHJveSB1c2VsZXNzIHRyYW5zbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDEpO1xuICAgIH1cblxuICAgIC8vIHNob3VsZCB3ZSBzd2l0Y2ggdHJhY2tzID9cbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBkYXRhO1xuICAgICAgLy8gbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gZGF0YTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5idWZmZXJGbHVzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5sZXZlbHMgPSB0aGlzLm1haW5EZXRhaWxzID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMuYnVmZmVyZWRUcmFjayA9IHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRyYWNrSWQgPSB0aGlzLnZpZGVvVHJhY2tDQyA9IHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICBpZiAodGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEpO1xuICAgICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBudWxsO1xuICAgIH1cbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RyYWNrJGRldGFpbHM7XG4gICAgaWYgKHRoaXMubWFpbkRldGFpbHMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgaWQ6IHRyYWNrSWRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBBdWRpbyB0cmFja3Mgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsICR7dHJhY2tJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFRyYWNrICR7dHJhY2tJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0ke25ld0RldGFpbHMubGFzdFBhcnRTbiA/IGBbcGFydC0ke25ld0RldGFpbHMubGFzdFBhcnRTbn0tJHtuZXdEZXRhaWxzLmxhc3RQYXJ0SW5kZXh9XWAgOiAnJ30sZHVyYXRpb246JHtuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb259YCk7XG4gICAgY29uc3QgdHJhY2sgPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF90cmFjayRkZXRhaWxzID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmNoZWNrTGl2ZVVwZGF0ZShuZXdEZXRhaWxzKTtcbiAgICAgIGNvbnN0IG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkIHx8ICFtYWluRGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRyYWNrLmRldGFpbHMgJiYgbmV3RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgbWFpbkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgYXVkaW8gcmVuZGl0aW9uIGlzIGFsaWduZWQgd2l0aCB0aGUgXCJtYWluXCIgcmVuZGl0aW9uLCB1c2luZ1xuICAgICAgICAvLyBwZHQgYXMgb3VyIHJlZmVyZW5jZSB0aW1lcy5cbiAgICAgICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQobmV3RGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCB0cmFjay5kZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSB0cmFja0lkO1xuXG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiB3ZSBhcmUgYWxpZ25lZCB3aXRoIHRoZSBtYWluIHBsYXlsaXN0XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAodGhpcy5tYWluRGV0YWlscyB8fCAhbmV3RGV0YWlscy5saXZlKSkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKHRyYWNrLmRldGFpbHMsIHNsaWRpbmcpO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciB0cmFjayB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLICYmICF0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICB0cmFja0lkLFxuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgQXVkaW8gdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSB3aWxsIG5vdCBiZSBidWZmZXJlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICB0aGlzLndhcm4oJ0F1ZGlvIHRyYWNrIGlzIHVuZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKCdBdWRpbyB0cmFjayBkZXRhaWxzIHVuZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgICB0aGlzLnJlbW92ZVVuYnVmZmVyZWRGcmFncyhmcmFnLnN0YXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Db2RlYyA9IGNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjIHx8ICdtcDRhLjQwLjInO1xuICAgIGxldCB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVySW50ZXJmYWNlKHRoaXMuaGxzLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTywgdGhpcy5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZS5iaW5kKHRoaXMpLCB0aGlzLl9oYW5kbGVUcmFuc211eGVyRmx1c2guYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB2aWRlbyBpbml0UFRTXG4gICAgLy8gSWYgbm90IHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIGNvbnN0IGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuICAgIGlmIChpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoaXMubG9nKGBUcmFuc211eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgIGNvbnN0IGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvLyBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgICBjb25zdCBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgICAgY29uc3QgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgICBjb25zdCBjaHVua01ldGEgPSBuZXcgQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQsIHBheWxvYWQuYnl0ZUxlbmd0aCwgcGFydEluZGV4LCBwYXJ0aWFsKTtcbiAgICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsICcnLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2coYFVua25vd24gdmlkZW8gUFRTIGZvciBjYyAke2ZyYWcuY2N9LCB3YWl0aW5nIGZvciB2aWRlbyBQVFMgYmVmb3JlIGRlbXV4aW5nIGF1ZGlvIGZyYWcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhY2hlXG4gICAgICB9ID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGEgfHwge1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBjYWNoZTogbmV3IENodW5rQ2FjaGUoKSxcbiAgICAgICAgY29tcGxldGU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY2FjaGUucHVzaChuZXcgVWludDhBcnJheShwYXlsb2FkKSk7XG4gICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gdGhpcy52aWRlb1RyYWNrQ0M7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICB9XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWREYXRhKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0RhdGEpIHtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEuY29tcGxldGUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpO1xuICB9XG4gIG9uQnVmZmVyUmVzZXQoIC8qIGV2ZW50OiBFdmVudHMuQlVGRkVSX1JFU0VUICovXG4gICkge1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBzb3VyY2VidWZmZXJzXG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gZGF0YS50cmFja3MuYXVkaW87XG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlciB8fCBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS50cmFja3MudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBkYXRhLnRyYWNrcy52aWRlby5idWZmZXIgfHwgbnVsbDtcbiAgICB9XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKSB7XG4gICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmFibGUgPSB0aGlzLnZpZGVvQnVmZmVyIHx8IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChidWZmZXJhYmxlKSB7XG4gICAgICAgICAgY29uc3QgYnVmZmVyZWRUaW1lUmFuZ2VzID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKGJ1ZmZlcmFibGUpO1xuICAgICAgICAgIGlmIChidWZmZXJlZFRpbWVSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAvLyBJZiBhIGxldmVsIHN3aXRjaCB3YXMgcmVxdWVzdGVkIHdoaWxlIGEgZnJhZ21lbnQgd2FzIGJ1ZmZlcmluZywgaXQgd2lsbCBlbWl0IHRoZSBGUkFHX0JVRkZFUkVEIGV2ZW50IHVwb24gY29tcGxldGlvblxuICAgICAgLy8gQXZvaWQgc2V0dGluZyBzdGF0ZSBiYWNrIHRvIElETEUgb3IgY29uY2x1ZGluZyB0aGUgYXVkaW8gc3dpdGNoOyBvdGhlcndpc2UsIHRoZSBzd2l0Y2hlZC10byB0cmFjayB3aWxsIG5vdCBidWZmZXJcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcDogJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBmaW5pc2hlZCBidWZmZXJpbmcsIGJ1dCB3YXMgYWJvcnRlZC4gc3RhdGU6ICR7dGhpcy5zdGF0ZX0sIGF1ZGlvU3dpdGNoOiAke3RoaXMuc3dpdGNoaW5nVHJhY2sgPyB0aGlzLnN3aXRjaGluZ1RyYWNrLm5hbWUgOiAnZmFsc2UnfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnN3aXRjaGluZ1RyYWNrO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIF9vYmplY3RTcHJlYWQyKHt9LCB0cmFjaykpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkY29udGV4dDtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19HQVA6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRyYWNrLCBpZiBub3QgcmV0cnlpbmcgdG8gbG9hZCB0cmFjaywgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLICYmICgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGNvbnRleHQudHlwZSkgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0spIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICBpZiAoIWRhdGEucGFyZW50IHx8IGRhdGEucGFyZW50ICE9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbDtcbiAgICAgICAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnYXVkaW8nKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIHtcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBpZiAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCkge1xuICAgIHZhciBfaWQzJHNhbXBsZXM7XG4gICAgY29uc3QgaWQgPSAnYXVkaW8nO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgY2h1bmtNZXRhXG4gICAgfSA9IHRyYW5zbXV4UmVzdWx0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgbGV2ZWxcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGxldmVsO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvLFxuICAgICAgdGV4dCxcbiAgICAgIGlkMyxcbiAgICAgIGluaXRTZWdtZW50XG4gICAgfSA9IHJlbXV4UmVzdWx0O1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgfHwgIWRldGFpbHMpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICBpZiAodGhpcy5zd2l0Y2hpbmdUcmFjayAmJiBhdWRpbykge1xuICAgICAgdGhpcy5jb21wbGV0ZUF1ZGlvU3dpdGNoKHRoaXMuc3dpdGNoaW5nVHJhY2spO1xuICAgIH1cbiAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgIGNvbnN0IG1hcEZyYWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCB8fCBmcmFnO1xuICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQudHJhY2tzLCBtYXBGcmFnbWVudCwgY2h1bmtNZXRhKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgIGZyYWc6IG1hcEZyYWdtZW50LFxuICAgICAgICBpZCxcbiAgICAgICAgdHJhY2tzOiBpbml0U2VnbWVudC50cmFja3NcbiAgICAgIH0pO1xuICAgICAgLy8gT25seSBmbHVzaCBhdWRpbyBmcm9tIG9sZCBhdWRpbyB0cmFja3Mgd2hlbiBQVFMgaXMga25vd24gb24gbmV3IGF1ZGlvIHRyYWNrXG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICBlbmREVFNcbiAgICAgIH0gPSBhdWRpbztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG4gICAgaWYgKGlkMyAhPSBudWxsICYmIChfaWQzJHNhbXBsZXMgPSBpZDMuc2FtcGxlcykgIT0gbnVsbCAmJiBfaWQzJHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbWl0dGVkSUQzID0gX2V4dGVuZHMoe1xuICAgICAgICBpZCxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZGV0YWlsc1xuICAgICAgfSwgaWQzKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAodGV4dCkge1xuICAgICAgY29uc3QgZW1pdHRlZFRleHQgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzXG4gICAgICB9LCB0ZXh0KTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICB9XG4gIH1cbiAgX2J1ZmZlckluaXRTZWdtZW50KHRyYWNrcywgZnJhZywgY2h1bmtNZXRhKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGVsZXRlIGFueSB2aWRlbyB0cmFjayBmb3VuZCBvbiBhdWRpbyB0cmFuc211eGVyXG4gICAgaWYgKHRyYWNrcy52aWRlbykge1xuICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcbiAgICB9XG5cbiAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhY2subGV2ZWxDb2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgIHRyYWNrLmlkID0gJ2F1ZGlvJztcbiAgICB0aGlzLmxvZyhgSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sIGNvZGVjc1twYXJzZWRdPVske3RyYWNrLmNvZGVjfV1gKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgIGNvbnN0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgaWYgKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc3Qgc2VnbWVudCA9IHtcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgZGF0YTogaW5pdFNlZ21lbnRcbiAgICAgIH07XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICB9XG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIGxvYWRGcmFnbWVudChmcmFnLCB0cmFjaywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkIG9yIGlmIGluIGF1ZGlvIHN3aXRjaFxuICAgIGNvbnN0IGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuXG4gICAgLy8gd2UgZm9yY2UgYSBmcmFnIGxvYWRpbmcgaW4gYXVkaW8gc3dpdGNoIGFzIGZyYWdtZW50IHRyYWNrZXIgbWlnaHQgbm90IGhhdmUgZXZpY3RlZCBwcmV2aW91cyBmcmFncyBpbiBjYXNlIG9mIHF1aWNrIGF1ZGlvIHN3aXRjaFxuICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyYWNrIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICB2YXIgX3RyYWNrJGRldGFpbHMyO1xuICAgICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgdGhpcy5fbG9hZEluaXRTZWdtZW50KGZyYWcsIHRyYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoKF90cmFjayRkZXRhaWxzMiA9IHRyYWNrLmRldGFpbHMpICE9IG51bGwgJiYgX3RyYWNrJGRldGFpbHMyLmxpdmUgJiYgIXRoaXMuaW5pdFBUU1tmcmFnLmNjXSkge1xuICAgICAgICB0aGlzLmxvZyhgV2FpdGluZyBmb3IgdmlkZW8gUFRTIGluIGNvbnRpbnVpdHkgY291bnRlciAke2ZyYWcuY2N9IG9mIGxpdmUgc3RyZWFtIGJlZm9yZSBsb2FkaW5nIGF1ZGlvIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHt0aGlzLnRyYWNrSWR9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBzdXBlci5sb2FkRnJhZ21lbnQoZnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgIH1cbiAgfVxuICBjb21wbGV0ZUF1ZGlvU3dpdGNoKHN3aXRjaGluZ1RyYWNrKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgbWVkaWEsXG4gICAgICBidWZmZXJlZFRyYWNrXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgYnVmZmVyZWRBdHRyaWJ1dGVzID0gYnVmZmVyZWRUcmFjayA9PSBudWxsID8gdm9pZCAwIDogYnVmZmVyZWRUcmFjay5hdHRycztcbiAgICBjb25zdCBzd2l0Y2hBdHRyaWJ1dGVzID0gc3dpdGNoaW5nVHJhY2suYXR0cnM7XG4gICAgaWYgKG1lZGlhICYmIGJ1ZmZlcmVkQXR0cmlidXRlcyAmJiAoYnVmZmVyZWRBdHRyaWJ1dGVzLkNIQU5ORUxTICE9PSBzd2l0Y2hBdHRyaWJ1dGVzLkNIQU5ORUxTIHx8IGJ1ZmZlcmVkQXR0cmlidXRlcy5OQU1FICE9PSBzd2l0Y2hBdHRyaWJ1dGVzLk5BTUUgfHwgYnVmZmVyZWRBdHRyaWJ1dGVzLkxBTkdVQUdFICE9PSBzd2l0Y2hBdHRyaWJ1dGVzLkxBTkdVQUdFKSkge1xuICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xuICAgICAgc3VwZXIuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJ2F1ZGlvJyk7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IHN3aXRjaGluZ1RyYWNrO1xuICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgX29iamVjdFNwcmVhZDIoe30sIHN3aXRjaGluZ1RyYWNrKSk7XG4gIH1cbn1cblxuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCAnW2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXJdJyk7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmdyb3VwSWQgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy50cmFja3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoID0gMDtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gIH1cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGV0YWlsc1xuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHRyYWNrSW5BY3RpdmVHcm91cCA9IHRoaXMudHJhY2tzSW5Hcm91cFtpZF07XG4gICAgaWYgKCF0cmFja0luQWN0aXZlR3JvdXAgfHwgdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWQgIT09IGdyb3VwSWQpIHtcbiAgICAgIHRoaXMud2FybihgVHJhY2sgd2l0aCBpZDoke2lkfSBhbmQgZ3JvdXA6JHtncm91cElkfSBub3QgZm91bmQgaW4gYWN0aXZlIGdyb3VwICR7dHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1ckRldGFpbHMgPSB0cmFja0luQWN0aXZlR3JvdXAuZGV0YWlscztcbiAgICB0cmFja0luQWN0aXZlR3JvdXAuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB0aGlzLmxvZyhgYXVkaW8tdHJhY2sgJHtpZH0gXCIke3RyYWNrSW5BY3RpdmVHcm91cC5uYW1lfVwiIGxhbmc6JHt0cmFja0luQWN0aXZlR3JvdXAubGFuZ30gZ3JvdXA6JHtncm91cElkfSBsb2FkZWQgWyR7ZGV0YWlscy5zdGFydFNOfS0ke2RldGFpbHMuZW5kU059XWApO1xuICAgIGlmIChpZCA9PT0gdGhpcy50cmFja0lkKSB7XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGlkLCBkYXRhLCBjdXJEZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICB9XG4gIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICB9XG4gIHN3aXRjaExldmVsKGxldmVsSW5kZXgpIHtcbiAgICBjb25zdCBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgaWYgKCEobGV2ZWxJbmZvICE9IG51bGwgJiYgbGV2ZWxJbmZvLmF1ZGlvR3JvdXBJZHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvR3JvdXBJZCA9IGxldmVsSW5mby5hdWRpb0dyb3VwSWRzW2xldmVsSW5mby51cmxJZF07XG4gICAgaWYgKHRoaXMuZ3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICB0aGlzLmdyb3VwSWQgPSBhdWRpb0dyb3VwSWQgfHwgbnVsbDtcbiAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKHRyYWNrID0+ICFhdWRpb0dyb3VwSWQgfHwgdHJhY2suZ3JvdXBJZCA9PT0gYXVkaW9Hcm91cElkKTtcblxuICAgICAgLy8gRGlzYWJsZSBzZWxlY3REZWZhdWx0VHJhY2sgaWYgdGhlcmUgYXJlIG5vIGRlZmF1bHQgdHJhY2tzXG4gICAgICBpZiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIWF1ZGlvVHJhY2tzLnNvbWUodHJhY2sgPT4gdHJhY2suZGVmYXVsdCkpIHtcbiAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IGF1ZGlvVHJhY2tzO1xuICAgICAgY29uc3QgYXVkaW9UcmFja3NVcGRhdGVkID0ge1xuICAgICAgICBhdWRpb1RyYWNrc1xuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKGBVcGRhdGluZyBhdWRpbyB0cmFja3MsICR7YXVkaW9UcmFja3MubGVuZ3RofSB0cmFjayhzKSBmb3VuZCBpbiBncm91cDoke2F1ZGlvR3JvdXBJZH1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCBhdWRpb1RyYWNrc1VwZGF0ZWQpO1xuICAgICAgdGhpcy5zZWxlY3RJbml0aWFsVHJhY2soKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkUmVsb2FkUGxheWxpc3QodGhpcy5jdXJyZW50VHJhY2spKSB7XG4gICAgICAvLyBSZXRyeSBwbGF5bGlzdCBsb2FkaW5nIGlmIG5vIHBsYXlsaXN0IGlzIG9yIGhhcyBiZWVuIGxvYWRlZCB5ZXRcbiAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayh0aGlzLnRyYWNrSWQpO1xuICAgIH1cbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgZGF0YS5jb250ZXh0LmlkID09PSB0aGlzLnRyYWNrSWQgJiYgZGF0YS5jb250ZXh0Lmdyb3VwSWQgPT09IHRoaXMuZ3JvdXBJZCkge1xuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgfVxuICB9XG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3NJbkdyb3VwO1xuICB9XG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cbiAgc2V0IGF1ZGlvVHJhY2sobmV3SWQpIHtcbiAgICAvLyBJZiBhdWRpbyB0cmFjayBpcyBzZWxlY3RlZCBmcm9tIEFQSSB0aGVuIGRvbid0IGNob29zZSBmcm9tIHRoZSBtYW5pZmVzdCBkZWZhdWx0IHRyYWNrXG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnNldEF1ZGlvVHJhY2sobmV3SWQpO1xuICB9XG4gIHNldEF1ZGlvVHJhY2sobmV3SWQpIHtcbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG5cbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3SWQgPCAwIHx8IG5ld0lkID49IHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybignSW52YWxpZCBpZCBwYXNzZWQgdG8gYXVkaW8tdHJhY2sgY29udHJvbGxlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIGNvbnN0IGxhc3RUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIHRyYWNrc1t0aGlzLnRyYWNrSWRdO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW25ld0lkXTtcbiAgICBjb25zdCB7XG4gICAgICBncm91cElkLFxuICAgICAgbmFtZVxuICAgIH0gPSB0cmFjaztcbiAgICB0aGlzLmxvZyhgU3dpdGNoaW5nIHRvIGF1ZGlvLXRyYWNrICR7bmV3SWR9IFwiJHtuYW1lfVwiIGxhbmc6JHt0cmFjay5sYW5nfSBncm91cDoke2dyb3VwSWR9YCk7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSB0cmFjaztcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgX29iamVjdFNwcmVhZDIoe30sIHRyYWNrKSk7XG4gICAgLy8gRG8gbm90IHJlbG9hZCB0cmFjayB1bmxlc3MgbGl2ZVxuICAgIGlmICh0cmFjay5kZXRhaWxzICYmICF0cmFjay5kZXRhaWxzLmxpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKHRyYWNrLnVybCwgbGFzdFRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBsYXN0VHJhY2suZGV0YWlscyk7XG4gICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gIH1cbiAgc2VsZWN0SW5pdGlhbFRyYWNrKCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgIGNvbnN0IHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKHRoaXMuY3VycmVudFRyYWNrKSB8IHRoaXMuZmluZFRyYWNrSWQobnVsbCk7XG4gICAgaWYgKHRyYWNrSWQgIT09IC0xKSB7XG4gICAgICB0aGlzLnNldEF1ZGlvVHJhY2sodHJhY2tJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBObyB0cmFjayBmb3VuZCBmb3IgcnVubmluZyBhdWRpbyBncm91cC1JRDogJHt0aGlzLmdyb3VwSWR9IHRyYWNrIGNvdW50OiAke2F1ZGlvVHJhY2tzLmxlbmd0aH1gKTtcbiAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmaW5kVHJhY2tJZChjdXJyZW50VHJhY2spIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF1ZGlvVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0cmFjayA9IGF1ZGlvVHJhY2tzW2ldO1xuICAgICAgaWYgKCF0aGlzLnNlbGVjdERlZmF1bHRUcmFjayB8fCB0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIGlmICghY3VycmVudFRyYWNrIHx8IGN1cnJlbnRUcmFjay5hdHRyc1snU1RBQkxFLVJFTkRJVElPTi1JRCddICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFRyYWNrLmF0dHJzWydTVEFCTEUtUkVORElUSU9OLUlEJ10gPT09IHRyYWNrLmF0dHJzWydTVEFCTEUtUkVORElUSU9OLUlEJ10pIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2suaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRUcmFjay5uYW1lID09PSB0cmFjay5uYW1lICYmIGN1cnJlbnRUcmFjay5sYW5nID09PSB0cmFjay5sYW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrLmlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHN1cGVyLmxvYWRQbGF5bGlzdCgpO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbdGhpcy50cmFja0lkXTtcbiAgICBpZiAodGhpcy5zaG91bGRMb2FkUGxheWxpc3QoYXVkaW9UcmFjaykpIHtcbiAgICAgIGNvbnN0IGlkID0gYXVkaW9UcmFjay5pZDtcbiAgICAgIGNvbnN0IGdyb3VwSWQgPSBhdWRpb1RyYWNrLmdyb3VwSWQ7XG4gICAgICBsZXQgdXJsID0gYXVkaW9UcmFjay51cmw7XG4gICAgICBpZiAoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IGhsc1VybFBhcmFtZXRlcnMuYWRkRGlyZWN0aXZlcyh1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMud2FybihgQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgIHRoaXMubG9nKGBsb2FkaW5nIGF1ZGlvLXRyYWNrIHBsYXlsaXN0ICR7aWR9IFwiJHthdWRpb1RyYWNrLm5hbWV9XCIgbGFuZzoke2F1ZGlvVHJhY2subGFuZ30gZ3JvdXA6JHtncm91cElkfWApO1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgaWQsXG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRyYWNrTGlzdDEsIHRyYWNrTGlzdDIpIHtcbiAgaWYgKHRyYWNrTGlzdDEubGVuZ3RoICE9PSB0cmFja0xpc3QyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrTGlzdDEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXN1YnRpdGxlQXR0cmlidXRlc0lkZW50aWNhbCh0cmFja0xpc3QxW2ldLmF0dHJzLCB0cmFja0xpc3QyW2ldLmF0dHJzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHN1YnRpdGxlQXR0cmlidXRlc0lkZW50aWNhbChhdHRyczEsIGF0dHJzMikge1xuICAvLyBNZWRpYSBvcHRpb25zIHdpdGggdGhlIHNhbWUgcmVuZGl0aW9uIElEIG11c3QgYmUgYml0IGlkZW50aWNhbFxuICBjb25zdCBzdGFibGVSZW5kaXRpb25JZCA9IGF0dHJzMVsnU1RBQkxFLVJFTkRJVElPTi1JRCddO1xuICBpZiAoc3RhYmxlUmVuZGl0aW9uSWQpIHtcbiAgICByZXR1cm4gc3RhYmxlUmVuZGl0aW9uSWQgPT09IGF0dHJzMlsnU1RBQkxFLVJFTkRJVElPTi1JRCddO1xuICB9XG4gIC8vIFdoZW4gcmVuZGl0aW9uIElEIGlzIG5vdCBwcmVzZW50LCBjb21wYXJlIGF0dHJpYnV0ZXNcbiAgcmV0dXJuICFbJ0xBTkdVQUdFJywgJ05BTUUnLCAnQ0hBUkFDVEVSSVNUSUNTJywgJ0FVVE9TRUxFQ1QnLCAnREVGQVVMVCcsICdGT1JDRUQnXS5zb21lKHN1YnRpdGxlQXR0cmlidXRlID0+IGF0dHJzMVtzdWJ0aXRsZUF0dHJpYnV0ZV0gIT09IGF0dHJzMltzdWJ0aXRsZUF0dHJpYnV0ZV0pO1xufVxuXG5jb25zdCBUSUNLX0lOVEVSVkFMID0gNTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5jbGFzcyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpIHtcbiAgICBzdXBlcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnW3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyXScsIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKTtcbiAgICB0aGlzLmxldmVscyA9IFtdO1xuICAgIHRoaXMuY3VycmVudFRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgdGhpcy5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgc3VwZXIub25NZWRpYURldGFjaGluZygpO1xuICB9XG4gIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICB9XG4gIG9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHN1Y2Nlc3NcbiAgICB9ID0gZGF0YTtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmVkID0gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAoIWJ1ZmZlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlL3VwZGF0ZSBhIGJ1ZmZlcmVkIGFycmF5IG1hdGNoaW5nIHRoZSBpbnRlcmZhY2UgdXNlZCBieSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvXG4gICAgLy8gc28gd2UgY2FuIHJlLXVzZSB0aGUgbG9naWMgdXNlZCB0byBkZXRlY3QgaG93IG11Y2ggaGFzIGJlZW4gYnVmZmVyZWRcbiAgICBsZXQgdGltZVJhbmdlO1xuICAgIGNvbnN0IGZyYWdTdGFydCA9IGZyYWcuc3RhcnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGZyYWdTdGFydCA+PSBidWZmZXJlZFtpXS5zdGFydCAmJiBmcmFnU3RhcnQgPD0gYnVmZmVyZWRbaV0uZW5kKSB7XG4gICAgICAgIHRpbWVSYW5nZSA9IGJ1ZmZlcmVkW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZ0VuZCA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgIHRpbWVSYW5nZS5lbmQgPSBmcmFnRW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lUmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiBmcmFnU3RhcnQsXG4gICAgICAgIGVuZDogZnJhZ0VuZFxuICAgICAgfTtcbiAgICAgIGJ1ZmZlcmVkLnB1c2godGltZVJhbmdlKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcpO1xuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldFxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgY29uc3QgZW5kT2Zmc2V0U3VidGl0bGVzID0gZW5kT2Zmc2V0IC0gMTtcbiAgICAgIGlmIChlbmRPZmZzZXRTdWJ0aXRsZXMgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkYXRhLmVuZE9mZnNldFN1YnRpdGxlcyA9IE1hdGgubWF4KDAsIGVuZE9mZnNldFN1YnRpdGxlcyk7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkLmZvckVhY2goYnVmZmVyZWQgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDspIHtcbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kIDw9IGVuZE9mZnNldFN1YnRpdGxlcykge1xuICAgICAgICAgICAgYnVmZmVyZWQuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgPCBlbmRPZmZzZXRTdWJ0aXRsZXMpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkW2ldLnN0YXJ0ID0gZW5kT2Zmc2V0U3VidGl0bGVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcywgUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpO1xuICAgIH1cbiAgfVxuICBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBkYXRhLmZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgaWYgKChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWVkIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKChmcmFnID09IG51bGwgPyB2b2lkIDAgOiBmcmFnLnR5cGUpID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBHb3QgYWxsIG5ldyBzdWJ0aXRsZSBsZXZlbHMuXG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGV2ZW50LCB7XG4gICAgc3VidGl0bGVUcmFja3NcbiAgfSkge1xuICAgIGlmIChzdWJ0aXRsZU9wdGlvbnNJZGVudGljYWwodGhpcy5sZXZlbHMsIHN1YnRpdGxlVHJhY2tzKSkge1xuICAgICAgdGhpcy5sZXZlbHMgPSBzdWJ0aXRsZVRyYWNrcy5tYXAobWVkaWFQbGF5bGlzdCA9PiBuZXcgTGV2ZWwobWVkaWFQbGF5bGlzdCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy5sZXZlbHMgPSBzdWJ0aXRsZVRyYWNrcy5tYXAobWVkaWFQbGF5bGlzdCA9PiB7XG4gICAgICBjb25zdCBsZXZlbCA9IG5ldyBMZXZlbChtZWRpYVBsYXlsaXN0KTtcbiAgICAgIHRoaXMudHJhY2tzQnVmZmVyZWRbbGV2ZWwuaWRdID0gW107XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfSk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZSgwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKTtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrU3dpdGNoKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgaWYgKCF0aGlzLmxldmVscy5sZW5ndGggfHwgdGhpcy5jdXJyZW50VHJhY2tJZCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRyYWNrIGhhcyB0aGUgbmVjZXNzYXJ5IGRldGFpbHMgdG8gbG9hZCBmcmFnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAoY3VycmVudFRyYWNrICE9IG51bGwgJiYgY3VycmVudFRyYWNrLmRldGFpbHMpIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyVGltZVJhbmdlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdHJhY2skZGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgaWQ6IHRyYWNrSWRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50VHJhY2tJZCxcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IGxldmVsc1tjdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKHRyYWNrSWQgPj0gbGV2ZWxzLmxlbmd0aCB8fCB0cmFja0lkICE9PSBjdXJyZW50VHJhY2tJZCB8fCAhdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgIGxldCBzbGlkaW5nID0gMDtcbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9IG51bGwgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgbWFpbkRldGFpbHMgPSB0aGlzLm1haW5EZXRhaWxzO1xuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgfHwgIW1haW5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCA9IG1haW5EZXRhaWxzLmZyYWdtZW50c1swXTtcbiAgICAgIGlmICghdHJhY2suZGV0YWlscykge1xuICAgICAgICBpZiAobmV3RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgbWFpbkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQobmV3RGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgfSBlbHNlIGlmIChtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAvLyBsaW5lIHVwIGxpdmUgcGxheWxpc3Qgd2l0aCBtYWluIHNvIHRoYXQgZnJhZ21lbnRzIGluIHJhbmdlIGFyZSBsb2FkZWRcbiAgICAgICAgICBzbGlkaW5nID0gbWFpblNsaWRpbmdTdGFydEZyYWdtZW50LnN0YXJ0O1xuICAgICAgICAgIGFkZFNsaWRpbmcobmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIHRyYWNrLmRldGFpbHMpO1xuICAgICAgICBpZiAoc2xpZGluZyA9PT0gMCAmJiBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAvLyByZWFsaWduIHdpdGggbWFpbiB3aGVuIHRoZXJlIGlzIG5vIG92ZXJsYXAgd2l0aCBsYXN0IHJlZnJlc2hcbiAgICAgICAgICBzbGlkaW5nID0gbWFpblNsaWRpbmdTdGFydEZyYWdtZW50LnN0YXJ0O1xuICAgICAgICAgIGFkZFNsaWRpbmcobmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSB0cmFja0lkO1xuICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgKHRoaXMubWFpbkRldGFpbHMgfHwgIW5ld0RldGFpbHMubGl2ZSkpIHtcbiAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbih0cmFjay5kZXRhaWxzLCBzbGlkaW5nKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG5cbiAgICAvLyBJZiBwbGF5bGlzdCBpcyBtaXNhbGlnbmVkIGJlY2F1c2Ugb2YgYmFkIFBEVCBvciBkcmlmdCwgZGVsZXRlIGRldGFpbHMgdG8gcmVzeW5jIHdpdGggbWFpbiBvbiByZWxvYWRcbiAgICBpZiAobmV3RGV0YWlscy5saXZlICYmICF0aGlzLmZyYWdDdXJyZW50ICYmIHRoaXMubWVkaWEgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuSURMRSkge1xuICAgICAgY29uc3QgZm91bmRGcmFnID0gZmluZEZyYWdtZW50QnlQVFMobnVsbCwgbmV3RGV0YWlscy5mcmFnbWVudHMsIHRoaXMubWVkaWEuY3VycmVudFRpbWUsIDApO1xuICAgICAgaWYgKCFmb3VuZEZyYWcpIHtcbiAgICAgICAgdGhpcy53YXJuKCdTdWJ0aXRsZSBwbGF5bGlzdCBub3QgYWxpZ25lZCB3aXRoIHBsYXliYWNrJyk7XG4gICAgICAgIHRyYWNrLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGZyYWdMb2FkZWREYXRhO1xuICAgIGNvbnN0IGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdERhdGEgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIC8vIGRlY3J5cHQgdGhlIHN1YnRpdGxlc1xuICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgcmVhc29uOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICBmcmFnXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KS50aGVuKGRlY3J5cHRlZERhdGEgPT4ge1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSxcbiAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgdHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICB0ZGVjcnlwdDogZW5kVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYCR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkb1RpY2soKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudFRyYWNrSWQsXG4gICAgICAgIGxldmVsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB0cmFjayA9IGxldmVsc1tjdXJyZW50VHJhY2tJZF07XG4gICAgICBpZiAoIWxldmVscy5sZW5ndGggfHwgIXRyYWNrIHx8ICF0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29uZmlnXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8odGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kOiB0YXJnZXRCdWZmZXJUaW1lLFxuICAgICAgICBsZW46IGJ1ZmZlckxlblxuICAgICAgfSA9IGJ1ZmZlcmVkSW5mbztcbiAgICAgIGNvbnN0IG1haW5CdWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWEsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgY29uc3QgdHJhY2tEZXRhaWxzID0gdHJhY2suZGV0YWlscztcbiAgICAgIGNvbnN0IG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJJbmZvID09IG51bGwgPyB2b2lkIDAgOiBtYWluQnVmZmVySW5mby5sZW4pICsgdHJhY2tEZXRhaWxzLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gICAgICBpZiAoYnVmZmVyTGVuID4gbWF4QnVmTGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgICBjb25zdCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZCA9IHRyYWNrRGV0YWlscy5lZGdlO1xuICAgICAgbGV0IGZvdW5kRnJhZyA9IG51bGw7XG4gICAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lIDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICBjb25zdCBsb29rdXBUb2xlcmFuY2UgPSB0YXJnZXRCdWZmZXJUaW1lID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTtcbiAgICAgICAgZm91bmRGcmFnID0gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIE1hdGgubWF4KGZyYWdtZW50c1swXS5zdGFydCwgdGFyZ2V0QnVmZmVyVGltZSksIGxvb2t1cFRvbGVyYW5jZSk7XG4gICAgICAgIGlmICghZm91bmRGcmFnICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc3RhcnQgPCBmcmFnbWVudHNbMF0uc3RhcnQpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kRnJhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3VuZEZyYWcgPSB0aGlzLm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQoZm91bmRGcmFnKTtcbiAgICAgIGlmIChmb3VuZEZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgLy8gTG9hZCBlYXJsaWVyIGZyYWdtZW50IGluIHNhbWUgZGlzY29udGludWl0eSB0byBtYWtlIHVwIGZvciBtaXNhbGlnbmVkIHBsYXlsaXN0cyBhbmQgY3VlcyB0aGF0IGV4dGVuZCBiZXlvbmQgZW5kIG9mIHNlZ21lbnRcbiAgICAgICAgY29uc3QgY3VyU05JZHggPSBmb3VuZEZyYWcuc24gLSB0cmFja0RldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgY29uc3QgcHJldkZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggLSAxXTtcbiAgICAgICAgaWYgKHByZXZGcmFnICYmIHByZXZGcmFnLmNjID09PSBmb3VuZEZyYWcuY2MgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUocHJldkZyYWcpID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZvdW5kRnJhZykgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgICAgICB0aGlzLmxvYWRGcmFnbWVudChmb3VuZEZyYWcsIHRyYWNrLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICBjb25zdCBtYXhDb25maWdCdWZmZXIgPSBzdXBlci5nZXRNYXhCdWZmZXJMZW5ndGgoKTtcbiAgICBpZiAoIW1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXhDb25maWdCdWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heChtYXhDb25maWdCdWZmZXIsIG1haW5CdWZmZXJMZW5ndGgpO1xuICB9XG4gIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZywgbGV2ZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICBzdXBlci5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgIH1cbiAgfVxuICBnZXQgbWVkaWFCdWZmZXJUaW1lUmFuZ2VzKCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyYWJsZUluc3RhbmNlKHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF0gfHwgW10pO1xuICB9XG59XG5jbGFzcyBCdWZmZXJhYmxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3Rvcih0aW1lcmFuZ2VzKSB7XG4gICAgdGhpcy5idWZmZXJlZCA9IHZvaWQgMDtcbiAgICBjb25zdCBnZXRSYW5nZSA9IChuYW1lLCBpbmRleCwgbGVuZ3RoKSA9PiB7XG4gICAgICBpbmRleCA9IGluZGV4ID4+PiAwO1xuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHtuYW1lfScgb24gJ1RpbWVSYW5nZXMnOiBUaGUgaW5kZXggcHJvdmlkZWQgKCR7aW5kZXh9KSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gYm91bmQgKCR7bGVuZ3RofSlgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1lcmFuZ2VzW2luZGV4XVtuYW1lXTtcbiAgICB9O1xuICAgIHRoaXMuYnVmZmVyZWQgPSB7XG4gICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJhbmdlcy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgZW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZSgnZW5kJywgaW5kZXgsIHRpbWVyYW5nZXMubGVuZ3RoKTtcbiAgICAgIH0sXG4gICAgICBzdGFydChpbmRleCkge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZ2UoJ3N0YXJ0JywgaW5kZXgsIHRpbWVyYW5nZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmNsYXNzIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgJ1tzdWJ0aXRsZS10cmFjay1jb250cm9sbGVyXScpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSAtMTtcbiAgICB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIgPSAoKSA9PiB0aGlzLm9uVGV4dFRyYWNrc0NoYW5nZWQoKTtcbiAgICB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlID0gKCkgPT4gdGhpcy5wb2xsVHJhY2tDaGFuZ2UoMCk7XG4gICAgdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IC0xO1xuICAgIHRoaXMuX3N1YnRpdGxlRGlzcGxheSA9IHRydWU7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy50cmFja3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIgPSB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0IHN1YnRpdGxlRGlzcGxheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3VidGl0bGVEaXNwbGF5O1xuICB9XG4gIHNldCBzdWJ0aXRsZURpc3BsYXkodmFsdWUpIHtcbiAgICB0aGlzLl9zdWJ0aXRsZURpc3BsYXkgPSB2YWx1ZTtcbiAgICBpZiAodGhpcy50cmFja0lkID4gLTEpIHtcbiAgICAgIHRoaXMudG9nZ2xlVHJhY2tNb2Rlcyh0aGlzLnRyYWNrSWQpO1xuICAgIH1cbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIHN1YnRpdGxlIHRyYWNrIGNoYW5nZSwgdGhlbiBleHRyYWN0IHRoZSBjdXJyZW50IHRyYWNrIElELlxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID4gLTEpIHtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRoaXMucXVldWVkRGVmYXVsdFRyYWNrO1xuICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSAtMTtcbiAgICB9XG4gICAgdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID0gISh0aGlzLm1lZGlhLnRleHRUcmFja3MgJiYgJ29uY2hhbmdlJyBpbiB0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgIGlmICh0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHRoaXMucG9sbFRyYWNrQ2hhbmdlKDUwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlKTtcbiAgICB9XG4gIH1cbiAgcG9sbFRyYWNrQ2hhbmdlKHRpbWVvdXQpIHtcbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy50cmFja0NoYW5nZUxpc3RlbmVyLCB0aW1lb3V0KTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgaWYgKCF0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhY2tJZCA+IC0xKSB7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IHRoaXMudHJhY2tJZDtcbiAgICB9XG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgLy8gQ2xlYXIgbG9hZGVkIGN1ZXMgb24gbWVkaWEgZGV0YWNobWVudCBmcm9tIHRyYWNrc1xuICAgIHRleHRUcmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKTtcbiAgICB9KTtcbiAgICAvLyBEaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MgYmVmb3JlIGRldGFjaG1lbnQgc28gd2hlbiByZWF0dGFjaGVkIG9ubHkgdHJhY2tzIGluIHRoYXQgY29udGVudCBhcmUgZW5hYmxlZC5cbiAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZCA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICB9XG5cbiAgLy8gRmlyZWQgd2hlbmV2ZXIgYSBuZXcgbWFuaWZlc3QgaXMgbG9hZGVkLlxuICBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xuICB9XG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZGV0YWlsc1xuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYWNrSWRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbdHJhY2tJZF07XG4gICAgaWYgKCFjdXJyZW50VHJhY2spIHtcbiAgICAgIHRoaXMud2FybihgSW52YWxpZCBzdWJ0aXRsZSB0cmFjayBpZCAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJEZXRhaWxzID0gY3VycmVudFRyYWNrLmRldGFpbHM7XG4gICAgY3VycmVudFRyYWNrLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgdGhpcy5sb2coYHN1YnRpdGxlIHRyYWNrICR7aWR9IGxvYWRlZCBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dYCk7XG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQoaWQsIGRhdGEsIGN1ckRldGFpbHMpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgc3dpdGNoTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBpZiAoIShsZXZlbEluZm8gIT0gbnVsbCAmJiBsZXZlbEluZm8udGV4dEdyb3VwSWRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0R3JvdXBJZCA9IGxldmVsSW5mby50ZXh0R3JvdXBJZHNbbGV2ZWxJbmZvLnVybElkXTtcbiAgICBjb25zdCBsYXN0VHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXAgPyB0aGlzLnRyYWNrc0luR3JvdXBbdGhpcy50cmFja0lkXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5ncm91cElkICE9PSB0ZXh0R3JvdXBJZCkge1xuICAgICAgY29uc3Qgc3VidGl0bGVUcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIodHJhY2sgPT4gIXRleHRHcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IHRleHRHcm91cElkKTtcbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IHN1YnRpdGxlVHJhY2tzO1xuICAgICAgY29uc3QgaW5pdGlhbFRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKGxhc3RUcmFjayA9PSBudWxsID8gdm9pZCAwIDogbGFzdFRyYWNrLm5hbWUpIHx8IHRoaXMuZmluZFRyYWNrSWQoKTtcbiAgICAgIHRoaXMuZ3JvdXBJZCA9IHRleHRHcm91cElkIHx8IG51bGw7XG4gICAgICBjb25zdCBzdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSB7XG4gICAgICAgIHN1YnRpdGxlVHJhY2tzXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coYFVwZGF0aW5nIHN1YnRpdGxlIHRyYWNrcywgJHtzdWJ0aXRsZVRyYWNrcy5sZW5ndGh9IHRyYWNrKHMpIGZvdW5kIGluIFwiJHt0ZXh0R3JvdXBJZH1cIiBncm91cC1pZGApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHN1YnRpdGxlVHJhY2tzVXBkYXRlZCk7XG4gICAgICBpZiAoaW5pdGlhbFRyYWNrSWQgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhpbml0aWFsVHJhY2tJZCwgbGFzdFRyYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkUmVsb2FkUGxheWxpc3QobGFzdFRyYWNrKSkge1xuICAgICAgLy8gUmV0cnkgcGxheWxpc3QgbG9hZGluZyBpZiBubyBwbGF5bGlzdCBpcyBvciBoYXMgYmVlbiBsb2FkZWQgeWV0XG4gICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sodGhpcy50cmFja0lkLCBsYXN0VHJhY2spO1xuICAgIH1cbiAgfVxuICBmaW5kVHJhY2tJZChuYW1lKSB7XG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdGV4dFRyYWNrc1tpXTtcbiAgICAgIGlmICghdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgfHwgdHJhY2suZGVmYXVsdCkge1xuICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZSA9PT0gdHJhY2submFtZSkge1xuICAgICAgICAgIHJldHVybiB0cmFjay5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmIGRhdGEuY29udGV4dC5ncm91cElkID09PSB0aGlzLmdyb3VwSWQpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgc3VidGl0bGVUcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgfVxuXG4gIC8qKiBnZXQvc2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoYmFzZWQgb24gaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuICBnZXQgc3VidGl0bGVUcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG4gIHNldCBzdWJ0aXRsZVRyYWNrKG5ld0lkKSB7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICBjb25zdCBsYXN0VHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXAgPyB0aGlzLnRyYWNrc0luR3JvdXBbdGhpcy50cmFja0lkXSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sobmV3SWQsIGxhc3RUcmFjayk7XG4gIH1cbiAgbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBzdXBlci5sb2FkUGxheWxpc3QoKTtcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbdGhpcy50cmFja0lkXTtcbiAgICBpZiAodGhpcy5zaG91bGRMb2FkUGxheWxpc3QoY3VycmVudFRyYWNrKSkge1xuICAgICAgY29uc3QgaWQgPSBjdXJyZW50VHJhY2suaWQ7XG4gICAgICBjb25zdCBncm91cElkID0gY3VycmVudFRyYWNrLmdyb3VwSWQ7XG4gICAgICBsZXQgdXJsID0gY3VycmVudFRyYWNrLnVybDtcbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sb2coYExvYWRpbmcgc3VidGl0bGUgcGxheWxpc3QgZm9yIGlkICR7aWR9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgaWQsXG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIG9sZCBzdWJ0aXRsZVRyYWNrIGFuZCBzZXRzIGN1cnJlbnQgbW9kZSBvbiB0aGUgbmV4dCBzdWJ0aXRsZVRyYWNrLlxuICAgKiBUaGlzIG9wZXJhdGVzIG9uIHRoZSBET00gdGV4dFRyYWNrcy5cbiAgICogQSB2YWx1ZSBvZiAtMSB3aWxsIGRpc2FibGUgYWxsIHN1YnRpdGxlIHRyYWNrcy5cbiAgICovXG4gIHRvZ2dsZVRyYWNrTW9kZXMobmV3SWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIHRyYWNrSWRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHRUcmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhtZWRpYS50ZXh0VHJhY2tzKTtcbiAgICBjb25zdCBncm91cFRyYWNrcyA9IHRleHRUcmFja3MuZmlsdGVyKHRyYWNrID0+IHRyYWNrLmdyb3VwSWQgPT09IHRoaXMuZ3JvdXBJZCk7XG4gICAgaWYgKG5ld0lkID09PSAtMSkge1xuICAgICAgW10uc2xpY2UuY2FsbCh0ZXh0VHJhY2tzKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgdHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2xkVHJhY2sgPSBncm91cFRyYWNrc1t0cmFja0lkXTtcbiAgICAgIGlmIChvbGRUcmFjaykge1xuICAgICAgICBvbGRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dFRyYWNrID0gZ3JvdXBUcmFja3NbbmV3SWRdO1xuICAgIGlmIChuZXh0VHJhY2spIHtcbiAgICAgIG5leHRUcmFjay5tb2RlID0gdGhpcy5zdWJ0aXRsZURpc3BsYXkgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHN1YnRpdGxlIGluZGV4IGFuZCBwZXJpb2RpY2FsbHkgcmVsb2FkaW5nIGlmIGxpdmUuXG4gICAqIERpc3BhdGNoZXMgdGhlIFNVQlRJVExFX1RSQUNLX1NXSVRDSCBldmVudCwgd2hpY2ggaW5zdHJ1Y3RzIHRoZSBzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciB0byBsb2FkIHRoZSBzZWxlY3RlZCB0cmFjay5cbiAgICovXG4gIHNldFN1YnRpdGxlVHJhY2sobmV3SWQsIGxhc3RUcmFjaykge1xuICAgIHZhciBfdHJhY2tzJG5ld0lkO1xuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcblxuICAgIC8vIHNldHRpbmcgdGhpcy5zdWJ0aXRsZVRyYWNrIHdpbGwgdHJpZ2dlciBpbnRlcm5hbCBsb2dpY1xuICAgIC8vIGlmIG1lZGlhIGhhcyBub3QgYmVlbiBhdHRhY2hlZCB5ZXQsIGl0IHdpbGwgZmFpbFxuICAgIC8vIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgdHJhY2sgaWRcbiAgICAvLyBhbmQgd2UnbGwgc2V0IHN1YnRpdGxlVHJhY2sgd2hlbiBvbk1lZGlhQXR0YWNoZWQgaXMgdHJpZ2dlcmVkXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IG5ld0lkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFja0lkICE9PSBuZXdJZCkge1xuICAgICAgdGhpcy50b2dnbGVUcmFja01vZGVzKG5ld0lkKTtcbiAgICB9XG5cbiAgICAvLyBleGl0IGlmIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0IG9yIGludmFsaWRcbiAgICBpZiAodGhpcy50cmFja0lkID09PSBuZXdJZCAmJiAobmV3SWQgPT09IC0xIHx8IChfdHJhY2tzJG5ld0lkID0gdHJhY2tzW25ld0lkXSkgIT0gbnVsbCAmJiBfdHJhY2tzJG5ld0lkLmRldGFpbHMpIHx8IG5ld0lkIDwgLTEgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW25ld0lkXTtcbiAgICB0aGlzLmxvZyhgU3dpdGNoaW5nIHRvIHN1YnRpdGxlLXRyYWNrICR7bmV3SWR9YCArICh0cmFjayA/IGAgXCIke3RyYWNrLm5hbWV9XCIgbGFuZzoke3RyYWNrLmxhbmd9IGdyb3VwOiR7dHJhY2suZ3JvdXBJZH1gIDogJycpKTtcbiAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGdyb3VwSWQgPSAnJyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdXJsXG4gICAgICB9ID0gdHJhY2s7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHtcbiAgICAgICAgaWQsXG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHVybFxuICAgICAgfSk7XG4gICAgICBjb25zdCBobHNVcmxQYXJhbWV0ZXJzID0gdGhpcy5zd2l0Y2hQYXJhbXModHJhY2sudXJsLCBsYXN0VHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzKTtcbiAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzd2l0Y2ggdG8gLTFcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgICBpZDogbmV3SWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvblRleHRUcmFja3NDaGFuZ2VkKCkge1xuICAgIGlmICghdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgfVxuICAgIC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcbiAgICBpZiAoIXRoaXMubWVkaWEgfHwgIXRoaXMuaGxzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRyYWNrSWQgPSAtMTtcbiAgICBjb25zdCB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgIGZvciAobGV0IGlkID0gMDsgaWQgPCB0cmFja3MubGVuZ3RoOyBpZCsrKSB7XG4gICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnaGlkZGVuJykge1xuICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIGN1cnJlbnQgc3VidGl0bGVUcmFjayB3aWxsIGludm9rZSBjb2RlLlxuICAgIGlmICh0aGlzLnN1YnRpdGxlVHJhY2sgIT09IHRyYWNrSWQpIHtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrSWQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0ZXh0VHJhY2tMaXN0KSB7XG4gIGNvbnN0IHRyYWNrcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFjayA9IHRleHRUcmFja0xpc3RbaV07XG4gICAgLy8gRWRnZSBhZGRzIGEgdHJhY2sgd2l0aG91dCBhIGxhYmVsOyB3ZSBkb24ndCB3YW50IHRvIHVzZSBpdFxuICAgIGlmICgodHJhY2sua2luZCA9PT0gJ3N1YnRpdGxlcycgfHwgdHJhY2sua2luZCA9PT0gJ2NhcHRpb25zJykgJiYgdHJhY2subGFiZWwpIHtcbiAgICAgIHRyYWNrcy5wdXNoKHRleHRUcmFja0xpc3RbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tzO1xufVxuXG5jbGFzcyBCdWZmZXJPcGVyYXRpb25RdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZUJ1ZmZlclJlZmVyZW5jZSkge1xuICAgIHRoaXMuYnVmZmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnF1ZXVlcyA9IHtcbiAgICAgIHZpZGVvOiBbXSxcbiAgICAgIGF1ZGlvOiBbXSxcbiAgICAgIGF1ZGlvdmlkZW86IFtdXG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBzb3VyY2VCdWZmZXJSZWZlcmVuY2U7XG4gIH1cbiAgYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgcXVldWUucHVzaChvcGVyYXRpb24pO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgdGhpcy5idWZmZXJzW3R5cGVdKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfVxuICBpbnNlcnRBYm9ydChvcGVyYXRpb24sIHR5cGUpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnVuc2hpZnQob3BlcmF0aW9uKTtcbiAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG4gIGFwcGVuZEJsb2NrZXIodHlwZSkge1xuICAgIGxldCBleGVjdXRlO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGV4ZWN1dGUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIGV4ZWN1dGUsXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHt9LFxuICAgICAgb25FcnJvcjogKCkgPT4ge31cbiAgICB9O1xuICAgIHRoaXMuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZXhlY3V0ZU5leHQodHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1ZmZlcnMsXG4gICAgICBxdWV1ZXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzYiA9IGJ1ZmZlcnNbdHlwZV07XG4gICAgY29uc3QgcXVldWUgPSBxdWV1ZXNbdHlwZV07XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcXVldWVbMF07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBPcGVyYXRpb25zIGFyZSBleHBlY3RlZCB0byByZXN1bHQgaW4gYW4gJ3VwZGF0ZWVuZCcgZXZlbnQgYmVpbmcgZmlyZWQuIElmIG5vdCwgdGhlIHF1ZXVlIHdpbGwgbG9jay4gT3BlcmF0aW9uc1xuICAgICAgICAvLyB3aGljaCBkbyBub3QgZW5kIHdpdGggdGhpcyBldmVudCBtdXN0IGNhbGwgX29uU0JVcGRhdGVFbmQgbWFudWFsbHlcbiAgICAgICAgb3BlcmF0aW9uLmV4ZWN1dGUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1tidWZmZXItb3BlcmF0aW9uLXF1ZXVlXTogVW5oYW5kbGVkIGV4Y2VwdGlvbiBleGVjdXRpbmcgdGhlIGN1cnJlbnQgb3BlcmF0aW9uJyk7XG4gICAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGUpO1xuXG4gICAgICAgIC8vIE9ubHkgc2hpZnQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9mZiwgb3RoZXJ3aXNlIHRoZSB1cGRhdGVlbmQgaGFuZGxlciB3aWxsIGRvIHRoaXMgZm9yIHVzXG4gICAgICAgIGlmICghKHNiICE9IG51bGwgJiYgc2IudXBkYXRpbmcpKSB7XG4gICAgICAgICAgcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSkge1xuICAgIHRoaXMucXVldWVzW3R5cGVdLnNoaWZ0KCk7XG4gICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgfVxuICBjdXJyZW50KHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZXNbdHlwZV1bMF07XG4gIH1cbn1cblxuY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuY29uc3QgVklERU9fQ09ERUNfUFJPRklMRV9SRVBBQ0UgPSAvKFtoYV12Yy4pKD86XFwuW14uLF0rKSsvO1xuY2xhc3MgQnVmZmVyQ29udHJvbGxlciB7XG4gIC8vIFRoZSBsZXZlbCBkZXRhaWxzIHVzZWQgdG8gZGV0ZXJtaW5lIGR1cmF0aW9uLCB0YXJnZXQtZHVyYXRpb24gYW5kIGxpdmVcblxuICAvLyBjYWNoZSB0aGUgc2VsZiBnZW5lcmF0ZWQgb2JqZWN0IHVybCB0byBkZXRlY3QgaGlqYWNrIG9mIHZpZGVvIHRhZ1xuXG4gIC8vIEEgcXVldWUgb2YgYnVmZmVyIG9wZXJhdGlvbnMgd2hpY2ggcmVxdWlyZSB0aGUgU291cmNlQnVmZmVyIHRvIG5vdCBiZSB1cGRhdGluZyB1cG9uIGV4ZWN1dGlvblxuXG4gIC8vIFJlZmVyZW5jZXMgdG8gZXZlbnQgbGlzdGVuZXJzIGZvciBlYWNoIFNvdXJjZUJ1ZmZlciwgc28gdGhhdCB0aGV5IGNhbiBiZSByZWZlcmVuY2VkIGZvciBldmVudCByZW1vdmFsXG5cbiAgLy8gVGhlIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkIGJlZm9yZSBhbnkgc291cmNlQnVmZmVycyBhcmUgY3JlYXRlZFxuXG4gIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgQlVGRkVSX0NPREVDIGV2ZW50cyByZWNlaXZlZFxuXG4gIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBhdHRhY2hlZCBtZWRpYSBlbGVtZW50XG5cbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGFjdGl2ZSBtZWRpYSBzb3VyY2VcblxuICAvLyBMYXN0IE1QMyBhdWRpbyBjaHVuayBhcHBlbmRlZFxuXG4gIC8vIGNvdW50ZXJzXG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSB2b2lkIDA7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gMDtcbiAgICB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IG51bGw7XG4gICAgdGhpcy5hcHBlbmRFcnJvciA9IDA7XG4gICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHZvaWQgMDtcbiAgICAvLyBLZWVwIGFzIGFycm93IGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNhbiBkaXJlY3RseSByZWZlcmVuY2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGFzIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZWRpYSxcbiAgICAgICAgbWVkaWFTb3VyY2VcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgbG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHtcbiAgICAgICAgICBtZWRpYVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XG4gICAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH07XG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlID0gKCkgPT4ge1xuICAgICAgbG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIGNsb3NlZCcpO1xuICAgIH07XG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkID0gKCkgPT4ge1xuICAgICAgbG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIGVuZGVkJyk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1lZGlhRW1wdGllZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWVkaWEsXG4gICAgICAgIF9vYmplY3RVcmxcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLnNyYyAhPT0gX29iamVjdFVybCkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYE1lZGlhIGVsZW1lbnQgc3JjIHdhcyBzZXQgd2hpbGUgYXR0YWNoaW5nIE1lZGlhU291cmNlICgke19vYmplY3RVcmx9ID4gJHttZWRpYS5zcmN9KWApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBoYXNTb3VyY2VUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCA+IDAgfHwgT2JqZWN0LmtleXModGhpcy5wZW5kaW5nVHJhY2tzKS5sZW5ndGggPiAwO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHRoaXMub25CdWZmZXJBcHBlbmRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQ0hBTkdFRCwgdGhpcy5vbkZyYWdDaGFuZ2VkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyk7XG4gIH1cbiAgX2luaXRTb3VyY2VCdWZmZXIoKSB7XG4gICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICB0aGlzLm9wZXJhdGlvblF1ZXVlID0gbmV3IEJ1ZmZlck9wZXJhdGlvblF1ZXVlKHRoaXMuc291cmNlQnVmZmVyKTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgIGF1ZGlvOiBbXSxcbiAgICAgIHZpZGVvOiBbXSxcbiAgICAgIGF1ZGlvdmlkZW86IFtdXG4gICAgfTtcbiAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IDA7XG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIHNvdXJjZWJ1ZmZlcnMgd2lsbCBiZSBjcmVhdGVkIGFsbCBhdCBvbmNlIHdoZW4gdGhlIGV4cGVjdGVkIG5iIG9mIHRyYWNrcyB3aWxsIGJlIHJlYWNoZWRcbiAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XG4gICAgbGV0IGNvZGVjRXZlbnRzID0gMjtcbiAgICBpZiAoZGF0YS5hdWRpbyAmJiAhZGF0YS52aWRlbyB8fCAhZGF0YS5hbHRBdWRpbyB8fCAhdHJ1ZSkge1xuICAgICAgY29kZWNFdmVudHMgPSAxO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gY29kZWNFdmVudHM7XG4gICAgbG9nZ2VyLmxvZyhgJHt0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWR9IGJ1ZmZlckNvZGVjIGV2ZW50KHMpIGV4cGVjdGVkYCk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIE1lZGlhU291cmNlKSB7XG4gICAgICBjb25zdCBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTtcbiAgICAgIC8vIE1lZGlhU291cmNlIGxpc3RlbmVycyBhcmUgYXJyb3cgZnVuY3Rpb25zIHdpdGggYSBsZXhpY2FsIHNjb3BlLCBhbmQgZG8gbm90IG5lZWQgdG8gYmUgYm91bmRcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7XG4gICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgIG1lZGlhLnNyYyA9IHNlbGYuVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XG4gICAgICAvLyBjYWNoZSB0aGUgbG9jYWxseSBnZW5lcmF0ZWQgb2JqZWN0IHVybFxuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbWVkaWEuc3JjO1xuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIG1lZGlhU291cmNlLFxuICAgICAgX29iamVjdFVybFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgbG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgICAgaWYgKG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBvbk1lZGlhRGV0YWNoaW5nOiAke2Vyci5tZXNzYWdlfSB3aGlsZSBjYWxsaW5nIGVuZE9mU3RyZWFtYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENsZWFuIHVwIHRoZSBTb3VyY2VCdWZmZXJzIGJ5IGludm9raW5nIG9uQnVmZmVyUmVzZXRcbiAgICAgIHRoaXMub25CdWZmZXJSZXNldCgpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTtcblxuICAgICAgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgICAgIGlmIChfb2JqZWN0VXJsKSB7XG4gICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKF9vYmplY3RVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgdmlkZW8gdGFnIHNyYyBvbmx5IGlmIGl0J3Mgb3VyIG93biB1cmwuIHNvbWUgZXh0ZXJuYWwgbGlicmFyaWVzIG1pZ2h0XG4gICAgICAgIC8vIGhpamFjayB0aGUgdmlkZW8gdGFnIGFuZCBjaGFuZ2UgaXRzICdzcmMnIHdpdGhvdXQgZGVzdHJveWluZyB0aGUgSGxzIGluc3RhbmNlIGZpcnN0XG4gICAgICAgIGlmIChtZWRpYS5zcmMgPT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBtZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgIG1lZGlhLmxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIud2FybignW2J1ZmZlci1jb250cm9sbGVyXTogbWVkaWEuc3JjIHdhcyBjaGFuZ2VkIGJ5IGEgdGhpcmQgcGFydHkgLSBza2lwIGNsZWFudXAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdW5kZWZpbmVkKTtcbiAgfVxuICBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzYikge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKHR5cGUpO1xuICAgICAgICAgIGlmICh0aGlzLm1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN5bmNocm9ub3VzbHkgcmVtb3ZlIHRoZSBTQiBmcm9tIHRoZSBtYXAgYmVmb3JlIHRoZSBuZXh0IGNhbGwgaW4gb3JkZXIgdG8gcHJldmVudCBhbiBhc3luYyBmdW5jdGlvbiBmcm9tXG4gICAgICAgICAgLy8gYWNjZXNzaW5nIGl0XG4gICAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIud2FybihgW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIHJlc2V0IHRoZSAke3R5cGV9IGJ1ZmZlcmAsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICB9XG4gIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qgc291cmNlQnVmZmVyQ291bnQgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoO1xuICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgICAvLyBjaGVjayBpZiBTb3VyY2VCdWZmZXIgY29kZWMgbmVlZHMgdG8gY2hhbmdlXG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgaWYgKHRyYWNrICYmIHR5cGVvZiB0cmFjay5idWZmZXIuY2hhbmdlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICBsZXZlbENvZGVjLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICB9ID0gZGF0YVt0cmFja05hbWVdO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2RlYyA9ICh0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjKS5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQQUNFLCAnJDEnKTtcbiAgICAgICAgICBjb25zdCBuZXh0Q29kZWMgPSAobGV2ZWxDb2RlYyB8fCBjb2RlYykucmVwbGFjZShWSURFT19DT0RFQ19QUk9GSUxFX1JFUEFDRSwgJyQxJyk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRDb2RlYyAhPT0gbmV4dENvZGVjKSB7XG4gICAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGAke2NvbnRhaW5lcn07Y29kZWNzPSR7bGV2ZWxDb2RlYyB8fCBjb2RlY31gO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGFuZ2VUeXBlKHRyYWNrTmFtZSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgW2J1ZmZlci1jb250cm9sbGVyXTogc3dpdGNoaW5nIGNvZGVjICR7Y3VycmVudENvZGVjfSB0byAke25leHRDb2RlY31gKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjogdHJhY2suYnVmZmVyLFxuICAgICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICBsZXZlbENvZGVjLFxuICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBzb3VyY2UgYnVmZmVyKHMpIG5vdCBjcmVhdGVkIHlldCwgYXBwZW5kZWQgYnVmZmVyIHRyYWNrcyBpbiB0aGlzLnBlbmRpbmdUcmFja3NcbiAgICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSBkYXRhW3RyYWNrTmFtZV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cbiAgICBpZiAoc291cmNlQnVmZmVyQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gTWF0aC5tYXgodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkIC0gMSwgMCk7XG4gICAgaWYgKHRoaXMubWVkaWFTb3VyY2UgJiYgdGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfVxuICB9XG4gIGFwcGVuZENoYW5nZVR5cGUodHlwZSwgbWltZVR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRpb25RdWV1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIGV4ZWN1dGU6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgW2J1ZmZlci1jb250cm9sbGVyXTogY2hhbmdpbmcgJHt0eXBlfSBzb3VyY2VCdWZmZXIgdHlwZSB0byAke21pbWVUeXBlfWApO1xuICAgICAgICAgIHNiLmNoYW5nZVR5cGUobWltZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge30sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7fSxcbiAgICAgIG9uRXJyb3I6IGUgPT4ge1xuICAgICAgICBsb2dnZXIud2FybihgW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIGNoYW5nZSAke3R5cGV9IFNvdXJjZUJ1ZmZlciB0eXBlYCwgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgfVxuICBvbkJ1ZmZlckFwcGVuZGluZyhldmVudCwgZXZlbnREYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgb3BlcmF0aW9uUXVldWUsXG4gICAgICB0cmFja3NcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgdHlwZSxcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgY2h1bmtNZXRhXG4gICAgfSA9IGV2ZW50RGF0YTtcbiAgICBjb25zdCBjaHVua1N0YXRzID0gY2h1bmtNZXRhLmJ1ZmZlcmluZ1t0eXBlXTtcbiAgICBjb25zdCBidWZmZXJBcHBlbmRpbmdTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY2h1bmtTdGF0cy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIGNvbnN0IGZyYWdCdWZmZXJpbmcgPSBmcmFnLnN0YXRzLmJ1ZmZlcmluZztcbiAgICBjb25zdCBwYXJ0QnVmZmVyaW5nID0gcGFydCA/IHBhcnQuc3RhdHMuYnVmZmVyaW5nIDogbnVsbDtcbiAgICBpZiAoZnJhZ0J1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZ0J1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIH1cbiAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogT25seSB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0IHdoZW4gYXVkaW8vbXBlZyBmcmFnbWVudCBvciBwYXJ0IGlzIG5vdCBjb250aWd1b3VzIHdpdGggcHJldmlvdXNseSBhcHBlbmRlZFxuICAgIC8vIEFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgKGRlc2lyZWQgcG9pbnQgaW4gdGhlIHRpbWVsaW5lIHdoZXJlIHRoZSBuZXh0IGZyYW1lcyBzaG91bGQgYmUgYXBwZW5kZWQpXG4gICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS5cbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICBsZXQgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSBmYWxzZTtcbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiAoYXVkaW9UcmFjayA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9UcmFjay5jb250YWluZXIpID09PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgIGNoZWNrVGltZXN0YW1wT2Zmc2V0ID0gIXRoaXMubGFzdE1wZWdBdWRpb0NodW5rIHx8IGNodW5rTWV0YS5pZCA9PT0gMSB8fCB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuay5zbiAhPT0gY2h1bmtNZXRhLnNuO1xuICAgICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBjaHVua01ldGE7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdTdGFydCA9IGZyYWcuc3RhcnQ7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmIChjaGVja1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGZyYWdTdGFydCAtIHNiLnRpbWVzdGFtcE9mZnNldDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMC4xKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYFtidWZmZXItY29udHJvbGxlcl06IFVwZGF0aW5nIGF1ZGlvIFNvdXJjZUJ1ZmZlciB0aW1lc3RhbXBPZmZzZXQgdG8gJHtmcmFnU3RhcnR9IChkZWx0YTogJHtkZWx0YX0pIHNuOiAke2ZyYWcuc259KWApO1xuICAgICAgICAgICAgICBzYi50aW1lc3RhbXBPZmZzZXQgPSBmcmFnU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZXN0YXJ0YCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZWVuZGApO1xuICAgICAgICBjb25zdCBlbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVFbmQgPSBjaHVua1N0YXRzLmVuZCA9IGVuZDtcbiAgICAgICAgaWYgKGZyYWdCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBmcmFnQnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBwYXJ0QnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzb3VyY2VCdWZmZXJcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRpbWVSYW5nZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIHRpbWVSYW5nZXNbdHlwZV0gPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc291cmNlQnVmZmVyW3R5cGVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICAgIHRpbWVSYW5nZXNcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZXJyID0+IHtcbiAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIHRvIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlcmAsIGVycik7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcisrO1xuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjtcbiAgICAgICAgICAvKiB3aXRoIFVIRCBjb250ZW50LCB3ZSBjb3VsZCBnZXQgbG9vcCBvZiBxdW90YSBleGNlZWRlZCBlcnJvciB1bnRpbFxuICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gUmV0cnlpbmcgY2FuIGhlbHAgcmVjb3Zlci5cbiAgICAgICAgICAqL1xuICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFtidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCAke2hscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeX0gdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gc291cmNlQnVmZmVyYCk7XG4gICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSk7XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZmx1c2hPcGVyYXRpb24gPSB0eXBlID0+ICh7XG4gICAgICBleGVjdXRlOiB0aGlzLnJlbW92ZUV4ZWN1dG9yLmJpbmQodGhpcywgdHlwZSwgZGF0YS5zdGFydE9mZnNldCwgZGF0YS5lbmRPZmZzZXQpLFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IFN0YXJ0ZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEZpbmlzaGVkIGZsdXNoaW5nICR7ZGF0YS5zdGFydE9mZnNldH0gLT4gJHtkYXRhLmVuZE9mZnNldH0gZm9yICR7dHlwZX0gU291cmNlIEJ1ZmZlcmApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwge1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZSA9PiB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgdG8gcmVtb3ZlIGZyb20gJHt0eXBlfSBTb3VyY2VCdWZmZXJgLCBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGF0YS50eXBlKSB7XG4gICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQoZmx1c2hPcGVyYXRpb24oZGF0YS50eXBlKSwgZGF0YS50eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbih0eXBlKSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25GcmFnUGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBidWZmZXJzQXBwZW5kZWRUbyA9IFtdO1xuICAgIGNvbnN0IGVsZW1lbnRhcnlTdHJlYW1zID0gcGFydCA/IHBhcnQuZWxlbWVudGFyeVN0cmVhbXMgOiBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10pIHtcbiAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ2F1ZGlvdmlkZW8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10pIHtcbiAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW8nKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dKSB7XG4gICAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ3ZpZGVvJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9uVW5ibG9ja2VkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGZyYWcuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19CVUZGRVJFRCwge1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBzdGF0cyxcbiAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoYnVmZmVyc0FwcGVuZGVkVG8ubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2dnZXIud2FybihgRnJhZ21lbnRzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgRWxlbWVudGFyeVN0cmVhbVR5cGUgc2V0LiB0eXBlOiAke2ZyYWcudHlwZX0gbGV2ZWw6ICR7ZnJhZy5sZXZlbH0gc246ICR7ZnJhZy5zbn1gKTtcbiAgICB9XG4gICAgdGhpcy5ibG9ja0J1ZmZlcnMob25VbmJsb2NrZWQsIGJ1ZmZlcnNBcHBlbmRlZFRvKTtcbiAgfVxuICBvbkZyYWdDaGFuZ2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5mbHVzaEJhY2tCdWZmZXIoKTtcbiAgfVxuXG4gIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuICAvLyBhbiB1bmRlZmluZWQgZGF0YS50eXBlIHdpbGwgbWFyayBhbGwgYnVmZmVycyBhcyBFT1MuXG4gIG9uQnVmZmVyRW9zKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgZW5kZWQgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkucmVkdWNlKChhY2MsIHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICBpZiAoc2IgJiYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICBzYi5lbmRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoIXNiLmVuZGVkKSB7XG4gICAgICAgICAgc2IuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgIGxvZ2dlci5sb2coYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gc291cmNlQnVmZmVyIG5vdyBFT1NgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyAmJiAhISghc2IgfHwgc2IuZW5kZWQpO1xuICAgIH0sIHRydWUpO1xuICAgIGlmIChlbmRlZCkge1xuICAgICAgbG9nZ2VyLmxvZyhgW2J1ZmZlci1jb250cm9sbGVyXTogUXVldWVpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKWApO1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnMoKCkgPT4ge1xuICAgICAgICB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgc2IuZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1lZGlhU291cmNlXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIW1lZGlhU291cmNlIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYFtidWZmZXItY29udHJvbGxlcl06IENvdWxkIG5vdCBjYWxsIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCkuIG1lZGlhU291cmNlLnJlYWR5U3RhdGU6ICR7bWVkaWFTb3VyY2UucmVhZHlTdGF0ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5sb2coYFtidWZmZXItY29udHJvbGxlcl06IENhbGxpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKWApO1xuICAgICAgICAvLyBBbGxvdyB0aGlzIHRvIHRocm93IGFuZCBiZSBjYXVnaHQgYnkgdGhlIGVucXVldWVpbmcgZnVuY3Rpb25cbiAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkxldmVsVXBkYXRlZChldmVudCwge1xuICAgIGRldGFpbHNcbiAgfSkge1xuICAgIGlmICghZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgaWYgKHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYmxvY2tCdWZmZXJzKHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24uYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgZmx1c2hCYWNrQnVmZmVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIGRldGFpbHMsXG4gICAgICBtZWRpYSxcbiAgICAgIHNvdXJjZUJ1ZmZlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgZGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VCdWZmZXJUeXBlcyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcbiAgICBpZiAoIXNvdXJjZUJ1ZmZlclR5cGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgbGl2ZUJhY2tCdWZmZXJMZW5ndGhcbiAgICBjb25zdCBiYWNrQnVmZmVyTGVuZ3RoID0gZGV0YWlscy5saXZlICYmIGhscy5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggIT09IG51bGwgPyBobHMuY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoIDogaGxzLmNvbmZpZy5iYWNrQnVmZmVyTGVuZ3RoO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIoYmFja0J1ZmZlckxlbmd0aCkgfHwgYmFja0J1ZmZlckxlbmd0aCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCB0YXJnZXREdXJhdGlvbiA9IGRldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcbiAgICBjb25zdCBtYXhCYWNrQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoYmFja0J1ZmZlckxlbmd0aCwgdGFyZ2V0RHVyYXRpb24pO1xuICAgIGNvbnN0IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA9IE1hdGguZmxvb3IoY3VycmVudFRpbWUgLyB0YXJnZXREdXJhdGlvbikgKiB0YXJnZXREdXJhdGlvbiAtIG1heEJhY2tCdWZmZXJMZW5ndGg7XG4gICAgc291cmNlQnVmZmVyVHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgaWYgKHNiKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgLy8gd2hlbiB0YXJnZXQgYnVmZmVyIHN0YXJ0IGV4Y2VlZHMgYWN0dWFsIGJ1ZmZlciBzdGFydFxuICAgICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID4gMCAmJiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPiBidWZmZXJlZC5zdGFydCgwKSkge1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICBidWZmZXJFbmQ6IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBldmVudDpcbiAgICAgICAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNiLmVuZGVkICYmIGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKSAtIGN1cnJlbnRUaW1lIDwgdGFyZ2V0RHVyYXRpb24gKiAyKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW2J1ZmZlci1jb250cm9sbGVyXTogQ2Fubm90IGZsdXNoICR7dHlwZX0gYmFjayBidWZmZXIgd2hpbGUgU291cmNlQnVmZmVyIGlzIGluIGVuZGVkIHN0YXRlYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24sXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIGN1cnJlbnQgbGV2ZWwgZHVyYXRpb24gb3Igb3ZlcnJpZGUgdG8gSW5maW5pdHkgaWYgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJcbiAgICogJ2xpdmVEdXJhdGlvbkluZmluaXR5YCBpcyBzZXQgdG8gYHRydWVgXG4gICAqIE1vcmUgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzM1NVxuICAgKi9cbiAgdXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLmRldGFpbHMgfHwgIXRoaXMubWVkaWEgfHwgIXRoaXMubWVkaWFTb3VyY2UgfHwgdGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGV0YWlscyxcbiAgICAgIGhscyxcbiAgICAgIG1lZGlhLFxuICAgICAgbWVkaWFTb3VyY2VcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBsZXZlbER1cmF0aW9uID0gZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQgKyBkZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgY29uc3QgbWVkaWFEdXJhdGlvbiA9IG1lZGlhLmR1cmF0aW9uO1xuICAgIGNvbnN0IG1zRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYVNvdXJjZS5kdXJhdGlvbikgPyBtZWRpYVNvdXJjZS5kdXJhdGlvbiA6IDA7XG4gICAgaWYgKGRldGFpbHMubGl2ZSAmJiBobHMuY29uZmlnLmxpdmVEdXJhdGlvbkluZmluaXR5KSB7XG4gICAgICAvLyBPdmVycmlkZSBkdXJhdGlvbiB0byBJbmZpbml0eVxuICAgICAgbG9nZ2VyLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgU291cmNlIGR1cmF0aW9uIGlzIHNldCB0byBJbmZpbml0eScpO1xuICAgICAgbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBJbmZpbml0eTtcbiAgICAgIHRoaXMudXBkYXRlU2Vla2FibGVSYW5nZShkZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsRHVyYXRpb24gPiBtc0R1cmF0aW9uICYmIGxldmVsRHVyYXRpb24gPiBtZWRpYUR1cmF0aW9uIHx8ICFpc0Zpbml0ZU51bWJlcihtZWRpYUR1cmF0aW9uKSkge1xuICAgICAgLy8gbGV2ZWxEdXJhdGlvbiB3YXMgdGhlIGxhc3QgdmFsdWUgd2Ugc2V0LlxuICAgICAgLy8gbm90IHVzaW5nIG1lZGlhU291cmNlLmR1cmF0aW9uIGFzIHRoZSBicm93c2VyIG1heSB0d2VhayB0aGlzIHZhbHVlXG4gICAgICAvLyBvbmx5IHVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaWYgaXRzIHZhbHVlIGluY3JlYXNlLCB0aGlzIGlzIHRvIGF2b2lkXG4gICAgICAvLyBmbHVzaGluZyBhbHJlYWR5IGJ1ZmZlcmVkIHBvcnRpb24gd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBxdWFsaXR5IGxldmVsXG4gICAgICBsb2dnZXIubG9nKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBVcGRhdGluZyBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gJHtsZXZlbER1cmF0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGxldmVsRHVyYXRpb247XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNlZWthYmxlUmFuZ2UobGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuICYmIGxldmVsRGV0YWlscy5saXZlICYmIG1lZGlhU291cmNlICE9IG51bGwgJiYgbWVkaWFTb3VyY2Uuc2V0TGl2ZVNlZWthYmxlUmFuZ2UpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZnJhZ21lbnRzWzBdLnN0YXJ0KTtcbiAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBzdGFydCArIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfVxuICBjaGVja1BlbmRpbmdUcmFja3MoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCxcbiAgICAgIG9wZXJhdGlvblF1ZXVlLFxuICAgICAgcGVuZGluZ1RyYWNrc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UndmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBleHBlY3RlZCBidWZmZXJDb2RlYyBldmVudHMuIFdoZW4gbm9uZSByZW1haW4sIGNyZWF0ZSBhbGwgdGhlIHNvdXJjZUJ1ZmZlcnMgYXQgb25jZS5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBNU0Ugc3BlYyBhbGxvd3MgaW1wbGVtZW50YXRpb25zIHRvIHRocm93IFF1b3RhRXhjZWVkZWRFcnJvcnMgaWYgY3JlYXRpbmcgbmV3IHNvdXJjZUJ1ZmZlcnMgYWZ0ZXJcbiAgICAvLyBkYXRhIGhhcyBiZWVuIGFwcGVuZGVkIHRvIGV4aXN0aW5nIG9uZXMuXG4gICAgLy8gMiB0cmFja3MgaXMgdGhlIG1heCAob25lIGZvciBhdWRpbywgb25lIGZvciB2aWRlbykuIElmIHdlJ3ZlIHJlYWNoIHRoaXMgbWF4IGdvIGFoZWFkIGFuZCBjcmVhdGUgdGhlIGJ1ZmZlcnMuXG4gICAgY29uc3QgcGVuZGluZ1RyYWNrc0NvdW50ID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgIGlmIChwZW5kaW5nVHJhY2tzQ291bnQgJiYgIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgfHwgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyKSB7XG4gICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgLy8gYXBwZW5kIGFueSBwZW5kaW5nIHNlZ21lbnRzIG5vdyAhXG4gICAgICBjb25zdCBidWZmZXJzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB7XG4gICAgICAgICAgdHJhY2tzOiB0aGlzLnRyYWNrc1xuICAgICAgICB9KTtcbiAgICAgICAgYnVmZmVycy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICAgIG9wZXJhdGlvblF1ZXVlLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdjb3VsZCBub3QgY3JlYXRlIHNvdXJjZSBidWZmZXIgZm9yIG1lZGlhIGNvZGVjKHMpJyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjcmVhdGVTb3VyY2VCdWZmZXJzKHRyYWNrcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZUJ1ZmZlcixcbiAgICAgIG1lZGlhU291cmNlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NyZWF0ZVNvdXJjZUJ1ZmZlcnMgY2FsbGVkIHdoZW4gbWVkaWFTb3VyY2Ugd2FzIG51bGwnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICBpZiAoIXNvdXJjZUJ1ZmZlclt0cmFja05hbWVdKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgc291cmNlIGJ1ZmZlciBleGlzdHMgZm9yIHRyYWNrICR7dHJhY2tOYW1lfSwgaG93ZXZlciB0cmFjayBkb2VzIG5vdGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgIGNvbnN0IGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XG4gICAgICAgIGxvZ2dlci5sb2coYFtidWZmZXItY29udHJvbGxlcl06IGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcigke21pbWVUeXBlfSlgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzYiA9IHNvdXJjZUJ1ZmZlclt0cmFja05hbWVdID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICBjb25zdCBzYk5hbWUgPSB0cmFja05hbWU7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICd1cGRhdGVzdGFydCcsIHRoaXMuX29uU0JVcGRhdGVTdGFydCk7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICd1cGRhdGVlbmQnLCB0aGlzLl9vblNCVXBkYXRlRW5kKTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ2Vycm9yJywgdGhpcy5fb25TQlVwZGF0ZUVycm9yKTtcbiAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja05hbWVdID0ge1xuICAgICAgICAgICAgYnVmZmVyOiBzYixcbiAgICAgICAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYzogdHJhY2subGV2ZWxDb2RlYyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0cmFjay5tZXRhZGF0YSxcbiAgICAgICAgICAgIGlkOiB0cmFjay5pZFxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgW2J1ZmZlci1jb250cm9sbGVyXTogZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFkZCBzb3VyY2VCdWZmZXI6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfb25TQlVwZGF0ZVN0YXJ0KHR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRpb25RdWV1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uU3RhcnQoKTtcbiAgfVxuICBfb25TQlVwZGF0ZUVuZCh0eXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3BlcmF0aW9uUXVldWVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBvcGVyYXRpb24gPSBvcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIG9wZXJhdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgfVxuICBfb25TQlVwZGF0ZUVycm9yKHR5cGUsIGV2ZW50KSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7dHlwZX0gU291cmNlQnVmZmVyIGVycm9yYCk7XG4gICAgbG9nZ2VyLmVycm9yKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke2Vycm9yfWAsIGV2ZW50KTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gU291cmNlQnVmZmVyIGVycm9ycyBhcmUgbm90IG5lY2Vzc2FyaWx5IGZhdGFsOyBpZiBzbywgdGhlIEhUTUxNZWRpYUVsZW1lbnQgd2lsbCBmaXJlIGFuIGVycm9yIGV2ZW50XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUixcbiAgICAgIGVycm9yLFxuICAgICAgZmF0YWw6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gdXBkYXRlZW5kIGlzIGFsd2F5cyBmaXJlZCBhZnRlciBlcnJvciwgc28gd2UnbGwgYWxsb3cgdGhhdCB0byBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmIG9mIHRoZSBxdWV1ZVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICBvcGVyYXRpb24ub25FcnJvcihldmVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiByZW1vdmUgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgcmVtb3ZlRXhlY3V0b3IodHlwZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgbWVkaWFTb3VyY2UsXG4gICAgICBvcGVyYXRpb25RdWV1ZSxcbiAgICAgIHNvdXJjZUJ1ZmZlclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzYikge1xuICAgICAgbG9nZ2VyLndhcm4oYFtidWZmZXItY29udHJvbGxlcl06IEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYS5kdXJhdGlvbikgPyBtZWRpYS5kdXJhdGlvbiA6IEluZmluaXR5O1xuICAgIGNvbnN0IG1zRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYVNvdXJjZS5kdXJhdGlvbikgPyBtZWRpYVNvdXJjZS5kdXJhdGlvbiA6IEluZmluaXR5O1xuICAgIGNvbnN0IHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnRPZmZzZXQpO1xuICAgIGNvbnN0IHJlbW92ZUVuZCA9IE1hdGgubWluKGVuZE9mZnNldCwgbWVkaWFEdXJhdGlvbiwgbXNEdXJhdGlvbik7XG4gICAgaWYgKHJlbW92ZUVuZCA+IHJlbW92ZVN0YXJ0ICYmICFzYi5lbmRpbmcpIHtcbiAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICBsb2dnZXIubG9nKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBSZW1vdmluZyBbJHtyZW1vdmVTdGFydH0sJHtyZW1vdmVFbmR9XSBmcm9tIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgc2IucmVtb3ZlKHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDeWNsZSB0aGUgcXVldWVcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiBhcHBlbmQgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLFxuICAgICAgc291cmNlQnVmZmVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFzYikge1xuICAgICAgbG9nZ2VyLndhcm4oYFtidWZmZXItY29udHJvbGxlcl06IEF0dGVtcHRpbmcgdG8gYXBwZW5kIHRvIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgIHNiLmFwcGVuZEJ1ZmZlcihkYXRhKTtcbiAgfVxuXG4gIC8vIEVucXVldWVzIGFuIG9wZXJhdGlvbiB0byBlYWNoIFNvdXJjZUJ1ZmZlciBxdWV1ZSB3aGljaCwgdXBvbiBleGVjdXRpb24sIHJlc29sdmVzIGEgcHJvbWlzZS4gV2hlbiBhbGwgcHJvbWlzZXNcbiAgLy8gcmVzb2x2ZSwgdGhlIG9uVW5ibG9ja2VkIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLiBGdW5jdGlvbnMgY2FsbGluZyB0aGlzIG1ldGhvZCBkbyBub3QgbmVlZCB0byB1bmJsb2NrIHRoZSBxdWV1ZVxuICAvLyB1cG9uIGNvbXBsZXRpb24sIHNpbmNlIHdlIGFscmVhZHkgZG8gaXQgaGVyZVxuICBibG9ja0J1ZmZlcnMob25VbmJsb2NrZWQsIGJ1ZmZlcnMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkpIHtcbiAgICBpZiAoIWJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyBvcGVyYXRpb24gcmVxdWVzdGVkLCBidXQgbm8gU291cmNlQnVmZmVycyBleGlzdCcpO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihvblVuYmxvY2tlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlXG4gICAgfSA9IHRoaXM7XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG4gICAgY29uc3QgYmxvY2tpbmdPcGVyYXRpb25zID0gYnVmZmVycy5tYXAodHlwZSA9PiBvcGVyYXRpb25RdWV1ZS5hcHBlbmRCbG9ja2VyKHR5cGUpKTtcbiAgICBQcm9taXNlLmFsbChibG9ja2luZ09wZXJhdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyBvcGVyYXRpb24gcmVzb2x2ZWQ7IHVuYmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICAgIG9uVW5ibG9ja2VkKCk7XG4gICAgICBidWZmZXJzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgIC8vIE9ubHkgY3ljbGUgdGhlIHF1ZXVlIGlmIHRoZSBTQiBpcyBub3QgdXBkYXRpbmcuIFRoZXJlJ3MgYSBidWcgaW4gQ2hyb21lIHdoaWNoIHNldHMgdGhlIFNCIHVwZGF0aW5nIGZsYWcgdG9cbiAgICAgICAgLy8gdHJ1ZSB3aGVuIGNoYW5naW5nIHRoZSBNZWRpYVNvdXJjZSBkdXJhdGlvbiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTU5MzU5JmNhbj0yJnE9bWVkaWFzb3VyY2UlMjBkdXJhdGlvbilcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBhIHdvcmthcm91bmQsIGl0J3MgcHJvYmFibHkgdXNlZnVsIHRvIGhhdmUgYXJvdW5kXG4gICAgICAgIGlmICghKHNiICE9IG51bGwgJiYgc2IudXBkYXRpbmcpKSB7XG4gICAgICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U291cmNlQnVmZmVyVHlwZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKTtcbiAgfVxuICBhZGRCdWZmZXJMaXN0ZW5lcih0eXBlLCBldmVudCwgZm4pIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lciA9IGZuLmJpbmQodGhpcywgdHlwZSk7XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7XG4gICAgICBldmVudCxcbiAgICAgIGxpc3RlbmVyXG4gICAgfSk7XG4gICAgYnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLmZvckVhY2gobCA9PiB7XG4gICAgICBidWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihsLmV2ZW50LCBsLmxpc3RlbmVyKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcbiAqXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gKlxuICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxuICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuLyoqXG4gKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcbiAqL1xuXG5jb25zdCBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcbiAgMHgyYTogMHhlMSxcbiAgLy8gbG93ZXJjYXNlIGEsIGFjdXRlIGFjY2VudFxuICAweDVjOiAweGU5LFxuICAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XG4gIDB4NWU6IDB4ZWQsXG4gIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZjogMHhmMyxcbiAgLy8gbG93ZXJjYXNlIG8sIGFjdXRlIGFjY2VudFxuICAweDYwOiAweGZhLFxuICAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XG4gIDB4N2I6IDB4ZTcsXG4gIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAweDdjOiAweGY3LFxuICAvLyBkaXZpc2lvbiBzeW1ib2xcbiAgMHg3ZDogMHhkMSxcbiAgLy8gdXBwZXJjYXNlIE4gdGlsZGVcbiAgMHg3ZTogMHhmMSxcbiAgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgMHg3ZjogMHgyNTg4LFxuICAvLyBGdWxsIGJsb2NrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAvLyBUSElTIE1FQU5TIFRIQVQgXFx4NTAgTVVTVCBCRSBBRERFRCBUTyBUSEUgVkFMVUVTXG4gIDB4ODA6IDB4YWUsXG4gIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxuICAweDgxOiAweGIwLFxuICAvLyBkZWdyZWUgc2lnblxuICAweDgyOiAweGJkLFxuICAvLyAxLzIgc3ltYm9sXG4gIDB4ODM6IDB4YmYsXG4gIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXG4gIDB4ODQ6IDB4MjEyMixcbiAgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXG4gIDB4ODU6IDB4YTIsXG4gIC8vIENlbnRzIHN5bWJvbFxuICAweDg2OiAweGEzLFxuICAvLyBQb3VuZHMgc3RlcmxpbmdcbiAgMHg4NzogMHgyNjZhLFxuICAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgMHg4ODogMHhlMCxcbiAgLy8gbG93ZXJjYXNlIGEsIGdyYXZlIGFjY2VudFxuICAweDg5OiAweDIwLFxuICAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcbiAgMHg4YTogMHhlOCxcbiAgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxuICAweDhiOiAweGUyLFxuICAvLyBsb3dlcmNhc2UgYSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4YzogMHhlYSxcbiAgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGQ6IDB4ZWUsXG4gIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhlOiAweGY0LFxuICAvLyBsb3dlcmNhc2UgbywgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZjogMHhmYixcbiAgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweDkwOiAweGMxLFxuICAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgMHg5MTogMHhjOSxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gIDB4OTI6IDB4ZDMsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAweDkzOiAweGRhLFxuICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgMHg5NDogMHhkYyxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gIDB4OTU6IDB4ZmMsXG4gIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAweDk2OiAweDIwMTgsXG4gIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gIDB4OTc6IDB4YTEsXG4gIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgMHg5ODogMHgyYSxcbiAgLy8gYXN0ZXJpc2tcbiAgMHg5OTogMHgyMDE5LFxuICAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAweDlhOiAweDI1MDEsXG4gIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gIDB4OWI6IDB4YTksXG4gIC8vIGNvcHlyaWdodCBzaWduXG4gIDB4OWM6IDB4MjEyMCxcbiAgLy8gU2VydmljZSBtYXJrXG4gIDB4OWQ6IDB4MjAyMixcbiAgLy8gKHJvdW5kKSBidWxsZXRcbiAgMHg5ZTogMHgyMDFjLFxuICAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweDlmOiAweDIwMWQsXG4gIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweGEwOiAweGMwLFxuICAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gIDB4YTE6IDB4YzIsXG4gIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gIDB4YTI6IDB4YzcsXG4gIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAweGEzOiAweGM4LFxuICAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gIDB4YTQ6IDB4Y2EsXG4gIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gIDB4YTU6IDB4Y2IsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAweGE2OiAweGViLFxuICAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAweGE3OiAweGNlLFxuICAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAweGE4OiAweGNmLFxuICAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAweGE5OiAweGVmLFxuICAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAweGFhOiAweGQ0LFxuICAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAweGFiOiAweGQ5LFxuICAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gIDB4YWM6IDB4ZjksXG4gIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgMHhhZDogMHhkYixcbiAgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgMHhhZTogMHhhYixcbiAgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgMHhhZjogMHhiYixcbiAgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweGIwOiAweGMzLFxuICAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgMHhiMTogMHhlMyxcbiAgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gIDB4YjI6IDB4Y2QsXG4gIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgMHhiMzogMHhjYyxcbiAgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAweGI0OiAweGVjLFxuICAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gIDB4YjU6IDB4ZDIsXG4gIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgMHhiNjogMHhmMixcbiAgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAweGI3OiAweGQ1LFxuICAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgMHhiODogMHhmNSxcbiAgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gIDB4Yjk6IDB4N2IsXG4gIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgMHhiYTogMHg3ZCxcbiAgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAweGJiOiAweDVjLFxuICAvLyBCYWNrc2xhc2hcbiAgMHhiYzogMHg1ZSxcbiAgLy8gQ2FyZXRcbiAgMHhiZDogMHg1ZixcbiAgLy8gVW5kZXJzY29yZVxuICAweGJlOiAweDdjLFxuICAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAweGJmOiAweDIyM2MsXG4gIC8vIFRpbGRlIG9wZXJhdG9yXG4gIDB4YzA6IDB4YzQsXG4gIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcbiAgMHhjMTogMHhlNCxcbiAgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAweGMyOiAweGQ2LFxuICAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gIDB4YzM6IDB4ZjYsXG4gIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcbiAgMHhjNDogMHhkZixcbiAgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgMHhjNTogMHhhNSxcbiAgLy8gWWVuIHN5bWJvbFxuICAweGM2OiAweGE0LFxuICAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cbiAgMHhjNzogMHgyNTAzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgMHhjODogMHhjNSxcbiAgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgMHhjOTogMHhlNSxcbiAgLy8gTG93ZXJjYXNlIEEsIHJpbmdcbiAgMHhjYTogMHhkOCxcbiAgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAweGNiOiAweGY4LFxuICAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgMHhjYzogMHgyNTBmLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgMHhjZDogMHgyNTEzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAweGNlOiAweDI1MTcsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgMHhjZjogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG5jb25zdCBnZXRDaGFyRm9yQnl0ZSA9IGZ1bmN0aW9uIGdldENoYXJGb3JCeXRlKGJ5dGUpIHtcbiAgbGV0IGNoYXJDb2RlID0gYnl0ZTtcbiAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XG4gICAgY2hhckNvZGUgPSBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlc1tieXRlXTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59O1xuY29uc3QgTlJfUk9XUyA9IDE1O1xuY29uc3QgTlJfQ09MUyA9IDEwMDtcbi8vIFRhYmxlcyB0byBsb29rIHVwIHJvdyBmcm9tIFBBQyBkYXRhXG5jb25zdCByb3dzTG93Q2gxID0ge1xuICAweDExOiAxLFxuICAweDEyOiAzLFxuICAweDE1OiA1LFxuICAweDE2OiA3LFxuICAweDE3OiA5LFxuICAweDEwOiAxMSxcbiAgMHgxMzogMTIsXG4gIDB4MTQ6IDE0XG59O1xuY29uc3Qgcm93c0hpZ2hDaDEgPSB7XG4gIDB4MTE6IDIsXG4gIDB4MTI6IDQsXG4gIDB4MTU6IDYsXG4gIDB4MTY6IDgsXG4gIDB4MTc6IDEwLFxuICAweDEzOiAxMyxcbiAgMHgxNDogMTVcbn07XG5jb25zdCByb3dzTG93Q2gyID0ge1xuICAweDE5OiAxLFxuICAweDFhOiAzLFxuICAweDFkOiA1LFxuICAweDFlOiA3LFxuICAweDFmOiA5LFxuICAweDE4OiAxMSxcbiAgMHgxYjogMTIsXG4gIDB4MWM6IDE0XG59O1xuY29uc3Qgcm93c0hpZ2hDaDIgPSB7XG4gIDB4MTk6IDIsXG4gIDB4MWE6IDQsXG4gIDB4MWQ6IDYsXG4gIDB4MWU6IDgsXG4gIDB4MWY6IDEwLFxuICAweDFiOiAxMyxcbiAgMHgxYzogMTVcbn07XG5jb25zdCBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG5jbGFzcyBDYXB0aW9uc0xvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGltZSA9IG51bGw7XG4gICAgdGhpcy52ZXJib3NlTGV2ZWwgPSAwO1xuICB9XG4gIGxvZyhzZXZlcml0eSwgbXNnKSB7XG4gICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IHNldmVyaXR5KSB7XG4gICAgICBjb25zdCBtID0gdHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJyA/IG1zZygpIDogbXNnO1xuICAgICAgbG9nZ2VyLmxvZyhgJHt0aGlzLnRpbWV9IFske3NldmVyaXR5fV0gJHttfWApO1xuICAgIH1cbiAgfVxufVxuY29uc3QgbnVtQXJyYXlUb0hleEFycmF5ID0gZnVuY3Rpb24gbnVtQXJyYXlUb0hleEFycmF5KG51bUFycmF5KSB7XG4gIGNvbnN0IGhleEFycmF5ID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIGhleEFycmF5O1xufTtcbmNsYXNzIFBlblN0YXRlIHtcbiAgY29uc3RydWN0b3IoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IHZvaWQgMDtcbiAgICB0aGlzLnVuZGVybGluZSA9IHZvaWQgMDtcbiAgICB0aGlzLml0YWxpY3MgPSB2b2lkIDA7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdm9pZCAwO1xuICAgIHRoaXMuZmxhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZCB8fCAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gdW5kZXJsaW5lIHx8IGZhbHNlO1xuICAgIHRoaXMuaXRhbGljcyA9IGl0YWxpY3MgfHwgZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZCB8fCAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmbGFzaCB8fCBmYWxzZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcbiAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gIH1cbiAgc2V0U3R5bGVzKHN0eWxlcykge1xuICAgIGNvbnN0IGF0dHJpYnMgPSBbJ2ZvcmVncm91bmQnLCAndW5kZXJsaW5lJywgJ2l0YWxpY3MnLCAnYmFja2dyb3VuZCcsICdmbGFzaCddO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3R5bGUgPSBhdHRyaWJzW2ldO1xuICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0RlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2g7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yZWdyb3VuZCA9PT0gb3RoZXIuZm9yZWdyb3VuZCAmJiB0aGlzLnVuZGVybGluZSA9PT0gb3RoZXIudW5kZXJsaW5lICYmIHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09IG90aGVyLmJhY2tncm91bmQgJiYgdGhpcy5mbGFzaCA9PT0gb3RoZXIuZmxhc2g7XG4gIH1cbiAgY29weShuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IG5ld1BlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgdGhpcy5pdGFsaWNzID0gbmV3UGVuU3RhdGUuaXRhbGljcztcbiAgICB0aGlzLmJhY2tncm91bmQgPSBuZXdQZW5TdGF0ZS5iYWNrZ3JvdW5kO1xuICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ2NvbG9yPScgKyB0aGlzLmZvcmVncm91bmQgKyAnLCB1bmRlcmxpbmU9JyArIHRoaXMudW5kZXJsaW5lICsgJywgaXRhbGljcz0nICsgdGhpcy5pdGFsaWNzICsgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2g7XG4gIH1cbn1cblxuLyoqXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3R5bGVkVW5pY29kZUNoYXIge1xuICBjb25zdHJ1Y3Rvcih1Y2hhciwgZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgIHRoaXMudWNoYXIgPSB2b2lkIDA7XG4gICAgdGhpcy5wZW5TdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXIgfHwgJyAnOyAvLyB1bmljb2RlIGNoYXJhY3RlclxuICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XG4gIH1cbiAgc2V0Q2hhcih1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfVxuICBzZXRQZW5TdGF0ZShuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcbiAgfVxuICBjb3B5KG5ld0NoYXIpIHtcbiAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJvdyB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIHRoaXMuY2hhcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5wb3MgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzLnB1c2gobmV3IFN0eWxlZFVuaWNvZGVDaGFyKCkpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoKTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xuICB9XG4gIGNvcHkob3RoZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcbiAgICB9XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cblxuICAvKipcbiAgICogIFNldCB0aGUgY3Vyc29yIHRvIGEgdmFsaWQgY29sdW1uLlxuICAgKi9cbiAgc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICB9XG4gICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zID4gTlJfQ09MUykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGN1cnNvciByZWxhdGl2ZSB0byBjdXJyZW50IHBvc2l0aW9uLlxuICAgKi9cbiAgbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICBjb25zdCBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcbiAgICBpZiAocmVsUG9zID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMucG9zICsgMTsgaSA8IG5ld1BvcyArIDE7IGkrKykge1xuICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgKi9cbiAgYmFja1NwYWNlKCkge1xuICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfVxuICBpbnNlcnRDaGFyKGJ5dGUpIHtcbiAgICBpZiAoYnl0ZSA+PSAweDkwKSB7XG4gICAgICAvLyBFeHRlbmRlZCBjaGFyXG4gICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIH1cbiAgICBjb25zdCBjaGFyID0gZ2V0Q2hhckZvckJ5dGUoYnl0ZSk7XG4gICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygwLCAoKSA9PiAnQ2Fubm90IGluc2VydCAnICsgYnl0ZS50b1N0cmluZygxNikgKyAnICgnICsgY2hhciArICcpIGF0IHBvc2l0aW9uICcgKyB0aGlzLnBvcyArICcuIFNraXBwaW5nIGl0IScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKGNoYXIsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB0aGlzLm1vdmVDdXJzb3IoMSk7XG4gIH1cbiAgY2xlYXJGcm9tUG9zKHN0YXJ0UG9zKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gc3RhcnRQb3M7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gIH1cbiAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgfVxuICBnZXRUZXh0U3RyaW5nKCkge1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG4gICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgIH1cbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH1cbiAgfVxuICBzZXRQZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgY29uc3QgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcbiAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDYXB0aW9uU2NyZWVuIHtcbiAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgdGhpcy5yb3dzID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclJvdyA9IHZvaWQgMDtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yb3dzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3cobG9nZ2VyKSk7XG4gICAgfSAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxuXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cbiAgY29weShvdGhlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY29weShvdGhlci5yb3dzW2ldKTtcbiAgICB9XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuICBiYWNrU3BhY2UoKSB7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LmJhY2tTcGFjZSgpO1xuICB9XG4gIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICovXG4gIGluc2VydENoYXIoY2hhcikge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5pbnNlcnRDaGFyKGNoYXIpO1xuICB9XG4gIHNldFBlbihzdHlsZXMpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XG4gIH1cbiAgbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICB9XG4gIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldEN1cnNvcihhYnNQb3MpO1xuICB9XG4gIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+ICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICBsZXQgbmV3Um93ID0gcGFjRGF0YS5yb3cgLSAxO1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzIC0gMTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhpcyBvbmx5IGFmZmVjdHMgUm9sbC11cCBDYXB0aW9ucyBieSBjaGVja2luZyB0aGlzLm5yUm9sbFVwUm93c1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgLy8gY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAvLyB0b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcbiAgICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgICAgLy8gV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxuICAgICAgLy8gV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cbiAgICAgIGNvbnN0IGxhc3RPdXRwdXRTY3JlZW4gPSB0aGlzLmxhc3RPdXRwdXRTY3JlZW47XG4gICAgICBpZiAobGFzdE91dHB1dFNjcmVlbikge1xuICAgICAgICBjb25zdCBwcmV2TGluZVRpbWUgPSBsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXhdLmN1ZVN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG4gICAgICAgIGlmIChwcmV2TGluZVRpbWUgJiYgdGltZSAhPT0gbnVsbCAmJiBwcmV2TGluZVRpbWUgPCB0aW1lKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5yUm9sbFVwUm93czsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93IC0gdGhpcy5uclJvbGxVcFJvd3MgKyBpICsgMV0uY29weShsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXggKyBpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VyclJvdyA9IG5ld1JvdztcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgY29uc3QgcHJldlBvcyA9IE1hdGgubWF4KGluZGVudCAtIDEsIDApO1xuICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgIGZvcmVncm91bmQ6IHBhY0RhdGEuY29sb3IsXG4gICAgICB1bmRlcmxpbmU6IHBhY0RhdGEudW5kZXJsaW5lLFxuICAgICAgaXRhbGljczogcGFjRGF0YS5pdGFsaWNzLFxuICAgICAgYmFja2dyb3VuZDogJ2JsYWNrJyxcbiAgICAgIGZsYXNoOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAqL1xuICBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xuICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XG4gICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvLyBTcGFjZVxuICB9XG5cbiAgc2V0Um9sbFVwUm93cyhuclJvd3MpIHtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG5yUm93cztcbiAgfVxuICByb2xsVXAoKSB7XG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgcmV0dXJuOyAvLyBOb3QgcHJvcGVybHkgc2V0dXBcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coMSwgKCkgPT4gdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICBjb25zdCB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcbiAgICBjb25zdCB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICB0b3BSb3cuY2xlYXIoKTtcbiAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JvbGxpbmcgdXAnKTtcbiAgICAvLyB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAqL1xuICBnZXREaXNwbGF5VGV4dChhc09uZVJvdykge1xuICAgIGFzT25lUm93ID0gYXNPbmVSb3cgfHwgZmFsc2U7XG4gICAgY29uc3QgZGlzcGxheVRleHQgPSBbXTtcbiAgICBsZXQgdGV4dCA9ICcnO1xuICAgIGxldCByb3dOciA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBjb25zdCByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcbiAgICAgIGlmIChyb3dUZXh0KSB7XG4gICAgICAgIHJvd05yID0gaSArIDE7XG4gICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyBcIjogJ1wiICsgcm93VGV4dCArIFwiJ1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlzcGxheVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgZ2V0VGV4dEFuZEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzO1xuICB9XG59XG5cbi8vIHZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbmNsYXNzIENlYTYwOENoYW5uZWwge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsTnVtYmVyLCBvdXRwdXRGaWx0ZXIsIGxvZ2dlcikge1xuICAgIHRoaXMuY2hOciA9IHZvaWQgMDtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy52ZXJib3NlID0gdm9pZCAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB2b2lkIDA7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy52ZXJib3NlID0gMDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbihsb2dnZXIpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyLnJlc2V0KCk7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICB9XG4gIGdldEhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICB9XG4gIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gbmV3SGFuZGxlcjtcbiAgfVxuICBzZXRQQUMocGFjRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKHBhY0RhdGEpO1xuICB9XG4gIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgfVxuICBzZXRNb2RlKG5ld01vZGUpIHtcbiAgICBpZiAobmV3TW9kZSA9PT0gdGhpcy5tb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+ICdNT0RFPScgKyBuZXdNb2RlKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZSAhPT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICB9XG4gIGluc2VydENoYXJzKGNoYXJzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5pbnNlcnRDaGFyKGNoYXJzW2ldKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuID0gdGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPyAnRElTUCcgOiAnTk9OX0RJU1AnO1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiBzY3JlZW4gKyAnOiAnICsgdGhpcy53cml0ZVNjcmVlbi5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygxLCAoKSA9PiAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGNjUkNMKCkge1xuICAgIC8vIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcgKHN3aXRjaCBtb2RlIHRvIFBvcCBPbilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gIH1cbiAgY2NCUygpIHtcbiAgICAvLyBCYWNrU3BhY2VcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfVEVYVCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcbiAgICBpZiAodGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkpIHtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBjY0FPRigpIHtcbiAgICAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuICB9XG4gIGNjQU9OKCkge1xuICAgIC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgfVxuICBjY0RFUigpIHtcbiAgICAvLyBEZWxldGUgdG8gRW5kIG9mIFJvd1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gIH1cbiAgY2NSVShuclJvd3MpIHtcbiAgICAvLyBSb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JVKCcgKyBuclJvd3MgKyAnKSAtIFJvbGwgVXAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcbiAgfVxuICBjY0ZPTigpIHtcbiAgICAvLyBGbGFzaCBPblxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbih7XG4gICAgICBmbGFzaDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNjUkRDKCkge1xuICAgIC8vIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZyAoc3dpdGNoIG1vZGUgdG8gUGFpbnRPbilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICB9XG4gIGNjVFIoKSB7XG4gICAgLy8gVGV4dCBSZXN0YXJ0IGluIHRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1RSJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfVxuICBjY1JURCgpIHtcbiAgICAvLyBSZXN1bWUgVGV4dCBEaXNwbGF5IGluIFRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JURCcpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gIH1cbiAgY2NFRE0oKSB7XG4gICAgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG4gIGNjQ1IoKSB7XG4gICAgLy8gQ2FycmlhZ2UgUmV0dXJuXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdDUiAtIENhcnJpYWdlIFJldHVybicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG4gIGNjRU5NKCkge1xuICAgIC8vIEVyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gIH1cbiAgY2NFT0MoKSB7XG4gICAgLy8gRW5kIG9mIENhcHRpb24gKEZsaXAgTWVtb3JpZXMpXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIGNvbnN0IHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdG1wO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDEsICgpID0+ICdESVNQOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgfVxuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfVxuICBjY1RPKG5yQ29scykge1xuICAgIC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLm1vdmVDdXJzb3IobnJDb2xzKTtcbiAgfVxuICBjY01JRFJPVyhzZWNvbmRCeXRlKSB7XG4gICAgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICBmbGFzaDogZmFsc2VcbiAgICB9O1xuICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcbiAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICBpZiAoIXN0eWxlcy5pdGFsaWNzKSB7XG4gICAgICBjb25zdCBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlIC8gMikgLSAweDEwO1xuICAgICAgY29uc3QgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XG4gICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ01JRFJPVzogJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlcykpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHN0eWxlcyk7XG4gIH1cbiAgb3V0cHV0RGF0YVVwZGF0ZShkaXNwYXRjaCA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG4gICAgaWYgKHRpbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICAvLyBTdGFydCBvZiBhIG5ldyBjdWVcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xuICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdGltZSwgdGhpcy5sYXN0T3V0cHV0U2NyZWVuKTtcbiAgICAgICAgICBpZiAoZGlzcGF0Y2ggJiYgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpID8gbnVsbCA6IHRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICB9XG4gIH1cbiAgY3VlU3BsaXRBdFRpbWUodCkge1xuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gV2lsbCBiZSAxIG9yIDIgd2hlbiBwYXJzaW5nIGNhcHRpb25zXG5cbmNsYXNzIENlYTYwOFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBvdXQxLCBvdXQyKSB7XG4gICAgdGhpcy5jaGFubmVscyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gMDtcbiAgICB0aGlzLmNtZEhpc3RvcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENhcHRpb25zTG9nZ2VyKCk7XG4gICAgdGhpcy5jaGFubmVscyA9IFtudWxsLCBuZXcgQ2VhNjA4Q2hhbm5lbChmaWVsZCwgb3V0MSwgbG9nZ2VyKSwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQgKyAxLCBvdXQyLCBsb2dnZXIpXTtcbiAgICB0aGlzLmNtZEhpc3RvcnkgPSBjcmVhdGVDbWRIaXN0b3J5KCk7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgZ2V0SGFuZGxlcihjaGFubmVsKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uZ2V0SGFuZGxlcigpO1xuICB9XG4gIHNldEhhbmRsZXIoY2hhbm5lbCwgbmV3SGFuZGxlcikge1xuICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAqL1xuICBhZGREYXRhKHRpbWUsIGJ5dGVMaXN0KSB7XG4gICAgbGV0IGNtZEZvdW5kO1xuICAgIGxldCBhO1xuICAgIGxldCBiO1xuICAgIGxldCBjaGFyc0ZvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5sb2dnZXIudGltZSA9IHRpbWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGlzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgIGIgPSBieXRlTGlzdFtpICsgMV0gJiAweDdmO1xuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSArICddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgfVxuICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VNaWRyb3coYSwgYik7XG4gICAgICB9XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZVBBQyhhLCBiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICB9XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNoYXJzRm91bmQgPSB0aGlzLnBhcnNlQ2hhcnMoYSwgYik7XG4gICAgICAgIGlmIChjaGFyc0ZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgY3VyckNoTnIgPSB0aGlzLmN1cnJlbnRDaGFubmVsO1xuICAgICAgICAgIGlmIChjdXJyQ2hOciAmJiBjdXJyQ2hOciA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2N1cnJDaE5yXTtcbiAgICAgICAgICAgIGNoYW5uZWwuaW5zZXJ0Q2hhcnMoY2hhcnNGb3VuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnTm8gY2hhbm5lbCBmb3VuZCB5ZXQuIFRFWFQtTU9ERT8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQgJiYgIWNoYXJzRm91bmQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDIsIFwiQ291bGRuJ3QgcGFyc2UgY2xlYW5lZCBkYXRhIFwiICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIENvbW1hbmQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgYSBjb21tYW5kIHdhcyBmb3VuZFxuICAgKi9cbiAgcGFyc2VDbWQoYSwgYikge1xuICAgIGNvbnN0IHtcbiAgICAgIGNtZEhpc3RvcnlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MWMgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFkKSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmO1xuICAgIGNvbnN0IGNvbmQyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgYiA+PSAweDIxICYmIGIgPD0gMHgyMztcbiAgICBpZiAoIShjb25kMSB8fCBjb25kMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpKSB7XG4gICAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIGNtZEhpc3RvcnkpO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2hOciA9IGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDE3ID8gMSA6IDI7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFjIHx8IGEgPT09IDB4MWQpIHtcbiAgICAgIGlmIChiID09PSAweDIwKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMSkge1xuICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICBjaGFubmVsLmNjQU9GKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI0KSB7XG4gICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICBjaGFubmVsLmNjUlUoMik7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjYpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI3KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICBjaGFubmVsLmNjRk9OKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjkpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJhKSB7XG4gICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJiKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVEQoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYykge1xuICAgICAgICBjaGFubmVsLmNjRURNKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmUpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VOTSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICB9XG4gICAgc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KTtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAqL1xuICBwYXJzZU1pZHJvdyhhLCBiKSB7XG4gICAgbGV0IGNoTnIgPSAwO1xuICAgIGlmICgoYSA9PT0gMHgxMSB8fCBhID09PSAweDE5KSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XG4gICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICBjaE5yID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoTnIgPSAyO1xuICAgICAgfVxuICAgICAgaWYgKGNoTnIgIT09IHRoaXMuY3VycmVudENoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDAsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWwuY2NNSURST1coYik7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ01JRFJPVyAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgUHJlYWJsZSBBY2Nlc3MgQ29kZXMgKFRhYmxlIDUzKS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgKi9cbiAgcGFyc2VQQUMoYSwgYikge1xuICAgIGxldCByb3c7XG4gICAgY29uc3QgY21kSGlzdG9yeSA9IHRoaXMuY21kSGlzdG9yeTtcbiAgICBjb25zdCBjYXNlMSA9IChhID49IDB4MTEgJiYgYSA8PSAweDE3IHx8IGEgPj0gMHgxOSAmJiBhIDw9IDB4MWYpICYmIGIgPj0gMHg0MCAmJiBiIDw9IDB4N2Y7XG4gICAgY29uc3QgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDVmO1xuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkpIHtcbiAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgfVxuXG4gICAgY29uc3QgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgIGlmIChiID49IDB4NDAgJiYgYiA8PSAweDVmKSB7XG4gICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0xvd0NoMVthXSA6IHJvd3NMb3dDaDJbYV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDB4NjAgPD0gYiA8PSAweDdGXG4gICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0hpZ2hDaDFbYV0gOiByb3dzSGlnaENoMlthXTtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoYW5uZWwuc2V0UEFDKHRoaXMuaW50ZXJwcmV0UEFDKHJvdywgYikpO1xuICAgIHNldExhc3RDbWQoYSwgYiwgY21kSGlzdG9yeSk7XG4gICAgdGhpcy5jdXJyZW50Q2hhbm5lbCA9IGNoTnI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJwcmV0IHRoZSBzZWNvbmQgYnl0ZSBvZiB0aGUgcGFjLCBhbmQgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbi5cbiAgICogQHJldHVybnMgcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnNcbiAgICovXG4gIGludGVycHJldFBBQyhyb3csIGJ5dGUpIHtcbiAgICBsZXQgcGFjSW5kZXg7XG4gICAgY29uc3QgcGFjRGF0YSA9IHtcbiAgICAgIGNvbG9yOiBudWxsLFxuICAgICAgaXRhbGljczogZmFsc2UsXG4gICAgICBpbmRlbnQ6IG51bGwsXG4gICAgICB1bmRlcmxpbmU6IGZhbHNlLFxuICAgICAgcm93OiByb3dcbiAgICB9O1xuICAgIGlmIChieXRlID4gMHg1Zikge1xuICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg2MDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg0MDtcbiAgICB9XG4gICAgcGFjRGF0YS51bmRlcmxpbmUgPSAocGFjSW5kZXggJiAxKSA9PT0gMTtcbiAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleCAvIDIpXTtcbiAgICB9IGVsc2UgaWYgKHBhY0luZGV4IDw9IDB4Zikge1xuICAgICAgcGFjRGF0YS5pdGFsaWNzID0gdHJ1ZTtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSAnd2hpdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNEYXRhLmluZGVudCA9IE1hdGguZmxvb3IoKHBhY0luZGV4IC0gMHgxMCkgLyAyKSAqIDQ7XG4gICAgfVxuICAgIHJldHVybiBwYWNEYXRhOyAvLyBOb3RlIHRoYXQgcm93IGhhcyB6ZXJvIG9mZnNldC4gVGhlIHNwZWMgdXNlcyAxLlxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIHBhcnNlQ2hhcnMoYSwgYikge1xuICAgIGxldCBjaGFubmVsTnI7XG4gICAgbGV0IGNoYXJDb2RlcyA9IG51bGw7XG4gICAgbGV0IGNoYXJDb2RlMSA9IG51bGw7XG4gICAgaWYgKGEgPj0gMHgxOSkge1xuICAgICAgY2hhbm5lbE5yID0gMjtcbiAgICAgIGNoYXJDb2RlMSA9IGEgLSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsTnIgPSAxO1xuICAgICAgY2hhckNvZGUxID0gYTtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2RlMSA+PSAweDExICYmIGNoYXJDb2RlMSA8PSAweDEzKSB7XG4gICAgICAvLyBTcGVjaWFsIGNoYXJhY3RlclxuICAgICAgbGV0IG9uZUNvZGU7XG4gICAgICBpZiAoY2hhckNvZGUxID09PSAweDExKSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg1MDtcbiAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUxID09PSAweDEyKSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg3MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg5MDtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIlNwZWNpYWwgY2hhciAnXCIgKyBnZXRDaGFyRm9yQnl0ZShvbmVDb2RlKSArIFwiJyBpbiBjaGFubmVsIFwiICsgY2hhbm5lbE5yKTtcbiAgICAgIGNoYXJDb2RlcyA9IFtvbmVDb2RlXTtcbiAgICB9IGVsc2UgaWYgKGEgPj0gMHgyMCAmJiBhIDw9IDB4N2YpIHtcbiAgICAgIGNoYXJDb2RlcyA9IGIgPT09IDAgPyBbYV0gOiBbYSwgYl07XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZXMpIHtcbiAgICAgIGNvbnN0IGhleENvZGVzID0gbnVtQXJyYXlUb0hleEFycmF5KGNoYXJDb2Rlcyk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XG4gICAgICBzZXRMYXN0Q21kKGEsIGIsIHRoaXMuY21kSGlzdG9yeSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyQ29kZXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgZXh0ZW5kZWQgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgbmV3IGZvcmVncm91bmQgY29sb3IgYmxhY2suXG4gICAqIEByZXR1cm5zIFRydWUgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuICAgKi9cbiAgcGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKSB7XG4gICAgY29uc3QgY2FzZTEgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmO1xuICAgIGNvbnN0IGNhc2UyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgYiA+PSAweDJkICYmIGIgPD0gMHgyZjtcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGluZGV4O1xuICAgIGNvbnN0IGJrZ0RhdGEgPSB7fTtcbiAgICBpZiAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSB7XG4gICAgICBpbmRleCA9IE1hdGguZmxvb3IoKGIgLSAweDIwKSAvIDIpO1xuICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmtnRGF0YS5iYWNrZ3JvdW5kICsgJ19zZW1pJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG4gICAgICBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoTnIgPSBhIDw9IDB4MTcgPyAxIDogMjtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgc2V0TGFzdENtZChhLCBiLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHN0YXRlIG9mIHBhcnNlciBhbmQgaXRzIGNoYW5uZWxzLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxzKS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG4gICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjaGFubmVsLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY21kSGlzdG9yeSA9IGNyZWF0ZUNtZEhpc3RvcnkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxuICAgKi9cbiAgY3VlU3BsaXRBdFRpbWUodCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG4gICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjaGFubmVsLmN1ZVNwbGl0QXRUaW1lKHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KSB7XG4gIGNtZEhpc3RvcnkuYSA9IGE7XG4gIGNtZEhpc3RvcnkuYiA9IGI7XG59XG5mdW5jdGlvbiBoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSB7XG4gIHJldHVybiBjbWRIaXN0b3J5LmEgPT09IGEgJiYgY21kSGlzdG9yeS5iID09PSBiO1xufVxuZnVuY3Rpb24gY3JlYXRlQ21kSGlzdG9yeSgpIHtcbiAgcmV0dXJuIHtcbiAgICBhOiBudWxsLFxuICAgIGI6IG51bGxcbiAgfTtcbn1cblxuY2xhc3MgT3V0cHV0RmlsdGVyIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmVDb250cm9sbGVyLCB0cmFja05hbWUpIHtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgIHRoaXMudHJhY2tOYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLmVuZFRpbWUgPSBudWxsO1xuICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlciA9IHRpbWVsaW5lQ29udHJvbGxlcjtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IHRyYWNrTmFtZTtcbiAgfVxuICBkaXNwYXRjaEN1ZSgpIHtcbiAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4sIHRoaXMuY3VlUmFuZ2VzKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIH1cbiAgbmV3Q3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsIHx8IHRoaXMuc3RhcnRUaW1lID4gc3RhcnRUaW1lKSB7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB9XG4gICAgdGhpcy5lbmRUaW1lID0gZW5kVGltZTtcbiAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5jcmVhdGVDYXB0aW9uc1RyYWNrKHRoaXMudHJhY2tOYW1lKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIFZUVEN1ZSA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5WVFRDdWUpIHtcbiAgICByZXR1cm4gc2VsZi5WVFRDdWU7XG4gIH1cbiAgY29uc3QgQWxsb3dlZERpcmVjdGlvbnMgPSBbJycsICdscicsICdybCddO1xuICBjb25zdCBBbGxvd2VkQWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnbWlkZGxlJywgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J107XG4gIGZ1bmN0aW9uIGlzQWxsb3dlZFZhbHVlKGFsbG93ZWQsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbmVjZXNzYXJ5IGZvciBhc3N1cmluZyB0aGUgZ2VuZXJpYyBjb25mb3JtcyB0byB0aGUgQXJyYXkgaW50ZXJmYWNlXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFsbG93ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJlc2V0IHRoZSB0eXBlIHNvIHRoYXQgdGhlIG5leHQgbmFycm93aW5nIHdvcmtzIHdlbGxcbiAgICBjb25zdCBsY1ZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyB1c2UgdGhlIGFsbG93IGxpc3QgdG8gbmFycm93IHRoZSB0eXBlIHRvIGEgc3BlY2lmaWMgc3Vic2V0IG9mIHN0cmluZ3NcbiAgICBpZiAofmFsbG93ZWQuaW5kZXhPZihsY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIGxjVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FsbG93ZWRWYWx1ZShBbGxvd2VkRGlyZWN0aW9ucywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBbGxvd2VkVmFsdWUoQWxsb3dlZEFsaWdubWVudHMsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBleHRlbmQob2JqLCAuLi5yZXN0KSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChjb25zdCBwIGluIGNvYmopIHtcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBmdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgY29uc3QgY3VlID0gdGhpcztcbiAgICBjb25zdCBiYXNlT2JqID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cbiAgICAgKiB0aGUgc3BlYy5cbiAgICAgKi9cblxuICAgIC8vIExldHMgdXMga25vdyB3aGVuIHRoZSBWVFRDdWUncyBkYXRhIGhhcyBjaGFuZ2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBuZWVkXG4gICAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAgIC8vIGxhemlseS5cbiAgICBjdWUuaGFzQmVlblJlc2V0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXG4gICAgICovXG5cbiAgICBsZXQgX2lkID0gJyc7XG4gICAgbGV0IF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICAgIGxldCBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIGxldCBfZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgbGV0IF90ZXh0ID0gdGV4dDtcbiAgICBsZXQgX3JlZ2lvbiA9IG51bGw7XG4gICAgbGV0IF92ZXJ0aWNhbCA9ICcnO1xuICAgIGxldCBfc25hcFRvTGluZXMgPSB0cnVlO1xuICAgIGxldCBfbGluZSA9ICdhdXRvJztcbiAgICBsZXQgX2xpbmVBbGlnbiA9ICdzdGFydCc7XG4gICAgbGV0IF9wb3NpdGlvbiA9IDUwO1xuICAgIGxldCBfcG9zaXRpb25BbGlnbiA9ICdtaWRkbGUnO1xuICAgIGxldCBfc2l6ZSA9IDUwO1xuICAgIGxldCBfYWxpZ24gPSAnbWlkZGxlJztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnaWQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwYXVzZU9uRXhpdCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3N0YXJ0VGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2VuZFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2VuZFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBfZW5kVGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd0ZXh0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIHRvZG86IGltcGxlbWVudCBWVFRSZWdpb24gcG9seWZpbGw/XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3JlZ2lvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzbmFwVG9MaW5lcycsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3NuYXBUb0xpbmVzID0gISF2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbkFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAqL1xuXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWVFRDdWUgbWV0aG9kc1xuICAgKi9cblxuICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICBjb25zdCBXZWJWVFQgPSBzZWxmLldlYlZUVDtcbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUoc2VsZiwgdGhpcy50ZXh0KTtcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHBvbHlmaWxsIGhhY2tcbiAgcmV0dXJuIFZUVEN1ZTtcbn0pKCk7XG5cbi8qXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9kaXN0L3Z0dC5qc1xuICovXG5cbmNsYXNzIFN0cmluZ0RlY29kZXIge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICB9XG59XG5cbi8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG5mdW5jdGlvbiBwYXJzZVRpbWVTdGFtcChpbnB1dCkge1xuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIHBhcnNlRmxvYXQoZiB8fCAwKTtcbiAgfVxuICBjb25zdCBtID0gaW5wdXQubWF0Y2goL14oPzooXFxkKyk6KT8oXFxkezJ9KTooXFxkezJ9KShcXC5cXGQrKT8vKTtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBhcnNlRmxvYXQobVsyXSkgPiA1OSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsyXSwgbVszXSwgMCwgbVs0XSk7XG4gIH1cbiAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3VycyAob3B0aW9uYWwpXTpbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKTtcbn1cblxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuY2xhc3MgU2V0dGluZ3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgc2V0KGssIHYpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9XG4gIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxuICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxuICBnZXQoaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgfVxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gIGhhcyhrKSB7XG4gICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XG4gIH1cbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgb25lIG9mIHRoZSBnaXZlbiBhbHRlcm5hdGl2ZXMuXG4gIGFsdChrLCB2LCBhKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgKHNpZ25lZCkgaW50ZWdlci5cbiAgaW50ZWdlcihrLCB2KSB7XG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkge1xuICAgICAgLy8gaW50ZWdlclxuICAgICAgdGhpcy5zZXQoaywgcGFyc2VJbnQodiwgMTApKTtcbiAgICB9XG4gIH1cbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICBwZXJjZW50KGssIHYpIHtcbiAgICBpZiAoL14oW1xcZF17MSwzfSkoXFwuW1xcZF0qKT8lJC8udGVzdCh2KSkge1xuICAgICAgY29uc3QgcGVyY2VudCA9IHBhcnNlRmxvYXQodik7XG4gICAgICBpZiAocGVyY2VudCA+PSAwICYmIHBlcmNlbnQgPD0gMTAwKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHBlcmNlbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldCBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgY29uc3QgZ3JvdXBzID0gZ3JvdXBEZWxpbSA/IGlucHV0LnNwbGl0KGdyb3VwRGVsaW0pIDogW2lucHV0XTtcbiAgZm9yIChjb25zdCBpIGluIGdyb3Vwcykge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrID0ga3ZbMF07XG4gICAgY29uc3QgdiA9IGt2WzFdO1xuICAgIGNhbGxiYWNrKGssIHYpO1xuICB9XG59XG5jb25zdCBkZWZhdWx0cyA9IG5ldyBWVFRDdWUoMCwgMCwgJycpO1xuLy8gJ21pZGRsZScgd2FzIGNoYW5nZWQgdG8gJ2NlbnRlcicgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnR0L3B1bGwvMjQ0XG4vLyAgU2FmYXJpIGRvZXNuJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBhbmQgQ2hyb21lIGRvLlxuY29uc3QgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcbmZ1bmN0aW9uIHBhcnNlQ3VlKGlucHV0LCBjdWUsIHJlZ2lvbkxpc3QpIHtcbiAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIGlucHV0IGlmIHdlIG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IuXG4gIGNvbnN0IG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgIGNvbnN0IHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuICAgIGlmICh0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZXN0YW1wOiAnICsgb0lucHV0KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlteXFxzYS16QS1aLV0rLywgJycpO1xuICAgIHJldHVybiB0cztcbiAgfVxuXG4gIC8vIDQuNC4yIFdlYlZUVCBjdWUgc2V0dGluZ3NcbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIGxldCB2YWxzO1xuICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxuICAgICAgICAgIGZvciAobGV0IGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocmVnaW9uTGlzdFtpXS5pZCA9PT0gdikge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydybCcsICdsciddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHNbMF0pO1xuICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoJ3NuYXBUb0xpbmVzJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsc1swXSwgWydhdXRvJ10pO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdCgncG9zaXRpb25BbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGluZS1sZWZ0JywgJ2xpbmUtcmlnaHQnLCAnYXV0byddKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FsaWduJzpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIC86LywgL1xccy8pO1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cbiAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KCdyZWdpb24nLCBudWxsKTtcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoJ3ZlcnRpY2FsJywgJycpO1xuICAgIGxldCBsaW5lID0gc2V0dGluZ3MuZ2V0KCdsaW5lJywgJ2F1dG8nKTtcbiAgICBpZiAobGluZSA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLmxpbmUgPT09IC0xKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBsaW5lIG51bWJlciBmb3IgU2FmYXJpXG4gICAgICBsaW5lID0gLTE7XG4gICAgfVxuICAgIGN1ZS5saW5lID0gbGluZTtcbiAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoJ3NpemUnLCAxMDApO1xuICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgIGxldCBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLnBvc2l0aW9uID09PSA1MCkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgcG9zaXRpb24gZm9yIFNhZmFyaVxuICAgICAgcG9zaXRpb24gPSBjdWUuYWxpZ24gPT09ICdzdGFydCcgfHwgY3VlLmFsaWduID09PSAnbGVmdCcgPyAwIDogY3VlLmFsaWduID09PSAnZW5kJyB8fCBjdWUuYWxpZ24gPT09ICdyaWdodCcgPyAxMDAgOiA1MDtcbiAgICB9XG4gICAgY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgfVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICgxKSBjb2xsZWN0IGN1ZSBzdGFydCB0aW1lXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGlmIChpbnB1dC5zbGljZSgwLCAzKSAhPT0gJy0tPicpIHtcbiAgICAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggJy0tPidcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgJy0tPicpOiBcIiArIG9JbnB1dCk7XG4gIH1cbiAgaW5wdXQgPSBpbnB1dC5zbGljZSgzKTtcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLmVuZFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cbmZ1bmN0aW9uIGZpeExpbmVCcmVha3MoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcbn1cbmNsYXNzIFZUVFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdGUgPSAnSU5JVElBTCc7XG4gICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcigpO1xuICAgIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xuICAgIHRoaXMuY3VlID0gbnVsbDtcbiAgICB0aGlzLm9uY3VlID0gdm9pZCAwO1xuICAgIHRoaXMub25wYXJzaW5nZXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5vbmZsdXNoID0gdm9pZCAwO1xuICB9XG4gIHBhcnNlKGRhdGEpIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZShkYXRhLCB7XG4gICAgICAgIHN0cmVhbTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcbiAgICAgIGxldCBidWZmZXIgPSBfdGhpcy5idWZmZXI7XG4gICAgICBsZXQgcG9zID0gMDtcbiAgICAgIGJ1ZmZlciA9IGZpeExpbmVCcmVha3MoYnVmZmVyKTtcbiAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW5lID0gYnVmZmVyLnNsaWNlKDAsIHBvcyk7XG4gICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBfdGhpcy5idWZmZXIgPSBidWZmZXIuc2xpY2UocG9zKTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIC8vIHN3aXRjaCAoaykge1xuICAgICAgICAvLyBjYXNlICdyZWdpb24nOlxuICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXJzZSByZWdpb24nLCB2KTtcbiAgICAgICAgLy8gcGFyc2VSZWdpb24odik7XG4gICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAvLyB9XG4gICAgICB9LCAvOi8pO1xuICAgIH1cblxuICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgIHRyeSB7XG4gICAgICBsZXQgbGluZSA9ICcnO1xuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KF90aGlzLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIC8vIHN0cmlwIG9mIFVURi04IEJPTSBpZiBhbnlcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9vcmRlcl9tYXJrI1VURi04XG4gICAgICAgIGNvbnN0IG0gPSBsaW5lLm1hdGNoKC9eKMOvwrvCvyk/V0VCVlRUKFsgXFx0XS4qKT8kLyk7XG4gICAgICAgIGlmICghKG0gIT0gbnVsbCAmJiBtWzBdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc3RhdGUgPSAnSEVBREVSJztcbiAgICAgIH1cbiAgICAgIGxldCBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKF90aGlzLmJ1ZmZlcikge1xuICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KF90aGlzLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChfdGhpcy5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgJ0hFQURFUic6XG4gICAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxuICAgICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xuICAgICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnTk9URSc6XG4gICAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnSUQnOlxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ05PVEUnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jdWUgPSBuZXcgVlRUQ3VlKDAsIDAsICcnKTtcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRSc7XG4gICAgICAgICAgICAvLyAzMC0zOSAtIENoZWNrIGlmIHNlbGYgbGluZSBjb250YWlucyBhbiBvcHRpb25hbCBpZGVudGlmaWVyIG9yIHRpbWluZyBkYXRhLlxuICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignLS0+JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgIF90aGlzLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAnQ1VFJzpcbiAgICAgICAgICAgIC8vIDQwIC0gQ29sbGVjdCBjdWUgdGltaW5ncyBhbmQgc2V0dGluZ3MuXG4gICAgICAgICAgICBpZiAoIV90aGlzLmN1ZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIF90aGlzLmN1ZSwgX3RoaXMucmVnaW9uTGlzdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IgaWdub3JlIHJlc3Qgb2YgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQkFEQ1VFJztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdDVUVURVhUJztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0NVRVRFWFQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTtcbiAgICAgICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbmN1ZSAmJiBfdGhpcy5jdWUpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLm9uY3VlKF90aGlzLmN1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdWUudGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdGhpcy5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnQkFEQ1VFJzpcbiAgICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXG4gICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdDVUVURVhUJyAmJiBfdGhpcy5jdWUgJiYgX3RoaXMub25jdWUpIHtcbiAgICAgICAgX3RoaXMub25jdWUoX3RoaXMuY3VlKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cbiAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgLy8gRmluaXNoIGRlY29kaW5nIHRoZSBzdHJlYW0uXG4gICAgICAvLyBfdGhpcy5idWZmZXIgKz0gX3RoaXMuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKF90aGlzLmN1ZSB8fCBfdGhpcy5zdGF0ZSA9PT0gJ0hFQURFUicpIHtcbiAgICAgICAgX3RoaXMuYnVmZmVyICs9ICdcXG5cXG4nO1xuICAgICAgICBfdGhpcy5wYXJzZSgpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgLy8gbGluZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ0lOSVRJQUwnIHx8IF90aGlzLnN0YXRlID09PSAnQkFEV0VCVlRUJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChfdGhpcy5vbnBhcnNpbmdlcnJvcikge1xuICAgICAgICBfdGhpcy5vbnBhcnNpbmdlcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF90aGlzLm9uZmx1c2gpIHtcbiAgICAgIF90aGlzLm9uZmx1c2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuY29uc3QgTElORUJSRUFLUyA9IC9cXHJcXG58XFxuXFxyfFxcbnxcXHIvZztcblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUxMVxuY29uc3Qgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoaW5wdXRTdHJpbmcsIHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKSB7XG4gIHJldHVybiBpbnB1dFN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xufTtcbmNvbnN0IGN1ZVN0cmluZzJtaWxsaXMgPSBmdW5jdGlvbiBjdWVTdHJpbmcybWlsbGlzKHRpbWVTdHJpbmcpIHtcbiAgbGV0IHRzID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSgtMykpO1xuICBjb25zdCBzZWNzID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSgtNiwgLTQpKTtcbiAgY29uc3QgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTksIC03KSk7XG4gIGNvbnN0IGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHJpbmcoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XG4gIGlmICghaXNGaW5pdGVOdW1iZXIodHMpIHx8ICFpc0Zpbml0ZU51bWJlcihzZWNzKSB8fCAhaXNGaW5pdGVOdW1iZXIobWlucykgfHwgIWlzRmluaXRlTnVtYmVyKGhvdXJzKSkge1xuICAgIHRocm93IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiBMb2NhbDoke3RpbWVTdHJpbmd9YCk7XG4gIH1cbiAgdHMgKz0gMTAwMCAqIHNlY3M7XG4gIHRzICs9IDYwICogMTAwMCAqIG1pbnM7XG4gIHRzICs9IDYwICogNjAgKiAxMDAwICogaG91cnM7XG4gIHJldHVybiB0cztcbn07XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2hcbmNvbnN0IGhhc2ggPSBmdW5jdGlvbiBoYXNoKHRleHQpIHtcbiAgbGV0IF9oYXNoID0gNTM4MTtcbiAgbGV0IGkgPSB0ZXh0Lmxlbmd0aDtcbiAgd2hpbGUgKGkpIHtcbiAgICBfaGFzaCA9IF9oYXNoICogMzMgXiB0ZXh0LmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gKF9oYXNoID4+PiAwKS50b1N0cmluZygpO1xufTtcblxuLy8gQ3JlYXRlIGEgdW5pcXVlIGhhc2ggaWQgZm9yIGEgY3VlIGJhc2VkIG9uIHN0YXJ0L2VuZCB0aW1lcyBhbmQgdGV4dC5cbi8vIFRoaXMgaGVscHMgdGltZWxpbmUtY29udHJvbGxlciB0byBhdm9pZCBzaG93aW5nIHJlcGVhdGVkIGNhcHRpb25zLlxuZnVuY3Rpb24gZ2VuZXJhdGVDdWVJZChzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgcmV0dXJuIGhhc2goc3RhcnRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChlbmRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaCh0ZXh0KTtcbn1cbmNvbnN0IGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XG4gIGxldCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICBsZXQgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcbiAgaWYgKCFwcmV2Q0MgfHwgIXByZXZDQy5uZXcgJiYgY3VyckNDLm5ldykge1xuICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgd2hpbGUgKChfcHJldkNDID0gcHJldkNDKSAhPSBudWxsICYmIF9wcmV2Q0MubmV3KSB7XG4gICAgdmFyIF9wcmV2Q0M7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgY3VyckNDID0gcHJldkNDO1xuICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgfVxuICB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZTtcbn07XG5mdW5jdGlvbiBwYXJzZVdlYlZUVCh2dHRCeXRlQXJyYXksIGluaXRQVFMsIHZ0dENDcywgY2MsIHRpbWVPZmZzZXQsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBWVFRQYXJzZXIoKTtcbiAgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXG4gIC8vIFVpbnQ4QXJyYXkucHJvdG90eXBlLnJlZHVjZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gSUUxMVxuICBjb25zdCB2dHRMaW5lcyA9IHV0ZjhBcnJheVRvU3RyKG5ldyBVaW50OEFycmF5KHZ0dEJ5dGVBcnJheSkpLnRyaW0oKS5yZXBsYWNlKExJTkVCUkVBS1MsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IGN1ZXMgPSBbXTtcbiAgY29uc3QgaW5pdDkwa0h6ID0gaW5pdFBUUyA/IHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlKGluaXRQVFMuYmFzZVRpbWUsIGluaXRQVFMudGltZXNjYWxlKSA6IDA7XG4gIGxldCBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gIGxldCB0aW1lc3RhbXBNYXBNUEVHVFMgPSAwO1xuICBsZXQgdGltZXN0YW1wTWFwTE9DQUwgPSAwO1xuICBsZXQgcGFyc2luZ0Vycm9yO1xuICBsZXQgaW5IZWFkZXIgPSB0cnVlO1xuICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXG4gICAgY29uc3QgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICBsZXQgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0O1xuXG4gICAgLy8gQ2FsY3VsYXRlIHN1YnRpdGxlIFBUUyBvZmZzZXRcbiAgICBjb25zdCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQgPSAodGltZXN0YW1wTWFwTVBFR1RTIC0gaW5pdDkwa0h6KSAvIDkwMDAwO1xuXG4gICAgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcbiAgICBpZiAoY3VyckNDICE9IG51bGwgJiYgY3VyckNDLm5ldykge1xuICAgICAgaWYgKHRpbWVzdGFtcE1hcExPQ0FMICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgIGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2ViVnR0TXBlZ1RzTWFwT2Zmc2V0KSB7XG4gICAgICBpZiAoIWluaXRQVFMpIHtcbiAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIGluaXRQVFMgZm9yIFZUVCBNUEVHVFMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgaGF2ZSBNUEVHVFMsIG9mZnNldCA9IHByZXNlbnRhdGlvbiB0aW1lICsgZGlzY29udGludWl0eSBvZmZzZXRcbiAgICAgIGN1ZU9mZnNldCA9IHdlYlZ0dE1wZWdUc01hcE9mZnNldCAtIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQ7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gY3VlLmVuZFRpbWUgLSBjdWUuc3RhcnRUaW1lO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5vcm1hbGl6ZVB0cygoY3VlLnN0YXJ0VGltZSArIGN1ZU9mZnNldCAtIHRpbWVzdGFtcE1hcExPQ0FMKSAqIDkwMDAwLCB0aW1lT2Zmc2V0ICogOTAwMDApIC8gOTAwMDA7XG4gICAgY3VlLnN0YXJ0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSwgMCk7XG4gICAgY3VlLmVuZFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUgKyBkdXJhdGlvbiwgMCk7XG5cbiAgICAvL3RyaW0gdHJhaWxpbmcgd2VidnR0IGJsb2NrIHdoaXRlc3BhY2VzXG4gICAgY29uc3QgdGV4dCA9IGN1ZS50ZXh0LnRyaW0oKTtcblxuICAgIC8vIEZpeCBlbmNvZGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQodGV4dCkpO1xuXG4gICAgLy8gSWYgdGhlIGN1ZSB3YXMgbm90IGFzc2lnbmVkIGFuIGlkIGZyb20gdGhlIFZUVCBmaWxlIChsaW5lIGFib3ZlIHRoZSBjb250ZW50KSwgY3JlYXRlIG9uZS5cbiAgICBpZiAoIWN1ZS5pZCkge1xuICAgICAgY3VlLmlkID0gZ2VuZXJhdGVDdWVJZChjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgdGV4dCk7XG4gICAgfVxuICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgIGN1ZXMucHVzaChjdWUpO1xuICAgIH1cbiAgfTtcbiAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcGFyc2luZ0Vycm9yID0gZXJyb3I7XG4gIH07XG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYXJzaW5nRXJyb3IpIHtcbiAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbEJhY2soY3Vlcyk7XG4gIH07XG5cbiAgLy8gR28gdGhyb3VnaCBjb250ZW50cyBsaW5lIGJ5IGxpbmUuXG4gIHZ0dExpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgaWYgKGluSGVhZGVyKSB7XG4gICAgICAvLyBMb29rIGZvciBYLVRJTUVTVEFNUC1NQVAgaW4gaGVhZGVyLlxuICAgICAgaWYgKHN0YXJ0c1dpdGgobGluZSwgJ1gtVElNRVNUQU1QLU1BUD0nKSkge1xuICAgICAgICAvLyBPbmNlIGZvdW5kLCBubyBtb3JlIGFyZSBhbGxvd2VkIGFueXdheSwgc28gc3RvcCBzZWFyY2hpbmcuXG4gICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIC8vIEV4dHJhY3QgTE9DQUwgYW5kIE1QRUdUUy5cbiAgICAgICAgbGluZS5zbGljZSgxNikuc3BsaXQoJywnKS5mb3JFYWNoKHRpbWVzdGFtcCA9PiB7XG4gICAgICAgICAgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTE9DQUw6JykpIHtcbiAgICAgICAgICAgIGN1ZVRpbWUgPSB0aW1lc3RhbXAuc2xpY2UoNik7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ01QRUdUUzonKSkge1xuICAgICAgICAgICAgdGltZXN0YW1wTWFwTVBFR1RTID0gcGFyc2VJbnQodGltZXN0YW1wLnNsaWNlKDcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENvbnZlcnQgY3VlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICAgIHRpbWVzdGFtcE1hcExPQ0FMID0gY3VlU3RyaW5nMm1pbGxpcyhjdWVUaW1lKSAvIDEwMDA7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcGFyc2luZ0Vycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHdpdGhvdXQgcGFyc2luZyBYLVRJTUVTVEFNUC1NQVAgbGluZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXG4gICAgcGFyc2VyLnBhcnNlKGxpbmUgKyAnXFxuJyk7XG4gIH0pO1xuICBwYXJzZXIuZmx1c2goKTtcbn1cblxuY29uc3QgSU1TQzFfQ09ERUMgPSAnc3RwcC50dG1sLmltMXQnO1xuXG4vLyBUaW1lIGZvcm1hdDogaDptOnM6ZnJhbWVzKC5zdWJmcmFtZXMpXG5jb25zdCBITVNGX1JFR0VYID0gL14oXFxkezIsfSk6KFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSlcXC4/KFxcZCspPyQvO1xuXG4vLyBUaW1lIGZvcm1hdDogaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgZnJhbWVzLCB0aWNrc1xuY29uc3QgVElNRV9VTklUX1JFR0VYID0gL14oXFxkKig/OlxcLlxcZCopPykoaHxtfHN8bXN8Znx0KSQvO1xuY29uc3QgdGV4dEFsaWduVG9MaW5lQWxpZ24gPSB7XG4gIGxlZnQ6ICdzdGFydCcsXG4gIGNlbnRlcjogJ2NlbnRlcicsXG4gIHJpZ2h0OiAnZW5kJyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIGVuZDogJ2VuZCdcbn07XG5mdW5jdGlvbiBwYXJzZUlNU0MxKHBheWxvYWQsIGluaXRQVFMsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBmaW5kQm94KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBbJ21kYXQnXSk7XG4gIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGVycm9yQ2FsbEJhY2sobmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgSU1TQzEgbWRhdCcpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHRtbExpc3QgPSByZXN1bHRzLm1hcChtZGF0ID0+IHV0ZjhBcnJheVRvU3RyKG1kYXQpKTtcbiAgY29uc3Qgc3luY1RpbWUgPSB0b1RpbWVzY2FsZUZyb21TY2FsZShpbml0UFRTLmJhc2VUaW1lLCAxLCBpbml0UFRTLnRpbWVzY2FsZSk7XG4gIHRyeSB7XG4gICAgdHRtbExpc3QuZm9yRWFjaCh0dG1sID0+IGNhbGxCYWNrKHBhcnNlVFRNTCh0dG1sLCBzeW5jVGltZSkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlcnJvckNhbGxCYWNrKGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgY29uc3QgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0dG1sLCAndGV4dC94bWwnKTtcbiAgY29uc3QgdHQgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3R0JylbMF07XG4gIGlmICghdHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHRtbCcpO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRSYXRlSW5mbyA9IHtcbiAgICBmcmFtZVJhdGU6IDMwLFxuICAgIHN1YkZyYW1lUmF0ZTogMSxcbiAgICBmcmFtZVJhdGVNdWx0aXBsaWVyOiAwLFxuICAgIHRpY2tSYXRlOiAwXG4gIH07XG4gIGNvbnN0IHJhdGVJbmZvID0gT2JqZWN0LmtleXMoZGVmYXVsdFJhdGVJbmZvKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgcmVzdWx0W2tleV0gPSB0dC5nZXRBdHRyaWJ1dGUoYHR0cDoke2tleX1gKSB8fCBkZWZhdWx0UmF0ZUluZm9ba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG4gIGNvbnN0IHRyaW0gPSB0dC5nZXRBdHRyaWJ1dGUoJ3htbDpzcGFjZScpICE9PSAncHJlc2VydmUnO1xuICBjb25zdCBzdHlsZUVsZW1lbnRzID0gY29sbGVjdGlvblRvRGljdGlvbmFyeShnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ3N0eWxpbmcnLCAnc3R5bGUnKSk7XG4gIGNvbnN0IHJlZ2lvbkVsZW1lbnRzID0gY29sbGVjdGlvblRvRGljdGlvbmFyeShnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ2xheW91dCcsICdyZWdpb24nKSk7XG4gIGNvbnN0IGN1ZUVsZW1lbnRzID0gZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdib2R5JywgJ1tiZWdpbl0nKTtcbiAgcmV0dXJuIFtdLm1hcC5jYWxsKGN1ZUVsZW1lbnRzLCBjdWVFbGVtZW50ID0+IHtcbiAgICBjb25zdCBjdWVUZXh0ID0gZ2V0VGV4dENvbnRlbnQoY3VlRWxlbWVudCwgdHJpbSk7XG4gICAgaWYgKCFjdWVUZXh0IHx8ICFjdWVFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYmVnaW4nKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2JlZ2luJyksIHJhdGVJbmZvKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2R1cicpLCByYXRlSW5mbyk7XG4gICAgbGV0IGVuZFRpbWUgPSBwYXJzZVR0bWxUaW1lKGN1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdlbmQnKSwgcmF0ZUluZm8pO1xuICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IHRpbWVzdGFtcFBhcnNpbmdFcnJvcihjdWVFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKGVuZFRpbWUgPT09IG51bGwpIHtcbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyB0aW1lc3RhbXBQYXJzaW5nRXJyb3IoY3VlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgfVxuICAgIGNvbnN0IGN1ZSA9IG5ldyBWVFRDdWUoc3RhcnRUaW1lIC0gc3luY1RpbWUsIGVuZFRpbWUgLSBzeW5jVGltZSwgY3VlVGV4dCk7XG4gICAgY3VlLmlkID0gZ2VuZXJhdGVDdWVJZChjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgY3VlLnRleHQpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHJlZ2lvbkVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWdpb24nKV07XG4gICAgY29uc3Qgc3R5bGUgPSBzdHlsZUVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpXTtcblxuICAgIC8vIEFwcGx5IHN0eWxlcyB0byBjdWVcbiAgICBjb25zdCBzdHlsZXMgPSBnZXRUdG1sU3R5bGVzKHJlZ2lvbiwgc3R5bGUsIHN0eWxlRWxlbWVudHMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRleHRBbGlnblxuICAgIH0gPSBzdHlsZXM7XG4gICAgaWYgKHRleHRBbGlnbikge1xuICAgICAgLy8gY3VlLnBvc2l0aW9uQWxpZ24gbm90IHNldHRhYmxlIGluIEZGfjIwMTZcbiAgICAgIGNvbnN0IGxpbmVBbGlnbiA9IHRleHRBbGlnblRvTGluZUFsaWduW3RleHRBbGlnbl07XG4gICAgICBpZiAobGluZUFsaWduKSB7XG4gICAgICAgIGN1ZS5saW5lQWxpZ24gPSBsaW5lQWxpZ247XG4gICAgICB9XG4gICAgICBjdWUuYWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgfVxuICAgIF9leHRlbmRzKGN1ZSwgc3R5bGVzKTtcbiAgICByZXR1cm4gY3VlO1xuICB9KS5maWx0ZXIoY3VlID0+IGN1ZSAhPT0gbnVsbCk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50Q29sbGVjdGlvbihmcm9tRWxlbWVudCwgcGFyZW50TmFtZSwgY2hpbGROYW1lKSB7XG4gIGNvbnN0IHBhcmVudCA9IGZyb21FbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHBhcmVudE5hbWUpWzBdO1xuICBpZiAocGFyZW50KSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2hpbGROYW1lKSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gY29sbGVjdGlvblRvRGljdGlvbmFyeShlbGVtZW50c1dpdGhJZCkge1xuICByZXR1cm4gZWxlbWVudHNXaXRoSWQucmVkdWNlKChkaWN0LCBlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneG1sOmlkJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICBkaWN0W2lkXSA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBkaWN0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudChlbGVtZW50LCB0cmltKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGVsZW1lbnQuY2hpbGROb2RlcykucmVkdWNlKChzdHIsIG5vZGUsIGkpID0+IHtcbiAgICB2YXIgX25vZGUkY2hpbGROb2RlcztcbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ2JyJyAmJiBpKSB7XG4gICAgICByZXR1cm4gc3RyICsgJ1xcbic7XG4gICAgfVxuICAgIGlmICgoX25vZGUkY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcykgIT0gbnVsbCAmJiBfbm9kZSRjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGdldFRleHRDb250ZW50KG5vZGUsIHRyaW0pO1xuICAgIH0gZWxzZSBpZiAodHJpbSkge1xuICAgICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQ7XG4gIH0sICcnKTtcbn1cbmZ1bmN0aW9uIGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSwgc3R5bGVFbGVtZW50cykge1xuICBjb25zdCB0dHNOcyA9ICdodHRwOi8vd3d3LnczLm9yZy9ucy90dG1sI3N0eWxpbmcnO1xuICBsZXQgcmVnaW9uU3R5bGUgPSBudWxsO1xuICBjb25zdCBzdHlsZUF0dHJpYnV0ZXMgPSBbJ2Rpc3BsYXlBbGlnbicsICd0ZXh0QWxpZ24nLCAnY29sb3InLCAnYmFja2dyb3VuZENvbG9yJywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknXG4gIC8vICdmb250V2VpZ2h0JyxcbiAgLy8gJ2xpbmVIZWlnaHQnLFxuICAvLyAnd3JhcE9wdGlvbicsXG4gIC8vICdmb250U3R5bGUnLFxuICAvLyAnZGlyZWN0aW9uJyxcbiAgLy8gJ3dyaXRpbmdNb2RlJ1xuICBdO1xuXG4gIGNvbnN0IHJlZ2lvblN0eWxlTmFtZSA9IHJlZ2lvbiAhPSBudWxsICYmIHJlZ2lvbi5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykgPyByZWdpb24uZ2V0QXR0cmlidXRlKCdzdHlsZScpIDogbnVsbDtcbiAgaWYgKHJlZ2lvblN0eWxlTmFtZSAmJiBzdHlsZUVsZW1lbnRzLmhhc093blByb3BlcnR5KHJlZ2lvblN0eWxlTmFtZSkpIHtcbiAgICByZWdpb25TdHlsZSA9IHN0eWxlRWxlbWVudHNbcmVnaW9uU3R5bGVOYW1lXTtcbiAgfVxuICByZXR1cm4gc3R5bGVBdHRyaWJ1dGVzLnJlZHVjZSgoc3R5bGVzLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRBdHRyaWJ1dGVOUyhzdHlsZSwgdHRzTnMsIG5hbWUpIHx8IGdldEF0dHJpYnV0ZU5TKHJlZ2lvbiwgdHRzTnMsIG5hbWUpIHx8IGdldEF0dHJpYnV0ZU5TKHJlZ2lvblN0eWxlLCB0dHNOcywgbmFtZSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzdHlsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlTlMoZWxlbWVudCwgbnMsIG5hbWUpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlTlMobnMsIG5hbWUpID8gZWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhucywgbmFtZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wUGFyc2luZ0Vycm9yKG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHR0bWwgdGltZXN0YW1wICR7bm9kZX1gKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVHRtbFRpbWUodGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICBpZiAoIXRpbWVBdHRyaWJ1dGVWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBzZWNvbmRzID0gcGFyc2VUaW1lU3RhbXAodGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgaWYgKHNlY29uZHMgPT09IG51bGwpIHtcbiAgICBpZiAoSE1TRl9SRUdFWC50ZXN0KHRpbWVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHNlY29uZHMgPSBwYXJzZUhvdXJzTWludXRlc1NlY29uZHNGcmFtZXModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfSBlbHNlIGlmIChUSU1FX1VOSVRfUkVHRVgudGVzdCh0aW1lQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICBzZWNvbmRzID0gcGFyc2VUaW1lVW5pdHModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWNvbmRzO1xufVxuZnVuY3Rpb24gcGFyc2VIb3Vyc01pbnV0ZXNTZWNvbmRzRnJhbWVzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgY29uc3QgbSA9IEhNU0ZfUkVHRVguZXhlYyh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICBjb25zdCBmcmFtZXMgPSAobVs0XSB8IDApICsgKG1bNV0gfCAwKSAvIHJhdGVJbmZvLnN1YkZyYW1lUmF0ZTtcbiAgcmV0dXJuIChtWzFdIHwgMCkgKiAzNjAwICsgKG1bMl0gfCAwKSAqIDYwICsgKG1bM10gfCAwKSArIGZyYW1lcyAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZVVuaXRzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgY29uc3QgbSA9IFRJTUVfVU5JVF9SRUdFWC5leGVjKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIGNvbnN0IHZhbHVlID0gTnVtYmVyKG1bMV0pO1xuICBjb25zdCB1bml0ID0gbVsyXTtcbiAgc3dpdGNoICh1bml0KSB7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gdmFsdWUgKiAzNjAwO1xuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIHZhbHVlICogNjA7XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIHZhbHVlICogMTAwMDtcbiAgICBjYXNlICdmJzpcbiAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbiAgICBjYXNlICd0JzpcbiAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLnRpY2tSYXRlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuY2xhc3MgVGltZWxpbmVDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLkN1ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IHZvaWQgMDtcbiAgICB0aGlzLmNlYTYwOFBhcnNlcjIgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0U24gPSAtMTtcbiAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSAtMTtcbiAgICB0aGlzLnByZXZDQyA9IC0xO1xuICAgIHRoaXMudnR0Q0NzID0gbmV3VlRUQ0NzKCk7XG4gICAgdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuQ3VlcyA9IGhscy5jb25maWcuY3VlSGFuZGxlcjtcbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHtcbiAgICAgIHRleHRUcmFjazE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazI6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazM6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazQ6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICBjb25zdCBjaGFubmVsMSA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazEnKTtcbiAgICAgIGNvbnN0IGNoYW5uZWwyID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMicpO1xuICAgICAgY29uc3QgY2hhbm5lbDMgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2szJyk7XG4gICAgICBjb25zdCBjaGFubmVsNCA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazQnKTtcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IG5ldyBDZWE2MDhQYXJzZXIoMSwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMiA9IG5ldyBDZWE2MDhQYXJzZXIoMywgY2hhbm5lbDMsIGNoYW5uZWw0KTtcbiAgICB9XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHRoaXMub25GcmFnUGFyc2luZ1VzZXJkYXRhLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfREVDUllQVEVELCB0aGlzLm9uRnJhZ0RlY3J5cHRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IHRoaXMuY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMiA9IG51bGw7XG4gIH1cbiAgYWRkQ3Vlcyh0cmFja05hbWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuLCBjdWVSYW5nZXMpIHtcbiAgICAvLyBza2lwIGN1ZXMgd2hpY2ggb3ZlcmxhcCBtb3JlIHRoYW4gNTAlIHdpdGggcHJldmlvdXNseSBwYXJzZWQgdGltZSByYW5nZXNcbiAgICBsZXQgbWVyZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IGN1ZVJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IGN1ZVJhbmdlID0gY3VlUmFuZ2VzW2ldO1xuICAgICAgY29uc3Qgb3ZlcmxhcCA9IGludGVyc2VjdGlvbihjdWVSYW5nZVswXSwgY3VlUmFuZ2VbMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgICBpZiAob3ZlcmxhcCA+PSAwKSB7XG4gICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XG4gICAgICAgIGN1ZVJhbmdlWzFdID0gTWF0aC5tYXgoY3VlUmFuZ2VbMV0sIGVuZFRpbWUpO1xuICAgICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgICBpZiAob3ZlcmxhcCAvIChlbmRUaW1lIC0gc3RhcnRUaW1lKSA+IDAuNSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgY3VlUmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICBjb25zdCB0cmFjayA9IHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIHRoaXMuQ3Vlcy5uZXdDdWUodHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3VlcyA9IHRoaXMuQ3Vlcy5uZXdDdWUobnVsbCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQ1VFU19QQVJTRUQsIHtcbiAgICAgICAgdHlwZTogJ2NhcHRpb25zJyxcbiAgICAgICAgY3VlcyxcbiAgICAgICAgdHJhY2s6IHRyYWNrTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCB7XG4gICAgZnJhZyxcbiAgICBpZCxcbiAgICBpbml0UFRTLFxuICAgIHRpbWVzY2FsZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgdW5wYXJzZWRWdHRGcmFnc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChpZCA9PT0gJ21haW4nKSB7XG4gICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7XG4gICAgICAgIGJhc2VUaW1lOiBpbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRHVlIHRvIGFzeW5jaHJvbm91cyBwcm9jZXNzaW5nLCBpbml0aWFsIFBUUyBtYXkgYXJyaXZlIGxhdGVyIHRoYW4gdGhlIGZpcnN0IFZUVCBmcmFnbWVudHMgYXJlIGxvYWRlZC5cbiAgICAvLyBQYXJzZSBhbnkgdW5wYXJzZWQgZnJhZ21lbnRzIHVwb24gcmVjZWl2aW5nIHRoZSBpbml0aWFsIFBUUy5cbiAgICBpZiAodW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgICAgdW5wYXJzZWRWdHRGcmFncy5mb3JFYWNoKGZyYWcgPT4ge1xuICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZChFdmVudHMuRlJBR19MT0FERUQsIGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldEV4aXN0aW5nVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWEudGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0ZXh0VHJhY2sgPSBtZWRpYS50ZXh0VHJhY2tzW2ldO1xuICAgICAgICBpZiAodGV4dFRyYWNrW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNyZWF0ZUNhcHRpb25zVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgdGhpcy5jcmVhdGVOYXRpdmVUcmFjayh0cmFja05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZU5vbk5hdGl2ZVRyYWNrKHRyYWNrTmFtZSk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZU5hdGl2ZVRyYWNrKHRyYWNrTmFtZSkge1xuICAgIGlmICh0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FwdGlvbnNQcm9wZXJ0aWVzLFxuICAgICAgY2FwdGlvbnNUcmFja3MsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsLFxuICAgICAgbGFuZ3VhZ2VDb2RlXG4gICAgfSA9IGNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgIC8vIEVuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgIGNvbnN0IGV4aXN0aW5nVHJhY2sgPSB0aGlzLmdldEV4aXN0aW5nVHJhY2sodHJhY2tOYW1lKTtcbiAgICBpZiAoIWV4aXN0aW5nVHJhY2spIHtcbiAgICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsIGxhYmVsLCBsYW5ndWFnZUNvZGUpO1xuICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAvLyBTZXQgYSBzcGVjaWFsIHByb3BlcnR5IG9uIHRoZSB0cmFjayBzbyB3ZSBrbm93IGl0J3MgbWFuYWdlZCBieSBIbHMuanNcbiAgICAgICAgdGV4dFRyYWNrW3RyYWNrTmFtZV0gPSB0cnVlO1xuICAgICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gZXhpc3RpbmdUcmFjaztcbiAgICAgIGNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBzZW5kQWRkVHJhY2tFdmVudChjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBtZWRpYSk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZU5vbk5hdGl2ZVRyYWNrKHRyYWNrTmFtZSkge1xuICAgIGlmICh0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBhIHNpbmdsZSB0cmFjayBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICBjb25zdCB0cmFja1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgIGlmICghdHJhY2tQcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsID0gdHJhY2tQcm9wZXJ0aWVzLmxhYmVsO1xuICAgIGNvbnN0IHRyYWNrID0ge1xuICAgICAgX2lkOiB0cmFja05hbWUsXG4gICAgICBsYWJlbCxcbiAgICAgIGtpbmQ6ICdjYXB0aW9ucycsXG4gICAgICBkZWZhdWx0OiB0cmFja1Byb3BlcnRpZXMubWVkaWEgPyAhIXRyYWNrUHJvcGVydGllcy5tZWRpYS5kZWZhdWx0IDogZmFsc2UsXG4gICAgICBjbG9zZWRDYXB0aW9uczogdHJhY2tQcm9wZXJ0aWVzLm1lZGlhXG4gICAgfTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5OT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5ELCB7XG4gICAgICB0cmFja3M6IFt0cmFja11cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhcHRpb25zVHJhY2tzXG4gICAgfSA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgIGNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBkZWxldGUgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICB9KTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5sYXN0U24gPSAtMTsgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gZnJhZ21lbnQgcGFyc2luZ1xuICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xO1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSBuZXdWVFRDQ3MoKTsgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gc3VidGl0bGUgbWFuaWZlc3RzXG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgaWYgKHRoaXMuY2VhNjA4UGFyc2VyMSAmJiB0aGlzLmNlYTYwOFBhcnNlcjIpIHtcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMS5yZXNldCgpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyLnJlc2V0KCk7XG4gICAgfVxuICB9XG4gIF9jbGVhblRyYWNrcygpIHtcbiAgICAvLyBjbGVhciBvdXRkYXRlZCBzdWJ0aXRsZXNcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IG1lZGlhLnRleHRUcmFja3M7XG4gICAgaWYgKHRleHRUcmFja3MpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRleHRUcmFja3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3MgfHwgW107XG4gICAgY29uc3QgaGFzSU1TQzEgPSB0cmFja3Muc29tZSh0cmFjayA9PiB0cmFjay50ZXh0Q29kZWMgPT09IElNU0MxX0NPREVDKTtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlV2ViVlRUIHx8IGhhc0lNU0MxICYmIHRoaXMuY29uZmlnLmVuYWJsZUlNU0MxKSB7XG4gICAgICBjb25zdCBsaXN0SXNJZGVudGljYWwgPSBzdWJ0aXRsZU9wdGlvbnNJZGVudGljYWwodGhpcy50cmFja3MsIHRyYWNrcyk7XG4gICAgICBpZiAobGlzdElzSWRlbnRpY2FsKSB7XG4gICAgICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgICBjb25zdCBpblVzZVRyYWNrcyA9IHRoaXMubWVkaWEgPyB0aGlzLm1lZGlhLnRleHRUcmFja3MgOiBudWxsO1xuICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKCh0cmFjaywgaW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQgdGV4dFRyYWNrO1xuICAgICAgICAgIGlmIChpblVzZVRyYWNrcyAmJiBpbmRleCA8IGluVXNlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGluVXNlVHJhY2sgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpblVzZVRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFja3NbaV0sIHRyYWNrKSkge1xuICAgICAgICAgICAgICAgIGluVXNlVHJhY2sgPSBpblVzZVRyYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXVzZSB0cmFja3Mgd2l0aCB0aGUgc2FtZSBsYWJlbCwgYnV0IGRvIG5vdCByZXVzZSA2MDgvNzA4IHRyYWNrc1xuICAgICAgICAgICAgaWYgKGluVXNlVHJhY2spIHtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrID0gaW5Vc2VUcmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0ZXh0VHJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0VHJhY2tLaW5kID0gdGhpcy5fY2FwdGlvbnNPclN1YnRpdGxlc0Zyb21DaGFyYWN0ZXJpc3RpY3ModHJhY2spO1xuICAgICAgICAgICAgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2sodGV4dFRyYWNrS2luZCwgdHJhY2submFtZSwgdHJhY2subGFuZyk7XG4gICAgICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgdGV4dFRyYWNrLmdyb3VwSWQgPSB0cmFjay5ncm91cElkO1xuICAgICAgICAgICAgdGhpcy50ZXh0VHJhY2tzLnB1c2godGV4dFRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiB0cmFja3MgZm9yIHRoZSBwcm92aWRlciB0byBjb25zdW1lXG4gICAgICAgIGNvbnN0IHRyYWNrc0xpc3QgPSB0aGlzLnRyYWNrcy5tYXAodHJhY2sgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogdHJhY2submFtZSxcbiAgICAgICAgICAgIGtpbmQ6IHRyYWNrLnR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRyYWNrLmRlZmF1bHQsXG4gICAgICAgICAgICBzdWJ0aXRsZVRyYWNrOiB0cmFja1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5OT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5ELCB7XG4gICAgICAgICAgdHJhY2tzOiB0cmFja3NMaXN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfY2FwdGlvbnNPclN1YnRpdGxlc0Zyb21DaGFyYWN0ZXJpc3RpY3ModHJhY2spIHtcbiAgICBpZiAodHJhY2suYXR0cnMuQ0hBUkFDVEVSSVNUSUNTKSB7XG4gICAgICBjb25zdCB0cmFuc2NyaWJlc1Nwb2tlbkRpYWxvZyA9IC90cmFuc2NyaWJlcy1zcG9rZW4tZGlhbG9nL2dpLnRlc3QodHJhY2suYXR0cnMuQ0hBUkFDVEVSSVNUSUNTKTtcbiAgICAgIGNvbnN0IGRlc2NyaWJlc011c2ljQW5kU291bmQgPSAvZGVzY3JpYmVzLW11c2ljLWFuZC1zb3VuZC9naS50ZXN0KHRyYWNrLmF0dHJzLkNIQVJBQ1RFUklTVElDUyk7XG4gICAgICBpZiAodHJhbnNjcmliZXNTcG9rZW5EaWFsb2cgJiYgZGVzY3JpYmVzTXVzaWNBbmRTb3VuZCkge1xuICAgICAgICByZXR1cm4gJ2NhcHRpb25zJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdzdWJ0aXRsZXMnO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgJiYgZGF0YS5jYXB0aW9ucykge1xuICAgICAgZGF0YS5jYXB0aW9ucy5mb3JFYWNoKGNhcHRpb25zVHJhY2sgPT4ge1xuICAgICAgICBjb25zdCBpbnN0cmVhbUlkTWF0Y2ggPSAvKD86Q0N8U0VSVklDRSkoWzEtNF0pLy5leGVjKGNhcHRpb25zVHJhY2suaW5zdHJlYW1JZCk7XG4gICAgICAgIGlmICghaW5zdHJlYW1JZE1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrTmFtZSA9IGB0ZXh0VHJhY2ske2luc3RyZWFtSWRNYXRjaFsxXX1gO1xuICAgICAgICBjb25zdCB0cmFja1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgICAgICBpZiAoIXRyYWNrUHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFja1Byb3BlcnRpZXMubGFiZWwgPSBjYXB0aW9uc1RyYWNrLm5hbWU7XG4gICAgICAgIGlmIChjYXB0aW9uc1RyYWNrLmxhbmcpIHtcbiAgICAgICAgICAvLyBvcHRpb25hbCBhdHRyaWJ1dGVcbiAgICAgICAgICB0cmFja1Byb3BlcnRpZXMubGFuZ3VhZ2VDb2RlID0gY2FwdGlvbnNUcmFjay5sYW5nO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrUHJvcGVydGllcy5tZWRpYSA9IGNhcHRpb25zVHJhY2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbChmcmFnKSB7XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgcmV0dXJuIGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5hdHRyc1snQ0xPU0VELUNBUFRJT05TJ107XG4gIH1cbiAgb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNlYTYwOFBhcnNlcjEsXG4gICAgICBjZWE2MDhQYXJzZXIyLFxuICAgICAgbGFzdFNuLFxuICAgICAgbGFzdFBhcnRJbmRleFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICEoY2VhNjA4UGFyc2VyMSAmJiBjZWE2MDhQYXJzZXIyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuICAgIGlmIChkYXRhLmZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgdmFyIF9kYXRhJHBhcnQkaW5kZXgsIF9kYXRhJHBhcnQ7XG4gICAgICBjb25zdCBzbiA9IGRhdGEuZnJhZy5zbjtcbiAgICAgIGNvbnN0IHBhcnRJbmRleCA9IChfZGF0YSRwYXJ0JGluZGV4ID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRwYXJ0LmluZGV4KSAhPSBudWxsID8gX2RhdGEkcGFydCRpbmRleCA6IC0xO1xuICAgICAgaWYgKCEoc24gPT09IGxhc3RTbiArIDEgfHwgc24gPT09IGxhc3RTbiAmJiBwYXJ0SW5kZXggPT09IGxhc3RQYXJ0SW5kZXggKyAxKSkge1xuICAgICAgICBjZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjIucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFNuID0gc247XG4gICAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSBwYXJ0SW5kZXg7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cbiAgICAgIGlmIChwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgICAgICAvLyBmcmFnbWVudCBhZnRlciBkZWNyeXB0aW9uIGhhcyBhIHN0YXRzIG9iamVjdFxuICAgICAgICBjb25zdCBkZWNyeXB0ZWQgPSAoJ3N0YXRzJyBpbiBkYXRhKTtcbiAgICAgICAgLy8gSWYgdGhlIHN1YnRpdGxlcyBhcmUgbm90IGVuY3J5cHRlZCwgcGFyc2UgVlRUcyBub3cuIE90aGVyd2lzZSwgd2UgbmVlZCB0byB3YWl0LlxuICAgICAgICBpZiAoZGVjcnlwdERhdGEgPT0gbnVsbCB8fCAhZGVjcnlwdERhdGEuZW5jcnlwdGVkIHx8IGRlY3J5cHRlZCkge1xuICAgICAgICAgIGNvbnN0IHRyYWNrUGxheWxpc3RNZWRpYSA9IHRoaXMudHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgICAgICAgIGNvbnN0IHZ0dENDcyA9IHRoaXMudnR0Q0NzO1xuICAgICAgICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XG4gICAgICAgICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBmcmFnLnN0YXJ0LFxuICAgICAgICAgICAgICBwcmV2Q0M6IHRoaXMucHJldkNDLFxuICAgICAgICAgICAgICBuZXc6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnByZXZDQyA9IGZyYWcuY2M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFja1BsYXlsaXN0TWVkaWEgJiYgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9PT0gSU1TQzFfQ09ERUMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlVlRUcyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gcGF5bG9hZCwgZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRW1wdHkgc3VidGl0bGUgcGF5bG9hZCcpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgcGFyc2VJTVNDMShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIGN1ZXMgPT4ge1xuICAgICAgdGhpcy5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBmcmFnOiBmcmFnXG4gICAgICB9KTtcbiAgICB9LCBlcnJvciA9PiB7XG4gICAgICBsb2dnZXIubG9nKGBGYWlsZWQgdG8gcGFyc2UgSU1TQzE6ICR7ZXJyb3J9YCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfcGFyc2VWVFRzKGRhdGEpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICAvLyBXZSBuZWVkIGFuIGluaXRpYWwgc3luY2hyb25pc2F0aW9uIFBUUy4gU3RvcmUgZnJhZ21lbnRzIGFzIGxvbmcgYXMgbm9uZSBoYXMgYXJyaXZlZFxuICAgIGNvbnN0IHtcbiAgICAgIGluaXRQVFMsXG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbWF4QXZDQyA9IGluaXRQVFMubGVuZ3RoIC0gMTtcbiAgICBpZiAoIWluaXRQVFNbZnJhZy5jY10gJiYgbWF4QXZDQyA9PT0gLTEpIHtcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxuICAgIGNvbnN0IHBheWxvYWRXZWJWVFQgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSAhPSBudWxsICYmIF9mcmFnJGluaXRTZWdtZW50LmRhdGEgPyBhcHBlbmRVaW50OEFycmF5KGZyYWcuaW5pdFNlZ21lbnQuZGF0YSwgbmV3IFVpbnQ4QXJyYXkocGF5bG9hZCkpIDogcGF5bG9hZDtcbiAgICBwYXJzZVdlYlZUVChwYXlsb2FkV2ViVlRULCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHRoaXMudnR0Q0NzLCBmcmFnLmNjLCBmcmFnLnN0YXJ0LCBjdWVzID0+IHtcbiAgICAgIHRoaXMuX2FwcGVuZEN1ZXMoY3VlcywgZnJhZy5sZXZlbCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZnJhZzogZnJhZ1xuICAgICAgfSk7XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgY29uc3QgbWlzc2luZ0luaXRQVFMgPSBlcnJvci5tZXNzYWdlID09PSAnTWlzc2luZyBpbml0UFRTIGZvciBWVFQgTVBFR1RTJztcbiAgICAgIGlmIChtaXNzaW5nSW5pdFBUUykge1xuICAgICAgICB1bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mYWxsYmFja1RvSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICB9XG4gICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cbiAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiAke2Vycm9yfWApO1xuICAgICAgaWYgKG1pc3NpbmdJbml0UFRTICYmIG1heEF2Q0MgPiBmcmFnLmNjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9mYWxsYmFja1RvSU1TQzEoZnJhZywgcGF5bG9hZCkge1xuICAgIC8vIElmIHRleHRDb2RlYyBpcyB1bmtub3duLCB0cnkgcGFyc2luZyBhcyBJTVNDMS4gU2V0IHRleHRDb2RlYyBiYXNlZCBvbiB0aGUgcmVzdWx0XG4gICAgY29uc3QgdHJhY2tQbGF5bGlzdE1lZGlhID0gdGhpcy50cmFja3NbZnJhZy5sZXZlbF07XG4gICAgaWYgKCF0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjKSB7XG4gICAgICBwYXJzZUlNU0MxKHBheWxvYWQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgKCkgPT4ge1xuICAgICAgICB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID0gSU1TQzFfQ09ERUM7XG4gICAgICAgIHRoaXMuX3BhcnNlSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSAnd3Z0dCc7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX2FwcGVuZEN1ZXMoY3VlcywgZnJhZ0xldmVsKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy50ZXh0VHJhY2tzW2ZyYWdMZXZlbF07XG4gICAgICAvLyBXZWJWVFRQYXJzZXIucGFyc2UgaXMgYW4gYXN5bmMgbWV0aG9kIGFuZCBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQgdHJhY2sgbW9kZSBpcyBzZXQgdG8gXCJkaXNhYmxlZFwiXG4gICAgICAvLyBiZWZvcmUgcGFyc2luZyBpcyBkb25lIHRoZW4gZG9uJ3QgdHJ5IHRvIGFjY2VzcyBjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkIGFzIGN1ZXMgd2lsbCBiZSBudWxsXG4gICAgICAvLyBhbmQgdHJ5aW5nIHRvIGFjY2VzcyBnZXRDdWVCeUlkIG1ldGhvZCBvZiBjdWVzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBCZWNhdXNlIHdlIGNoZWNrIGlmIHRoZSBtb2RlIGlzIGRpc2FibGVkLCB3ZSBjYW4gZm9yY2UgY2hlY2sgYGN1ZXNgIGJlbG93LiBUaGV5IGNhbid0IGJlIG51bGwuXG4gICAgICBpZiAoIXRleHRUcmFjayB8fCB0ZXh0VHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdWVzLmZvckVhY2goY3VlID0+IGFkZEN1ZVRvVHJhY2sodGV4dFRyYWNrLCBjdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbZnJhZ0xldmVsXTtcbiAgICAgIGlmICghY3VycmVudFRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYWNrID0gY3VycmVudFRyYWNrLmRlZmF1bHQgPyAnZGVmYXVsdCcgOiAnc3VidGl0bGVzJyArIGZyYWdMZXZlbDtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiAnc3VidGl0bGVzJyxcbiAgICAgICAgY3VlcyxcbiAgICAgICAgdHJhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkZyYWdEZWNyeXB0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgIHRoaXMub25GcmFnTG9hZGVkKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgfVxuICB9XG4gIG9uU3VidGl0bGVUcmFja3NDbGVhcmVkKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICB9XG4gIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YShldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNlYTYwOFBhcnNlcjEsXG4gICAgICBjZWE2MDhQYXJzZXIyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIShjZWE2MDhQYXJzZXIxICYmIGNlYTYwOFBhcnNlcjIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBzYW1wbGVzXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiB0aGlzLmNsb3NlZENhcHRpb25zRm9yTGV2ZWwoZnJhZykgPT09ICdOT05FJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgZXZlbnQgY29udGFpbnMgY2FwdGlvbnMgKGZvdW5kIGluIHRoZSBieXRlcyBwcm9wZXJ0eSksIHB1c2ggYWxsIGJ5dGVzIGludG8gdGhlIHBhcnNlciBpbW1lZGlhdGVseVxuICAgIC8vIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiB0aGUgUFRTIHZhbHVlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjY0J5dGVzID0gc2FtcGxlc1tpXS5ieXRlcztcbiAgICAgIGlmIChjY0J5dGVzKSB7XG4gICAgICAgIGNvbnN0IGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGNjQnl0ZXMpO1xuICAgICAgICBjZWE2MDhQYXJzZXIxLmFkZERhdGEoc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXNbMF0pO1xuICAgICAgICBjZWE2MDhQYXJzZXIyLmFkZERhdGEoc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXNbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCB7XG4gICAgc3RhcnRPZmZzZXQsXG4gICAgZW5kT2Zmc2V0LFxuICAgIGVuZE9mZnNldFN1YnRpdGxlcyxcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgbWVkaWEuY3VycmVudFRpbWUgPCBlbmRPZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2xlYXIgNjA4IGNhcHRpb24gY3VlcyBmcm9tIHRoZSBjYXB0aW9ucyBUZXh0VHJhY2tzIHdoZW4gdGhlIHZpZGVvIGJhY2sgYnVmZmVyIGlzIGZsdXNoZWRcbiAgICAvLyBGb3J3YXJkIGN1ZXMgYXJlIG5ldmVyIHJlbW92ZWQgYmVjYXVzZSB3ZSBjYW4gbG9vc2Ugc3RyZWFtZWQgNjA4IGNvbnRlbnQgZnJvbSByZWNlbnQgZnJhZ21lbnRzXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FwdGlvbnNUcmFja3NcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHJlbW92ZUN1ZXNJblJhbmdlKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgLy8gQ2xlYXIgVlRUL0lNU0MxIHN1YnRpdGxlIGN1ZXMgZnJvbSB0aGUgc3VidGl0bGUgVGV4dFRyYWNrcyB3aGVuIHRoZSBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0U3VidGl0bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRleHRUcmFja3NcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRleHRUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHJlbW92ZUN1ZXNJblJhbmdlKHRleHRUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleHRyYWN0Q2VhNjA4RGF0YShieXRlQXJyYXkpIHtcbiAgICBjb25zdCBhY3R1YWxDQ0J5dGVzID0gW1tdLCBbXV07XG4gICAgY29uc3QgY291bnQgPSBieXRlQXJyYXlbMF0gJiAweDFmO1xuICAgIGxldCBwb3NpdGlvbiA9IDI7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBjb25zdCB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY29uc3QgY2NieXRlMSA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjb25zdCBjY2J5dGUyID0gMHg3ZiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjY1ZhbGlkID0gKDB4MDQgJiB0bXBCeXRlKSAhPT0gMDsgLy8gU3VwcG9ydCBhbGwgZm91ciBjaGFubmVsc1xuICAgICAgaWYgKGNjVmFsaWQpIHtcbiAgICAgICAgY29uc3QgY2NUeXBlID0gMHgwMyAmIHRtcEJ5dGU7XG4gICAgICAgIGlmICgweDAwIC8qIENFQTYwOCBmaWVsZDEqLyA9PT0gY2NUeXBlIHx8IDB4MDEgLyogQ0VBNjA4IGZpZWxkMiovID09PSBjY1R5cGUpIHtcbiAgICAgICAgICAvLyBFeGNsdWRlIENFQTcwOCBDQyBkYXRhLlxuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICB9XG59XG5mdW5jdGlvbiBjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCBtYW5pZmVzdFRyYWNrKSB7XG4gIHJldHVybiAhIWluVXNlVHJhY2sgJiYgaW5Vc2VUcmFjay5sYWJlbCA9PT0gbWFuaWZlc3RUcmFjay5uYW1lICYmICEoaW5Vc2VUcmFjay50ZXh0VHJhY2sxIHx8IGluVXNlVHJhY2sudGV4dFRyYWNrMik7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcbiAgcmV0dXJuIE1hdGgubWluKHgyLCB5MikgLSBNYXRoLm1heCh4MSwgeTEpO1xufVxuZnVuY3Rpb24gbmV3VlRUQ0NzKCkge1xuICByZXR1cm4ge1xuICAgIGNjT2Zmc2V0OiAwLFxuICAgIHByZXNlbnRhdGlvbk9mZnNldDogMCxcbiAgICAwOiB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIHByZXZDQzogLTEsXG4gICAgICBuZXc6IHRydWVcbiAgICB9XG4gIH07XG59XG5cbi8qXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcbiAqL1xuXG5jbGFzcyBDYXBMZXZlbENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5maXJzdExldmVsID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXIoKTtcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHRoaXMub25GcHNEcm9wTGV2ZWxDYXBwaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH1cbiAgb25GcHNEcm9wTGV2ZWxDYXBwaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gRG9uJ3QgYWRkIGEgcmVzdHJpY3RlZCBsZXZlbCBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2RhdGEuZHJvcHBlZExldmVsXTtcbiAgICBpZiAodGhpcy5pc0xldmVsQWxsb3dlZChsZXZlbCkpIHtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKHtcbiAgICAgICAgYml0cmF0ZTogbGV2ZWwuYml0cmF0ZSxcbiAgICAgICAgaGVpZ2h0OiBsZXZlbC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBsZXZlbC53aWR0aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gU3RhcnQgY2FwcGluZyBpbW1lZGlhdGVseSBpZiB0aGUgbWFuaWZlc3QgaGFzIHNpZ25hbGVkIHZpZGVvIGNvZGVjc1xuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgb25CdWZmZXJDb2RlY3MoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBJZiB0aGUgbWFuaWZlc3QgZGlkIG5vdCBzaWduYWwgYSB2aWRlbyBjb2RlYyBjYXBwaW5nIGhhcyBiZWVuIGRlZmVycmVkIHVudGlsIHdlJ3JlIGNlcnRhaW4gdmlkZW8gaXMgcHJlc2VudFxuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XG4gIH1cbiAgZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhSGVpZ2h0ID4gMCAmJiB0aGlzLm1lZGlhV2lkdGggPiAwKSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmdldE1heExldmVsKGxldmVscy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nICYmIHRoaXMuc3RyZWFtQ29udHJvbGxlcikge1xuICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBobHMuYXV0b0xldmVsQ2FwcGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAgKi9cbiAgZ2V0TWF4TGV2ZWwoY2FwTGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICBpZiAoIWxldmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRMZXZlbHMgPSBsZXZlbHMuZmlsdGVyKChsZXZlbCwgaW5kZXgpID0+IHRoaXMuaXNMZXZlbEFsbG93ZWQobGV2ZWwpICYmIGluZGV4IDw9IGNhcExldmVsSW5kZXgpO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplKHZhbGlkTGV2ZWxzLCB0aGlzLm1lZGlhV2lkdGgsIHRoaXMubWVkaWFIZWlnaHQpO1xuICB9XG4gIHN0YXJ0Q2FwcGluZygpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgLy8gRG9uJ3QgcmVzZXQgY2FwcGluZyBpZiBzdGFydGVkIHR3aWNlOyB0aGlzIGNhbiBoYXBwZW4gaWYgdGhlIG1hbmlmZXN0IHNpZ25hbHMgYSB2aWRlbyBjb2RlY1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5obHMuZmlyc3RMZXZlbCA9IHRoaXMuZ2V0TWF4TGV2ZWwodGhpcy5maXJzdExldmVsKTtcbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDEwMDApO1xuICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICB9XG4gIHN0b3BDYXBwaW5nKCkge1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgZ2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5jbGllbnRSZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnRSZWN0O1xuICAgIH1cbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgYm91bmRzUmVjdCA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBtZWRpYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGJvdW5kc1JlY3Qud2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICAgICAgYm91bmRzUmVjdC5oZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgICAgIGlmICghYm91bmRzUmVjdC53aWR0aCAmJiAhYm91bmRzUmVjdC5oZWlnaHQpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgbWVkaWEgZWxlbWVudCBoYXMgbm8gd2lkdGggb3IgaGVpZ2h0IChlcXVpdmFsZW50IHRvIG5vdCBiZWluZyBpbiB0aGUgRE9NKSxcbiAgICAgICAgLy8gdGhlbiB1c2UgaXRzIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlcyAobWVkaWEud2lkdGgsIG1lZGlhLmhlaWdodClcbiAgICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRSZWN0LmxlZnQgfHwgbWVkaWEud2lkdGggfHwgMDtcbiAgICAgICAgYm91bmRzUmVjdC5oZWlnaHQgPSBjbGllbnRSZWN0LmJvdHRvbSAtIGNsaWVudFJlY3QudG9wIHx8IG1lZGlhLmhlaWdodCB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsaWVudFJlY3QgPSBib3VuZHNSZWN0O1xuICAgIHJldHVybiBib3VuZHNSZWN0O1xuICB9XG4gIGdldCBtZWRpYVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS53aWR0aCAqIHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICB9XG4gIGdldCBtZWRpYUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkuaGVpZ2h0ICogdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gIH1cbiAgZ2V0IGNvbnRlbnRTY2FsZUZhY3RvcigpIHtcbiAgICBsZXQgcGl4ZWxSYXRpbyA9IDE7XG4gICAgaWYgKCF0aGlzLmhscy5jb25maWcuaWdub3JlRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGl4ZWxSYXRpbyA9IHNlbGYuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBpeGVsUmF0aW87XG4gIH1cbiAgaXNMZXZlbEFsbG93ZWQobGV2ZWwpIHtcbiAgICBjb25zdCByZXN0cmljdGVkTGV2ZWxzID0gdGhpcy5yZXN0cmljdGVkTGV2ZWxzO1xuICAgIHJldHVybiAhcmVzdHJpY3RlZExldmVscy5zb21lKHJlc3RyaWN0ZWRMZXZlbCA9PiB7XG4gICAgICByZXR1cm4gbGV2ZWwuYml0cmF0ZSA9PT0gcmVzdHJpY3RlZExldmVsLmJpdHJhdGUgJiYgbGV2ZWwud2lkdGggPT09IHJlc3RyaWN0ZWRMZXZlbC53aWR0aCAmJiBsZXZlbC5oZWlnaHQgPT09IHJlc3RyaWN0ZWRMZXZlbC5oZWlnaHQ7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldE1heExldmVsQnlNZWRpYVNpemUobGV2ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBMZXZlbHMgY2FuIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBidXQgZGlmZmVyaW5nIGJhbmR3aWR0aHMgLSBzaW5jZSBsZXZlbHMgYXJlIG9yZGVyZWQsIHdlIGNhbiBsb29rIHRvIHRoZSBuZXh0XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UndmUgY2hvc2VuIHRoZSBncmVhdGVzdCBiYW5kd2lkdGggZm9yIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnNcbiAgICBjb25zdCBhdEdyZWF0ZXN0QmFuZHdpZHRoID0gKGN1ckxldmVsLCBuZXh0TGV2ZWwpID0+IHtcbiAgICAgIGlmICghbmV4dExldmVsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1ckxldmVsLndpZHRoICE9PSBuZXh0TGV2ZWwud2lkdGggfHwgY3VyTGV2ZWwuaGVpZ2h0ICE9PSBuZXh0TGV2ZWwuaGVpZ2h0O1xuICAgIH07XG5cbiAgICAvLyBJZiB3ZSBydW4gdGhyb3VnaCB0aGUgbG9vcCB3aXRob3V0IGJyZWFraW5nLCB0aGUgbWVkaWEncyBkaW1lbnNpb25zIGFyZSBncmVhdGVyIHRoYW4gZXZlcnkgbGV2ZWwsIHNvIGRlZmF1bHQgdG9cbiAgICAvLyB0aGUgbWF4IGxldmVsXG4gICAgbGV0IG1heExldmVsSW5kZXggPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICBpZiAoKGxldmVsLndpZHRoID49IHdpZHRoIHx8IGxldmVsLmhlaWdodCA+PSBoZWlnaHQpICYmIGF0R3JlYXRlc3RCYW5kd2lkdGgobGV2ZWwsIGxldmVsc1tpICsgMV0pKSB7XG4gICAgICAgIG1heExldmVsSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heExldmVsSW5kZXg7XG4gIH1cbn1cblxuY2xhc3MgRlBTQ29udHJvbGxlciB7XG4gIC8vIHN0cmVhbSBjb250cm9sbGVyIG11c3QgYmUgcHJvdmlkZWQgYXMgYSBkZXBlbmRlbmN5IVxuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5sYXN0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gMDtcbiAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gMDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcikge1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHN0cmVhbUNvbnRyb2xsZXI7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgfVxuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgaWYgKGNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xuICAgICAgY29uc3QgbWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2Ygc2VsZi5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgICBpZiAobWVkaWEgJiYgdHlwZW9mIG1lZGlhLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChkZWNvZGVkRnJhbWVzKSB7XG4gICAgICBpZiAodGhpcy5sYXN0VGltZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lO1xuICAgICAgICBjb25zdCBjdXJyZW50RHJvcHBlZCA9IGRyb3BwZWRGcmFtZXMgLSB0aGlzLmxhc3REcm9wcGVkRnJhbWVzO1xuICAgICAgICBjb25zdCBjdXJyZW50RGVjb2RlZCA9IGRlY29kZWRGcmFtZXMgLSB0aGlzLmxhc3REZWNvZGVkRnJhbWVzO1xuICAgICAgICBjb25zdCBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZDtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUCwge1xuICAgICAgICAgIGN1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCxcbiAgICAgICAgICBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsXG4gICAgICAgICAgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xuICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IGhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQgKiBjdXJyZW50RGVjb2RlZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IGhscy5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBsb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbCxcbiAgICAgICAgICAgICAgICBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gZHJvcHBlZEZyYW1lcztcbiAgICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSBkZWNvZGVkRnJhbWVzO1xuICAgIH1cbiAgfVxuICBjaGVja0ZQU0ludGVydmFsKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgY29uc3QgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzLCB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSFRNTFZpZGVvRWxlbWVudCBkb2Vzbid0IGluY2x1ZGUgdGhlIHdlYmtpdCB0eXBlc1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlby53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgdmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBMT0dHRVJfUFJFRklYID0gJ1tlbWVdJztcbi8qKlxuICogQ29udHJvbGxlciB0byBkZWFsIHdpdGggZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMgKEVNRSlcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VuY3J5cHRlZF9NZWRpYV9FeHRlbnNpb25zX0FQSVxuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEVNRUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPSB7fTtcbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5tZWRpYUtleVNlc3Npb25zID0gW107XG4gICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSB7fTtcbiAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA/IFtFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlXSA6IFtdO1xuICAgIHRoaXMub25NZWRpYUVuY3J5cHRlZCA9IHRoaXMuX29uTWVkaWFFbmNyeXB0ZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uV2FpdGluZ0ZvcktleSA9IHRoaXMuX29uV2FpdGluZ0ZvcktleS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZGVidWcgPSBsb2dnZXIuZGVidWcuYmluZChsb2dnZXIsIExPR0dFUl9QUkVGSVgpO1xuICAgIHRoaXMubG9nID0gbG9nZ2VyLmxvZy5iaW5kKGxvZ2dlciwgTE9HR0VSX1BSRUZJWCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIExPR0dFUl9QUkVGSVgpO1xuICAgIHRoaXMuZXJyb3IgPSBsb2dnZXIuZXJyb3IuYmluZChsb2dnZXIsIExPR0dFUl9QUkVGSVgpO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hlZCgpO1xuICAgIC8vIFJlbW92ZSBhbnkgcmVmZXJlbmNlcyB0aGF0IGNvdWxkIGJlIGhlbGQgaW4gY29uZmlnIG9wdGlvbnMgb3IgY2FsbGJhY2tzXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uZmlnLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMgPSBudWxsO1xuICAgIGNvbmZpZy5saWNlbnNlWGhyU2V0dXAgPSBjb25maWcubGljZW5zZVJlc3BvbnNlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgY29uZmlnLmRybVN5c3RlbXMgPSBjb25maWcuZHJtU3lzdGVtT3B0aW9ucyA9IHt9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMub25NZWRpYUVuY3J5cHRlZCA9IHRoaXMub25XYWl0aW5nRm9yS2V5ID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gIH1cbiAgZ2V0TGljZW5zZVNlcnZlclVybChrZXlTeXN0ZW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm1TeXN0ZW1zLFxuICAgICAgd2lkZXZpbmVMaWNlbnNlVXJsXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGtleVN5c3RlbUNvbmZpZ3VyYXRpb24gPSBkcm1TeXN0ZW1zW2tleVN5c3RlbV07XG4gICAgaWYgKGtleVN5c3RlbUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHJldHVybiBrZXlTeXN0ZW1Db25maWd1cmF0aW9uLmxpY2Vuc2VVcmw7XG4gICAgfVxuXG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoa2V5U3lzdGVtID09PSBLZXlTeXN0ZW1zLldJREVWSU5FICYmIHdpZGV2aW5lTGljZW5zZVVybCkge1xuICAgICAgcmV0dXJuIHdpZGV2aW5lTGljZW5zZVVybDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBsaWNlbnNlIHNlcnZlciBVUkwgY29uZmlndXJlZCBmb3Iga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gIH1cbiAgZ2V0U2VydmVyQ2VydGlmaWNhdGVVcmwoa2V5U3lzdGVtKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJtU3lzdGVtc1xuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBrZXlTeXN0ZW1Db25maWd1cmF0aW9uID0gZHJtU3lzdGVtc1trZXlTeXN0ZW1dO1xuICAgIGlmIChrZXlTeXN0ZW1Db25maWd1cmF0aW9uKSB7XG4gICAgICByZXR1cm4ga2V5U3lzdGVtQ29uZmlndXJhdGlvbi5zZXJ2ZXJDZXJ0aWZpY2F0ZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2coYE5vIFNlcnZlciBDZXJ0aWZpY2F0ZSBpbiBjb25maWcuZHJtU3lzdGVtc1tcIiR7a2V5U3lzdGVtfVwiXWApO1xuICAgIH1cbiAgfVxuICBhdHRlbXB0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbXNUb0F0dGVtcHQpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgY29uc3QgdW5pcXVlQ29kZWMgPSAodmFsdWUsIGksIGEpID0+ICEhdmFsdWUgJiYgYS5pbmRleE9mKHZhbHVlKSA9PT0gaTtcbiAgICBjb25zdCBhdWRpb0NvZGVjcyA9IGxldmVscy5tYXAobGV2ZWwgPT4gbGV2ZWwuYXVkaW9Db2RlYykuZmlsdGVyKHVuaXF1ZUNvZGVjKTtcbiAgICBjb25zdCB2aWRlb0NvZGVjcyA9IGxldmVscy5tYXAobGV2ZWwgPT4gbGV2ZWwudmlkZW9Db2RlYykuZmlsdGVyKHVuaXF1ZUNvZGVjKTtcbiAgICBpZiAoYXVkaW9Db2RlY3MubGVuZ3RoICsgdmlkZW9Db2RlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB2aWRlb0NvZGVjcy5wdXNoKCdhdmMxLjQyZTAxZScpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgYXR0ZW1wdCA9IGtleVN5c3RlbXMgPT4ge1xuICAgICAgICBjb25zdCBrZXlTeXN0ZW0gPSBrZXlTeXN0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuZ2V0TWVkaWFLZXlzUHJvbWlzZShrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcykudGhlbihtZWRpYUtleXMgPT4gcmVzb2x2ZSh7XG4gICAgICAgICAga2V5U3lzdGVtLFxuICAgICAgICAgIG1lZGlhS2V5c1xuICAgICAgICB9KSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGlmIChrZXlTeXN0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYXR0ZW1wdChrZXlTeXN0ZW1zKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRU1FS2V5RXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICB9LCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBhdHRlbXB0KGtleVN5c3RlbXNUb0F0dGVtcHQpO1xuICAgIH0pO1xuICB9XG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW0sIHN1cHBvcnRlZENvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuY1xuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoISh0eXBlb2YgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGxldCBlcnJNZXNzYWdlID0gYENvbmZpZ3VyZWQgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGlzIG5vdCBhIGZ1bmN0aW9uICR7cmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuY31gO1xuICAgICAgaWYgKHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9PT0gbnVsbCAmJiBzZWxmLmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgICAgIGVyck1lc3NhZ2UgPSBgbmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBpcyBub3QgYXZhaWxhYmxlIG92ZXIgaW5zZWN1cmUgcHJvdG9jb2wgJHtsb2NhdGlvbi5wcm90b2NvbH1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jKGtleVN5c3RlbSwgc3VwcG9ydGVkQ29uZmlndXJhdGlvbnMpO1xuICB9XG4gIGdldE1lZGlhS2V5c1Byb21pc2Uoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgICAvLyBUaGlzIGNhbiB0aHJvdywgYnV0IGlzIGNhdWdodCBpbiBldmVudCBoYW5kbGVyIGNhbGxwYXRoXG4gICAgY29uc3QgbWVkaWFLZXlTeXN0ZW1Db25maWdzID0gZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgdGhpcy5jb25maWcuZHJtU3lzdGVtT3B0aW9ucyk7XG4gICAgY29uc3Qga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPSB0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzW2tleVN5c3RlbV07XG4gICAgbGV0IGtleVN5c3RlbUFjY2VzcyA9IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzID09IG51bGwgPyB2b2lkIDAgOiBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5rZXlTeXN0ZW1BY2Nlc3M7XG4gICAgaWYgKCFrZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgIHRoaXMubG9nKGBSZXF1ZXN0aW5nIGVuY3J5cHRlZCBtZWRpYSBcIiR7a2V5U3lzdGVtfVwiIGtleS1zeXN0ZW0gYWNjZXNzIHdpdGggY29uZmlnOiAke0pTT04uc3RyaW5naWZ5KG1lZGlhS2V5U3lzdGVtQ29uZmlncyl9YCk7XG4gICAgICBrZXlTeXN0ZW1BY2Nlc3MgPSB0aGlzLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQ29uZmlncyk7XG4gICAgICBjb25zdCBfa2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPSB0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzW2tleVN5c3RlbV0gPSB7XG4gICAgICAgIGtleVN5c3RlbUFjY2Vzc1xuICAgICAgfTtcbiAgICAgIGtleVN5c3RlbUFjY2Vzcy5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBGYWlsZWQgdG8gb2J0YWluIGFjY2VzcyB0byBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCI6ICR7ZXJyb3J9YCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBrZXlTeXN0ZW1BY2Nlc3MudGhlbihtZWRpYUtleVN5c3RlbUFjY2VzcyA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBBY2Nlc3MgZm9yIGtleS1zeXN0ZW0gXCIke21lZGlhS2V5U3lzdGVtQWNjZXNzLmtleVN5c3RlbX1cIiBvYnRhaW5lZGApO1xuICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZVJlcXVlc3QgPSB0aGlzLmZldGNoU2VydmVyQ2VydGlmaWNhdGUoa2V5U3lzdGVtKTtcbiAgICAgICAgdGhpcy5sb2coYENyZWF0ZSBtZWRpYS1rZXlzIGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICAgIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXMgPSBtZWRpYUtleVN5c3RlbUFjY2Vzcy5jcmVhdGVNZWRpYUtleXMoKS50aGVuKG1lZGlhS2V5cyA9PiB7XG4gICAgICAgICAgdGhpcy5sb2coYE1lZGlhLWtleXMgY3JlYXRlZCBmb3IgXCIke2tleVN5c3RlbX1cImApO1xuICAgICAgICAgIHJldHVybiBjZXJ0aWZpY2F0ZVJlcXVlc3QudGhlbihjZXJ0aWZpY2F0ZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWVkaWFLZXlzU2VydmVyQ2VydGlmaWNhdGUobWVkaWFLZXlzLCBrZXlTeXN0ZW0sIGNlcnRpZmljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZWRpYUtleXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfa2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIG1lZGlhLWtleXMgZm9yIFwiJHtrZXlTeXN0ZW19XCJ9OiAke2Vycm9yfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXM7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVN5c3RlbUFjY2Vzcy50aGVuKCgpID0+IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cyk7XG4gIH1cbiAgY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCh7XG4gICAgZGVjcnlwdGRhdGEsXG4gICAga2V5U3lzdGVtLFxuICAgIG1lZGlhS2V5c1xuICB9KSB7XG4gICAgdGhpcy5sb2coYENyZWF0aW5nIGtleS1zeXN0ZW0gc2Vzc2lvbiBcIiR7a2V5U3lzdGVtfVwiIGtleUlkOiAke0hleC5oZXhEdW1wKGRlY3J5cHRkYXRhLmtleUlkIHx8IFtdKX1gKTtcbiAgICBjb25zdCBtZWRpYUtleXNTZXNzaW9uID0gbWVkaWFLZXlzLmNyZWF0ZVNlc3Npb24oKTtcbiAgICBjb25zdCBtZWRpYUtleVNlc3Npb25Db250ZXh0ID0ge1xuICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICBrZXlTeXN0ZW0sXG4gICAgICBtZWRpYUtleXMsXG4gICAgICBtZWRpYUtleXNTZXNzaW9uLFxuICAgICAga2V5U3RhdHVzOiAnc3RhdHVzLXBlbmRpbmcnXG4gICAgfTtcbiAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMucHVzaChtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgICByZXR1cm4gbWVkaWFLZXlTZXNzaW9uQ29udGV4dDtcbiAgfVxuICByZW5ld0tleVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YTtcbiAgICBpZiAoZGVjcnlwdGRhdGEucHNzaCkge1xuICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQobWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICBjb25zdCBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpO1xuICAgICAgY29uc3Qgc2NoZW1lID0gJ2NlbmMnO1xuICAgICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdID0gdGhpcy5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlTZXNzaW9uQ29udGV4dCwgc2NoZW1lLCBkZWNyeXB0ZGF0YS5wc3NoLCAnZXhwaXJlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCByZW5ldyBleHBpcmVkIHNlc3Npb24uIE1pc3NpbmcgcHNzaCBpbml0RGF0YS5gKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICB9XG4gIGdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKSB7XG4gICAgaWYgKCFkZWNyeXB0ZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVhZCBrZXlJZCBvZiB1bmRlZmluZWQgZGVjcnlwdGRhdGEnKTtcbiAgICB9XG4gICAgaWYgKGRlY3J5cHRkYXRhLmtleUlkID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleUlkIGlzIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIEhleC5oZXhEdW1wKGRlY3J5cHRkYXRhLmtleUlkKTtcbiAgfVxuICB1cGRhdGVLZXlTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQsIGRhdGEpIHtcbiAgICB2YXIgX21lZGlhS2V5U2Vzc2lvbkNvbnRlO1xuICAgIGNvbnN0IGtleVNlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgdGhpcy5sb2coYFVwZGF0aW5nIGtleS1zZXNzaW9uIFwiJHtrZXlTZXNzaW9uLnNlc3Npb25JZH1cIiBmb3Iga2V5SUQgJHtIZXguaGV4RHVtcCgoKF9tZWRpYUtleVNlc3Npb25Db250ZSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfbWVkaWFLZXlTZXNzaW9uQ29udGUua2V5SWQpIHx8IFtdKX1cbiAgICAgIH0gKGRhdGEgbGVuZ3RoOiAke2RhdGEgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhfSlgKTtcbiAgICByZXR1cm4ga2V5U2Vzc2lvbi51cGRhdGUoZGF0YSk7XG4gIH1cbiAgc2VsZWN0S2V5U3lzdGVtRm9ybWF0KGZyYWcpIHtcbiAgICBjb25zdCBrZXlGb3JtYXRzID0gT2JqZWN0LmtleXMoZnJhZy5sZXZlbGtleXMgfHwge30pO1xuICAgIGlmICghdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICB0aGlzLmxvZyhgU2VsZWN0aW5nIGtleS1zeXN0ZW0gZnJvbSBmcmFnbWVudCAoc246ICR7ZnJhZy5zbn0gJHtmcmFnLnR5cGV9OiAke2ZyYWcubGV2ZWx9KSBrZXkgZm9ybWF0cyAke2tleUZvcm1hdHMuam9pbignLCAnKX1gKTtcbiAgICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IHRoaXMuZ2V0S2V5Rm9ybWF0UHJvbWlzZShrZXlGb3JtYXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMua2V5Rm9ybWF0UHJvbWlzZTtcbiAgfVxuICBnZXRLZXlGb3JtYXRQcm9taXNlKGtleUZvcm1hdHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qga2V5U3lzdGVtc0luQ29uZmlnID0gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgICBjb25zdCBrZXlTeXN0ZW1zVG9BdHRlbXB0ID0ga2V5Rm9ybWF0cy5tYXAoa2V5U3lzdGVtRm9ybWF0VG9LZXlTeXN0ZW1Eb21haW4pLmZpbHRlcih2YWx1ZSA9PiAhIXZhbHVlICYmIGtleVN5c3RlbXNJbkNvbmZpZy5pbmRleE9mKHZhbHVlKSAhPT0gLTEpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZShrZXlTeXN0ZW1zVG9BdHRlbXB0KS50aGVuKCh7XG4gICAgICAgIGtleVN5c3RlbVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlTeXN0ZW1Gb3JtYXQgPSBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pO1xuICAgICAgICBpZiAoa2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgICAgICAgcmVzb2x2ZShrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGZvcm1hdCBmb3Iga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiYCkpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIGxvYWRLZXkoZGF0YSkge1xuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gZGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgY29uc3Qga2V5RGV0YWlscyA9IGAoa2V5SWQ6ICR7a2V5SWR9IGZvcm1hdDogXCIke2RlY3J5cHRkYXRhLmtleUZvcm1hdH1cIiBtZXRob2Q6ICR7ZGVjcnlwdGRhdGEubWV0aG9kfSB1cmk6ICR7ZGVjcnlwdGRhdGEudXJpfSlgO1xuICAgIHRoaXMubG9nKGBTdGFydGluZyBzZXNzaW9uIGZvciBrZXkgJHtrZXlEZXRhaWxzfWApO1xuICAgIGxldCBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF07XG4gICAgaWYgKCFrZXlTZXNzaW9uQ29udGV4dFByb21pc2UpIHtcbiAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXSA9IHRoaXMuZ2V0S2V5U3lzdGVtRm9yS2V5UHJvbWlzZShkZWNyeXB0ZGF0YSkudGhlbigoe1xuICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgIG1lZGlhS2V5c1xuICAgICAgfSkgPT4ge1xuICAgICAgICB0aGlzLnRocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5sb2coYEhhbmRsZSBlbmNyeXB0ZWQgbWVkaWEgc246ICR7ZGF0YS5mcmFnLnNufSAke2RhdGEuZnJhZy50eXBlfTogJHtkYXRhLmZyYWcubGV2ZWx9IHVzaW5nIGtleSAke2tleURldGFpbHN9YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIGNvbnN0IGtleVNlc3Npb25Db250ZXh0ID0gdGhpcy5jcmVhdGVNZWRpYUtleVNlc3Npb25Db250ZXh0KHtcbiAgICAgICAgICAgIGtleVN5c3RlbSxcbiAgICAgICAgICAgIG1lZGlhS2V5cyxcbiAgICAgICAgICAgIGRlY3J5cHRkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc2NoZW1lID0gJ2NlbmMnO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleVNlc3Npb25Db250ZXh0LCBzY2hlbWUsIGRlY3J5cHRkYXRhLnBzc2gsICdwbGF5bGlzdC1rZXknKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS5jYXRjaChlcnJvciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycm9yKSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTZXNzaW9uQ29udGV4dFByb21pc2U7XG4gIH1cbiAgdGhyb3dJZkRlc3Ryb3llZChtZXNzYWdlID0gJ0ludmFsaWQgc3RhdGUnKSB7XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJyk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVNRUtleUVycm9yKSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXJyb3IuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fS0VZUyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0S2V5U3lzdGVtRm9yS2V5UHJvbWlzZShkZWNyeXB0ZGF0YSkge1xuICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgY29uc3QgbWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXTtcbiAgICBpZiAoIW1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGtleVN5c3RlbSA9IGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKGRlY3J5cHRkYXRhLmtleUZvcm1hdCk7XG4gICAgICBjb25zdCBrZXlTeXN0ZW1zVG9BdHRlbXB0ID0ga2V5U3lzdGVtID8gW2tleVN5c3RlbV0gOiBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICAgIHJldHVybiB0aGlzLmF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gICAgfVxuICAgIHJldHVybiBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICB9XG4gIGdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2Uoa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgIGlmICgha2V5U3lzdGVtc1RvQXR0ZW1wdC5sZW5ndGgpIHtcbiAgICAgIGtleVN5c3RlbXNUb0F0dGVtcHQgPSBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGtleVN5c3RlbXNUb0F0dGVtcHQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRSxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0sIGBNaXNzaW5nIGtleS1zeXN0ZW0gbGljZW5zZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgJHtKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRybVN5c3RlbXM6IHRoaXMuY29uZmlnLmRybVN5c3RlbXNcbiAgICAgIH0pfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbXNUb0F0dGVtcHQpO1xuICB9XG4gIF9vbk1lZGlhRW5jcnlwdGVkKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdERhdGFUeXBlLFxuICAgICAgaW5pdERhdGFcbiAgICB9ID0gZXZlbnQ7XG4gICAgdGhpcy5kZWJ1ZyhgXCIke2V2ZW50LnR5cGV9XCIgZXZlbnQ6IGluaXQgZGF0YSB0eXBlOiBcIiR7aW5pdERhdGFUeXBlfVwiYCk7XG5cbiAgICAvLyBJZ25vcmUgZXZlbnQgd2hlbiBpbml0RGF0YSBpcyBudWxsXG4gICAgaWYgKGluaXREYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBrZXlJZDtcbiAgICBsZXQga2V5U3lzdGVtRG9tYWluO1xuICAgIGlmIChpbml0RGF0YVR5cGUgPT09ICdzaW5mJyAmJiB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zW0tleVN5c3RlbXMuRkFJUlBMQVldKSB7XG4gICAgICAvLyBNYXRjaCBzaW5mIGtleUlkIHRvIHBsYXlsaXN0IHNrZDovL2tleUlkPVxuICAgICAgY29uc3QganNvbiA9IGJpbjJzdHIobmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNpbmYgPSBiYXNlNjREZWNvZGUoSlNPTi5wYXJzZShqc29uKS5zaW5mKTtcbiAgICAgICAgY29uc3QgdGVuYyA9IHBhcnNlU2luZihuZXcgVWludDhBcnJheShzaW5mKSk7XG4gICAgICAgIGlmICghdGVuYykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBrZXlJZCA9IHRlbmMuc3ViYXJyYXkoOCwgMjQpO1xuICAgICAgICBrZXlTeXN0ZW1Eb21haW4gPSBLZXlTeXN0ZW1zLkZBSVJQTEFZO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy53YXJuKCdGYWlsZWQgdG8gcGFyc2Ugc2luZiBcImVuY3J5cHRlZFwiIGV2ZW50IG1lc3NhZ2UgaW5pdERhdGEnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdXBwb3J0IGNsZWFyLWxlYWQga2V5LXNlc3Npb24gY3JlYXRpb24gKG90aGVyd2lzZSBkZXBlbmQgb24gcGxheWxpc3Qga2V5cylcbiAgICAgIGNvbnN0IHBzc2hJbmZvID0gcGFyc2VQc3NoKGluaXREYXRhKTtcbiAgICAgIGlmIChwc3NoSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocHNzaEluZm8udmVyc2lvbiA9PT0gMCAmJiBwc3NoSW5mby5zeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLldJREVWSU5FICYmIHBzc2hJbmZvLmRhdGEpIHtcbiAgICAgICAga2V5SWQgPSBwc3NoSW5mby5kYXRhLnN1YmFycmF5KDgsIDI0KTtcbiAgICAgIH1cbiAgICAgIGtleVN5c3RlbURvbWFpbiA9IGtleVN5c3RlbUlkVG9LZXlTeXN0ZW1Eb21haW4ocHNzaEluZm8uc3lzdGVtSWQpO1xuICAgIH1cbiAgICBpZiAoIWtleVN5c3RlbURvbWFpbiB8fCAha2V5SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga2V5SWRIZXggPSBIZXguaGV4RHVtcChrZXlJZCk7XG4gICAgY29uc3Qge1xuICAgICAga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlLFxuICAgICAgbWVkaWFLZXlTZXNzaW9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGxldCBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRIZXhdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWFLZXlTZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTWF0Y2ggcGxheWxpc3Qga2V5XG4gICAgICBjb25zdCBrZXlDb250ZXh0ID0gbWVkaWFLZXlTZXNzaW9uc1tpXTtcbiAgICAgIGNvbnN0IGRlY3J5cHRkYXRhID0ga2V5Q29udGV4dC5kZWNyeXB0ZGF0YTtcbiAgICAgIGlmIChkZWNyeXB0ZGF0YS5wc3NoIHx8ICFkZWNyeXB0ZGF0YS5rZXlJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZEtleUlkSGV4ID0gSGV4LmhleER1bXAoZGVjcnlwdGRhdGEua2V5SWQpO1xuICAgICAgaWYgKGtleUlkSGV4ID09PSBvbGRLZXlJZEhleCB8fCBkZWNyeXB0ZGF0YS51cmkucmVwbGFjZSgvLS9nLCAnJykuaW5kZXhPZihrZXlJZEhleCkgIT09IC0xKSB7XG4gICAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtvbGRLZXlJZEhleF07XG4gICAgICAgIGRlbGV0ZSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vbb2xkS2V5SWRIZXhdO1xuICAgICAgICBkZWNyeXB0ZGF0YS5wc3NoID0gbmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEpO1xuICAgICAgICBkZWNyeXB0ZGF0YS5rZXlJZCA9IGtleUlkO1xuICAgICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRIZXhdID0ga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleUNvbnRleHQsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsICdlbmNyeXB0ZWQtZXZlbnQta2V5LW1hdGNoJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFrZXlTZXNzaW9uQ29udGV4dFByb21pc2UpIHtcbiAgICAgIC8vIENsZWFyLWxlYWQga2V5IChub3QgZW5jb3VudGVyZWQgaW4gcGxheWxpc3QpXG4gICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRIZXhdID0gdGhpcy5nZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKFtrZXlTeXN0ZW1Eb21haW5dKS50aGVuKCh7XG4gICAgICAgIGtleVN5c3RlbSxcbiAgICAgICAgbWVkaWFLZXlzXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHZhciBfa2V5U3lzdGVtVG9LZXlTeXN0ZW07XG4gICAgICAgIHRoaXMudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSgnSVNPLTIzMDAxLTcnLCBrZXlJZEhleCwgKF9rZXlTeXN0ZW1Ub0tleVN5c3RlbSA9IGtleVN5c3RlbURvbWFpblRvS2V5U3lzdGVtRm9ybWF0KGtleVN5c3RlbSkpICE9IG51bGwgPyBfa2V5U3lzdGVtVG9LZXlTeXN0ZW0gOiAnJyk7XG4gICAgICAgIGRlY3J5cHRkYXRhLnBzc2ggPSBuZXcgVWludDhBcnJheShpbml0RGF0YSk7XG4gICAgICAgIGRlY3J5cHRkYXRhLmtleUlkID0ga2V5SWQ7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIGNvbnN0IGtleVNlc3Npb25Db250ZXh0ID0gdGhpcy5jcmVhdGVNZWRpYUtleVNlc3Npb25Db250ZXh0KHtcbiAgICAgICAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAgICAgICAga2V5U3lzdGVtLFxuICAgICAgICAgICAgbWVkaWFLZXlzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oa2V5U2Vzc2lvbkNvbnRleHQsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsICdlbmNyeXB0ZWQtZXZlbnQtbm8tbWF0Y2gnKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKTtcbiAgfVxuICBfb25XYWl0aW5nRm9yS2V5KGV2ZW50KSB7XG4gICAgdGhpcy5sb2coYFwiJHtldmVudC50eXBlfVwiIGV2ZW50YCk7XG4gIH1cbiAgYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cykge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5zbGljZSgpO1xuICAgIHRoaXMubG9nKGBTZXR0aW5nIG1lZGlhLWtleXMgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAvLyBPbmx5IG9uZSBzZXRNZWRpYUtleXMoKSBjYW4gcnVuIGF0IG9uZSB0aW1lLCBhbmQgbXVsdGlwbGUgc2V0TWVkaWFLZXlzKCkgb3BlcmF0aW9uc1xuICAgIC8vIGNhbiBiZSBxdWV1ZWQgZm9yIGV4ZWN1dGlvbiBmb3IgbXVsdGlwbGUga2V5IHNlc3Npb25zLlxuICAgIGNvbnN0IHNldE1lZGlhS2V5c1Byb21pc2UgPSBQcm9taXNlLmFsbChxdWV1ZSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gc2V0IG1lZGlhS2V5cyB3aXRob3V0IG1lZGlhIGVsZW1lbnQgYXR0YWNoZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1lZGlhLnNldE1lZGlhS2V5cyhtZWRpYUtleXMpO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0TWVkaWFLZXlzUXVldWUucHVzaChzZXRNZWRpYUtleXNQcm9taXNlKTtcbiAgICByZXR1cm4gc2V0TWVkaWFLZXlzUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMubG9nKGBNZWRpYS1rZXlzIHNldCBmb3IgXCIke2tleVN5c3RlbX1cImApO1xuICAgICAgcXVldWUucHVzaChzZXRNZWRpYUtleXNQcm9taXNlKTtcbiAgICAgIHRoaXMuc2V0TWVkaWFLZXlzUXVldWUgPSB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlLmZpbHRlcihwID0+IHF1ZXVlLmluZGV4T2YocCkgPT09IC0xKTtcbiAgICB9KTtcbiAgfVxuICBnZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihjb250ZXh0LCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCByZWFzb24pIHtcbiAgICB2YXIgX3RoaXMkY29uZmlnJGRybVN5c3RlLCBfdGhpcyRjb25maWckZHJtU3lzdGUyO1xuICAgIGNvbnN0IGdlbmVyYXRlUmVxdWVzdEZpbHRlciA9IChfdGhpcyRjb25maWckZHJtU3lzdGUgPSB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJGNvbmZpZyRkcm1TeXN0ZTIgPSBfdGhpcyRjb25maWckZHJtU3lzdGVbY29udGV4dC5rZXlTeXN0ZW1dKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY29uZmlnJGRybVN5c3RlMi5nZW5lcmF0ZVJlcXVlc3Q7XG4gICAgaWYgKGdlbmVyYXRlUmVxdWVzdEZpbHRlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWFwcGVkSW5pdERhdGEgPSBnZW5lcmF0ZVJlcXVlc3RGaWx0ZXIuY2FsbCh0aGlzLmhscywgaW5pdERhdGFUeXBlLCBpbml0RGF0YSwgY29udGV4dCk7XG4gICAgICAgIGlmICghbWFwcGVkSW5pdERhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgZnJvbSBjb25maWd1cmVkIGdlbmVyYXRlUmVxdWVzdCBmaWx0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0RGF0YVR5cGUgPSBtYXBwZWRJbml0RGF0YS5pbml0RGF0YVR5cGU7XG4gICAgICAgIGluaXREYXRhID0gY29udGV4dC5kZWNyeXB0ZGF0YS5wc3NoID0gbWFwcGVkSW5pdERhdGEuaW5pdERhdGEgPyBuZXcgVWludDhBcnJheShtYXBwZWRJbml0RGF0YS5pbml0RGF0YSkgOiBudWxsO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdmFyIF90aGlzJGhscztcbiAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBpZiAoKF90aGlzJGhscyA9IHRoaXMuaGxzKSAhPSBudWxsICYmIF90aGlzJGhscy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5pdERhdGEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubG9nKGBTa2lwcGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcIiR7cmVhc29ufVwiIChubyBpbml0RGF0YSlgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhjb250ZXh0LmRlY3J5cHRkYXRhKTtcbiAgICB0aGlzLmxvZyhgR2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcIiR7cmVhc29ufVwiOiAke2tleUlkfSAoaW5pdCBkYXRhIHR5cGU6ICR7aW5pdERhdGFUeXBlfSBsZW5ndGg6ICR7aW5pdERhdGEgPyBpbml0RGF0YS5ieXRlTGVuZ3RoIDogbnVsbH0pYCk7XG4gICAgY29uc3QgbGljZW5zZVN0YXR1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24ub25tZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qga2V5U2Vzc2lvbiA9IGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICAgIGlmICgha2V5U2Vzc2lvbikge1xuICAgICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lc3NhZ2VUeXBlLFxuICAgICAgICBtZXNzYWdlXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB0aGlzLmxvZyhgXCIke21lc3NhZ2VUeXBlfVwiIG1lc3NhZ2UgZXZlbnQgZm9yIHNlc3Npb24gXCIke2tleVNlc3Npb24uc2Vzc2lvbklkfVwiIG1lc3NhZ2Ugc2l6ZTogJHttZXNzYWdlLmJ5dGVMZW5ndGh9YCk7XG4gICAgICBpZiAobWVzc2FnZVR5cGUgPT09ICdsaWNlbnNlLXJlcXVlc3QnIHx8IG1lc3NhZ2VUeXBlID09PSAnbGljZW5zZS1yZW5ld2FsJykge1xuICAgICAgICB0aGlzLnJlbmV3TGljZW5zZShjb250ZXh0LCBtZXNzYWdlKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2VUeXBlID09PSAnbGljZW5zZS1yZWxlYXNlJykge1xuICAgICAgICBpZiAoY29udGV4dC5rZXlTeXN0ZW0gPT09IEtleVN5c3RlbXMuRkFJUlBMQVkpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUtleVNlc3Npb24oY29udGV4dCwgc3RyVG9VdGY4YXJyYXkoJ2Fja25vd2xlZGdlZCcpKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZVNlc3Npb24oY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2FybihgdW5oYW5kbGVkIG1lZGlhIGtleSBtZXNzYWdlIHR5cGUgXCIke21lc3NhZ2VUeXBlfVwiYCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24ub25rZXlzdGF0dXNlc2NoYW5nZSA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb24gPSBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgICBpZiAoIWtleVNlc3Npb24pIHtcbiAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vbktleVN0YXR1c0NoYW5nZShjb250ZXh0KTtcbiAgICAgIGNvbnN0IGtleVN0YXR1cyA9IGNvbnRleHQua2V5U3RhdHVzO1xuICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdrZXlTdGF0dXMnLCBrZXlTdGF0dXMpO1xuICAgICAgaWYgKGtleVN0YXR1cyA9PT0gJ2V4cGlyZWQnKSB7XG4gICAgICAgIHRoaXMud2FybihgJHtjb250ZXh0LmtleVN5c3RlbX0gZXhwaXJlZCBmb3Iga2V5ICR7a2V5SWR9YCk7XG4gICAgICAgIHRoaXMucmVuZXdLZXlTZXNzaW9uKGNvbnRleHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qga2V5VXNhYmxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxpY2Vuc2VTdGF0dXMub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIGxpY2Vuc2VTdGF0dXMub24oJ2tleVN0YXR1cycsIGtleVN0YXR1cyA9PiB7XG4gICAgICAgIGlmIChrZXlTdGF0dXMuc3RhcnRzV2l0aCgndXNhYmxlJykpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnb3V0cHV0LXJlc3RyaWN0ZWQnKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgICB9LCAnSERDUCBsZXZlbCBvdXRwdXQgcmVzdHJpY3RlZCcpKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdpbnRlcm5hbC1lcnJvcicpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgfSwgYGtleSBzdGF0dXMgY2hhbmdlZCB0byBcIiR7a2V5U3RhdHVzfVwiYCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleVN0YXR1cyA9PT0gJ2V4cGlyZWQnKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigna2V5IGV4cGlyZWQgd2hpbGUgZ2VuZXJhdGluZyByZXF1ZXN0JykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud2FybihgdW5oYW5kbGVkIGtleSBzdGF0dXMgY2hhbmdlIFwiJHtrZXlTdGF0dXN9XCJgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5nZW5lcmF0ZVJlcXVlc3QoaW5pdERhdGFUeXBlLCBpbml0RGF0YSkudGhlbigoKSA9PiB7XG4gICAgICB2YXIgX2NvbnRleHQkbWVkaWFLZXlzU2VzO1xuICAgICAgdGhpcy5sb2coYFJlcXVlc3QgZ2VuZXJhdGVkIGZvciBrZXktc2Vzc2lvbiBcIiR7KF9jb250ZXh0JG1lZGlhS2V5c1NlcyA9IGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb250ZXh0JG1lZGlhS2V5c1Nlcy5zZXNzaW9uSWR9XCIga2V5SWQ6ICR7a2V5SWR9YCk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19TRVNTSU9OLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICB9LCBgRXJyb3IgZ2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0OiAke2Vycm9yfWApO1xuICAgIH0pLnRoZW4oKCkgPT4ga2V5VXNhYmxlUHJvbWlzZSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgbGljZW5zZVN0YXR1cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMucmVtb3ZlU2Vzc2lvbihjb250ZXh0KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgbGljZW5zZVN0YXR1cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH0pO1xuICB9XG4gIG9uS2V5U3RhdHVzQ2hhbmdlKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24ua2V5U3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzLCBrZXlJZCkgPT4ge1xuICAgICAgdGhpcy5sb2coYGtleSBzdGF0dXMgY2hhbmdlIFwiJHtzdGF0dXN9XCIgZm9yIGtleVN0YXR1c2VzIGtleUlkOiAke0hleC5oZXhEdW1wKCdidWZmZXInIGluIGtleUlkID8gbmV3IFVpbnQ4QXJyYXkoa2V5SWQuYnVmZmVyLCBrZXlJZC5ieXRlT2Zmc2V0LCBrZXlJZC5ieXRlTGVuZ3RoKSA6IG5ldyBVaW50OEFycmF5KGtleUlkKSl9IHNlc3Npb24ga2V5SWQ6ICR7SGV4LmhleER1bXAobmV3IFVpbnQ4QXJyYXkobWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YS5rZXlJZCB8fCBbXSkpfSB1cmk6ICR7bWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YS51cml9YCk7XG4gICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0LmtleVN0YXR1cyA9IHN0YXR1cztcbiAgICB9KTtcbiAgfVxuICBmZXRjaFNlcnZlckNlcnRpZmljYXRlKGtleVN5c3RlbSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgY29uc3QgY2VydExvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmdldFNlcnZlckNlcnRpZmljYXRlVXJsKGtleVN5c3RlbSk7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5sb2coYEZldGNoaW5nIHNlcnZlckNlcnRpZmljYXRlIGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgdXJsXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGNvbmZpZy5jZXJ0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXgsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpXG4gICAgICAgICAgfSwgYFwiJHtrZXlTeXN0ZW19XCIgY2VydGlmaWNhdGUgcmVxdWVzdCBmYWlsZWQgKCR7dXJsfSkuIFN0YXR1czogJHtyZXNwb25zZS5jb2RlfSAoJHtyZXNwb25zZS50ZXh0fSlgKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGBcIiR7a2V5U3lzdGVtfVwiIGNlcnRpZmljYXRlIHJlcXVlc3QgdGltZWQgb3V0ICgke3VybH0pYCkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignYWJvcnRlZCcpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNlcnRMb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfSk7XG4gIH1cbiAgc2V0TWVkaWFLZXlzU2VydmVyQ2VydGlmaWNhdGUobWVkaWFLZXlzLCBrZXlTeXN0ZW0sIGNlcnQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbWVkaWFLZXlzLnNldFNlcnZlckNlcnRpZmljYXRlKGNlcnQpLnRoZW4oc3VjY2VzcyA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBzZXRTZXJ2ZXJDZXJ0aWZpY2F0ZSAke3N1Y2Nlc3MgPyAnc3VjY2VzcycgOiAnbm90IHN1cHBvcnRlZCBieSBDRE0nfSAoJHtjZXJ0ID09IG51bGwgPyB2b2lkIDAgOiBjZXJ0LmJ5dGVMZW5ndGh9KSBvbiBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICAgIHJlc29sdmUobWVkaWFLZXlzKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVELFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlbmV3TGljZW5zZShjb250ZXh0LCBrZXlNZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdExpY2Vuc2UoY29udGV4dCwgbmV3IFVpbnQ4QXJyYXkoa2V5TWVzc2FnZSkpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVLZXlTZXNzaW9uKGNvbnRleHQsIG5ldyBVaW50OEFycmF5KGRhdGEpKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9LCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHNldHVwTGljZW5zZVhIUih4aHIsIHVybCwga2V5c0xpc3RJdGVtLCBsaWNlbnNlQ2hhbGxlbmdlKSB7XG4gICAgY29uc3QgbGljZW5zZVhoclNldHVwID0gdGhpcy5jb25maWcubGljZW5zZVhoclNldHVwO1xuICAgIGlmICghbGljZW5zZVhoclNldHVwKSB7XG4gICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0uZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgcmVtb3ZlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpY2Vuc2VYaHJTZXR1cC5jYWxsKHRoaXMuaGxzLCB4aHIsIHVybCwga2V5c0xpc3RJdGVtLCBsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBpZiAoIWtleXNMaXN0SXRlbS5kZWNyeXB0ZGF0YSkge1xuICAgICAgICAvLyBLZXkgc2Vzc2lvbiByZW1vdmVkLiBDYW5jZWwgbGljZW5zZSByZXF1ZXN0LlxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIGxldCdzIHRyeSB0byBvcGVuIGJlZm9yZSBydW5uaW5nIHNldHVwXG4gICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbGljZW5zZVhoclNldHVwLmNhbGwodGhpcy5obHMsIHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgIH0pLnRoZW4obGljZW5zZVhoclNldHVwUmVzdWx0ID0+IHtcbiAgICAgIC8vIGlmIGxpY2Vuc2VYaHJTZXR1cCBkaWQgbm90IHlldCBjYWxsIG9wZW4sIGxldCdzIGRvIGl0IG5vd1xuICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmaW5hbExpY2Vuc2VDaGFsbGVuZ2UgPSBsaWNlbnNlWGhyU2V0dXBSZXN1bHQgPyBsaWNlbnNlWGhyU2V0dXBSZXN1bHQgOiBsaWNlbnNlQ2hhbGxlbmdlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlOiBmaW5hbExpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdExpY2Vuc2Uoa2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICBjb25zdCBrZXlMb2FkUG9saWN5ID0gdGhpcy5jb25maWcua2V5TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLmdldExpY2Vuc2VTZXJ2ZXJVcmwoa2V5U2Vzc2lvbkNvbnRleHQua2V5U3lzdGVtKTtcbiAgICAgIHRoaXMubG9nKGBTZW5kaW5nIGxpY2Vuc2UgcmVxdWVzdCB0byBVUkw6ICR7dXJsfWApO1xuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5obHMgfHwgIWtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBMaWNlbnNlIHJlY2VpdmVkICR7ZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YX1gKTtcbiAgICAgICAgICAgIGNvbnN0IGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrID0gdGhpcy5jb25maWcubGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAobGljZW5zZVJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2suY2FsbCh0aGlzLmhscywgeGhyLCB1cmwsIGtleVNlc3Npb25Db250ZXh0KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlDb25maWcgPSBrZXlMb2FkUG9saWN5LmVycm9yUmV0cnk7XG4gICAgICAgICAgICBjb25zdCBtYXhOdW1SZXRyeSA9IHJldHJ5Q29uZmlnID8gcmV0cnlDb25maWcubWF4TnVtUmV0cnkgOiAwO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQrKztcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA+IG1heE51bVJldHJ5IHx8IHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA1MDApIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IHhocixcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgY29kZTogeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHhoci5zdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBgTGljZW5zZSBSZXF1ZXN0IFhIUiBmYWlsZWQgKCR7dXJsfSkuIFN0YXR1czogJHt4aHIuc3RhdHVzfSAoJHt4aHIuc3RhdHVzVGV4dH0pYCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdHNMZWZ0ID0gbWF4TnVtUmV0cnkgLSB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCArIDE7XG4gICAgICAgICAgICAgIHRoaXMud2FybihgUmV0cnlpbmcgbGljZW5zZSByZXF1ZXN0LCAke2F0dGVtcHRzTGVmdH0gYXR0ZW1wdHMgbGVmdGApO1xuICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RMaWNlbnNlKGtleVNlc3Npb25Db250ZXh0LCBsaWNlbnNlQ2hhbGxlbmdlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIgJiYga2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhoci5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIgPSB4aHI7XG4gICAgICB0aGlzLnNldHVwTGljZW5zZVhIUih4aHIsIHVybCwga2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpLnRoZW4oKHtcbiAgICAgICAgeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHhoci5zZW5kKGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gZGF0YS5tZWRpYTtcblxuICAgIC8vIGtlZXAgcmVmZXJlbmNlIG9mIG1lZGlhXG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuY3J5cHRlZCcsIHRoaXMub25NZWRpYUVuY3J5cHRlZCk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignd2FpdGluZ2ZvcmtleScsIHRoaXMub25XYWl0aW5nRm9yS2V5KTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoZWQoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGNvbnN0IG1lZGlhS2V5c0xpc3QgPSB0aGlzLm1lZGlhS2V5U2Vzc2lvbnM7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmNyeXB0ZWQnLCB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2FpdGluZ2ZvcmtleScsIHRoaXMub25XYWl0aW5nRm9yS2V5KTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZSA9IFtdO1xuICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucyA9IFtdO1xuICAgIHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0ge307XG4gICAgTGV2ZWxLZXkuY2xlYXJLZXlVcmlUb0tleUlkTWFwKCk7XG5cbiAgICAvLyBDbG9zZSBhbGwgc2Vzc2lvbnMgYW5kIHJlbW92ZSBtZWRpYSBrZXlzIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuXG4gICAgY29uc3Qga2V5U2Vzc2lvbkNvdW50ID0gbWVkaWFLZXlzTGlzdC5sZW5ndGg7XG4gICAgRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA9IFByb21pc2UuYWxsKG1lZGlhS2V5c0xpc3QubWFwKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPT4gdGhpcy5yZW1vdmVTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpKS5jb25jYXQobWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnNldE1lZGlhS2V5cyhudWxsKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICB0aGlzLmxvZyhgQ291bGQgbm90IGNsZWFyIG1lZGlhIGtleXM6ICR7ZXJyb3J9LiBtZWRpYS5zcmM6ICR7bWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnNyY31gKTtcbiAgICB9KSkpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKGtleVNlc3Npb25Db3VudCkge1xuICAgICAgICB0aGlzLmxvZygnZmluaXNoZWQgY2xvc2luZyBrZXkgc2Vzc2lvbnMgYW5kIGNsZWFyaW5nIG1lZGlhIGtleXMnKTtcbiAgICAgICAgbWVkaWFLZXlzTGlzdC5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbnMgYW5kIGNsZWFyIG1lZGlhIGtleXM6ICR7ZXJyb3J9LiBtZWRpYS5zcmM6ICR7bWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnNyY31gKTtcbiAgICB9KTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIHtcbiAgICBzZXNzaW9uS2V5c1xuICB9KSB7XG4gICAgaWYgKCFzZXNzaW9uS2V5cyB8fCAhdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMua2V5Rm9ybWF0UHJvbWlzZSkge1xuICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IHNlc3Npb25LZXlzLnJlZHVjZSgoZm9ybWF0cywgc2Vzc2lvbktleSkgPT4ge1xuICAgICAgICBpZiAoZm9ybWF0cy5pbmRleE9mKHNlc3Npb25LZXkua2V5Rm9ybWF0KSA9PT0gLTEpIHtcbiAgICAgICAgICBmb3JtYXRzLnB1c2goc2Vzc2lvbktleS5rZXlGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSwgW10pO1xuICAgICAgdGhpcy5sb2coYFNlbGVjdGluZyBrZXktc3lzdGVtIGZyb20gc2Vzc2lvbi1rZXlzICR7a2V5Rm9ybWF0cy5qb2luKCcsICcpfWApO1xuICAgICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gdGhpcy5nZXRLZXlGb3JtYXRQcm9taXNlKGtleUZvcm1hdHMpO1xuICAgIH1cbiAgfVxuICByZW1vdmVTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYUtleXNTZXNzaW9uLFxuICAgICAgbGljZW5zZVhoclxuICAgIH0gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICAgIGlmIChtZWRpYUtleXNTZXNzaW9uKSB7XG4gICAgICB0aGlzLmxvZyhgUmVtb3ZlIGxpY2Vuc2VzIGFuZCBrZXlzIGFuZCBjbG9zZSBzZXNzaW9uICR7bWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWR9YCk7XG4gICAgICBtZWRpYUtleXNTZXNzaW9uLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICBtZWRpYUtleXNTZXNzaW9uLm9ua2V5c3RhdHVzZXNjaGFuZ2UgPSBudWxsO1xuICAgICAgaWYgKGxpY2Vuc2VYaHIgJiYgbGljZW5zZVhoci5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIGxpY2Vuc2VYaHIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbiA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIgPSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucy5pbmRleE9mKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5tZWRpYUtleVNlc3Npb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVkaWFLZXlzU2Vzc2lvbi5yZW1vdmUoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgcmVtb3ZlIHNlc3Npb246ICR7ZXJyb3J9YCk7XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG1lZGlhS2V5c1Nlc3Npb24uY2xvc2UoKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjbG9zZSBzZXNzaW9uOiAke2Vycm9yfWApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5FTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlID0gdm9pZCAwO1xuY2xhc3MgRU1FS2V5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgZGF0YS5lcnJvciB8fCAoZGF0YS5lcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICBkYXRhLmVyciA9IGRhdGEuZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBDTUNEIHNwZWMgdmVyc2lvblxuICovXG5jb25zdCBDTUNEVmVyc2lvbiA9IDE7XG5cbi8qKlxuICogQ01DRCBPYmplY3QgVHlwZVxuICovXG52YXIgQ01DRE9iamVjdFR5cGUgPSB7XG4gIE1BTklGRVNUOiBcIm1cIixcbiAgQVVESU86IFwiYVwiLFxuICBWSURFTzogXCJ2XCIsXG4gIE1VWEVEOiBcImF2XCIsXG4gIElOSVQ6IFwiaVwiLFxuICBDQVBUSU9OOiBcImNcIixcbiAgVElNRURfVEVYVDogXCJ0dFwiLFxuICBLRVk6IFwia1wiLFxuICBPVEhFUjogXCJvXCJcbn07XG5cbi8qKlxuICogQ01DRCBTdHJlYW1pbmcgRm9ybWF0XG4gKi9cbmNvbnN0IENNQ0RTdHJlYW1pbmdGb3JtYXRITFMgPSAnaCc7XG5cbi8qKlxuICogQ01DRCBTdHJlYW1pbmcgVHlwZVxuICovXG5cbi8qKlxuICogQ01DRCBIZWFkZXJzXG4gKi9cblxuLyoqXG4gKiBDTUNEXG4gKi9cblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBDb21tb24gTWVkaWEgQ2xpZW50IERhdGEgKENNQ0QpXG4gKiBAc2VlIGh0dHBzOi8vY2RuLmN0YS50ZWNoL2N0YS9tZWRpYS9tZWRpYS9yZXNvdXJjZXMvc3RhbmRhcmRzL3BkZnMvY3RhLTUwMDQtZmluYWwucGRmXG4gKi9cbmNsYXNzIENNQ0RDb250cm9sbGVyIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gdm9pZCAwO1xuICAgIHRoaXMuc2lkID0gdm9pZCAwO1xuICAgIHRoaXMuY2lkID0gdm9pZCAwO1xuICAgIHRoaXMudXNlSGVhZGVycyA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHRydWU7XG4gICAgdGhpcy5hdWRpb0J1ZmZlciA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gdm9pZCAwO1xuICAgIHRoaXMub25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5zdGFydmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMub25QbGF5aW5nID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIG1hbmlmZXN0IHJlcXVlc3QuXG4gICAgICovXG4gICAgdGhpcy5hcHBseVBsYXlsaXN0RGF0YSA9IGNvbnRleHQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5hcHBseShjb250ZXh0LCB7XG4gICAgICAgICAgb3Q6IENNQ0RPYmplY3RUeXBlLk1BTklGRVNULFxuICAgICAgICAgIHN1OiAhdGhpcy5pbml0aWFsaXplZFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgbWFuaWZlc3QgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIHNlZ21lbnQgcmVxdWVzdFxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlGcmFnbWVudERhdGEgPSBjb250ZXh0ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udGV4dC5mcmFnO1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnbWVudC5sZXZlbF07XG4gICAgICAgIGNvbnN0IG90ID0gdGhpcy5nZXRPYmplY3RUeXBlKGZyYWdtZW50KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICBkOiBmcmFnbWVudC5kdXJhdGlvbiAqIDEwMDAsXG4gICAgICAgICAgb3RcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG90ID09PSBDTUNET2JqZWN0VHlwZS5WSURFTyB8fCBvdCA9PT0gQ01DRE9iamVjdFR5cGUuQVVESU8gfHwgb3QgPT0gQ01DRE9iamVjdFR5cGUuTVVYRUQpIHtcbiAgICAgICAgICBkYXRhLmJyID0gbGV2ZWwuYml0cmF0ZSAvIDEwMDA7XG4gICAgICAgICAgZGF0YS50YiA9IHRoaXMuZ2V0VG9wQmFuZHdpZHRoKG90KSAvIDEwMDA7XG4gICAgICAgICAgZGF0YS5ibCA9IHRoaXMuZ2V0QnVmZmVyTGVuZ3RoKG90KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0NvdWxkIG5vdCBnZW5lcmF0ZSBzZWdtZW50IENNQ0QgZGF0YS4nLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgY29uc3Qge1xuICAgICAgY21jZFxuICAgIH0gPSBjb25maWc7XG4gICAgaWYgKGNtY2QgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLnBMb2FkZXIgPSB0aGlzLmNyZWF0ZVBsYXlsaXN0TG9hZGVyKCk7XG4gICAgICBjb25maWcuZkxvYWRlciA9IHRoaXMuY3JlYXRlRnJhZ21lbnRMb2FkZXIoKTtcbiAgICAgIHRoaXMuc2lkID0gY21jZC5zZXNzaW9uSWQgfHwgQ01DRENvbnRyb2xsZXIudXVpZCgpO1xuICAgICAgdGhpcy5jaWQgPSBjbWNkLmNvbnRlbnRJZDtcbiAgICAgIHRoaXMudXNlSGVhZGVycyA9IGNtY2QudXNlSGVhZGVycyA9PT0gdHJ1ZTtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGVkKCk7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IHRoaXMuYXVkaW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XG4gICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vblBsYXlpbmcpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgdGhpcy5vbldhaXRpbmcpO1xuICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub25QbGF5aW5nKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkdHJhY2tzJGF1ZGlvLCBfZGF0YSR0cmFja3MkdmlkZW87XG4gICAgdGhpcy5hdWRpb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkYXVkaW8gPSBkYXRhLnRyYWNrcy5hdWRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHRyYWNrcyRhdWRpby5idWZmZXI7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkdmlkZW8gPSBkYXRhLnRyYWNrcy52aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHRyYWNrcyR2aWRlby5idWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBiYXNlbGluZSBDTUNEIGRhdGFcbiAgICovXG4gIGNyZWF0ZURhdGEoKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhO1xuICAgIHJldHVybiB7XG4gICAgICB2OiBDTUNEVmVyc2lvbixcbiAgICAgIHNmOiBDTUNEU3RyZWFtaW5nRm9ybWF0SExTLFxuICAgICAgc2lkOiB0aGlzLnNpZCxcbiAgICAgIGNpZDogdGhpcy5jaWQsXG4gICAgICBwcjogKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLnBsYXliYWNrUmF0ZSxcbiAgICAgIG10cDogdGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGUgLyAxMDAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBDTUNEIGRhdGEgdG8gYSByZXF1ZXN0LlxuICAgKi9cbiAgYXBwbHkoY29udGV4dCwgZGF0YSA9IHt9KSB7XG4gICAgLy8gYXBwbHkgYmFzZWxpbmUgZGF0YVxuICAgIF9leHRlbmRzKGRhdGEsIHRoaXMuY3JlYXRlRGF0YSgpKTtcbiAgICBjb25zdCBpc1ZpZGVvID0gZGF0YS5vdCA9PT0gQ01DRE9iamVjdFR5cGUuSU5JVCB8fCBkYXRhLm90ID09PSBDTUNET2JqZWN0VHlwZS5WSURFTyB8fCBkYXRhLm90ID09PSBDTUNET2JqZWN0VHlwZS5NVVhFRDtcbiAgICBpZiAodGhpcy5zdGFydmVkICYmIGlzVmlkZW8pIHtcbiAgICAgIGRhdGEuYnMgPSB0cnVlO1xuICAgICAgZGF0YS5zdSA9IHRydWU7XG4gICAgICB0aGlzLnN0YXJ2ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3UgPT0gbnVsbCkge1xuICAgICAgZGF0YS5zdSA9IHRoaXMuYnVmZmVyaW5nO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEltcGxlbWVudCBydHAsIG5yciwgbm9yLCBkbFxuXG4gICAgaWYgKHRoaXMudXNlSGVhZGVycykge1xuICAgICAgY29uc3QgaGVhZGVycyA9IENNQ0RDb250cm9sbGVyLnRvSGVhZGVycyhkYXRhKTtcbiAgICAgIGlmICghT2JqZWN0LmtleXMoaGVhZGVycykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY29udGV4dC5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnRleHQuaGVhZGVycyA9IHt9O1xuICAgICAgfVxuICAgICAgX2V4dGVuZHMoY29udGV4dC5oZWFkZXJzLCBoZWFkZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcXVlcnkgPSBDTUNEQ29udHJvbGxlci50b1F1ZXJ5KGRhdGEpO1xuICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250ZXh0LnVybCA9IENNQ0RDb250cm9sbGVyLmFwcGVuZFF1ZXJ5VG9VcmkoY29udGV4dC51cmwsIHF1ZXJ5KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBDTUNEIG9iamVjdCB0eXBlLlxuICAgKi9cbiAgZ2V0T2JqZWN0VHlwZShmcmFnbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gZnJhZ21lbnQ7XG4gICAgaWYgKHR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIHJldHVybiBDTUNET2JqZWN0VHlwZS5USU1FRF9URVhUO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybiBDTUNET2JqZWN0VHlwZS5JTklUO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIENNQ0RPYmplY3RUeXBlLkFVRElPO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBpZiAoIXRoaXMuaGxzLmF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gQ01DRE9iamVjdFR5cGUuTVVYRUQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ01DRE9iamVjdFR5cGUuVklERU87XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBoaWdoZXN0IGJpdHJhdGUuXG4gICAqL1xuICBnZXRUb3BCYW5kd2lkdGgodHlwZSkge1xuICAgIGxldCBiaXRyYXRlID0gMDtcbiAgICBsZXQgbGV2ZWxzO1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICh0eXBlID09PSBDTUNET2JqZWN0VHlwZS5BVURJTykge1xuICAgICAgbGV2ZWxzID0gaGxzLmF1ZGlvVHJhY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXggPSBobHMubWF4QXV0b0xldmVsO1xuICAgICAgY29uc3QgbGVuID0gbWF4ID4gLTEgPyBtYXggKyAxIDogaGxzLmxldmVscy5sZW5ndGg7XG4gICAgICBsZXZlbHMgPSBobHMubGV2ZWxzLnNsaWNlKDAsIGxlbik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGV2ZWwgb2YgbGV2ZWxzKSB7XG4gICAgICBpZiAobGV2ZWwuYml0cmF0ZSA+IGJpdHJhdGUpIHtcbiAgICAgICAgYml0cmF0ZSA9IGxldmVsLmJpdHJhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaXRyYXRlID4gMCA/IGJpdHJhdGUgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgbGVuZ3RoIGZvciBhIG1lZGlhIHR5cGUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBnZXRCdWZmZXJMZW5ndGgodHlwZSkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5obHMubWVkaWE7XG4gICAgY29uc3QgYnVmZmVyID0gdHlwZSA9PT0gQ01DRE9iamVjdFR5cGUuQVVESU8gPyB0aGlzLmF1ZGlvQnVmZmVyIDogdGhpcy52aWRlb0J1ZmZlcjtcbiAgICBpZiAoIWJ1ZmZlciB8fCAhbWVkaWEpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IGluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXIsIG1lZGlhLmN1cnJlbnRUaW1lLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICByZXR1cm4gaW5mby5sZW4gKiAxMDAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBsYXlsaXN0IGxvYWRlclxuICAgKi9cbiAgY3JlYXRlUGxheWxpc3RMb2FkZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcExvYWRlclxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBhcHBseSA9IHRoaXMuYXBwbHlQbGF5bGlzdERhdGE7XG4gICAgY29uc3QgQ3RvciA9IHBMb2FkZXIgfHwgdGhpcy5jb25maWcubG9hZGVyO1xuICAgIHJldHVybiBjbGFzcyBDbWNkUGxheWxpc3RMb2FkZXIge1xuICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubG9hZGVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBDdG9yKGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBnZXQgc3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5zdGF0cztcbiAgICAgIH1cbiAgICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGFib3J0KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgICBhcHBseShjb250ZXh0KTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICovXG4gIGNyZWF0ZUZyYWdtZW50TG9hZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZMb2FkZXJcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgYXBwbHkgPSB0aGlzLmFwcGx5RnJhZ21lbnREYXRhO1xuICAgIGNvbnN0IEN0b3IgPSBmTG9hZGVyIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gY2xhc3MgQ21jZEZyYWdtZW50TG9hZGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmxvYWRlciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgQ3Rvcihjb25maWcpO1xuICAgICAgfVxuICAgICAgZ2V0IHN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuc3RhdHM7XG4gICAgICB9XG4gICAgICBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmNvbnRleHQ7XG4gICAgICB9XG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICAgICAgYXBwbHkoY29udGV4dCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSByYW5kb20gdjQgVVVJXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgdXVpZCgpIHtcbiAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKCkpO1xuICAgIGNvbnN0IHV1aWQgPSB1cmwudG9TdHJpbmcoKTtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgcmV0dXJuIHV1aWQuc2xpY2UodXVpZC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIGEgQ01DRCBkYXRhIG9iamVjdCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlZmluZWQgaW4gdGhlXG4gICAqIHNlY3Rpb24gMy4yIG9mXG4gICAqIFtDVEEtNTAwNF0oaHR0cHM6Ly9jZG4uY3RhLnRlY2gvY3RhL21lZGlhL21lZGlhL3Jlc291cmNlcy9zdGFuZGFyZHMvcGRmcy9jdGEtNTAwNC1maW5hbC5wZGYpLlxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZShkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IGlzVmFsaWQgPSB2YWx1ZSA9PiAhTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJyAmJiB2YWx1ZSAhPT0gZmFsc2U7XG4gICAgY29uc3QgdG9Sb3VuZGVkID0gdmFsdWUgPT4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgY29uc3QgdG9IdW5kcmVkID0gdmFsdWUgPT4gdG9Sb3VuZGVkKHZhbHVlIC8gMTAwKSAqIDEwMDtcbiAgICBjb25zdCB0b1VybFNhZmUgPSB2YWx1ZSA9PiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIGNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gICAgICBicjogdG9Sb3VuZGVkLFxuICAgICAgZDogdG9Sb3VuZGVkLFxuICAgICAgYmw6IHRvSHVuZHJlZCxcbiAgICAgIGRsOiB0b0h1bmRyZWQsXG4gICAgICBtdHA6IHRvSHVuZHJlZCxcbiAgICAgIG5vcjogdG9VcmxTYWZlLFxuICAgICAgcnRwOiB0b0h1bmRyZWQsXG4gICAgICB0YjogdG9Sb3VuZGVkXG4gICAgfTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSB8fCB7fSkuc29ydCgpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCB2YWx1ZSA9IGRhdGFba2V5XTtcblxuICAgICAgLy8gaWdub3JlIGludmFsaWQgdmFsdWVzXG4gICAgICBpZiAoIWlzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJzaW9uIHNob3VsZCBvbmx5IGJlIHJlcG9ydGVkIGlmIG5vdCBlcXVhbCB0byAxLlxuICAgICAgaWYgKGtleSA9PT0gJ3YnICYmIHZhbHVlID09PSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBQbGF5YmFjayByYXRlIHNob3VsZCBvbmx5IGJlIHNlbnQgaWYgbm90IGVxdWFsIHRvIDEuXG4gICAgICBpZiAoa2V5ID09ICdwcicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENlcnRhaW4gdmFsdWVzIHJlcXVpcmUgc3BlY2lhbCBmb3JtYXR0aW5nXG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBmb3JtYXR0ZXJzW2tleV07XG4gICAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVyKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VyaWFsaXplIHRoZSBrZXkvdmFsdWUgcGFpclxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBpZiAoa2V5ID09PSAnb3QnIHx8IGtleSA9PT0gJ3NmJyB8fCBrZXkgPT09ICdzdCcpIHtcbiAgICAgICAgcmVzdWx0ID0gYCR7a2V5fT0ke3ZhbHVlfWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCA9IGAke2tleX09JHt2YWx1ZX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYCR7a2V5fT0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuICAgICAgfVxuICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzLmpvaW4oJywnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgQ01DRCBkYXRhIG9iamVjdCB0byByZXF1ZXN0IGhlYWRlcnMgYWNjb3JkaW5nIHRvIHRoZSBydWxlc1xuICAgKiBkZWZpbmVkIGluIHRoZSBzZWN0aW9uIDIuMSBhbmQgMy4yIG9mXG4gICAqIFtDVEEtNTAwNF0oaHR0cHM6Ly9jZG4uY3RhLnRlY2gvY3RhL21lZGlhL21lZGlhL3Jlc291cmNlcy9zdGFuZGFyZHMvcGRmcy9jdGEtNTAwNC1maW5hbC5wZGYpLlxuICAgKi9cbiAgc3RhdGljIHRvSGVhZGVycyhkYXRhKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBjb25zdCBoZWFkZXJOYW1lcyA9IFsnT2JqZWN0JywgJ1JlcXVlc3QnLCAnU2Vzc2lvbicsICdTdGF0dXMnXTtcbiAgICBjb25zdCBoZWFkZXJHcm91cHMgPSBbe30sIHt9LCB7fSwge31dO1xuICAgIGNvbnN0IGhlYWRlck1hcCA9IHtcbiAgICAgIGJyOiAwLFxuICAgICAgZDogMCxcbiAgICAgIG90OiAwLFxuICAgICAgdGI6IDAsXG4gICAgICBibDogMSxcbiAgICAgIGRsOiAxLFxuICAgICAgbXRwOiAxLFxuICAgICAgbm9yOiAxLFxuICAgICAgbnJyOiAxLFxuICAgICAgc3U6IDEsXG4gICAgICBjaWQ6IDIsXG4gICAgICBwcjogMixcbiAgICAgIHNmOiAyLFxuICAgICAgc2lkOiAyLFxuICAgICAgc3Q6IDIsXG4gICAgICB2OiAyLFxuICAgICAgYnM6IDMsXG4gICAgICBydHA6IDNcbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIC8vIFVubWFwcGVkIGZpZWxkcyBhcmUgbWFwcGVkIHRvIHRoZSBSZXF1ZXN0IGhlYWRlclxuICAgICAgY29uc3QgaW5kZXggPSBoZWFkZXJNYXBba2V5XSAhPSBudWxsID8gaGVhZGVyTWFwW2tleV0gOiAxO1xuICAgICAgaGVhZGVyR3JvdXBzW2luZGV4XVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBDTUNEQ29udHJvbGxlci5zZXJpYWxpemUoaGVhZGVyR3JvdXBzW2ldKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBoZWFkZXJzW2BDTUNELSR7aGVhZGVyTmFtZXNbaV19YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gcXVlcnkgYXJncyBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzXG4gICAqIGRlZmluZWQgaW4gdGhlIHNlY3Rpb24gMi4yIGFuZCAzLjIgb2ZcbiAgICogW0NUQS01MDA0XShodHRwczovL2Nkbi5jdGEudGVjaC9jdGEvbWVkaWEvbWVkaWEvcmVzb3VyY2VzL3N0YW5kYXJkcy9wZGZzL2N0YS01MDA0LWZpbmFsLnBkZikuXG4gICAqL1xuICBzdGF0aWMgdG9RdWVyeShkYXRhKSB7XG4gICAgcmV0dXJuIGBDTUNEPSR7ZW5jb2RlVVJJQ29tcG9uZW50KENNQ0RDb250cm9sbGVyLnNlcmlhbGl6ZShkYXRhKSl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgcXVlcnkgYXJncyB0byBhIHVyaS5cbiAgICovXG4gIHN0YXRpYyBhcHBlbmRRdWVyeVRvVXJpKHVyaSwgcXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdXJpO1xuICAgIH1cbiAgICBjb25zdCBzZXBhcmF0b3IgPSB1cmkuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JztcbiAgICByZXR1cm4gYCR7dXJpfSR7c2VwYXJhdG9yfSR7cXVlcnl9YDtcbiAgfVxufVxuXG5jb25zdCBQQVRIV0FZX1BFTkFMVFlfRFVSQVRJT05fTVMgPSAzMDAwMDA7XG5jbGFzcyBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMudXJpID0gbnVsbDtcbiAgICB0aGlzLnBhdGh3YXlJZCA9ICcuJztcbiAgICB0aGlzLnBhdGh3YXlQcmlvcml0eSA9IG51bGw7XG4gICAgdGhpcy50aW1lVG9Mb2FkID0gMzAwO1xuICAgIHRoaXMucmVsb2FkVGltZXIgPSAtMTtcbiAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5sZXZlbHMgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBudWxsO1xuICAgIHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICAgIHRoaXMucGVuYWxpemVkUGF0aHdheXMgPSB7fTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGBbY29udGVudC1zdGVlcmluZ106YCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZWxvYWRUaW1lcik7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLnVyaSkge1xuICAgICAgaWYgKHRoaXMudXBkYXRlZCkge1xuICAgICAgICBjb25zdCB0dGwgPSBNYXRoLm1heCh0aGlzLnRpbWVUb0xvYWQgKiAxMDAwIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy51cGRhdGVkKSwgMCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpLCB0dGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2FkU3RlZXJpbmdNYW5pZmVzdCh0aGlzLnVyaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFRpbWVyKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICB9XG4gIHJlbW92ZUxldmVsKGxldmVsVG9SZW1vdmUpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICBpZiAobGV2ZWxzKSB7XG4gICAgICB0aGlzLmxldmVscyA9IGxldmVscy5maWx0ZXIobGV2ZWwgPT4gbGV2ZWwgIT09IGxldmVsVG9SZW1vdmUpO1xuICAgIH1cbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRpbWVUb0xvYWQgPSAzMDA7XG4gICAgdGhpcy51cGRhdGVkID0gMDtcbiAgICB0aGlzLnVyaSA9IG51bGw7XG4gICAgdGhpcy5wYXRod2F5SWQgPSAnLic7XG4gICAgdGhpcy5sZXZlbHMgPSB0aGlzLmF1ZGlvVHJhY2tzID0gdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRlbnRTdGVlcmluZ1xuICAgIH0gPSBkYXRhO1xuICAgIGlmIChjb250ZW50U3RlZXJpbmcgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXRod2F5SWQgPSBjb250ZW50U3RlZXJpbmcucGF0aHdheUlkO1xuICAgIHRoaXMudXJpID0gY29udGVudFN0ZWVyaW5nLnVyaTtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZCgpO1xuICAgIH1cbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVycm9yQWN0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKChlcnJvckFjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JBY3Rpb24uYWN0aW9uKSA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3ggJiYgZXJyb3JBY3Rpb24uZmxhZ3MgPT09IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3QpIHtcbiAgICAgIGxldCBwYXRod2F5UHJpb3JpdHkgPSB0aGlzLnBhdGh3YXlQcmlvcml0eTtcbiAgICAgIGNvbnN0IHBhdGh3YXlJZCA9IHRoaXMucGF0aHdheUlkO1xuICAgICAgaWYgKCF0aGlzLnBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF0pIHtcbiAgICAgICAgdGhpcy5wZW5hbGl6ZWRQYXRod2F5c1twYXRod2F5SWRdID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9XG4gICAgICBpZiAoIXBhdGh3YXlQcmlvcml0eSAmJiB0aGlzLmxldmVscykge1xuICAgICAgICAvLyBJZiBQQVRIV0FZLVBSSU9SSVRZIHdhcyBub3QgcHJvdmlkZWQsIGxpc3QgcGF0aHdheXMgZm9yIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIHBhdGh3YXlQcmlvcml0eSA9IHRoaXMubGV2ZWxzLnJlZHVjZSgocGF0aHdheXMsIGxldmVsKSA9PiB7XG4gICAgICAgICAgaWYgKHBhdGh3YXlzLmluZGV4T2YobGV2ZWwucGF0aHdheUlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHBhdGh3YXlzLnB1c2gobGV2ZWwucGF0aHdheUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhdGh3YXlzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICB9XG4gICAgICBpZiAocGF0aHdheVByaW9yaXR5ICYmIHBhdGh3YXlQcmlvcml0eS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSk7XG4gICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdGhpcy5wYXRod2F5SWQgIT09IHBhdGh3YXlJZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmlsdGVyUGFyc2VkTGV2ZWxzKGxldmVscykge1xuICAgIC8vIEZpbHRlciBsZXZlbHMgdG8gb25seSBpbmNsdWRlIHRob3NlIHRoYXQgYXJlIGluIHRoZSBpbml0aWFsIHBhdGh3YXlcbiAgICB0aGlzLmxldmVscyA9IGxldmVscztcbiAgICBsZXQgcGF0aHdheUxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheSh0aGlzLnBhdGh3YXlJZCk7XG4gICAgaWYgKHBhdGh3YXlMZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBwYXRod2F5SWQgPSBsZXZlbHNbMF0ucGF0aHdheUlkO1xuICAgICAgdGhpcy5sb2coYE5vIGxldmVscyBmb3VuZCBpbiBQYXRod2F5ICR7dGhpcy5wYXRod2F5SWR9LiBTZXR0aW5nIGluaXRpYWwgUGF0aHdheSB0byBcIiR7cGF0aHdheUlkfVwiYCk7XG4gICAgICBwYXRod2F5TGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHBhdGh3YXlJZCk7XG4gICAgICB0aGlzLnBhdGh3YXlJZCA9IHBhdGh3YXlJZDtcbiAgICB9XG4gICAgaWYgKHBhdGh3YXlMZXZlbHMubGVuZ3RoICE9PSBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZyhgRm91bmQgJHtwYXRod2F5TGV2ZWxzLmxlbmd0aH0vJHtsZXZlbHMubGVuZ3RofSBsZXZlbHMgaW4gUGF0aHdheSBcIiR7dGhpcy5wYXRod2F5SWR9XCJgKTtcbiAgICAgIHJldHVybiBwYXRod2F5TGV2ZWxzO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxzO1xuICB9XG4gIGdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxldmVscy5maWx0ZXIobGV2ZWwgPT4gcGF0aHdheUlkID09PSBsZXZlbC5wYXRod2F5SWQpO1xuICB9XG4gIHVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpIHtcbiAgICB0aGlzLnBhdGh3YXlQcmlvcml0eSA9IHBhdGh3YXlQcmlvcml0eTtcbiAgICBsZXQgbGV2ZWxzO1xuXG4gICAgLy8gRXZhbHVhdGUgaWYgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcGF0aHdheSBmcm9tIHRoZSBwZW5hbGl6ZWQgbGlzdFxuICAgIGNvbnN0IHBlbmFsaXplZFBhdGh3YXlzID0gdGhpcy5wZW5hbGl6ZWRQYXRod2F5cztcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBPYmplY3Qua2V5cyhwZW5hbGl6ZWRQYXRod2F5cykuZm9yRWFjaChwYXRod2F5SWQgPT4ge1xuICAgICAgaWYgKG5vdyAtIHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF0gPiBQQVRIV0FZX1BFTkFMVFlfRFVSQVRJT05fTVMpIHtcbiAgICAgICAgZGVsZXRlIHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRod2F5UHJpb3JpdHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhdGh3YXlJZCA9IHBhdGh3YXlQcmlvcml0eVtpXTtcbiAgICAgIGlmIChwZW5hbGl6ZWRQYXRod2F5c1twYXRod2F5SWRdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGh3YXlJZCA9PT0gdGhpcy5wYXRod2F5SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWw7XG4gICAgICBjb25zdCBzZWxlY3RlZExldmVsID0gdGhpcy5obHMubGV2ZWxzW3NlbGVjdGVkSW5kZXhdO1xuICAgICAgbGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHBhdGh3YXlJZCk7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5sb2coYFNldHRpbmcgUGF0aHdheSB0byBcIiR7cGF0aHdheUlkfVwiYCk7XG4gICAgICAgIHRoaXMucGF0aHdheUlkID0gcGF0aHdheUlkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwge1xuICAgICAgICAgIGxldmVsc1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IExldmVsQ29udHJvbGxlcidzIGxldmVsIHRvIHRyaWdnZXIgTEVWRUxfU1dJVENISU5HIHdoaWNoIGxvYWRzIHBsYXlsaXN0IGlmIG5lZWRlZFxuICAgICAgICBjb25zdCBsZXZlbEFmdGVyQ2hhbmdlID0gdGhpcy5obHMubGV2ZWxzW3NlbGVjdGVkSW5kZXhdO1xuICAgICAgICBpZiAoc2VsZWN0ZWRMZXZlbCAmJiBsZXZlbEFmdGVyQ2hhbmdlICYmIHRoaXMubGV2ZWxzKSB7XG4gICAgICAgICAgaWYgKGxldmVsQWZ0ZXJDaGFuZ2UuYXR0cnNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10gIT09IHNlbGVjdGVkTGV2ZWwuYXR0cnNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10gJiYgbGV2ZWxBZnRlckNoYW5nZS5iaXRyYXRlICE9PSBzZWxlY3RlZExldmVsLmJpdHJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBVbnN0YWJsZSBQYXRod2F5cyBjaGFuZ2UgZnJvbSBiaXRyYXRlICR7c2VsZWN0ZWRMZXZlbC5iaXRyYXRlfSB0byAke2xldmVsQWZ0ZXJDaGFuZ2UuYml0cmF0ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsb25lUGF0aHdheXMocGF0aHdheUNsb25lcykge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvR3JvdXBDbG9uZU1hcCA9IHt9O1xuICAgIGNvbnN0IHN1YnRpdGxlR3JvdXBDbG9uZU1hcCA9IHt9O1xuICAgIHBhdGh3YXlDbG9uZXMuZm9yRWFjaChwYXRod2F5Q2xvbmUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBJRDogY2xvbmVJZCxcbiAgICAgICAgJ0JBU0UtSUQnOiBiYXNlSWQsXG4gICAgICAgICdVUkktUkVQTEFDRU1FTlQnOiB1cmlSZXBsYWNlbWVudFxuICAgICAgfSA9IHBhdGh3YXlDbG9uZTtcbiAgICAgIGlmIChsZXZlbHMuc29tZShsZXZlbCA9PiBsZXZlbC5wYXRod2F5SWQgPT09IGNsb25lSWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsb25lZFZhcmlhbnRzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KGJhc2VJZCkubWFwKGJhc2VMZXZlbCA9PiB7XG4gICAgICAgIGNvbnN0IGxldmVsUGFyc2VkID0gX2V4dGVuZHMoe30sIGJhc2VMZXZlbCk7XG4gICAgICAgIGxldmVsUGFyc2VkLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldmVsUGFyc2VkLnVybCA9IHBlcmZvcm1VcmlSZXBsYWNlbWVudChiYXNlTGV2ZWwudXJpLCBiYXNlTGV2ZWwuYXR0cnNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10sICdQRVItVkFSSUFOVC1VUklTJywgdXJpUmVwbGFjZW1lbnQpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGJhc2VMZXZlbC5hdHRycyk7XG4gICAgICAgIGF0dHJpYnV0ZXNbJ1BBVEhXQVktSUQnXSA9IGNsb25lSWQ7XG4gICAgICAgIGNvbnN0IGNsb25lZEF1ZGlvR3JvdXBJZCA9IGF0dHJpYnV0ZXMuQVVESU8gJiYgYCR7YXR0cmlidXRlcy5BVURJT31fY2xvbmVfJHtjbG9uZUlkfWA7XG4gICAgICAgIGNvbnN0IGNsb25lZFN1YnRpdGxlR3JvdXBJZCA9IGF0dHJpYnV0ZXMuU1VCVElUTEVTICYmIGAke2F0dHJpYnV0ZXMuU1VCVElUTEVTfV9jbG9uZV8ke2Nsb25lSWR9YDtcbiAgICAgICAgaWYgKGNsb25lZEF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgIGF1ZGlvR3JvdXBDbG9uZU1hcFthdHRyaWJ1dGVzLkFVRElPXSA9IGNsb25lZEF1ZGlvR3JvdXBJZDtcbiAgICAgICAgICBhdHRyaWJ1dGVzLkFVRElPID0gY2xvbmVkQXVkaW9Hcm91cElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9uZWRTdWJ0aXRsZUdyb3VwSWQpIHtcbiAgICAgICAgICBzdWJ0aXRsZUdyb3VwQ2xvbmVNYXBbYXR0cmlidXRlcy5TVUJUSVRMRVNdID0gY2xvbmVkU3VidGl0bGVHcm91cElkO1xuICAgICAgICAgIGF0dHJpYnV0ZXMuU1VCVElUTEVTID0gY2xvbmVkU3VidGl0bGVHcm91cElkO1xuICAgICAgICB9XG4gICAgICAgIGxldmVsUGFyc2VkLmF0dHJzID0gYXR0cmlidXRlcztcbiAgICAgICAgY29uc3QgY2xvbmVkTGV2ZWwgPSBuZXcgTGV2ZWwobGV2ZWxQYXJzZWQpO1xuICAgICAgICBhZGRHcm91cElkKGNsb25lZExldmVsLCAnYXVkaW8nLCBjbG9uZWRBdWRpb0dyb3VwSWQpO1xuICAgICAgICBhZGRHcm91cElkKGNsb25lZExldmVsLCAndGV4dCcsIGNsb25lZFN1YnRpdGxlR3JvdXBJZCk7XG4gICAgICAgIHJldHVybiBjbG9uZWRMZXZlbDtcbiAgICAgIH0pO1xuICAgICAgbGV2ZWxzLnB1c2goLi4uY2xvbmVkVmFyaWFudHMpO1xuICAgICAgY2xvbmVSZW5kaXRpb25Hcm91cHModGhpcy5hdWRpb1RyYWNrcywgYXVkaW9Hcm91cENsb25lTWFwLCB1cmlSZXBsYWNlbWVudCwgY2xvbmVJZCk7XG4gICAgICBjbG9uZVJlbmRpdGlvbkdyb3Vwcyh0aGlzLnN1YnRpdGxlVHJhY2tzLCBzdWJ0aXRsZUdyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkU3RlZXJpbmdNYW5pZmVzdCh1cmkpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5sb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZyk7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2coYEZhaWxlZCB0byBwYXJzZSBTdGVlcmluZyBNYW5pZmVzdCBVUkk6ICR7dXJpfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodXJsLnByb3RvY29sICE9PSAnZGF0YTonKSB7XG4gICAgICBjb25zdCB0aHJvdWdocHV0ID0gKHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlIHx8IGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKSB8IDA7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXRod2F5JywgdGhpcy5wYXRod2F5SWQpO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfdGhyb3VnaHB1dCcsICcnICsgdGhyb3VnaHB1dCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIHVybDogdXJsLmhyZWZcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRQb2xpY3kgPSBjb25maWcuc3RlZXJpbmdNYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICBjb25zdCBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkgPSBsb2FkUG9saWN5LmVycm9yUmV0cnkgfHwgbG9hZFBvbGljeS50aW1lb3V0UmV0cnkgfHwge307XG4gICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgbG9hZFBvbGljeSxcbiAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgIG1heFJldHJ5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkubWF4TnVtUmV0cnkgfHwgMCxcbiAgICAgIHJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5yZXRyeURlbGF5TXMgfHwgMCxcbiAgICAgIG1heFJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhSZXRyeURlbGF5TXMgfHwgMFxuICAgIH07XG4gICAgY29uc3QgY2FsbGJhY2tzID0ge1xuICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgTG9hZGVkIHN0ZWVyaW5nIG1hbmlmZXN0OiBcIiR7dXJsfVwiYCk7XG4gICAgICAgIGNvbnN0IHN0ZWVyaW5nRGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChzdGVlcmluZ0RhdGEuVkVSU0lPTiAhPT0gMSkge1xuICAgICAgICAgIHRoaXMubG9nKGBTdGVlcmluZyBWRVJTSU9OICR7c3RlZXJpbmdEYXRhLlZFUlNJT059IG5vdCBzdXBwb3J0ZWQhYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnRpbWVUb0xvYWQgPSBzdGVlcmluZ0RhdGEuVFRMO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJ1JFTE9BRC1VUkknOiByZWxvYWRVcmksXG4gICAgICAgICAgJ1BBVEhXQVktQ0xPTkVTJzogcGF0aHdheUNsb25lcyxcbiAgICAgICAgICAnUEFUSFdBWS1QUklPUklUWSc6IHBhdGh3YXlQcmlvcml0eVxuICAgICAgICB9ID0gc3RlZXJpbmdEYXRhO1xuICAgICAgICBpZiAocmVsb2FkVXJpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXJpID0gbmV3IHNlbGYuVVJMKHJlbG9hZFVyaSwgdXJsKS5ocmVmO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBGYWlsZWQgdG8gcGFyc2UgU3RlZXJpbmcgTWFuaWZlc3QgUkVMT0FELVVSSTogJHtyZWxvYWRVcml9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpIHx8IGNvbnRleHQudXJsKTtcbiAgICAgICAgaWYgKHBhdGh3YXlDbG9uZXMpIHtcbiAgICAgICAgICB0aGlzLmNsb25lUGF0aHdheXMocGF0aHdheUNsb25lcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGh3YXlQcmlvcml0eSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoZXJyb3IsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgRXJyb3IgbG9hZGluZyBzdGVlcmluZyBtYW5pZmVzdDogJHtlcnJvci5jb2RlfSAke2Vycm9yLnRleHR9ICgke2NvbnRleHQudXJsfSlgKTtcbiAgICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDEwKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIG1hbmlmZXN0ICR7Y29udGV4dC51cmx9IG5vIGxvbmdlciBhdmFpbGFibGVgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR0bCA9IHRoaXMudGltZVRvTG9hZCAqIDEwMDA7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0MjkpIHtcbiAgICAgICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICAgICAgICBpZiAodHlwZW9mIChsb2FkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvYWRlci5nZXRSZXNwb25zZUhlYWRlcikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSBsb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1JldHJ5LUFmdGVyJyk7XG4gICAgICAgICAgICBpZiAocmV0cnlBZnRlcikge1xuICAgICAgICAgICAgICB0dGwgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXIpICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIG1hbmlmZXN0ICR7Y29udGV4dC51cmx9IHJhdGUgbGltaXRlZGApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSB8fCBjb250ZXh0LnVybCwgdHRsKTtcbiAgICAgIH0sXG4gICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgdGhpcy5sb2coYFRpbWVvdXQgbG9hZGluZyBzdGVlcmluZyBtYW5pZmVzdCAoJHtjb250ZXh0LnVybH0pYCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpIHx8IGNvbnRleHQudXJsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nKGBSZXF1ZXN0aW5nIHN0ZWVyaW5nIG1hbmlmZXN0OiAke3VybH1gKTtcbiAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgY2FsbGJhY2tzKTtcbiAgfVxuICBzY2hlZHVsZVJlZnJlc2godXJpLCB0dGxNcyA9IHRoaXMudGltZVRvTG9hZCAqIDEwMDApIHtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFRpbWVyKTtcbiAgICB0aGlzLnJlbG9hZFRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMubG9hZFN0ZWVyaW5nTWFuaWZlc3QodXJpKTtcbiAgICB9LCB0dGxNcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lUmVuZGl0aW9uR3JvdXBzKHRyYWNrcywgZ3JvdXBDbG9uZU1hcCwgdXJpUmVwbGFjZW1lbnQsIGNsb25lSWQpIHtcbiAgaWYgKCF0cmFja3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmtleXMoZ3JvdXBDbG9uZU1hcCkuZm9yRWFjaChhdWRpb0dyb3VwSWQgPT4ge1xuICAgIGNvbnN0IGNsb25lZFRyYWNrcyA9IHRyYWNrcy5maWx0ZXIodHJhY2sgPT4gdHJhY2suZ3JvdXBJZCA9PT0gYXVkaW9Hcm91cElkKS5tYXAodHJhY2sgPT4ge1xuICAgICAgY29uc3QgY2xvbmVkVHJhY2sgPSBfZXh0ZW5kcyh7fSwgdHJhY2spO1xuICAgICAgY2xvbmVkVHJhY2suZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgIGNsb25lZFRyYWNrLmF0dHJzID0gbmV3IEF0dHJMaXN0KGNsb25lZFRyYWNrLmF0dHJzKTtcbiAgICAgIGNsb25lZFRyYWNrLnVybCA9IGNsb25lZFRyYWNrLmF0dHJzLlVSSSA9IHBlcmZvcm1VcmlSZXBsYWNlbWVudCh0cmFjay51cmwsIHRyYWNrLmF0dHJzWydTVEFCTEUtUkVORElUSU9OLUlEJ10sICdQRVItUkVORElUSU9OLVVSSVMnLCB1cmlSZXBsYWNlbWVudCk7XG4gICAgICBjbG9uZWRUcmFjay5ncm91cElkID0gY2xvbmVkVHJhY2suYXR0cnNbJ0dST1VQLUlEJ10gPSBncm91cENsb25lTWFwW2F1ZGlvR3JvdXBJZF07XG4gICAgICBjbG9uZWRUcmFjay5hdHRyc1snUEFUSFdBWS1JRCddID0gY2xvbmVJZDtcbiAgICAgIHJldHVybiBjbG9uZWRUcmFjaztcbiAgICB9KTtcbiAgICB0cmFja3MucHVzaCguLi5jbG9uZWRUcmFja3MpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1VcmlSZXBsYWNlbWVudCh1cmksIHN0YWJsZUlkLCBwZXJPcHRpb25LZXksIHVyaVJlcGxhY2VtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBIT1NUOiBob3N0LFxuICAgIFBBUkFNUzogcGFyYW1zLFxuICAgIFtwZXJPcHRpb25LZXldOiBwZXJPcHRpb25VcmlzXG4gIH0gPSB1cmlSZXBsYWNlbWVudDtcbiAgbGV0IHBlclZhcmlhbnRVcmk7XG4gIGlmIChzdGFibGVJZCkge1xuICAgIHBlclZhcmlhbnRVcmkgPSBwZXJPcHRpb25VcmlzID09IG51bGwgPyB2b2lkIDAgOiBwZXJPcHRpb25VcmlzW3N0YWJsZUlkXTtcbiAgICBpZiAocGVyVmFyaWFudFVyaSkge1xuICAgICAgdXJpID0gcGVyVmFyaWFudFVyaTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gIGlmIChob3N0ICYmICFwZXJWYXJpYW50VXJpKSB7XG4gICAgdXJsLmhvc3QgPSBob3N0O1xuICB9XG4gIGlmIChwYXJhbXMpIHtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLnNvcnQoKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgcGFyYW1zW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1cmwuaHJlZjtcbn1cblxuY29uc3QgQUdFX0hFQURFUl9MSU5FX1JFR0VYID0gL15hZ2U6XFxzKltcXGQuXStcXHMqJC9pbTtcbmNsYXNzIFhockxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMueGhyU2V0dXAgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSB2b2lkIDA7XG4gICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZyA/IGNvbmZpZy54aHJTZXR1cCB8fCBudWxsIDogbnVsbDtcbiAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IDA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgfVxuICBhYm9ydEludGVybmFsKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIGxvYWRlci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgIGlmIChsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdmFyIF90aGlzJGNhbGxiYWNrcztcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPSBudWxsICYmIF90aGlzJGNhbGxiYWNrcy5vbkFib3J0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgIH1cbiAgfVxuICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgaWYgKHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLicpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfVxuICBsb2FkSW50ZXJuYWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhociA9IHRoaXMubG9hZGVyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMubG9hZGluZy5maXJzdCA9IDA7XG4gICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICBzdGF0cy5hYm9ydGVkID0gZmFsc2U7XG4gICAgY29uc3QgeGhyU2V0dXAgPSB0aGlzLnhoclNldHVwO1xuICAgIGlmICh4aHJTZXR1cCkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRzLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLm9wZW5BbmRTZW5kWGhyKHhociwgY29udGV4dCwgY29uZmlnKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgLy8gSUUxMSB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIHhoci5vcGVuIGlmIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGFuIEhUVFAgcmVzb3VyY2Ugb3ZlciBIVFRQU1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgICBjb2RlOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHRleHQ6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSwgY29udGV4dCwgeGhyLCBzdGF0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW5BbmRTZW5kWGhyKHhociwgY29udGV4dCwgY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgb3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpIHtcbiAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5jb250ZXh0LmhlYWRlcnM7XG4gICAgY29uc3Qge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXMsXG4gICAgICBtYXhMb2FkVGltZU1zXG4gICAgfSA9IGNvbmZpZy5sb2FkUG9saWN5O1xuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQgLSAxKSk7XG4gICAgfVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlO1xuICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIGNvbmZpZy50aW1lb3V0ID0gbWF4VGltZVRvRmlyc3RCeXRlTXMgJiYgaXNGaW5pdGVOdW1iZXIobWF4VGltZVRvRmlyc3RCeXRlTXMpID8gbWF4VGltZVRvRmlyc3RCeXRlTXMgOiBtYXhMb2FkVGltZU1zO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfVxuICByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBsb2FkZXI6IHhocixcbiAgICAgIHN0YXRzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0IHx8ICF4aHIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gPj0gSEVBREVSU19SRUNFSVZFRFxuICAgIGlmIChyZWFkeVN0YXRlID49IDIpIHtcbiAgICAgIGlmIChzdGF0cy5sb2FkaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgICAgLy8gcmVhZHlTdGF0ZSA+PSAyIEFORCByZWFkeVN0YXRlICE9PTQgKHJlYWR5U3RhdGUgPSBIRUFERVJTX1JFQ0VJVkVEIHx8IExPQURJTkcpIHJlYXJtIHRpbWVvdXQgYXMgeGhyIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgaWYgKGNvbmZpZy50aW1lb3V0ICE9PSBjb25maWcubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zKSB7XG4gICAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgICAgY29uZmlnLnRpbWVvdXQgPSBjb25maWcubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zO1xuICAgICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zIC0gKHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXG4gICAgICAgIGNvbnN0IHVzZVJlc3BvbnNlID0geGhyLnJlc3BvbnNlVHlwZSAhPT0gJ3RleHQnO1xuICAgICAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgJiYgKHVzZVJlc3BvbnNlICYmIHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0ICE9PSBudWxsKSkge1xuICAgICAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHVzZVJlc3BvbnNlID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICBjb25zdCBsZW4gPSB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICAgICAgc3RhdHMuYndFc3RpbWF0ZSA9IHN0YXRzLnRvdGFsICogODAwMCAvIChzdGF0cy5sb2FkaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgIGlmICghdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb25Qcm9ncmVzcyA9IHRoaXMuY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEsIHhocik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICB1cmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBjb2RlOiBzdGF0dXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHhocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmV0cnlDb25maWcgPSBjb25maWcubG9hZFBvbGljeS5lcnJvclJldHJ5O1xuICAgICAgICAgIGNvbnN0IHJldHJ5Q291bnQgPSBzdGF0cy5yZXRyeTtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGlmIChzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgZmFsc2UsIHN0YXR1cykpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYCR7c3RhdHVzfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9YCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgICAgICAgY29kZTogc3RhdHVzLFxuICAgICAgICAgICAgICB0ZXh0OiB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgfSwgY29udGV4dCwgeGhyLCBzdGF0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWR0aW1lb3V0KCkge1xuICAgIHZhciBfdGhpcyRjb25maWc7XG4gICAgY29uc3QgcmV0cnlDb25maWcgPSAoX3RoaXMkY29uZmlnID0gdGhpcy5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb25maWcubG9hZFBvbGljeS50aW1lb3V0UmV0cnk7XG4gICAgY29uc3QgcmV0cnlDb3VudCA9IHRoaXMuc3RhdHMucmV0cnk7XG4gICAgaWYgKHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCB0cnVlKSkge1xuICAgICAgdGhpcy5yZXRyeShyZXRyeUNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKGB0aW1lb3V0IHdoaWxlIGxvYWRpbmcgJHt0aGlzLmNvbnRleHQudXJsfWApO1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXRyeShyZXRyeUNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBzdGF0c1xuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHN0YXRzLnJldHJ5KTtcbiAgICBzdGF0cy5yZXRyeSsrO1xuICAgIGxvZ2dlci53YXJuKGAke3N0YXR1cyA/ICdIVFRQIFN0YXR1cyAnICsgc3RhdHVzIDogJ1RpbWVvdXQnfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9LCByZXRyeWluZyAke3N0YXRzLnJldHJ5fS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBpbiAke3RoaXMucmV0cnlEZWxheX1tc2ApO1xuICAgIC8vIGFib3J0IGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZVxuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAvLyBzY2hlZHVsZSByZXRyeVxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICB9XG4gIGxvYWRwcm9ncmVzcyhldmVudCkge1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICB9XG4gIGdldENhY2hlQWdlKCkge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmICh0aGlzLmxvYWRlciAmJiBBR0VfSEVBREVSX0xJTkVfUkVHRVgudGVzdCh0aGlzLmxvYWRlci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgIGNvbnN0IGFnZUhlYWRlciA9IHRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKCdhZ2UnKTtcbiAgICAgIHJlc3VsdCA9IGFnZUhlYWRlciA/IHBhcnNlRmxvYXQoYWdlSGVhZGVyKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSkge1xuICAgIGlmICh0aGlzLmxvYWRlciAmJiBuZXcgUmVnRXhwKGBeJHtuYW1lfTpcXFxccypbXFxcXGQuXStcXFxccyokYCwgJ2ltJykudGVzdCh0aGlzLmxvYWRlci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRlci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmV0Y2hTdXBwb3J0ZWQoKSB7XG4gIGlmIChcbiAgLy8gQHRzLWlnbm9yZVxuICBzZWxmLmZldGNoICYmIHNlbGYuQWJvcnRDb250cm9sbGVyICYmIHNlbGYuUmVhZGFibGVTdHJlYW0gJiYgc2VsZi5SZXF1ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBzZWxmLlJlYWRhYmxlU3RyZWFtKHt9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIG5vb3AgKi9cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgQllURVJBTkdFID0gLyhcXGQrKS0oXFxkKylcXC8oXFxkKykvO1xuY2xhc3MgRmV0Y2hMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgLyogSGxzQ29uZmlnICovKSB7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdm9pZCAwO1xuICAgIHRoaXMucmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29udGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwIHx8IGdldFJlcXVlc3Q7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IHNlbGYuQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGVyID0gdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICB9XG4gIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlO1xuICAgIGlmICghKHJlc3BvbnNlICE9IG51bGwgJiYgcmVzcG9uc2Uub2spKSB7XG4gICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICB9XG4gIGFib3J0KCkge1xuICAgIHZhciBfdGhpcyRjYWxsYmFja3M7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgaWYgKChfdGhpcyRjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcykgIT0gbnVsbCAmJiBfdGhpcyRjYWxsYmFja3Mub25BYm9ydCkge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgIH1cbiAgfVxuICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIGlmIChzdGF0cy5sb2FkaW5nLnN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgfVxuICAgIHN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGluaXRQYXJhbXMgPSBnZXRSZXF1ZXN0UGFyYW1ldGVycyhjb250ZXh0LCB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBvblByb2dyZXNzID0gY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgY29uc3QgaXNBcnJheUJ1ZmZlciA9IGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xuICAgIGNvbnN0IExFTkdUSCA9IGlzQXJyYXlCdWZmZXIgPyAnYnl0ZUxlbmd0aCcgOiAnbGVuZ3RoJztcbiAgICBjb25zdCB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNcyxcbiAgICAgIG1heExvYWRUaW1lTXNcbiAgICB9ID0gY29uZmlnLmxvYWRQb2xpY3k7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLmZldGNoU2V0dXAoY29udGV4dCwgaW5pdFBhcmFtcyk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgY29uZmlnLnRpbWVvdXQgPSBtYXhUaW1lVG9GaXJzdEJ5dGVNcyAmJiBpc0Zpbml0ZU51bWJlcihtYXhUaW1lVG9GaXJzdEJ5dGVNcykgPyBtYXhUaW1lVG9GaXJzdEJ5dGVNcyA6IG1heExvYWRUaW1lTXM7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIGNhbGxiYWNrcy5vblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgIH0sIGNvbmZpZy50aW1lb3V0KTtcbiAgICBzZWxmLmZldGNoKHRoaXMucmVxdWVzdCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5sb2FkZXIgPSByZXNwb25zZTtcbiAgICAgIGNvbnN0IGZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIGNvbmZpZy50aW1lb3V0ID0gbWF4TG9hZFRpbWVNcztcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgICAgY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICB9LCBtYXhMb2FkVGltZU1zIC0gKGZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCkpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHRcbiAgICAgICAgfSA9IHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRmV0Y2hFcnJvcihzdGF0dXNUZXh0IHx8ICdmZXRjaCwgYmFkIG5ldHdvcmsgcmVzcG9uc2UnLCBzdGF0dXMsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSBmaXJzdDtcbiAgICAgIHN0YXRzLnRvdGFsID0gZ2V0Q29udGVudExlbmd0aChyZXNwb25zZS5oZWFkZXJzKSB8fCBzdGF0cy50b3RhbDtcbiAgICAgIGlmIChvblByb2dyZXNzICYmIGlzRmluaXRlTnVtYmVyKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkUHJvZ3Jlc3NpdmVseShyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIGNvbmZpZy5oaWdoV2F0ZXJNYXJrLCBvblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgfSkudGhlbihyZXNwb25zZURhdGEgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXNwb25zZVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICBjb25zdCB0b3RhbCA9IHJlc3BvbnNlRGF0YVtMRU5HVEhdO1xuICAgICAgaWYgKHRvdGFsKSB7XG4gICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gdG90YWw7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZXJSZXNwb25zZSA9IHtcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzXG4gICAgICB9O1xuICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgIWlzRmluaXRlTnVtYmVyKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCByZXNwb25zZURhdGEsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MobG9hZGVyUmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCByZXNwb25zZSk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDT1JTIGVycm9ycyByZXN1bHQgaW4gYW4gdW5kZWZpbmVkIGNvZGUuIFNldCBpdCB0byAwIGhlcmUgdG8gYWxpZ24gd2l0aCBYSFIncyBiZWhhdmlvclxuICAgICAgLy8gd2hlbiBkZXN0cm95aW5nLCAnZXJyb3InIGl0c2VsZiBjYW4gYmUgdW5kZWZpbmVkXG4gICAgICBjb25zdCBjb2RlID0gIWVycm9yID8gMCA6IGVycm9yLmNvZGUgfHwgMDtcbiAgICAgIGNvbnN0IHRleHQgPSAhZXJyb3IgPyBudWxsIDogZXJyb3IubWVzc2FnZTtcbiAgICAgIGNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgdGV4dFxuICAgICAgfSwgY29udGV4dCwgZXJyb3IgPyBlcnJvci5kZXRhaWxzIDogbnVsbCwgc3RhdHMpO1xuICAgIH0pO1xuICB9XG4gIGdldENhY2hlQWdlKCkge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICBjb25zdCBhZ2VIZWFkZXIgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdhZ2UnKTtcbiAgICAgIHJlc3VsdCA9IGFnZUhlYWRlciA/IHBhcnNlRmxvYXQoYWdlSGVhZGVyKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlID8gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKSA6IG51bGw7XG4gIH1cbiAgbG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBoaWdoV2F0ZXJNYXJrID0gMCwgb25Qcm9ncmVzcykge1xuICAgIGNvbnN0IGNodW5rQ2FjaGUgPSBuZXcgQ2h1bmtDYWNoZSgpO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLmRvbmUpIHtcbiAgICAgICAgICBpZiAoY2h1bmtDYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rID0gZGF0YS52YWx1ZTtcbiAgICAgICAgY29uc3QgbGVuID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBzdGF0cy5sb2FkZWQgKz0gbGVuO1xuICAgICAgICBpZiAobGVuIDwgaGlnaFdhdGVyTWFyayB8fCBjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGUgY3VycmVudCBjaHVuayBpcyB0b28gc21hbGwgdG8gdG8gYmUgZW1pdHRlZCBvciB0aGUgY2FjaGUgYWxyZWFkeSBoYXMgZGF0YVxuICAgICAgICAgIC8vIFB1c2ggaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgICAgY2h1bmtDYWNoZS5wdXNoKGNodW5rKTtcbiAgICAgICAgICBpZiAoY2h1bmtDYWNoZS5kYXRhTGVuZ3RoID49IGhpZ2hXYXRlck1hcmspIHtcbiAgICAgICAgICAgIC8vIGZsdXNoIGluIG9yZGVyIHRvIGpvaW4gdGhlIHR5cGVkIGFycmF5c1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLCByZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm90aGluZyBjYWNoZWQgYWxyZWFkeSwgYW5kIHRoZSBjaGFjaGUgaXMgbGFyZ2UgZW5vdWdoXG4gICAgICAgICAgLy8ganVzdCBlbWl0IHRoZSBwcm9ncmVzcyBldmVudFxuICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgLyogYWJvcnRlZCAqL1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHB1bXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dCwgc2lnbmFsKSB7XG4gIGNvbnN0IGluaXRQYXJhbXMgPSB7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBtb2RlOiAnY29ycycsXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgc2lnbmFsLFxuICAgIGhlYWRlcnM6IG5ldyBzZWxmLkhlYWRlcnMoX2V4dGVuZHMoe30sIGNvbnRleHQuaGVhZGVycykpXG4gIH07XG4gIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgaW5pdFBhcmFtcy5oZWFkZXJzLnNldCgnUmFuZ2UnLCAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIFN0cmluZyhjb250ZXh0LnJhbmdlRW5kIC0gMSkpO1xuICB9XG4gIHJldHVybiBpbml0UGFyYW1zO1xufVxuZnVuY3Rpb24gZ2V0Qnl0ZVJhbmdlTGVuZ3RoKGJ5dGVSYW5nZUhlYWRlcikge1xuICBjb25zdCByZXN1bHQgPSBCWVRFUkFOR0UuZXhlYyhieXRlUmFuZ2VIZWFkZXIpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdFsyXSkgLSBwYXJzZUludChyZXN1bHRbMV0pICsgMTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29udGVudExlbmd0aChoZWFkZXJzKSB7XG4gIGNvbnN0IGNvbnRlbnRSYW5nZSA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LVJhbmdlJyk7XG4gIGlmIChjb250ZW50UmFuZ2UpIHtcbiAgICBjb25zdCBieXRlUmFuZ2VMZW5ndGggPSBnZXRCeXRlUmFuZ2VMZW5ndGgoY29udGVudFJhbmdlKTtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoYnl0ZVJhbmdlTGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGJ5dGVSYW5nZUxlbmd0aDtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29udGVudExlbmd0aCA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpO1xuICBpZiAoY29udGVudExlbmd0aCkge1xuICAgIHJldHVybiBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdChjb250ZXh0LCBpbml0UGFyYW1zKSB7XG4gIHJldHVybiBuZXcgc2VsZi5SZXF1ZXN0KGNvbnRleHQudXJsLCBpbml0UGFyYW1zKTtcbn1cbmNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXRhaWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuXG5jb25zdCBXSElURVNQQUNFX0NIQVIgPSAvXFxzLztcbmNvbnN0IEN1ZXMgPSB7XG4gIG5ld0N1ZSh0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHJvdztcbiAgICAvLyB0aGUgdHlwZSBkYXRhIHN0YXRlcyB0aGlzIGlzIFZUVEN1ZSwgYnV0IGl0IGNhbiBwb3RlbnRpYWxseSBiZSBhIFRleHRUcmFja0N1ZSBvbiBvbGQgYnJvd3NlcnNcbiAgICBsZXQgY3VlO1xuICAgIGxldCBpbmRlbnRpbmc7XG4gICAgbGV0IGluZGVudDtcbiAgICBsZXQgdGV4dDtcbiAgICBjb25zdCBDdWUgPSBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKykge1xuICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICB0ZXh0ID0gJyc7XG4gICAgICBpZiAoIXJvdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgdmFyIF90cmFjayRjdWVzO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHJvdy5jaGFycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGlmIChXSElURVNQQUNFX0NIQVIudGVzdChyb3cuY2hhcnNbY10udWNoYXIpICYmIGluZGVudGluZykge1xuICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRvIGJlIHVzZWQgZm9yIGNsZWFuaW5nLXVwIG9ycGhhbmVkIHJvbGwtdXAgY2FwdGlvbnNcbiAgICAgICAgcm93LmN1ZVN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcblxuICAgICAgICAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKSB7XG4gICAgICAgICAgZW5kVGltZSArPSAwLjAwMDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGVudCA+PSAxNikge1xuICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1ZVRleHQgPSBmaXhMaW5lQnJlYWtzKHRleHQudHJpbSgpKTtcbiAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBjdWUgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHRyYWNrIGRvIG5vdCBwdXNoIGl0XG4gICAgICAgIGlmICghKHRyYWNrICE9IG51bGwgJiYgKF90cmFjayRjdWVzID0gdHJhY2suY3VlcykgIT0gbnVsbCAmJiBfdHJhY2skY3Vlcy5nZXRDdWVCeUlkKGlkKSkpIHtcbiAgICAgICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG4gICAgICAgICAgY3VlLmlkID0gaWQ7XG4gICAgICAgICAgY3VlLmxpbmUgPSByICsgMTtcbiAgICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgLy8gQ2xhbXAgdGhlIHBvc2l0aW9uIGJldHdlZW4gMTAgYW5kIDgwIHBlcmNlbnQgKENFQS02MDggUEFDIGluZGVudCBjb2RlKVxuICAgICAgICAgIC8vIGh0dHBzOi8vZHZjcy53My5vcmcvaGcvdGV4dC10cmFja3MvcmF3LWZpbGUvZGVmYXVsdC82MDh0b1ZUVC82MDh0b1ZUVC5odG1sI3Bvc2l0aW9uaW5nLWluLWNlYS02MDhcbiAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gYW5kIGNhcHRpb25zIGJyZWFrIHdpdGggb3V0IG9mIGJvdW5kcyAwLTEwMCB2YWx1ZXNcbiAgICAgICAgICBjdWUucG9zaXRpb24gPSAxMCArIE1hdGgubWluKDgwLCBNYXRoLmZsb29yKGluZGVudCAqIDggLyAzMikgKiAxMCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2goY3VlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhY2sgJiYgcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgLy8gU29ydCBib3R0b20gY3VlcyBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgdGhleSByZW5kZXIgaW4gbGluZSBvcmRlciB3aGVuIG92ZXJsYXBwaW5nIGluIENocm9tZVxuICAgICAgcmVzdWx0LnNvcnQoKGN1ZUEsIGN1ZUIpID0+IHtcbiAgICAgICAgaWYgKGN1ZUEubGluZSA9PT0gJ2F1dG8nIHx8IGN1ZUIubGluZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ZUEubGluZSA+IDggJiYgY3VlQi5saW5lID4gOCkge1xuICAgICAgICAgIHJldHVybiBjdWVCLmxpbmUgLSBjdWVBLmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1ZUEubGluZSAtIGN1ZUIubGluZTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmZvckVhY2goY3VlID0+IGFkZEN1ZVRvVHJhY2sodHJhY2ssIGN1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBmcmFnTG9hZFBvbGljeS5kZWZhdWx0XG4gKi9cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQgYW5kIHBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0XG4gKi9cblxuY29uc3QgZGVmYXVsdExvYWRQb2xpY3kgPSB7XG4gIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiA4MDAwLFxuICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgdGltZW91dFJldHJ5OiBudWxsLFxuICBlcnJvclJldHJ5OiBudWxsXG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqIElmIHBvc3NpYmxlLCBrZWVwIGhsc0RlZmF1bHRDb25maWcgc2hhbGxvd1xuICogSXQgaXMgY2xvbmVkIHdoZW5ldmVyIGEgbmV3IEhscyBpbnN0YW5jZSBpcyBjcmVhdGVkLCBieSBrZWVwaW5nIHRoZSBjb25maWdcbiAqIHNoYWxsb3cgdGhlIHByb3BlcnRpZXMgYXJlIGNsb25lZCwgYW5kIHdlIGRvbid0IGVuZCB1cCBtYW5pcHVsYXRpbmcgdGhlIGRlZmF1bHRcbiAqL1xuY29uc3QgaGxzRGVmYXVsdENvbmZpZyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBzdGFydFBvc2l0aW9uOiAtMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlYnVnOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBsb2dnZXJcbiAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpZ25vcmVEZXZpY2VQaXhlbFJhdGlvOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGJhY2tCdWZmZXJMZW5ndGg6IEluZmluaXR5LFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVySG9sZTogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMixcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU9mZnNldDogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogMC4yNSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6IDMsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDogSW5maW5pdHksXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZTogMSxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYmFja0J1ZmZlckxlbmd0aFxuICAgKi9cbiAgbGl2ZUJhY2tCdWZmZXJMZW5ndGg6IG51bGwsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZW5hYmxlV29ya2VyOiB0cnVlLFxuICAvLyB1c2VkIGJ5IHRyYW5zbXV4ZXJcbiAgd29ya2VyUGF0aDogbnVsbCxcbiAgLy8gdXNlZCBieSB0cmFuc211eGVyXG4gIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLFxuICAvLyB1c2VkIGJ5IGRlY3J5cHRlclxuICBzdGFydExldmVsOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgbGV2ZWwtY29udHJvbGxlclxuICBzdGFydEZyYWdQcmVmZXRjaDogZmFsc2UsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMixcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxvYWRlcjogWGhyTG9hZGVyLFxuICAvLyBsb2FkZXI6IEZldGNoTG9hZGVyLFxuICBmTG9hZGVyOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIHBMb2FkZXI6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgeGhyU2V0dXA6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSB4aHItbG9hZGVyXG4gIGxpY2Vuc2VYaHJTZXR1cDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgYWJyQ29udHJvbGxlcjogQWJyQ29udHJvbGxlcixcbiAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiBDYXBMZXZlbENvbnRyb2xsZXIsXG4gIGVycm9yQ29udHJvbGxlcjogRXJyb3JDb250cm9sbGVyLFxuICBmcHNDb250cm9sbGVyOiBGUFNDb250cm9sbGVyLFxuICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiAxLFxuICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IHRydWUsXG4gIC8vIHVzZWQgYnkgdHMtZGVtdXhlclxuICBhYnJFd21hRmFzdExpdmU6IDMsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dMaXZlOiA5LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFGYXN0Vm9EOiAzLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93Vm9EOiA5LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSxcbiAgLy8gNTAwIGticHMgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4TG9hZGluZ0RlbGF5OiA0LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1pbkF1dG9CaXRyYXRlOiAwLFxuICAvLyB1c2VkIGJ5IGhsc1xuICBlbWVFbmFibGVkOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB3aWRldmluZUxpY2Vuc2VVcmw6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBkcm1TeXN0ZW1zOiB7fSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBkcm1TeXN0ZW1PcHRpb25zOiB7fSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jOiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHRlc3RCYW5kd2lkdGg6IHRydWUsXG4gIHByb2dyZXNzaXZlOiBmYWxzZSxcbiAgbG93TGF0ZW5jeU1vZGU6IHRydWUsXG4gIGNtY2Q6IHVuZGVmaW5lZCxcbiAgZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzOiB0cnVlLFxuICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzOiB0cnVlLFxuICBlbmFibGVJRDNNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGNlcnRMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDogZGVmYXVsdExvYWRQb2xpY3lcbiAgfSxcbiAga2V5TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiA4MDAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDEsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAyMDAwMCxcbiAgICAgICAgYmFja29mZjogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiA4LFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMjAwMDAsXG4gICAgICAgIGJhY2tvZmY6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtYW5pZmVzdExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogSW5maW5pdHksXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGxheWxpc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGZyYWdMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMTIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiA0LFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDYsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzdGVlcmluZ01hbmlmZXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDEsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwXG4gICAgICB9XG4gICAgfSBcbiAgfSxcbiAgLy8gVGhlc2UgZGVmYXVsdCBzZXR0aW5ncyBhcmUgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUgYWJvdmUgcG9saWNpZXNcbiAgLy8gYW5kIGFyZSBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IDEsXG4gIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCxcbiAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCxcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNixcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDBcbn0sIHRpbWVsaW5lQ29uZmlnKCkpLCB7fSwge1xuICBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI6IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciAsXG4gIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyOiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciAsXG4gIHRpbWVsaW5lQ29udHJvbGxlcjogVGltZWxpbmVDb250cm9sbGVyICxcbiAgYXVkaW9TdHJlYW1Db250cm9sbGVyOiBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgLFxuICBhdWRpb1RyYWNrQ29udHJvbGxlcjogQXVkaW9UcmFja0NvbnRyb2xsZXIgLFxuICBlbWVDb250cm9sbGVyOiBFTUVDb250cm9sbGVyICxcbiAgY21jZENvbnRyb2xsZXI6IENNQ0RDb250cm9sbGVyICxcbiAgY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjogQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciBcbn0pO1xuZnVuY3Rpb24gdGltZWxpbmVDb25maWcoKSB7XG4gIHJldHVybiB7XG4gICAgY3VlSGFuZGxlcjogQ3VlcyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVXZWJWVFQ6IHRydWUsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlSU1TQzE6IHRydWUsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWw6ICdFbmdsaXNoJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGU6ICdlbicsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFiZWw6ICdTcGFuaXNoJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6ICdlcycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2szTGFiZWw6ICdVbmtub3duIENDJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazNMYW5ndWFnZUNvZGU6ICcnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhYmVsOiAnVW5rbm93biBDQycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlOiAnJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICByZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHk6IHRydWVcbiAgfTtcbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIHVzZXJDb25maWcpIHtcbiAgaWYgKCh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb24ndCBtaXggdXAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50L2xpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCBhbmQgbGl2ZVN5bmNEdXJhdGlvbi9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIpO1xuICB9XG4gIGlmICh1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCA9PT0gdW5kZWZpbmVkIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IDw9IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvbkNvdW50XCInKTtcbiAgfVxuICBpZiAodXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvblwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvblwiJyk7XG4gIH1cbiAgY29uc3QgZGVmYXVsdHNDb3B5ID0gZGVlcENweShkZWZhdWx0Q29uZmlnKTtcblxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGRlcHJlY2F0ZWQgY29uZmlnIHZhbHVlc1xuICBjb25zdCBkZXByZWNhdGVkU2V0dGluZ1R5cGVzID0gWydtYW5pZmVzdCcsICdsZXZlbCcsICdmcmFnJ107XG4gIGNvbnN0IGRlcHJlY2F0ZWRTZXR0aW5ncyA9IFsnVGltZU91dCcsICdNYXhSZXRyeScsICdSZXRyeURlbGF5JywgJ01heFJldHJ5VGltZW91dCddO1xuICBkZXByZWNhdGVkU2V0dGluZ1R5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgY29uc3QgcG9saWN5TmFtZSA9IGAke3R5cGUgPT09ICdsZXZlbCcgPyAncGxheWxpc3QnIDogdHlwZX1Mb2FkUG9saWN5YDtcbiAgICBjb25zdCBwb2xpY3lOb3RTZXQgPSB1c2VyQ29uZmlnW3BvbGljeU5hbWVdID09PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVwb3J0ID0gW107XG4gICAgZGVwcmVjYXRlZFNldHRpbmdzLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICBjb25zdCBkZXByZWNhdGVkU2V0dGluZyA9IGAke3R5cGV9TG9hZGluZyR7c2V0dGluZ31gO1xuICAgICAgY29uc3QgdmFsdWUgPSB1c2VyQ29uZmlnW2RlcHJlY2F0ZWRTZXR0aW5nXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHBvbGljeU5vdFNldCkge1xuICAgICAgICByZXBvcnQucHVzaChkZXByZWNhdGVkU2V0dGluZyk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gZGVmYXVsdHNDb3B5W3BvbGljeU5hbWVdLmRlZmF1bHQ7XG4gICAgICAgIHVzZXJDb25maWdbcG9saWN5TmFtZV0gPSB7XG4gICAgICAgICAgZGVmYXVsdDogc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChzZXR0aW5nKSB7XG4gICAgICAgICAgY2FzZSAnVGltZU91dCc6XG4gICAgICAgICAgICBzZXR0aW5ncy5tYXhMb2FkVGltZU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy5tYXhUaW1lVG9GaXJzdEJ5dGVNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTWF4UmV0cnknOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeS5tYXhOdW1SZXRyeSA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5Lm1heE51bVJldHJ5ID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdSZXRyeURlbGF5JzpcbiAgICAgICAgICAgIHNldHRpbmdzLmVycm9yUmV0cnkucmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkucmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNYXhSZXRyeVRpbWVvdXQnOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeS5tYXhSZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeS5tYXhSZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlcG9ydC5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBobHMuanMgY29uZmlnOiBcIiR7cmVwb3J0LmpvaW4oJ1wiLCBcIicpfVwiIHNldHRpbmcocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBcIiR7cG9saWN5TmFtZX1cIjogJHtKU09OLnN0cmluZ2lmeSh1c2VyQ29uZmlnW3BvbGljeU5hbWVdKX1gKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRzQ29weSksIHVzZXJDb25maWcpO1xufVxuZnVuY3Rpb24gZGVlcENweShvYmopIHtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmoubWFwKGRlZXBDcHkpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgICByZXN1bHRba2V5XSA9IGRlZXBDcHkob2JqW2tleV0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZVN0cmVhbWluZ01vZGUoY29uZmlnKSB7XG4gIGNvbnN0IGN1cnJlbnRMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICBpZiAoY3VycmVudExvYWRlciAhPT0gRmV0Y2hMb2FkZXIgJiYgY3VycmVudExvYWRlciAhPT0gWGhyTG9hZGVyKSB7XG4gICAgLy8gSWYgYSBkZXZlbG9wZXIgaGFzIGNvbmZpZ3VyZWQgdGhlaXIgb3duIGxvYWRlciwgcmVzcGVjdCB0aGF0IGNob2ljZVxuICAgIGxvZ2dlci5sb2coJ1tjb25maWddOiBDdXN0b20gbG9hZGVyIGRldGVjdGVkLCBjYW5ub3QgZW5hYmxlIHByb2dyZXNzaXZlIHN0cmVhbWluZycpO1xuICAgIGNvbmZpZy5wcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNhblN0cmVhbVByb2dyZXNzaXZlbHkgPSBmZXRjaFN1cHBvcnRlZCgpO1xuICAgIGlmIChjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5KSB7XG4gICAgICBjb25maWcubG9hZGVyID0gRmV0Y2hMb2FkZXI7XG4gICAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTID0gdHJ1ZTtcbiAgICAgIGxvZ2dlci5sb2coJ1tjb25maWddOiBQcm9ncmVzc2l2ZSBzdHJlYW1pbmcgZW5hYmxlZCwgdXNpbmcgRmV0Y2hMb2FkZXInKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYEhsc2AgY2xhc3MgaXMgdGhlIGNvcmUgb2YgdGhlIEhMUy5qcyBsaWJyYXJ5IHVzZWQgdG8gaW5zdGFudGlhdGUgcGxheWVyIGluc3RhbmNlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSGxzIHtcbiAgLyoqXG4gICAqIFRoZSBydW50aW1lIGNvbmZpZ3VyYXRpb24gdXNlZCBieSB0aGUgcGxheWVyLiBBdCBpbnN0YW50aWF0aW9uIHRoaXMgaXMgY29tYmluYXRpb24gb2YgYGhscy51c2VyQ29uZmlnYCBtZXJnZWQgb3ZlciBgSGxzLkRlZmF1bHRDb25maWdgLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHByb3ZpZGVkIG9uIHBsYXllciBpbnN0YW50aWF0aW9uLlxuICAgKi9cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWRlby1kZXYvaGxzLmpzIHBhY2thZ2UgdmVyc2lvbi5cbiAgICovXG4gIHN0YXRpYyBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gXCIxLjQuMTJcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcmVxdWlyZWQgTWVkaWFTb3VyY2UgRXh0ZW5zaW9ucyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBpc1N1cHBvcnRlZCgpO1xuICB9XG4gIHN0YXRpYyBnZXQgRXZlbnRzKCkge1xuICAgIHJldHVybiBFdmVudHM7XG4gIH1cbiAgc3RhdGljIGdldCBFcnJvclR5cGVzKCkge1xuICAgIHJldHVybiBFcnJvclR5cGVzO1xuICB9XG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzKCkge1xuICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBuZXcgaW5zdGFuY2VzLlxuICAgKi9cbiAgc3RhdGljIGdldCBEZWZhdWx0Q29uZmlnKCkge1xuICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgIHJldHVybiBobHNEZWZhdWx0Q29uZmlnO1xuICAgIH1cbiAgICByZXR1cm4gSGxzLmRlZmF1bHRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFwcGxpZWQgdG8gbmV3IGluc3RhbmNlcy5cbiAgICovXG4gIHN0YXRpYyBzZXQgRGVmYXVsdENvbmZpZyhkZWZhdWx0Q29uZmlnKSB7XG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgKiBAcGFyYW0gdXNlckNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcHBsaWVkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYFxuICAgKi9cbiAgY29uc3RydWN0b3IodXNlckNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy51c2VyQ29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IG51bGw7XG4gICAgdGhpcy5hYnJDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYnVmZmVyQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbWVDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY21jZENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICBlbmFibGVMb2dzKHVzZXJDb25maWcuZGVidWcgfHwgZmFsc2UsICdIbHMgaW5zdGFuY2UnKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG1lcmdlQ29uZmlnKEhscy5EZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnKTtcbiAgICB0aGlzLnVzZXJDb25maWcgPSB1c2VyQ29uZmlnO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICBpZiAoY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXG4gICAgY29uc3Qge1xuICAgICAgYWJyQ29udHJvbGxlcjogQ29uZmlnQWJyQ29udHJvbGxlcixcbiAgICAgIGJ1ZmZlckNvbnRyb2xsZXI6IENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIsXG4gICAgICBjYXBMZXZlbENvbnRyb2xsZXI6IENvbmZpZ0NhcExldmVsQ29udHJvbGxlcixcbiAgICAgIGVycm9yQ29udHJvbGxlcjogQ29uZmlnRXJyb3JDb250cm9sbGVyLFxuICAgICAgZnBzQ29udHJvbGxlcjogQ29uZmlnRnBzQ29udHJvbGxlclxuICAgIH0gPSBjb25maWc7XG4gICAgY29uc3QgZXJyb3JDb250cm9sbGVyID0gbmV3IENvbmZpZ0Vycm9yQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBhYnJDb250cm9sbGVyID0gdGhpcy5hYnJDb250cm9sbGVyID0gbmV3IENvbmZpZ0FickNvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgYnVmZmVyQ29udHJvbGxlciA9IHRoaXMuYnVmZmVyQ29udHJvbGxlciA9IG5ldyBDb25maWdCdWZmZXJDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGNhcExldmVsQ29udHJvbGxlciA9IHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gbmV3IENvbmZpZ0NhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBmcHNDb250cm9sbGVyID0gbmV3IENvbmZpZ0Zwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgcGxheUxpc3RMb2FkZXIgPSBuZXcgUGxheWxpc3RMb2FkZXIodGhpcyk7XG4gICAgY29uc3QgaWQzVHJhY2tDb250cm9sbGVyID0gbmV3IElEM1RyYWNrQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBDb25maWdDb250ZW50U3RlZXJpbmdDb250cm9sbGVyID0gY29uZmlnLmNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI7XG4gICAgLy8gQ29uZW50U3RlZXJpbmdDb250cm9sbGVyIGlzIGRlZmluZWQgYmVmb3JlIExldmVsQ29udHJvbGxlciB0byByZWNlaXZlIE11bHRpdmFyaWFudCBQbGF5bGlzdCBldmVudHMgZmlyc3RcbiAgICBjb25zdCBjb250ZW50U3RlZXJpbmcgPSBDb25maWdDb250ZW50U3RlZXJpbmdDb250cm9sbGVyID8gbmV3IENvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIodGhpcykgOiBudWxsO1xuICAgIGNvbnN0IGxldmVsQ29udHJvbGxlciA9IHRoaXMubGV2ZWxDb250cm9sbGVyID0gbmV3IExldmVsQ29udHJvbGxlcih0aGlzLCBjb250ZW50U3RlZXJpbmcpO1xuICAgIC8vIEZyYWdtZW50VHJhY2tlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlIFN0cmVhbUNvbnRyb2xsZXIgYmVjYXVzZSB0aGUgb3JkZXIgb2YgZXZlbnQgaGFuZGxpbmcgaXMgaW1wb3J0YW50XG4gICAgY29uc3QgZnJhZ21lbnRUcmFja2VyID0gbmV3IEZyYWdtZW50VHJhY2tlcih0aGlzKTtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgS2V5TG9hZGVyKHRoaXMuY29uZmlnKTtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IFN0cmVhbUNvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpO1xuXG4gICAgLy8gQ2FwIGxldmVsIGNvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIGZsdXNoIHRoZSBidWZmZXJcbiAgICBjYXBMZXZlbENvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcbiAgICAvLyBmcHNDb250cm9sbGVyIHVzZXMgc3RyZWFtQ29udHJvbGxlciB0byBzd2l0Y2ggd2hlbiBmcmFtZXMgYXJlIGJlaW5nIGRyb3BwZWRcbiAgICBmcHNDb250cm9sbGVyLnNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcik7XG4gICAgY29uc3QgbmV0d29ya0NvbnRyb2xsZXJzID0gW3BsYXlMaXN0TG9hZGVyLCBsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xuICAgIGlmIChjb250ZW50U3RlZXJpbmcpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5zcGxpY2UoMSwgMCwgY29udGVudFN0ZWVyaW5nKTtcbiAgICB9XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSBuZXR3b3JrQ29udHJvbGxlcnM7XG4gICAgY29uc3QgY29yZUNvbXBvbmVudHMgPSBbYWJyQ29udHJvbGxlciwgYnVmZmVyQ29udHJvbGxlciwgY2FwTGV2ZWxDb250cm9sbGVyLCBmcHNDb250cm9sbGVyLCBpZDNUcmFja0NvbnRyb2xsZXIsIGZyYWdtZW50VHJhY2tlcl07XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXIsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgY29uc3QgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2gobmV3IEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzKHRoaXMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSk7XG4gICAgfVxuICAgIC8vIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBuZXR3b3JrQ29udHJvbGxlcnMpO1xuICAgIGNvbnN0IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzID0gY29uZmlnLnN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICBpZiAoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKG5ldyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIGtleUxvYWRlci5lbWVDb250cm9sbGVyID0gdGhpcy5lbWVDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5lbWVDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgdGhpcy5jbWNkQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuY21jZENvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKExhdGVuY3lDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuXG4gICAgLy8gRXJyb3IgY29udHJvbGxlciBoYW5kbGVzIGVycm9ycyBiZWZvcmUgYW5kIGFmdGVyIGFsbCBvdGhlciBjb250cm9sbGVyc1xuICAgIC8vIFRoaXMgbGlzdGVuZXIgd2lsbCBiZSBpbnZva2VkIGFmdGVyIGFsbCBvdGhlciBjb250cm9sbGVycyBlcnJvciBsaXN0ZW5lcnNcbiAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChlcnJvckNvbnRyb2xsZXIpO1xuICAgIGNvbnN0IG9uRXJyb3JPdXQgPSBlcnJvckNvbnRyb2xsZXIub25FcnJvck91dDtcbiAgICBpZiAodHlwZW9mIG9uRXJyb3JPdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMub24oRXZlbnRzLkVSUk9SLCBvbkVycm9yT3V0LCBlcnJvckNvbnRyb2xsZXIpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVDb250cm9sbGVyKENvbnRyb2xsZXJDbGFzcywgY29tcG9uZW50cykge1xuICAgIGlmIChDb250cm9sbGVyQ2xhc3MpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXJJbnN0YW5jZSA9IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcyk7XG4gICAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goY29udHJvbGxlckluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250cm9sbGVySW5zdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gRGVsZWdhdGUgdGhlIEV2ZW50RW1pdHRlciB0aHJvdWdoIHRoZSBwdWJsaWMgQVBJIG9mIEhscy5qc1xuICBvbihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQgPSB0aGlzKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vbihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICB9XG4gIG9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0ID0gdGhpcykge1xuICAgIHRoaXMuX2VtaXR0ZXIub25jZShldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICB9XG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgIHRoaXMuX2VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgfVxuICBvZmYoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0ID0gdGhpcywgb25jZSkge1xuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCwgb25jZSk7XG4gIH1cbiAgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKGV2ZW50KTtcbiAgfVxuICBlbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmVtaXQoZXZlbnQsIG5hbWUsIGV2ZW50T2JqZWN0KTtcbiAgfVxuICB0cmlnZ2VyKGV2ZW50LCBldmVudE9iamVjdCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgZXZlbnQsIGV2ZW50T2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgZXZlbnQsIGV2ZW50T2JqZWN0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdBbiBpbnRlcm5hbCBlcnJvciBoYXBwZW5lZCB3aGlsZSBoYW5kbGluZyBldmVudCAnICsgZXZlbnQgKyAnLiBFcnJvciBtZXNzYWdlOiBcIicgKyBlLm1lc3NhZ2UgKyAnXCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOicsIGUpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJDb3VudChldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiB0aGUgaW5zdGFuY2VcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgbG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuREVTVFJPWUlORywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29tcG9uZW50ID0+IGNvbXBvbmVudC5kZXN0cm95KCkpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiBjb21wb25lbnQuZGVzdHJveSgpKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgLy8gUmVtb3ZlIGFueSByZWZlcmVuY2VzIHRoYXQgY291bGQgYmUgaGVsZCBpbiBjb25maWcgb3B0aW9ucyBvciBjYWxsYmFja3NcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25maWcueGhyU2V0dXAgPSBjb25maWcuZmV0Y2hTZXR1cCA9IHVuZGVmaW5lZDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy51c2VyQ29uZmlnID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBIbHMuanMgdG8gYSBtZWRpYSBlbGVtZW50XG4gICAqL1xuICBhdHRhY2hNZWRpYShtZWRpYSkge1xuICAgIGxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XG4gICAgdGhpcy5fbWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSElORywge1xuICAgICAgbWVkaWE6IG1lZGlhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoIEhscy5qcyBmcm9tIHRoZSBtZWRpYVxuICAgKi9cbiAgZGV0YWNoTWVkaWEoKSB7XG4gICAgbG9nZ2VyLmxvZygnZGV0YWNoTWVkaWEnKTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgVVJMLiBDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUuXG4gICAqL1xuICBsb2FkU291cmNlKHVybCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgbG9hZGVkU291cmNlID0gdGhpcy51cmw7XG4gICAgY29uc3QgbG9hZGluZ1NvdXJjZSA9IHRoaXMudXJsID0gdXJsVG9vbGtpdEV4cG9ydHMuYnVpbGRBYnNvbHV0ZVVSTChzZWxmLmxvY2F0aW9uLmhyZWYsIHVybCwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgfSk7XG4gICAgbG9nZ2VyLmxvZyhgbG9hZFNvdXJjZToke2xvYWRpbmdTb3VyY2V9YCk7XG4gICAgaWYgKG1lZGlhICYmIGxvYWRlZFNvdXJjZSAmJiAobG9hZGVkU291cmNlICE9PSBsb2FkaW5nU291cmNlIHx8IHRoaXMuYnVmZmVyQ29udHJvbGxlci5oYXNTb3VyY2VUeXBlcygpKSkge1xuICAgICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfVxuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHtcbiAgICAgIHVybDogdXJsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgbG9hZGluZyBkYXRhIGZyb20gdGhlIHN0cmVhbSBzb3VyY2UuXG4gICAqIERlcGVuZGluZyBvbiBkZWZhdWx0IGNvbmZpZywgY2xpZW50IHN0YXJ0cyBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBhIHNvdXJjZSBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFBvc2l0aW9uIC0gU2V0IHRoZSBzdGFydCBwb3NpdGlvbiB0byBzdHJlYW0gZnJvbS5cbiAgICogRGVmYXVsdHMgdG8gLTEgKE5vbmU6IHN0YXJ0cyBmcm9tIGVhcmxpZXN0IHBvaW50KVxuICAgKi9cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24gPSAtMSkge1xuICAgIGxvZ2dlci5sb2coYHN0YXJ0TG9hZCgke3N0YXJ0UG9zaXRpb259KWApO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICBjb250cm9sbGVyLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxvYWRpbmcgb2YgYW55IHN0cmVhbSBkYXRhLlxuICAgKi9cbiAgc3RvcExvYWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge1xuICAgICAgY29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3YXAgdGhyb3VnaCBwb3NzaWJsZSBhdWRpbyBjb2RlY3MgaW4gdGhlIHN0cmVhbSAoZm9yIGV4YW1wbGUgdG8gc3dpdGNoIGZyb20gc3RlcmVvIHRvIDUuMSlcbiAgICovXG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIGxvZ2dlci5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLnN3YXBBdWRpb0NvZGVjKCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgbWVkaWEtZWxlbWVudCBmYWlscywgdGhpcyBhbGxvd3MgdG8gZGV0YWNoIGFuZCB0aGVuIHJlLWF0dGFjaCBpdFxuICAgKiBhcyBvbmUgY2FsbCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAgICpcbiAgICogQXV0b21hdGljIHJlY292ZXJ5IG9mIG1lZGlhLWVycm9ycyBieSB0aGlzIHByb2Nlc3MgaXMgY29uZmlndXJhYmxlLlxuICAgKi9cbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgbG9nZ2VyLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMuX21lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgIH1cbiAgfVxuICByZW1vdmVMZXZlbChsZXZlbEluZGV4LCB1cmxJZCA9IDApIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5yZW1vdmVMZXZlbChsZXZlbEluZGV4LCB1cmxJZCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgbGV2ZWxzICh2YXJpYW50cykgc29ydGVkIGJ5IEhEQ1AtTEVWRUwsIEJBTkRXSURUSCwgU0NPUkUsIGFuZCBSRVNPTFVUSU9OIChoZWlnaHQpXG4gICAqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscztcbiAgICByZXR1cm4gbGV2ZWxzID8gbGV2ZWxzIDogW107XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgcXVhbGl0eSBsZXZlbCAodmFyaWFudCkgY3VycmVudGx5IHBsYXllZFxuICAgKi9cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBpbW1lZGlhdGVseS4gVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuIFRoYXQgbWVhbnMgcGxheWJhY2sgd2lsbCBpbnRlcnJ1cHQgYXQgbGVhc3Qgc2hvcnRseSB0byByZS1idWZmZXIgYW5kIHJlLXN5bmMgZXZlbnR1YWxseS4gU2V0IHRvIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uLlxuICAgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBjdXJyZW50TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5jbGVhclRpbWVyKCk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZCBhcyBzY2hlZHVsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXIuXG4gICAqL1xuICBnZXQgbmV4dExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGZvciBuZXh0IGxvYWRlZCBkYXRhLlxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSB2aWRlbyBxdWFsaXR5IGFzYXAsIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrLlxuICAgKiBNYXkgYWJvcnQgY3VycmVudCBsb2FkaW5nIG9mIGRhdGEsIGFuZCBmbHVzaCBwYXJ0cyBvZiBidWZmZXIgKG91dHNpZGUgY3VycmVudGx5IHBsYXllZCBmcmFnbWVudCByZWdpb24pLlxuICAgKiBAcGFyYW0gbmV3TGV2ZWwgLSBQYXNzIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAqL1xuICBzZXQgbmV4dExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IG5leHRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiB0aGUgY3VycmVudGx5IG9yIGxhc3QgKG9mIG5vbmUgaXMgbG9hZGVkIGN1cnJlbnRseSkgc2VnbWVudFxuICAgKi9cbiAgZ2V0IGxvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSBxdWFsaXR5IHdpdGhvdXQgZmx1c2hpbmcsIGJ1dCBpbnRlcnJ1cHQgY3VycmVudCBsb2FkaW5nLlxuICAgKiBUaHVzIHRoZSBtb21lbnQgd2hlbiB0aGUgcXVhbGl0eSBzd2l0Y2ggd2lsbCBhcHBlYXIgaW4gZWZmZWN0IHdpbGwgb25seSBiZSBhZnRlciB0aGUgYWxyZWFkeSBleGlzdGluZyBidWZmZXIuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBsb2FkTGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbG9hZExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZFxuICAgKi9cbiAgZ2V0IG5leHRMb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBsb2FkZWQgc2VnbWVudCBpbiBhIGZ1bGx5IFwibm9uLWRlc3RydWN0aXZlXCIgd2F5LlxuICAgKiBTYW1lIGFzIGBsb2FkTGV2ZWxgIGJ1dCB3aWxsIHdhaXQgZm9yIG5leHQgc3dpdGNoICh1bnRpbCBjdXJyZW50IGxvYWRpbmcgaXMgZG9uZSkuXG4gICAqL1xuICBzZXQgbmV4dExvYWRMZXZlbChsZXZlbCkge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcbiAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAqL1xuICBnZXQgZmlyc3RMZXZlbCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgXCJmaXJzdC1sZXZlbFwiLCBzZWUgZ2V0dGVyLlxuICAgKi9cbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgZmlyc3RMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAqL1xuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgKi9cbiAgc2V0IHN0YXJ0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgc3RhcnRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIC8vIGlmIG5vdCBpbiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgZGV0ZWN0aW9uLCBlbnN1cmUgc3RhcnRMZXZlbCBpcyBncmVhdGVyIHRoYW4gbWluQXV0b0xldmVsXG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1heChuZXdMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICAgIH1cbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBsZXZlbCBjYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgc2V0IHZpYSBgY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplYC5cbiAgICovXG4gIGdldCBjYXBMZXZlbFRvUGxheWVyU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBsZXZlbCBjYXBwaW5nLiBJZiBkaXNhYmxlZCBhZnRlciBwcmV2aW91c2x5IGVuYWJsZWQsIGBuZXh0TGV2ZWxTd2l0Y2hgIHdpbGwgYmUgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICAgKi9cbiAgc2V0IGNhcExldmVsVG9QbGF5ZXJTaXplKHNob3VsZFN0YXJ0Q2FwcGluZykge1xuICAgIGNvbnN0IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplID0gISFzaG91bGRTdGFydENhcHBpbmc7XG4gICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplICE9PSB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0YXJ0Q2FwcGluZygpOyAvLyBJZiBjYXBwaW5nIG9jY3VycywgbmV4dExldmVsU3dpdGNoIHdpbGwgaGFwcGVuIGJhc2VkIG9uIHNpemUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpO1xuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpOyAvLyBOb3cgd2UncmUgdW5jYXBwZWQsIGdldCB0aGUgbmV4dCBsZXZlbCBhc2FwLlxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSA9IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAqL1xuICBnZXQgYXV0b0xldmVsQ2FwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJhbmR3aWR0aCBlc3RpbWF0ZSBpbiBiaXRzIHBlciBzZWNvbmQsIHdoZW4gYXZhaWxhYmxlLiBPdGhlcndpc2UsIGBOYU5gIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0IGJhbmR3aWR0aEVzdGltYXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ3RXN0aW1hdG9yXG4gICAgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGltZSB0byBmaXJzdCBieXRlIGVzdGltYXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgdHRmYkVzdGltYXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ3RXN0aW1hdG9yXG4gICAgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWwpIHtcbiAgICBpZiAodGhpcy5fYXV0b0xldmVsQ2FwcGluZyAhPT0gbmV3TGV2ZWwpIHtcbiAgICAgIGxvZ2dlci5sb2coYHNldCBhdXRvTGV2ZWxDYXBwaW5nOiR7bmV3TGV2ZWx9YCk7XG4gICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9XG4gIGdldCBtYXhIZGNwTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heEhkY3BMZXZlbDtcbiAgfVxuICBzZXQgbWF4SGRjcExldmVsKHZhbHVlKSB7XG4gICAgaWYgKEhkY3BMZXZlbHMuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgdGhpcy5fbWF4SGRjcExldmVsID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICovXG4gIGdldCBhdXRvTGV2ZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogTGV2ZWwgc2V0IG1hbnVhbGx5IChpZiBhbnkpXG4gICAqL1xuICBnZXQgbWFudWFsTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlXG4gICAqL1xuICBnZXQgbWluQXV0b0xldmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBtaW5BdXRvQml0cmF0ZVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzKSByZXR1cm4gMDtcbiAgICBjb25zdCBsZW4gPSBsZXZlbHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbHNbaV0ubWF4Qml0cmF0ZSA+PSBtaW5BdXRvQml0cmF0ZSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nXG4gICAqL1xuICBnZXQgbWF4QXV0b0xldmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1dG9MZXZlbENhcHBpbmcsXG4gICAgICBtYXhIZGNwTGV2ZWxcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgbWF4QXV0b0xldmVsO1xuICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nID09PSAtMSAmJiBsZXZlbHMgJiYgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGF1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuICAgIGlmIChtYXhIZGNwTGV2ZWwpIHtcbiAgICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGktLTspIHtcbiAgICAgICAgY29uc3QgaGRjcExldmVsID0gbGV2ZWxzW2ldLmF0dHJzWydIRENQLUxFVkVMJ107XG4gICAgICAgIGlmIChoZGNwTGV2ZWwgJiYgaGRjcExldmVsIDw9IG1heEhkY3BMZXZlbCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICovXG4gIGdldCBuZXh0QXV0b0xldmVsKCkge1xuICAgIC8vIGVuc3VyZSBuZXh0IGF1dG8gbGV2ZWwgaXMgYmV0d2VlbiAgbWluIGFuZCBtYXggYXV0byBsZXZlbFxuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpLCB0aGlzLm1heEF1dG9MZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogdGhpcyBzZXR0ZXIgaXMgdXNlZCB0byBmb3JjZSBuZXh0IGF1dG8gbGV2ZWwuXG4gICAqIHRoaXMgaXMgdXNlZnVsIHRvIGZvcmNlIGEgc3dpdGNoIGRvd24gaW4gYXV0byBtb2RlOlxuICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXG4gICAqIGZvcmNlZCB2YWx1ZSBpcyB2YWxpZCBmb3Igb25lIGZyYWdtZW50LiB1cG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkaW5nIGF0IGZvcmNlZCBsZXZlbCxcbiAgICogdGhpcyB2YWx1ZSB3aWxsIGJlIHJlc2V0dGVkIHRvIC0xIGJ5IEFCUiBjb250cm9sbGVyLlxuICAgKi9cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heCh0aGlzLm1pbkF1dG9MZXZlbCwgbmV4dExldmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGRhdGV0aW1lIHZhbHVlIHJlbGF0aXZlIHRvIG1lZGlhLmN1cnJlbnRUaW1lIGZvciB0aGUgYWN0aXZlIGxldmVsIFByb2dyYW0gRGF0ZSBUaW1lIGlmIHByZXNlbnRcbiAgICovXG4gIGdldCBwbGF5aW5nRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cbiAgZ2V0IG1haW5Gb3J3YXJkQnVmZmVySW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIHNlbGVjdGFibGUgYXVkaW8gdHJhY2tzXG4gICAqL1xuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrIDogLTE7XG4gIH1cblxuICAvKipcbiAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXG4gICAqL1xuICBzZXQgYXVkaW9UcmFjayhhdWRpb1RyYWNrSWQpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3RcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcygpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKVxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2soKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgfVxuICBnZXQgbWVkaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlbGVjdCBhbiBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzXG4gICAqL1xuICBzZXQgc3VidGl0bGVUcmFjayhzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrID0gc3VidGl0bGVUcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHN1YnRpdGxlIGRpc3BsYXkgaXMgZW5hYmxlZCBvciBub3RcbiAgICovXG4gIGdldCBzdWJ0aXRsZURpc3BsYXkoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIHN1YnRpdGxlIGRpc3BsYXkgcmVuZGVyaW5nXG4gICAqL1xuICBzZXQgc3VidGl0bGVEaXNwbGF5KHZhbHVlKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCBtb2RlIGZvciBMb3ctTGF0ZW5jeSBITFMgbG9hZGluZ1xuICAgKi9cbiAgZ2V0IGxvd0xhdGVuY3lNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBMb3ctTGF0ZW5jeSBITFMgcGFydCBwbGF5bGlzdCBhbmQgc2VnbWVudCBsb2FkaW5nLCBhbmQgc3RhcnQgbGl2ZSBzdHJlYW1zIGF0IHBsYXlsaXN0IFBBUlQtSE9MRC1CQUNLIHJhdGhlciB0aGFuIEhPTEQtQkFDSy5cbiAgICovXG4gIHNldCBsb3dMYXRlbmN5TW9kZShtb2RlKSB7XG4gICAgdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgPSBtb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIHN5bmMgcG9pbnQgKGllIGVkZ2Ugb2YgbGl2ZSBwb3NpdGlvbiBtaW51cyBzYWZldHkgZGVsYXkgZGVmaW5lZCBieSBgYGBobHMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25gYGApXG4gICAqIEByZXR1cm5zIG51bGwgcHJpb3IgdG8gbG9hZGluZyBsaXZlIFBsYXlsaXN0XG4gICAqL1xuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlZCBwb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBlZGdlIChpZSBlZGdlIG9mIGxpdmUgcGxheWxpc3QgcGx1cyB0aW1lIHN5bmMgcGxheWxpc3QgYWR2YW5jZWQpXG4gICAqIEByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgKi9cbiAgZ2V0IGxhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYmVmb3JlIHRoZSBwbGF5ZXIgc2Vla3MgZm9yd2FyZCB0byBgYGBobHMubGl2ZVN5bmNQb3NpdGlvbmBgYFxuICAgKiBjb25maWd1cmVkIHVzaW5nIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudGBgYCAobXVsdGlwbGUgb2YgdGFyZ2V0IGR1cmF0aW9uKSBvciBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uYGBgXG4gICAqIEByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgKi9cbiAgZ2V0IG1heExhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubWF4TGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0YXJnZXQgZGlzdGFuY2UgZnJvbSB0aGUgZWRnZSBhcyBjYWxjdWxhdGVkIGJ5IHRoZSBsYXRlbmN5IGNvbnRyb2xsZXJcbiAgICovXG4gIGdldCB0YXJnZXRMYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIGVkZ2Ugb2YgdGhlIGN1cnJlbnQgbGl2ZSBwbGF5bGlzdCBpcyBhZHZhbmNpbmcgb3IgMSBpZiB0aGVyZSBpcyBub25lXG4gICAqL1xuICBnZXQgZHJpZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIuZHJpZnQ7XG4gIH1cblxuICAvKipcbiAgICogc2V0IHRvIHRydWUgd2hlbiBzdGFydExvYWQgaXMgY2FsbGVkIGJlZm9yZSBNQU5JRkVTVF9QQVJTRUQgZXZlbnRcbiAgICovXG4gIGdldCBmb3JjZVN0YXJ0TG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmZvcmNlU3RhcnRMb2FkO1xuICB9XG59XG5IbHMuZGVmYXVsdENvbmZpZyA9IHZvaWQgMDtcblxuZXhwb3J0IHsgSGxzIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhscy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hls.js/dist/hls.mjs\n");

/***/ }),

/***/ "./node_modules/slim-js/dist/directives/all.js":
/*!*****************************************************!*\
  !*** ./node_modules/slim-js/dist/directives/all.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"./node_modules/slim-js/dist/index.js\");\nvar{block:M,repeatCtx:E,internals:p,index:ie}=_index_js__WEBPACK_IMPORTED_MODULE_0__.Internals,A=\"*foreach\",h=Symbol(),b=new Range,T={attribute:(t,e)=>e===A,process:({targetNode:t,scopeNode:e,expression:r})=>{let o=document.createElement(\"template\");t[M]=\"abort\",t.removeAttribute(A);let i=t.outerHTML,a=document.createComment(\"*foreach\"),u=t.parentElement||t.parentNode||e.shadowRoot||e;u.insertBefore(a,t);let n=[];function f(l=[]){let c=l.length,v=n.length;if(c<v){let{[c]:s,[v-1]:d}=n;b.setStartBefore(s),b.setEndAfter(d),b.deleteContents(),n.slice(c).forEach(m=>{m[p][h].clear(),(0,_index_js__WEBPACK_IMPORTED_MODULE_0__.removeBindings)(e,m)}),n.length=c}v=n.length,o.innerHTML=i.repeat(Math.max(0,c-v)),b.selectNodeContents(o.content);let x=b.extractContents(),y=Array.from(x.children);y.forEach((s,d)=>{s[E]=l[n.length+d];let{bounds:m,clear:j}=(0,_index_js__WEBPACK_IMPORTED_MODULE_0__.processDOM)(e,s);s[p]=s[p]||{},s[p][h]={bounds:m,clear:j},m.forEach(R=>R())}),u.insertBefore(x,a),n.forEach((s,d)=>{s[E]=l[d],s[p][h].bounds.forEach(m=>m())}),n.push(...y)}return{update:f,removeNode:!0}}};_index_js__WEBPACK_IMPORTED_MODULE_0__.DirectiveRegistry.add(T,!0);var{block:O}=_index_js__WEBPACK_IMPORTED_MODULE_0__.Internals,w=(t,e)=>{let r=t.cloneNode(!0),{clear:o,bounds:i}=(0,_index_js__WEBPACK_IMPORTED_MODULE_0__.processDOM)(e,r);return{clear:o,bounds:i,copy:r}},L={attribute:(t,e)=>e===\"*if\",process:({scopeNode:t,targetNode:e,expression:r})=>{let o=document.createComment(\"*if\");e[O]=\"abort\",e.removeAttribute(\"*if\"),e.parentNode?.insertBefore(o,e);let i,a,u;return{update:f=>{f?(!i&&({copy:i,bounds:a,clear:u}=w(e,t)),a.forEach(l=>l()),o.parentNode?.insertBefore(i,o)):i&&(i.remove(),u(),i=a=u=void 0)},removeNode:!0,removeAttribute:!0}},noExecution:!1};_index_js__WEBPACK_IMPORTED_MODULE_0__.DirectiveRegistry.add(L);var{dashToCamel:z}=_index_js__WEBPACK_IMPORTED_MODULE_0__.Utils,{debug:S,block:$}=_index_js__WEBPACK_IMPORTED_MODULE_0__.Internals,q={attribute:(t,e)=>e.startsWith(\".\"),process:({attributeName:t,targetNode:e})=>{let r=z(t.slice(1));return{update:o=>{e[$]!==\"abort\"&&(e[r]=o)},removeAttribute:!_index_js__WEBPACK_IMPORTED_MODULE_0__.Slim[S]}}};_index_js__WEBPACK_IMPORTED_MODULE_0__.DirectiveRegistry.add(q);var J={attribute:(t,e,r=\"\")=>{let o=e[0];return r&&o!==\"@\"&&o!==\".\"&&o!==\"*\"&&r.slice(0,2)===\"{{\"&&r.slice(-2)===\"}}\"},process:({attributeName:t,targetNode:e})=>e[_index_js__WEBPACK_IMPORTED_MODULE_0__.Internals.block]===\"abort\"?{}:{update:r=>{if(e[_index_js__WEBPACK_IMPORTED_MODULE_0__.Internals.block]===\"abort\")return e.removeAttribute(t);typeof r==\"boolean\"||typeof r==\"undefined\"||r===null?r?e.setAttribute(t,\"\"):e.removeAttribute(t):e.setAttribute(t,\"\"+r)},removeNode:!1,removeAttribute:!0}};_index_js__WEBPACK_IMPORTED_MODULE_0__.DirectiveRegistry.add(J);var{dashToCamel:V,memoize:X,createFunction:Y}=_index_js__WEBPACK_IMPORTED_MODULE_0__.Utils,Z=X(V),N=/(.+)(\\((.*)\\)){1}/,ee={attribute:(t,e)=>e.startsWith(\"@\"),process:({attributeName:t,targetNode:e,scopeNode:r,expression:o,context:i})=>{let a=Z(t.slice(1)),u=N.test(o||\"\"),n=function(f){let l=Y(\"event\",\"item\",`return ${o};`),c;return u||(c=l.call(r)),c?c(f,i):l.call(r,f,i())};return e.addEventListener(a,n),{removeAttribute:!0}}};_index_js__WEBPACK_IMPORTED_MODULE_0__.DirectiveRegistry.add(ee);var re={attribute:(t,e)=>e===\"#ref\",process:({attribute:t,targetNode:e,scopeNode:r})=>{let o=t.value;return Object.defineProperty(r,o,{value:e,configurable:!0}),{removeAttribute:!0}},noExecution:!0};_index_js__WEBPACK_IMPORTED_MODULE_0__.DirectiveRegistry.add(re);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2xpbS1qcy9kaXN0L2RpcmVjdGl2ZXMvYWxsLmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQW1HLElBQUkseUNBQXlDLENBQUMsZ0RBQUMsd0NBQXdDLGlDQUFpQyxzQ0FBc0MsSUFBSSx5Q0FBeUMsa0NBQWtDLHdHQUF3RyxvQkFBb0IsU0FBUyxpQkFBaUIsMEJBQTBCLFFBQVEsSUFBSSxjQUFjLEdBQUcsK0VBQStFLGdCQUFnQix5REFBQyxNQUFNLGFBQWEsaUZBQWlGLG1EQUFtRCxrQkFBa0IsbUJBQW1CLElBQUksaUJBQWlCLENBQUMscURBQUMsTUFBTSxhQUFhLFVBQVUsaUJBQWlCLG1CQUFtQix3Q0FBd0MseUNBQXlDLGVBQWUsT0FBTywwQkFBMEIsNERBQUssT0FBc0YsSUFBSSxRQUFRLENBQUMsZ0RBQUMsV0FBVyx1QkFBdUIsaUJBQWlCLENBQUMscURBQUMsTUFBTSxPQUFPLHlCQUF5QixJQUFJLHFDQUFxQyxzQ0FBc0MsSUFBSSxvQ0FBb0Msc0VBQXNFLFVBQVUsT0FBTyxXQUFXLFNBQVMsd0JBQXdCLDZGQUE2RixtQ0FBbUMsaUJBQWlCLDREQUFLLElBQXdGLElBQUksY0FBYyxDQUFDLDRDQUFDLEVBQUUsZ0JBQWdCLENBQUMsZ0RBQUMsSUFBSSw2Q0FBNkMsNkJBQTZCLElBQUksb0JBQW9CLE9BQU8sV0FBVyx5QkFBeUIsa0JBQWtCLDJDQUFDLE9BQU8sNERBQUssSUFBbUUsT0FBTyx1QkFBdUIsV0FBVyx1REFBdUQsb0JBQW9CLEVBQUUsV0FBVyw2QkFBNkIsS0FBSyxzREFBTyxjQUFjLEVBQUUsV0FBVyxLQUFLLHNEQUFPLHdDQUF3Qyx3SEFBd0gsb0NBQW9DLDREQUFLLElBQStELElBQUkseUNBQXlDLENBQUMsNENBQUMsMEJBQTBCLEVBQUUsTUFBTSw2Q0FBNkMsZ0VBQWdFLElBQUksa0RBQWtELGlDQUFpQyxHQUFHLEtBQUssa0RBQWtELGdDQUFnQyxzQkFBc0IsNERBQUssS0FBc0QsUUFBUSxzQ0FBc0MscUNBQXFDLElBQUksY0FBYyxrQ0FBa0Msd0JBQXdCLEdBQUcsb0JBQW9CLGlCQUFpQiw0REFBTSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbGltLWpzL2Rpc3QvZGlyZWN0aXZlcy9hbGwuanM/ZWY1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7cHJvY2Vzc0RPTSBhcyBDLHJlbW92ZUJpbmRpbmdzIGFzIGcsSW50ZXJuYWxzIGFzIGssRGlyZWN0aXZlUmVnaXN0cnkgYXMgQn1mcm9tXCIuLi9pbmRleC5qc1wiO3ZhcntibG9jazpNLHJlcGVhdEN0eDpFLGludGVybmFsczpwLGluZGV4OmllfT1rLEE9XCIqZm9yZWFjaFwiLGg9U3ltYm9sKCksYj1uZXcgUmFuZ2UsVD17YXR0cmlidXRlOih0LGUpPT5lPT09QSxwcm9jZXNzOih7dGFyZ2V0Tm9kZTp0LHNjb3BlTm9kZTplLGV4cHJlc3Npb246cn0pPT57bGV0IG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO3RbTV09XCJhYm9ydFwiLHQucmVtb3ZlQXR0cmlidXRlKEEpO2xldCBpPXQub3V0ZXJIVE1MLGE9ZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIipmb3JlYWNoXCIpLHU9dC5wYXJlbnRFbGVtZW50fHx0LnBhcmVudE5vZGV8fGUuc2hhZG93Um9vdHx8ZTt1Lmluc2VydEJlZm9yZShhLHQpO2xldCBuPVtdO2Z1bmN0aW9uIGYobD1bXSl7bGV0IGM9bC5sZW5ndGgsdj1uLmxlbmd0aDtpZihjPHYpe2xldHtbY106cyxbdi0xXTpkfT1uO2Iuc2V0U3RhcnRCZWZvcmUocyksYi5zZXRFbmRBZnRlcihkKSxiLmRlbGV0ZUNvbnRlbnRzKCksbi5zbGljZShjKS5mb3JFYWNoKG09PnttW3BdW2hdLmNsZWFyKCksZyhlLG0pfSksbi5sZW5ndGg9Y312PW4ubGVuZ3RoLG8uaW5uZXJIVE1MPWkucmVwZWF0KE1hdGgubWF4KDAsYy12KSksYi5zZWxlY3ROb2RlQ29udGVudHMoby5jb250ZW50KTtsZXQgeD1iLmV4dHJhY3RDb250ZW50cygpLHk9QXJyYXkuZnJvbSh4LmNoaWxkcmVuKTt5LmZvckVhY2goKHMsZCk9PntzW0VdPWxbbi5sZW5ndGgrZF07bGV0e2JvdW5kczptLGNsZWFyOmp9PUMoZSxzKTtzW3BdPXNbcF18fHt9LHNbcF1baF09e2JvdW5kczptLGNsZWFyOmp9LG0uZm9yRWFjaChSPT5SKCkpfSksdS5pbnNlcnRCZWZvcmUoeCxhKSxuLmZvckVhY2goKHMsZCk9PntzW0VdPWxbZF0sc1twXVtoXS5ib3VuZHMuZm9yRWFjaChtPT5tKCkpfSksbi5wdXNoKC4uLnkpfXJldHVybnt1cGRhdGU6ZixyZW1vdmVOb2RlOiEwfX19O0IuYWRkKFQsITApO2ltcG9ydHtEaXJlY3RpdmVSZWdpc3RyeSBhcyBfLEludGVybmFscyBhcyBILHByb2Nlc3NET00gYXMgSX1mcm9tXCIuLi9pbmRleC5qc1wiO3ZhcntibG9jazpPfT1ILHc9KHQsZSk9PntsZXQgcj10LmNsb25lTm9kZSghMCkse2NsZWFyOm8sYm91bmRzOml9PUkoZSxyKTtyZXR1cm57Y2xlYXI6byxib3VuZHM6aSxjb3B5OnJ9fSxMPXthdHRyaWJ1dGU6KHQsZSk9PmU9PT1cIippZlwiLHByb2Nlc3M6KHtzY29wZU5vZGU6dCx0YXJnZXROb2RlOmUsZXhwcmVzc2lvbjpyfSk9PntsZXQgbz1kb2N1bWVudC5jcmVhdGVDb21tZW50KFwiKmlmXCIpO2VbT109XCJhYm9ydFwiLGUucmVtb3ZlQXR0cmlidXRlKFwiKmlmXCIpLGUucGFyZW50Tm9kZT8uaW5zZXJ0QmVmb3JlKG8sZSk7bGV0IGksYSx1O3JldHVybnt1cGRhdGU6Zj0+e2Y/KCFpJiYoe2NvcHk6aSxib3VuZHM6YSxjbGVhcjp1fT13KGUsdCkpLGEuZm9yRWFjaChsPT5sKCkpLG8ucGFyZW50Tm9kZT8uaW5zZXJ0QmVmb3JlKGksbykpOmkmJihpLnJlbW92ZSgpLHUoKSxpPWE9dT12b2lkIDApfSxyZW1vdmVOb2RlOiEwLHJlbW92ZUF0dHJpYnV0ZTohMH19LG5vRXhlY3V0aW9uOiExfTtfLmFkZChMKTtpbXBvcnR7VXRpbHMgYXMgRixJbnRlcm5hbHMgYXMgUCxEaXJlY3RpdmVSZWdpc3RyeSBhcyBVLFNsaW0gYXMgV31mcm9tXCIuLi9pbmRleC5qc1wiO3ZhcntkYXNoVG9DYW1lbDp6fT1GLHtkZWJ1ZzpTLGJsb2NrOiR9PVAscT17YXR0cmlidXRlOih0LGUpPT5lLnN0YXJ0c1dpdGgoXCIuXCIpLHByb2Nlc3M6KHthdHRyaWJ1dGVOYW1lOnQsdGFyZ2V0Tm9kZTplfSk9PntsZXQgcj16KHQuc2xpY2UoMSkpO3JldHVybnt1cGRhdGU6bz0+e2VbJF0hPT1cImFib3J0XCImJihlW3JdPW8pfSxyZW1vdmVBdHRyaWJ1dGU6IVdbU119fX07VS5hZGQocSk7aW1wb3J0e0RpcmVjdGl2ZVJlZ2lzdHJ5IGFzIEcsSW50ZXJuYWxzIGFzIER9ZnJvbVwiLi4vaW5kZXguanNcIjt2YXIgSj17YXR0cmlidXRlOih0LGUscj1cIlwiKT0+e2xldCBvPWVbMF07cmV0dXJuIHImJm8hPT1cIkBcIiYmbyE9PVwiLlwiJiZvIT09XCIqXCImJnIuc2xpY2UoMCwyKT09PVwie3tcIiYmci5zbGljZSgtMik9PT1cIn19XCJ9LHByb2Nlc3M6KHthdHRyaWJ1dGVOYW1lOnQsdGFyZ2V0Tm9kZTplfSk9PmVbRC5ibG9ja109PT1cImFib3J0XCI/e306e3VwZGF0ZTpyPT57aWYoZVtELmJsb2NrXT09PVwiYWJvcnRcIilyZXR1cm4gZS5yZW1vdmVBdHRyaWJ1dGUodCk7dHlwZW9mIHI9PVwiYm9vbGVhblwifHx0eXBlb2Ygcj09XCJ1bmRlZmluZWRcInx8cj09PW51bGw/cj9lLnNldEF0dHJpYnV0ZSh0LFwiXCIpOmUucmVtb3ZlQXR0cmlidXRlKHQpOmUuc2V0QXR0cmlidXRlKHQsXCJcIityKX0scmVtb3ZlTm9kZTohMSxyZW1vdmVBdHRyaWJ1dGU6ITB9fTtHLmFkZChKKTtpbXBvcnR7RGlyZWN0aXZlUmVnaXN0cnkgYXMgSyxVdGlscyBhcyBRfWZyb21cIi4uL2luZGV4LmpzXCI7dmFye2Rhc2hUb0NhbWVsOlYsbWVtb2l6ZTpYLGNyZWF0ZUZ1bmN0aW9uOll9PVEsWj1YKFYpLE49LyguKykoXFwoKC4qKVxcKSl7MX0vLGVlPXthdHRyaWJ1dGU6KHQsZSk9PmUuc3RhcnRzV2l0aChcIkBcIikscHJvY2Vzczooe2F0dHJpYnV0ZU5hbWU6dCx0YXJnZXROb2RlOmUsc2NvcGVOb2RlOnIsZXhwcmVzc2lvbjpvLGNvbnRleHQ6aX0pPT57bGV0IGE9Wih0LnNsaWNlKDEpKSx1PU4udGVzdChvfHxcIlwiKSxuPWZ1bmN0aW9uKGYpe2xldCBsPVkoXCJldmVudFwiLFwiaXRlbVwiLGByZXR1cm4gJHtvfTtgKSxjO3JldHVybiB1fHwoYz1sLmNhbGwocikpLGM/YyhmLGkpOmwuY2FsbChyLGYsaSgpKX07cmV0dXJuIGUuYWRkRXZlbnRMaXN0ZW5lcihhLG4pLHtyZW1vdmVBdHRyaWJ1dGU6ITB9fX07Sy5hZGQoZWUpO2ltcG9ydHtEaXJlY3RpdmVSZWdpc3RyeSBhcyB0ZX1mcm9tXCIuLi9pbmRleC5qc1wiO3ZhciByZT17YXR0cmlidXRlOih0LGUpPT5lPT09XCIjcmVmXCIscHJvY2Vzczooe2F0dHJpYnV0ZTp0LHRhcmdldE5vZGU6ZSxzY29wZU5vZGU6cn0pPT57bGV0IG89dC52YWx1ZTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsbyx7dmFsdWU6ZSxjb25maWd1cmFibGU6ITB9KSx7cmVtb3ZlQXR0cmlidXRlOiEwfX0sbm9FeGVjdXRpb246ITB9O3RlLmFkZChyZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/slim-js/dist/directives/all.js\n");

/***/ }),

/***/ "./node_modules/slim-js/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/slim-js/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": () => (/* binding */ u),\n/* harmony export */   \"DirectiveRegistry\": () => (/* binding */ Z),\n/* harmony export */   \"Internals\": () => (/* binding */ rt),\n/* harmony export */   \"Phase\": () => (/* binding */ st),\n/* harmony export */   \"PluginRegistry\": () => (/* binding */ C),\n/* harmony export */   \"Slim\": () => (/* binding */ u),\n/* harmony export */   \"Utils\": () => (/* binding */ pe),\n/* harmony export */   \"createBind\": () => (/* binding */ te),\n/* harmony export */   \"processDOM\": () => (/* binding */ ne),\n/* harmony export */   \"removeBindings\": () => (/* binding */ Re)\n/* harmony export */ });\nvar $=Object.defineProperty;var De=(e,t,o)=>t in e?$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o;var Oe=e=>$(e,\"__esModule\",{value:!0});var Se=(e,t)=>{Oe(e);for(var o in t)$(e,o,{get:t[o],enumerable:!0})};var q=(e,t,o)=>(De(e,typeof t!=\"symbol\"?t+\"\":t,o),o);var pe={};Se(pe,{NOOP:()=>R,createFunction:()=>M,dashToCamel:()=>Ae,findCtx:()=>H,forceUpdate:()=>je,isForcedUpdate:()=>Q,lazyQueue:()=>Y,markFlush:()=>X,memoize:()=>D,normalize:()=>J,requestIdleCallback:()=>k});var p=Symbol,a=p(\"block\"),E=p(\"repeat\"),k=window.requestIdleCallback||((e,...t)=>setTimeout(e)),N=p(\"internals\"),v=p(),A=p(),y=p(),F=p(),U=p(),le=p();var _=new WeakSet,de=new WeakMap;function je(e,...t){let o=[...arguments].slice(1),n=de.get(e);if(!n)return console.error(\"Flush error\");_.add(e),o.length?n(...o):n(),requestAnimationFrame(()=>_.delete(e))}var H=e=>{for(;e&&!e[E];)e=e.parentElement;return e?.[E]},Q=e=>_.has(e),X=(e,t)=>de.set(e,t),ve=/-[a-z]/g,Ae=e=>e.indexOf(\"-\")<0?e:e.replace(ve,t=>t[1].toUpperCase()),ye={timeRemaining:()=>!0},Y=(e,t=20,o=R)=>{let n={timeout:t},i=e[Symbol.iterator](),r=i.next(),l=()=>k(d,n),d=(s=ye)=>{for(;s.timeRemaining()&&!r.done;)r.value(),r=i.next();s?.didTimeout&&!r.done&&(r.value(),r=i.next()),r.done?o():l()};l()},J=e=>e.replace(/\\n/g,\"\").replace(/[\\t ]+\\</g,\"<\").replace(/\\>[\\t ]+\\</g,\"><\").replace(/\\>[\\t ]+$/g,\">\"),D=e=>{let t={};return o=>t[o]||(t[o]=e(o))},me={},M=(...e)=>{let t=e.join(\"$\");return me[t]||(me[t]=new Function(...e))},R=()=>{};var Fe=Symbol(),Me=/(\\{\\{([^\\{|^\\}]+)\\}\\})/gi,ue=/(this\\.[\\w+|\\d*]*)+/gi,fe=/item(\\.[\\w+|\\d*]*)*/gi,Pe=(e=\"\")=>{let t=[],o=null;for(ue.lastIndex=fe.lastIndex=0;o=ue.exec(e);)t.push(o[1].split(\".\")[1]);return fe.test(e)&&t.push(Fe),{paths:t,expressions:t.length?e.match(Me)||[]:[]}},G=D(Pe);var O=Symbol(),K=class{constructor(){this[O]=[]}add(t,o=!1){o?this[O].unshift(t):this[O].push(t)}getAll(){return[...this[O]]}},he=class extends K{exec(t,o){this[O].forEach(n=>n(t,o))}},Z=new K,C=new he;var xe=[],Ee={},ee=\"abort\",P=console,ge=(e,t,...o)=>u[U]&&(P.group(e),P.error(t),P.info(...o),P.groupEnd()),Ie=D(e=>\"`\"+e.replaceAll(\"{{\",\"${\").replaceAll(\"}}\",\"}\")+\"`\"),ze=NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_TEXT,be=e=>document.createTreeWalker(e,ze),I=(e,t)=>typeof e===t,S=new WeakMap,Be=e=>I(e,\"function\")?e():e,te=(e,t,o,n)=>{let i=S.get(e)||S.set(e,{}).get(e);if(!i[o]){let l=(Object.getOwnPropertyDescriptor(e,o)||Ee).set,d=e[o];Object.defineProperty(e,o,{get:()=>d,set:s=>{(s!==d||I(s,\"object\"))&&(d=s,l&&l(s),oe(e,o,d))}})}(i[o]=i[o]||new Set).add(t);let r=t[N]=t[N]||{};return I(o,\"symbol\")?R:((r[o]=r[o]||new Set).add(n),()=>{r[o].delete(n)})},Ne=(e,t,o)=>{(e[t]||xe).forEach(n=>{let i=n[E]||o;n[N][t].forEach(r=>r(i))})},oe=(e,t,o)=>{let n=S.get(e)||S.set(e,{}).get(e);t!==\"*\"?Ne(n,t,o):Object.keys(n).forEach(i=>Ne(n,i,e[i]))},Re=(e,t,o=\"*\")=>{let n=S.get(e)||Ee;if(o===\"*\"){Object.keys(n).forEach(r=>Re(e,t,r));return}let i=n[o];if(i){let r=be(t),l=r.currentNode;for(;l;)i.delete(l),l=r.nextNode()}},ne=(e,t)=>{let o=new Set,n=new Set,i=new Set,r=new Set,l=Z.getAll(),d=be(t),s=d.currentNode||d.nextNode();for(;s;s=d.nextNode()){let m=s;s.nodeType,s.nodeValue,s.addEventListener;let w=s.nodeName,z=()=>H(m);if(s.nodeType===Node.ELEMENT_NODE){let c=s;if(w.includes(\"-\")&&I(c[a],\"undefined\")&&(c[a]=!0,requestAnimationFrame(()=>c[a]=!1)),c[a]===ee)continue;let T=Array.from(c.attributes),g=0,B=T.length;e:for(g;g<B;g++){let f=T[g],b=f.nodeName,h=f.nodeValue||\"\";if(s[a]===ee)break e;let x=h.trim(),j=x.slice(0,2)===\"{{\"&&x.slice(-2)===\"}}\"?x.slice(2,-2):x,re=~x.indexOf(\"{{\")?G(j).paths:xe;t:for(let L of l){if(s[a]===ee)break t;if(L.attribute(f,b,h)){let{update:ie,removeAttribute:Te,removeNode:ke}=L.process({attribute:f,attributeName:b,attributeValue:h,context:z,expression:j,props:re,scopeNode:e,targetNode:c,targetNodeName:w});if(Te&&i.add(f),ke&&r.add(c),ie){let ce=L.noExecution?R:M(\"item\",`return ${j}`),ae=(W=z())=>{try{let V=ce===R?void 0:ce.call(e,Be(W));ie(V,Q(e))}catch(V){ge(`Directive Error ${b}`,V.message,`Expression: ${j}`,\"Node\",c)}};n.add(ae),re.forEach(W=>{o.add(te(e,s,W,ae))})}}}}}else if(s.nodeType===Node.TEXT_NODE){let c=s.textContent;if(!~c.indexOf(\"{{\"))continue;let T=s,{paths:g}=G(c),B=Ie(c),f=M(\"item\",`return ${B}`),b=(h=z())=>{try{T.nodeValue=f.call(e,h)}catch(x){ge(`Expression error: ${c}`,x.message,\"Node\",T.parentElement)}};n.add(b),g.forEach(h=>o.add(te(e,s,h,b)))}}return r.forEach(m=>m.remove()),u[U]||i.forEach(m=>{try{m.ownerElement.removeAttribute(m.nodeName)}catch(w){}}),{flush:(...m)=>{m.length?m.forEach(w=>oe(e,w)):oe(e,\"*\")},clear:()=>Y(o),bounds:n}};var Ce=Symbol,se=Ce(),we=Ce(),u=class extends HTMLElement{static element(t,o,n=class extends Slim{}){n.template=o,customElements.define(t,n)}constructor(){super();this[se]()}onBeforeCreated(){}onCreated(){}onAdded(){}onRemoved(){}onRender(){}connectedCallback(){this.onAdded(),C.exec(y,this)}disconnectedCallback(){this.onRemoved(),C.exec(F,this)}[se](){if(this[a]!==\"abort\"){if(this[a])return requestAnimationFrame(()=>this[se]());this.onBeforeCreated(),this.constructor.useShadow&&!this.shadowRoot&&this.attachShadow({mode:\"open\"}),C.exec(v,this),this[we]()}}[we](){let t=J(this.constructor.template);if(t){let o=document.createElement(\"template\");o.innerHTML=t,Promise.resolve().then(()=>{let{flush:n}=ne(this,o.content);X(this,n),n(),this.onCreated(),C.exec(A,this),(this.shadowRoot||this).appendChild(o.content),this.onRender()})}}};q(u,\"template\",\"\"),q(u,\"useShadow\",!0);var st={ADDED:y,CREATE:v,RENDER:A,REMOVED:F},rt={repeatCtx:E,internals:N,block:a,index:le,requestIdleCallback:k};Window.prototype.Slim=u;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2xpbS1qcy9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSw0QkFBNEIsOEJBQThCLGtEQUFrRCxTQUFTLDRCQUE0QixTQUFTLEVBQUUsZUFBZSxNQUFNLHNCQUFzQix1QkFBdUIsR0FBRyxxREFBcUQsVUFBVSxPQUFPLGlNQUFpTSxFQUFFLHNKQUFzSixpQ0FBaUMsb0JBQW9CLDBDQUEwQywwQ0FBMEMscUVBQXFFLFVBQVUsS0FBSyxTQUFTLG1CQUFtQixjQUFjLGtIQUFrSCxxQkFBcUIsa0JBQWtCLE9BQU8sVUFBVSwyREFBMkQsS0FBSywyQkFBMkIsc0JBQXNCLCtEQUErRCxJQUFJLCtHQUErRyxTQUFTLDRCQUE0QixNQUFNLFlBQVksa0JBQWtCLHlDQUF5QyxVQUFVLHVCQUF1QixFQUFFLEtBQUssSUFBSSxLQUFLLEVBQUUsdUVBQXVFLGdCQUFnQixnQ0FBZ0MsYUFBYSw0QkFBNEIsK0JBQStCLGlEQUFpRCxTQUFTLHVCQUF1QixjQUFjLFdBQVcsWUFBWSxxQ0FBcUMsU0FBUyxvQkFBb0Isb0JBQW9CLFVBQVUsNEJBQTRCLGtCQUFrQixlQUFlLHlIQUF5SCxLQUFLLGlCQUFpQixJQUFJLDZLQUE2SywwQkFBMEIsU0FBUyxVQUFVLDREQUE0RCwyQkFBMkIsa0JBQWtCLGlEQUFpRCxFQUFFLDRCQUE0QixvQkFBb0IseURBQXlELGVBQWUsRUFBRSxjQUFjLHVCQUF1QixjQUFjLHlCQUF5QixFQUFFLGNBQWMsMEJBQTBCLFNBQVMsMERBQTBELGtCQUFrQixtQkFBbUIsWUFBWSxxQ0FBcUMsT0FBTyxXQUFXLE1BQU0sNEJBQTRCLEtBQUssRUFBRSw2QkFBNkIsWUFBWSwrRkFBK0YsS0FBSyxFQUFFLGdCQUFnQixRQUFRLDBDQUEwQyw0QkFBNEIsbUNBQW1DLFFBQVEseUdBQXlHLDhDQUE4QyxRQUFRLElBQUksS0FBSywwQ0FBMEMscUJBQXFCLG1DQUFtQyxvQkFBb0IsbUNBQW1DLGlCQUFpQixrQkFBa0IscUJBQXFCLHVCQUF1QixJQUFJLDJDQUEyQyxZQUFZLHVIQUF1SCxFQUFFLGlDQUFpQywwQ0FBMEMsRUFBRSxnQkFBZ0IsSUFBSSxxQ0FBcUMsV0FBVyxTQUFTLHNCQUFzQixFQUFFLDJCQUEyQixFQUFFLGNBQWMseUJBQXlCLG9CQUFvQixNQUFNLHFDQUFxQyxvQkFBb0Isa0JBQWtCLFlBQVksU0FBUyxRQUFRLG1DQUFtQyxFQUFFLGVBQWUsSUFBSSx3QkFBd0IsU0FBUyx3QkFBd0IsRUFBRSxzQ0FBc0MsMkNBQTJDLG9EQUFvRCxJQUFJLDJDQUEyQyxXQUFXLEdBQUcsZUFBZSx5Q0FBeUMsMkJBQTJCLDBEQUEwRCx5Q0FBeUMsRUFBRSx3Q0FBd0MsY0FBYyxRQUFRLFdBQVcsbUJBQW1CLGFBQWEsV0FBVyxhQUFhLFlBQVksb0JBQW9CLDhCQUE4Qix1QkFBdUIsZ0NBQWdDLE9BQU8sc0JBQXNCLHdEQUF3RCx3RkFBd0YsWUFBWSw2QkFBNkIsT0FBTyxtQ0FBbUMsTUFBTSx5Q0FBeUMsMENBQTBDLElBQUksUUFBUSxvQkFBb0IsNkdBQTZHLEtBQUssdUNBQXVDLFFBQVEsb0NBQW9DLEtBQUssZ0VBQWdFLHdCQUFtTTtBQUNycEwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2xpbS1qcy9kaXN0L2luZGV4LmpzP2EyN2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICQ9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBEZT0oZSx0LG8pPT50IGluIGU/JChlLHQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm99KTplW3RdPW87dmFyIE9lPWU9PiQoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgU2U9KGUsdCk9PntPZShlKTtmb3IodmFyIG8gaW4gdCkkKGUsbyx7Z2V0OnRbb10sZW51bWVyYWJsZTohMH0pfTt2YXIgcT0oZSx0LG8pPT4oRGUoZSx0eXBlb2YgdCE9XCJzeW1ib2xcIj90K1wiXCI6dCxvKSxvKTt2YXIgcGU9e307U2UocGUse05PT1A6KCk9PlIsY3JlYXRlRnVuY3Rpb246KCk9Pk0sZGFzaFRvQ2FtZWw6KCk9PkFlLGZpbmRDdHg6KCk9PkgsZm9yY2VVcGRhdGU6KCk9PmplLGlzRm9yY2VkVXBkYXRlOigpPT5RLGxhenlRdWV1ZTooKT0+WSxtYXJrRmx1c2g6KCk9PlgsbWVtb2l6ZTooKT0+RCxub3JtYWxpemU6KCk9PkoscmVxdWVzdElkbGVDYWxsYmFjazooKT0+a30pO3ZhciBwPVN5bWJvbCxhPXAoXCJibG9ja1wiKSxFPXAoXCJyZXBlYXRcIiksaz13aW5kb3cucmVxdWVzdElkbGVDYWxsYmFja3x8KChlLC4uLnQpPT5zZXRUaW1lb3V0KGUpKSxOPXAoXCJpbnRlcm5hbHNcIiksdj1wKCksQT1wKCkseT1wKCksRj1wKCksVT1wKCksbGU9cCgpO3ZhciBfPW5ldyBXZWFrU2V0LGRlPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIGplKGUsLi4udCl7bGV0IG89Wy4uLmFyZ3VtZW50c10uc2xpY2UoMSksbj1kZS5nZXQoZSk7aWYoIW4pcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJGbHVzaCBlcnJvclwiKTtfLmFkZChlKSxvLmxlbmd0aD9uKC4uLm8pOm4oKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9Pl8uZGVsZXRlKGUpKX12YXIgSD1lPT57Zm9yKDtlJiYhZVtFXTspZT1lLnBhcmVudEVsZW1lbnQ7cmV0dXJuIGU/LltFXX0sUT1lPT5fLmhhcyhlKSxYPShlLHQpPT5kZS5zZXQoZSx0KSx2ZT0vLVthLXpdL2csQWU9ZT0+ZS5pbmRleE9mKFwiLVwiKTwwP2U6ZS5yZXBsYWNlKHZlLHQ9PnRbMV0udG9VcHBlckNhc2UoKSkseWU9e3RpbWVSZW1haW5pbmc6KCk9PiEwfSxZPShlLHQ9MjAsbz1SKT0+e2xldCBuPXt0aW1lb3V0OnR9LGk9ZVtTeW1ib2wuaXRlcmF0b3JdKCkscj1pLm5leHQoKSxsPSgpPT5rKGQsbiksZD0ocz15ZSk9Pntmb3IoO3MudGltZVJlbWFpbmluZygpJiYhci5kb25lOylyLnZhbHVlKCkscj1pLm5leHQoKTtzPy5kaWRUaW1lb3V0JiYhci5kb25lJiYoci52YWx1ZSgpLHI9aS5uZXh0KCkpLHIuZG9uZT9vKCk6bCgpfTtsKCl9LEo9ZT0+ZS5yZXBsYWNlKC9cXG4vZyxcIlwiKS5yZXBsYWNlKC9bXFx0IF0rXFw8L2csXCI8XCIpLnJlcGxhY2UoL1xcPltcXHQgXStcXDwvZyxcIj48XCIpLnJlcGxhY2UoL1xcPltcXHQgXSskL2csXCI+XCIpLEQ9ZT0+e2xldCB0PXt9O3JldHVybiBvPT50W29dfHwodFtvXT1lKG8pKX0sbWU9e30sTT0oLi4uZSk9PntsZXQgdD1lLmpvaW4oXCIkXCIpO3JldHVybiBtZVt0XXx8KG1lW3RdPW5ldyBGdW5jdGlvbiguLi5lKSl9LFI9KCk9Pnt9O3ZhciBGZT1TeW1ib2woKSxNZT0vKFxce1xceyhbXlxce3xeXFx9XSspXFx9XFx9KS9naSx1ZT0vKHRoaXNcXC5bXFx3K3xcXGQqXSopKy9naSxmZT0vaXRlbShcXC5bXFx3K3xcXGQqXSopKi9naSxQZT0oZT1cIlwiKT0+e2xldCB0PVtdLG89bnVsbDtmb3IodWUubGFzdEluZGV4PWZlLmxhc3RJbmRleD0wO289dWUuZXhlYyhlKTspdC5wdXNoKG9bMV0uc3BsaXQoXCIuXCIpWzFdKTtyZXR1cm4gZmUudGVzdChlKSYmdC5wdXNoKEZlKSx7cGF0aHM6dCxleHByZXNzaW9uczp0Lmxlbmd0aD9lLm1hdGNoKE1lKXx8W106W119fSxHPUQoUGUpO3ZhciBPPVN5bWJvbCgpLEs9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzW09dPVtdfWFkZCh0LG89ITEpe28/dGhpc1tPXS51bnNoaWZ0KHQpOnRoaXNbT10ucHVzaCh0KX1nZXRBbGwoKXtyZXR1cm5bLi4udGhpc1tPXV19fSxoZT1jbGFzcyBleHRlbmRzIEt7ZXhlYyh0LG8pe3RoaXNbT10uZm9yRWFjaChuPT5uKHQsbykpfX0sWj1uZXcgSyxDPW5ldyBoZTt2YXIgeGU9W10sRWU9e30sZWU9XCJhYm9ydFwiLFA9Y29uc29sZSxnZT0oZSx0LC4uLm8pPT51W1VdJiYoUC5ncm91cChlKSxQLmVycm9yKHQpLFAuaW5mbyguLi5vKSxQLmdyb3VwRW5kKCkpLEllPUQoZT0+XCJgXCIrZS5yZXBsYWNlQWxsKFwie3tcIixcIiR7XCIpLnJlcGxhY2VBbGwoXCJ9fVwiLFwifVwiKStcImBcIiksemU9Tm9kZUZpbHRlci5TSE9XX0VMRU1FTlR8Tm9kZUZpbHRlci5TSE9XX1RFWFQsYmU9ZT0+ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlLHplKSxJPShlLHQpPT50eXBlb2YgZT09PXQsUz1uZXcgV2Vha01hcCxCZT1lPT5JKGUsXCJmdW5jdGlvblwiKT9lKCk6ZSx0ZT0oZSx0LG8sbik9PntsZXQgaT1TLmdldChlKXx8Uy5zZXQoZSx7fSkuZ2V0KGUpO2lmKCFpW29dKXtsZXQgbD0oT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG8pfHxFZSkuc2V0LGQ9ZVtvXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLHtnZXQ6KCk9PmQsc2V0OnM9PnsocyE9PWR8fEkocyxcIm9iamVjdFwiKSkmJihkPXMsbCYmbChzKSxvZShlLG8sZCkpfX0pfShpW29dPWlbb118fG5ldyBTZXQpLmFkZCh0KTtsZXQgcj10W05dPXRbTl18fHt9O3JldHVybiBJKG8sXCJzeW1ib2xcIik/UjooKHJbb109cltvXXx8bmV3IFNldCkuYWRkKG4pLCgpPT57cltvXS5kZWxldGUobil9KX0sTmU9KGUsdCxvKT0+eyhlW3RdfHx4ZSkuZm9yRWFjaChuPT57bGV0IGk9bltFXXx8bztuW05dW3RdLmZvckVhY2gocj0+cihpKSl9KX0sb2U9KGUsdCxvKT0+e2xldCBuPVMuZ2V0KGUpfHxTLnNldChlLHt9KS5nZXQoZSk7dCE9PVwiKlwiP05lKG4sdCxvKTpPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGk9Pk5lKG4saSxlW2ldKSl9LFJlPShlLHQsbz1cIipcIik9PntsZXQgbj1TLmdldChlKXx8RWU7aWYobz09PVwiKlwiKXtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKHI9PlJlKGUsdCxyKSk7cmV0dXJufWxldCBpPW5bb107aWYoaSl7bGV0IHI9YmUodCksbD1yLmN1cnJlbnROb2RlO2Zvcig7bDspaS5kZWxldGUobCksbD1yLm5leHROb2RlKCl9fSxuZT0oZSx0KT0+e2xldCBvPW5ldyBTZXQsbj1uZXcgU2V0LGk9bmV3IFNldCxyPW5ldyBTZXQsbD1aLmdldEFsbCgpLGQ9YmUodCkscz1kLmN1cnJlbnROb2RlfHxkLm5leHROb2RlKCk7Zm9yKDtzO3M9ZC5uZXh0Tm9kZSgpKXtsZXQgbT1zO3Mubm9kZVR5cGUscy5ub2RlVmFsdWUscy5hZGRFdmVudExpc3RlbmVyO2xldCB3PXMubm9kZU5hbWUsej0oKT0+SChtKTtpZihzLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUpe2xldCBjPXM7aWYody5pbmNsdWRlcyhcIi1cIikmJkkoY1thXSxcInVuZGVmaW5lZFwiKSYmKGNbYV09ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT5jW2FdPSExKSksY1thXT09PWVlKWNvbnRpbnVlO2xldCBUPUFycmF5LmZyb20oYy5hdHRyaWJ1dGVzKSxnPTAsQj1ULmxlbmd0aDtlOmZvcihnO2c8QjtnKyspe2xldCBmPVRbZ10sYj1mLm5vZGVOYW1lLGg9Zi5ub2RlVmFsdWV8fFwiXCI7aWYoc1thXT09PWVlKWJyZWFrIGU7bGV0IHg9aC50cmltKCksaj14LnNsaWNlKDAsMik9PT1cInt7XCImJnguc2xpY2UoLTIpPT09XCJ9fVwiP3guc2xpY2UoMiwtMik6eCxyZT1+eC5pbmRleE9mKFwie3tcIik/RyhqKS5wYXRoczp4ZTt0OmZvcihsZXQgTCBvZiBsKXtpZihzW2FdPT09ZWUpYnJlYWsgdDtpZihMLmF0dHJpYnV0ZShmLGIsaCkpe2xldHt1cGRhdGU6aWUscmVtb3ZlQXR0cmlidXRlOlRlLHJlbW92ZU5vZGU6a2V9PUwucHJvY2Vzcyh7YXR0cmlidXRlOmYsYXR0cmlidXRlTmFtZTpiLGF0dHJpYnV0ZVZhbHVlOmgsY29udGV4dDp6LGV4cHJlc3Npb246aixwcm9wczpyZSxzY29wZU5vZGU6ZSx0YXJnZXROb2RlOmMsdGFyZ2V0Tm9kZU5hbWU6d30pO2lmKFRlJiZpLmFkZChmKSxrZSYmci5hZGQoYyksaWUpe2xldCBjZT1MLm5vRXhlY3V0aW9uP1I6TShcIml0ZW1cIixgcmV0dXJuICR7an1gKSxhZT0oVz16KCkpPT57dHJ5e2xldCBWPWNlPT09Uj92b2lkIDA6Y2UuY2FsbChlLEJlKFcpKTtpZShWLFEoZSkpfWNhdGNoKFYpe2dlKGBEaXJlY3RpdmUgRXJyb3IgJHtifWAsVi5tZXNzYWdlLGBFeHByZXNzaW9uOiAke2p9YCxcIk5vZGVcIixjKX19O24uYWRkKGFlKSxyZS5mb3JFYWNoKFc9PntvLmFkZCh0ZShlLHMsVyxhZSkpfSl9fX19fWVsc2UgaWYocy5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFKXtsZXQgYz1zLnRleHRDb250ZW50O2lmKCF+Yy5pbmRleE9mKFwie3tcIikpY29udGludWU7bGV0IFQ9cyx7cGF0aHM6Z309RyhjKSxCPUllKGMpLGY9TShcIml0ZW1cIixgcmV0dXJuICR7Qn1gKSxiPShoPXooKSk9Pnt0cnl7VC5ub2RlVmFsdWU9Zi5jYWxsKGUsaCl9Y2F0Y2goeCl7Z2UoYEV4cHJlc3Npb24gZXJyb3I6ICR7Y31gLHgubWVzc2FnZSxcIk5vZGVcIixULnBhcmVudEVsZW1lbnQpfX07bi5hZGQoYiksZy5mb3JFYWNoKGg9Pm8uYWRkKHRlKGUscyxoLGIpKSl9fXJldHVybiByLmZvckVhY2gobT0+bS5yZW1vdmUoKSksdVtVXXx8aS5mb3JFYWNoKG09Pnt0cnl7bS5vd25lckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG0ubm9kZU5hbWUpfWNhdGNoKHcpe319KSx7Zmx1c2g6KC4uLm0pPT57bS5sZW5ndGg/bS5mb3JFYWNoKHc9Pm9lKGUsdykpOm9lKGUsXCIqXCIpfSxjbGVhcjooKT0+WShvKSxib3VuZHM6bn19O3ZhciBDZT1TeW1ib2wsc2U9Q2UoKSx3ZT1DZSgpLHU9Y2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudHtzdGF0aWMgZWxlbWVudCh0LG8sbj1jbGFzcyBleHRlbmRzIFNsaW17fSl7bi50ZW1wbGF0ZT1vLGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0LG4pfWNvbnN0cnVjdG9yKCl7c3VwZXIoKTt0aGlzW3NlXSgpfW9uQmVmb3JlQ3JlYXRlZCgpe31vbkNyZWF0ZWQoKXt9b25BZGRlZCgpe31vblJlbW92ZWQoKXt9b25SZW5kZXIoKXt9Y29ubmVjdGVkQ2FsbGJhY2soKXt0aGlzLm9uQWRkZWQoKSxDLmV4ZWMoeSx0aGlzKX1kaXNjb25uZWN0ZWRDYWxsYmFjaygpe3RoaXMub25SZW1vdmVkKCksQy5leGVjKEYsdGhpcyl9W3NlXSgpe2lmKHRoaXNbYV0hPT1cImFib3J0XCIpe2lmKHRoaXNbYV0pcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+dGhpc1tzZV0oKSk7dGhpcy5vbkJlZm9yZUNyZWF0ZWQoKSx0aGlzLmNvbnN0cnVjdG9yLnVzZVNoYWRvdyYmIXRoaXMuc2hhZG93Um9vdCYmdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6XCJvcGVuXCJ9KSxDLmV4ZWModix0aGlzKSx0aGlzW3dlXSgpfX1bd2VdKCl7bGV0IHQ9Sih0aGlzLmNvbnN0cnVjdG9yLnRlbXBsYXRlKTtpZih0KXtsZXQgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7by5pbm5lckhUTUw9dCxQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57bGV0e2ZsdXNoOm59PW5lKHRoaXMsby5jb250ZW50KTtYKHRoaXMsbiksbigpLHRoaXMub25DcmVhdGVkKCksQy5leGVjKEEsdGhpcyksKHRoaXMuc2hhZG93Um9vdHx8dGhpcykuYXBwZW5kQ2hpbGQoby5jb250ZW50KSx0aGlzLm9uUmVuZGVyKCl9KX19fTtxKHUsXCJ0ZW1wbGF0ZVwiLFwiXCIpLHEodSxcInVzZVNoYWRvd1wiLCEwKTt2YXIgc3Q9e0FEREVEOnksQ1JFQVRFOnYsUkVOREVSOkEsUkVNT1ZFRDpGfSxydD17cmVwZWF0Q3R4OkUsaW50ZXJuYWxzOk4sYmxvY2s6YSxpbmRleDpsZSxyZXF1ZXN0SWRsZUNhbGxiYWNrOmt9O1dpbmRvdy5wcm90b3R5cGUuU2xpbT11O2V4cG9ydHt1IGFzIENvbXBvbmVudCxaIGFzIERpcmVjdGl2ZVJlZ2lzdHJ5LHJ0IGFzIEludGVybmFscyxzdCBhcyBQaGFzZSxDIGFzIFBsdWdpblJlZ2lzdHJ5LHUgYXMgU2xpbSxwZSBhcyBVdGlscyx0ZSBhcyBjcmVhdGVCaW5kLG5lIGFzIHByb2Nlc3NET00sUmUgYXMgcmVtb3ZlQmluZGluZ3N9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/slim-js/dist/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/css/app.css")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;